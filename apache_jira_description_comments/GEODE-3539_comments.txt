Commit 17662cd46de7939577b4fc20183319288c655932 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://git-wip-us.apache.org/repos/asf?p=geode.git;h=17662cd ]

GEODE-3539: add test for invalid command

* also rework GfshCommandIntegrationTest in assembly module


Commit 17662cd46de7939577b4fc20183319288c655932 in geode's branch refs/heads/feature/GEODE-3543 from [~jinmeiliao]
[ https://git-wip-us.apache.org/repos/asf?p=geode.git;h=17662cd ]

GEODE-3539: add test for invalid command

* also rework GfshCommandIntegrationTest in assembly module


Commit dedfd8ec3fbc140917de876f0345be7e9ddab65f in geode's branch refs/heads/develop from [~jstewart]
[ https://git-wip-us.apache.org/repos/asf?p=geode.git;h=dedfd8e ]

GEODE-3539: Add tests for List Members and Describe Member


Commit 13dfbb46cfd4fe94da0c1ac7da56995082b5a52e in geode's branch refs/heads/develop from [~khowe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=13dfbb4 ]

GEODE-3539: Add test for missing coverage of status locator command

Also removes some commented out code


Commit 13dfbb46cfd4fe94da0c1ac7da56995082b5a52e in geode's branch refs/heads/feature/GEODE-3083 from [~khowe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=13dfbb4 ]

GEODE-3539: Add test for missing coverage of status locator command

Also removes some commented out code


Commit 1de8b77fbf32568a8bf7092246b68b8c3a622faf in geode's branch refs/heads/develop from [~prhomberg]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=1de8b77 ]

GEODE-3539: Add missing test coverage for 'describe config' command.

This closes #800.


Commit bee0afb2f9618f8b0ba4d431058205a5e5140bc7 in geode's branch refs/heads/develop from [~khowe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=bee0afb ]

GEODE-3539: Add tests for 'alter runtime'


Commit 9d7d55f881982b9e2e7942340f18ce3e9c0d6c50 in geode's branch refs/heads/develop from [~khowe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=9d7d55f ]

GEODE-3539: Refactor to put the alter runtime tests in a separate class


Commit b0348cd3d656848217ed6bb4e06d568203882ddb in geode's branch refs/heads/develop from [~khowe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=b0348cd ]

GEODE-3539: Additional test refactoring

Separated remaining tests from ConfigCommandDUnitTest into command specific classes.


Commit b0348cd3d656848217ed6bb4e06d568203882ddb in geode's branch refs/heads/feature/GEODE-3687 from [~khowe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=b0348cd ]

GEODE-3539: Additional test refactoring

Separated remaining tests from ConfigCommandDUnitTest into command specific classes.


Commit b0348cd3d656848217ed6bb4e06d568203882ddb in geode's branch refs/heads/feature/GEODE-3604 from [~khowe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=b0348cd ]

GEODE-3539: Additional test refactoring

Separated remaining tests from ConfigCommandDUnitTest into command specific classes.


Commit 739e80d63ced113eda504f2912b854c791a5aa02 in geode's branch refs/heads/develop from [~khowe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=739e80d ]

GEODE-3539: Enhanced test coverage for alter runtime command options


Commit 22b02c73e52795ff9175b693a5e3121d0d3618b7 in geode's branch refs/heads/develop from [~khowe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=22b02c7 ]

GEODE-3539: refactored to reduce code duplication


Commit 5212362cee996b20e4552116ac303adec6aa4479 in geode's branch refs/heads/develop from [~jstewart]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=5212362 ]

GEODE-3539: Add tests for 'remove' command

This closes #872.


Commit b2c7605e756bccdd24a94384f851352ff6bb7b90 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=b2c7605 ]

GEODE-3539: consolidate IndexType for better option verification (#910)

* consolidate IndexType
* simplify IndexType class and fix analyzeSerializable test
* add unit test to make sure old behavior is preserved


Commit 9952a1ea95bfa80fd96d94a83b93c389d431fa1f in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=9952a1e ]

GEODE-3539: refactor CreateIndexCommand and add more tests (#915)

* refactor CreateIndexCommand and add more tests
* fix EnumConverter


jinmeiliao opened a new pull request #966: GEODE-3539: add tests for GetCommand and PutCommand
URL: https://github.com/apache/geode/pull/966
 
 
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao closed pull request #966: GEODE-3539: add tests for GetCommand and PutCommand
URL: https://github.com/apache/geode/pull/966
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GetCommandIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GetCommandIntegrationTest.java
new file mode 100644
index 0000000000..6df8be9a5e
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GetCommandIntegrationTest.java
@@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+import java.io.Serializable;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+import org.junit.rules.RuleChain;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.CacheLoader;
+import org.apache.geode.cache.CacheLoaderException;
+import org.apache.geode.cache.LoaderHelper;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.ServerStarterRule;
+
+
+@Category(IntegrationTest.class)
+public class GetCommandIntegrationTest {
+
+  private static ServerStarterRule server =
+      new ServerStarterRule().withJMXManager().withAutoStart();
+
+  private static GfshShellConnectionRule gfsh =
+      new GfshShellConnectionRule(server::getJmxPort, GfshShellConnectionRule.PortType.jmxManager);
+
+  @ClassRule
+  public static RuleChain chain = RuleChain.outerRule(server).around(gfsh);
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    Cache cache = server.getCache();
+    RegionFactory<String, User> regionFactory = cache.createRegionFactory(RegionShortcut.REPLICATE);
+
+    regionFactory.setCacheLoader(new UserDataStoreCacheLoader());
+    regionFactory.setInitialCapacity(51);
+    regionFactory.setKeyConstraint(String.class);
+    regionFactory.setLoadFactor(0.75f);
+    regionFactory.setStatisticsEnabled(false);
+    regionFactory.setValueConstraint(User.class);
+
+    Region<String, User> users = regionFactory.create("Users");
+    assertThat(users.getName()).isEqualTo("Users");
+    assertThat(users.getFullPath()).isEqualTo("/Users");
+
+    users.put("jonbloom", new User("jonbloom"));
+    assertFalse(users.isEmpty());
+    assertEquals(1, users.size());
+  }
+
+  @Test
+  public void get() throws Exception {
+    gfsh.executeAndVerifyCommand("get --region=Users --key=jonbloom");
+  }
+
+  @Test
+  public void getWithSlashedRegionName() throws Exception {
+    gfsh.executeAndVerifyCommand("get --region=/Users --key=jonbloom");
+  }
+
+  @Test
+  public void getOnCacheMiss() throws Exception {
+    gfsh.executeAndVerifyCommand("get --region=Users --key=jonbloom");
+    assertThat(gfsh.getGfshOutput()).contains("Result      : true");
+    gfsh.executeAndVerifyCommand("get --region=Users --key=jondoe --load-on-cache-miss=false");
+    assertThat(gfsh.getGfshOutput()).contains("Result      : false");
+
+    gfsh.executeAndVerifyCommand("get --region=Users --key=jondoe");
+    assertThat(gfsh.getGfshOutput()).contains("Result      : true");
+
+    // get something that does not exist
+    gfsh.executeAndVerifyCommand("get --region=Users --key=missingUser --load-on-cache-miss");
+    assertThat(gfsh.getGfshOutput()).contains("Result      : false");
+  }
+
+  private static class User implements Serializable {
+    private final String username;
+
+    public User(final String username) {
+      assert username != null : "The username cannot be null!";
+      this.username = username;
+    }
+
+    public String getUsername() {
+      return username;
+    }
+
+    @Override
+    public boolean equals(final Object obj) {
+      if (obj == this) {
+        return true;
+      }
+
+      if (!(obj instanceof User)) {
+        return false;
+      }
+
+      User that = (User) obj;
+
+      return this.getUsername().equals(that.getUsername());
+    }
+  }
+
+  private static class UserDataStoreCacheLoader implements CacheLoader<String, User>, Serializable {
+
+    private static final Map<String, User> userDataStore = new HashMap<String, User>(5);
+
+    static {
+      userDataStore.put("jackhandy", createUser("jackhandy"));
+      userDataStore.put("janedoe", createUser("janedoe"));
+      userDataStore.put("jondoe", createUser("jondoe"));
+      userDataStore.put("piedoe", createUser("piedoe"));
+      userDataStore.put("supertool", createUser("supertool"));
+    }
+
+    protected static User createUser(final String username) {
+      return new User(username);
+    }
+
+    @Override
+    public User load(final LoaderHelper<String, User> helper) throws CacheLoaderException {
+      return userDataStore.get(helper.getKey());
+    }
+
+    @Override
+    public void close() {
+      userDataStore.clear();
+    }
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GetCommandOnRegionWithCacheLoaderDuringCacheMissDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GetCommandOnRegionWithCacheLoaderDuringCacheMissDUnitTest.java
deleted file mode 100644
index 3f9fa50fb2..0000000000
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GetCommandOnRegionWithCacheLoaderDuringCacheMissDUnitTest.java
+++ /dev/null
@@ -1,390 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-package org.apache.geode.management.internal.cli.commands;
-
-import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;
-import static org.apache.geode.distributed.ConfigurationProperties.NAME;
-import static org.apache.geode.test.dunit.Assert.assertEquals;
-import static org.apache.geode.test.dunit.Assert.assertFalse;
-import static org.apache.geode.test.dunit.Assert.assertNotNull;
-import static org.apache.geode.test.dunit.Assert.assertNull;
-import static org.apache.geode.test.dunit.Assert.assertTrue;
-import static org.apache.geode.test.dunit.Assert.fail;
-import static org.apache.geode.test.dunit.Host.getHost;
-import static org.apache.geode.test.dunit.LogWriterUtils.getLogWriter;
-import static org.apache.geode.test.dunit.Wait.waitForCriterion;
-
-import java.io.Serializable;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Properties;
-
-import org.junit.Test;
-import org.junit.experimental.categories.Category;
-
-import org.apache.geode.cache.Cache;
-import org.apache.geode.cache.CacheLoader;
-import org.apache.geode.cache.CacheLoaderException;
-import org.apache.geode.cache.LoaderHelper;
-import org.apache.geode.cache.Region;
-import org.apache.geode.cache.RegionFactory;
-import org.apache.geode.cache.RegionShortcut;
-import org.apache.geode.management.DistributedRegionMXBean;
-import org.apache.geode.management.ManagementService;
-import org.apache.geode.management.ManagerMXBean;
-import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.HeadlessGfsh;
-import org.apache.geode.management.internal.cli.i18n.CliStrings;
-import org.apache.geode.management.internal.cli.result.CommandResult;
-import org.apache.geode.management.internal.cli.result.CompositeResultData;
-import org.apache.geode.management.internal.cli.result.ResultData;
-import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
-import org.apache.geode.test.dunit.SerializableRunnable;
-import org.apache.geode.test.dunit.SerializableRunnableIF;
-import org.apache.geode.test.dunit.VM;
-import org.apache.geode.test.dunit.WaitCriterion;
-import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.categories.FlakyTest;
-
-/**
- * The GetCommandOnRegionWithCacheLoaderDuringCacheMissDUnitTest class is test suite of test cases
- * testing the Gfsh 'get' data command when a cache miss occurs on data in a Region with a
- * CacheLoader defined.
- *
- * @see org.apache.geode.management.internal.cli.commands.CliCommandTestBase
- * @see org.apache.geode.management.internal.cli.commands.GetCommand
- * @since GemFire 8.0
- */
-@Category({DistributedTest.class, FlakyTest.class}) // GEODE-3530
-@SuppressWarnings("serial")
-public class GetCommandOnRegionWithCacheLoaderDuringCacheMissDUnitTest extends CliCommandTestBase {
-
-  private static final String GEMFIRE_MANAGER_NAME = "GemManagerNode";
-  private static final String GEMFIRE_SERVER_NAME = "GemServerDataNode";
-  private static final String GEMFIRE_LOG_LEVEL = System.getProperty("logLevel", "config");
-  private static final String USERS_REGION_NAME = "Users";
-
-  @Override
-  public final void postSetUpCliCommandTestBase() throws Exception {
-    Properties managerDistributedSystemProperties =
-        createDistributedSystemProperties(GEMFIRE_MANAGER_NAME);
-    HeadlessGfsh gfsh = setUpJmxManagerOnVm0ThenConnect(managerDistributedSystemProperties); // vm 0
-                                                                                             // --
-                                                                                             // locator/manager
-
-    assertNotNull(gfsh); // controller vm -- gfsh
-    assertTrue(gfsh.isConnectedAndReady());
-
-    setupGemFire(); // vm 1 -- server
-    verifyGemFireSetup(createPeer(getHost(0).getVM(0), managerDistributedSystemProperties));
-  }
-
-  @Test
-  public void testGetOnCacheMiss() {
-    doHousekeeping();
-
-    CommandStringBuilder command = new CommandStringBuilder(CliStrings.GET);
-    command.addOption(CliStrings.GET__REGIONNAME, USERS_REGION_NAME);
-    command.addOption(CliStrings.GET__KEY, "jonbloom");
-
-    assertResult(true, runCommand(command.toString()));
-
-    command = new CommandStringBuilder(CliStrings.GET);
-    command.addOption(CliStrings.GET__REGIONNAME, USERS_REGION_NAME);
-    command.addOption(CliStrings.GET__KEY, "jondoe");
-    command.addOption(CliStrings.GET__LOAD, "false");
-
-    assertResult(false, runCommand(command.toString()));
-
-    command = new CommandStringBuilder(CliStrings.GET);
-    command.addOption(CliStrings.GET__REGIONNAME, USERS_REGION_NAME);
-    command.addOption(CliStrings.GET__KEY, "jondoe");
-    command.addOption(CliStrings.GET__LOAD, "true");
-
-    assertResult(true, runCommand(command.toString()));
-
-    // NOTE test the unspecified default value for the --load-on-cache-miss
-    command = new CommandStringBuilder(CliStrings.GET);
-    command.addOption(CliStrings.GET__REGIONNAME, USERS_REGION_NAME);
-    command.addOption(CliStrings.GET__KEY, "janedoe");
-
-    assertResult(true, runCommand(command.toString()));
-
-    // NOTE now test an absolute cache miss both for in the Region as well as the CacheLoader
-    command = new CommandStringBuilder(CliStrings.GET);
-    command.addOption(CliStrings.GET__REGIONNAME, USERS_REGION_NAME);
-    command.addOption(CliStrings.GET__KEY, "nonexistinguser");
-    command.addOption(CliStrings.GET__LOAD, "true");
-
-    assertResult(false, runCommand(command.toString()));
-  }
-
-  private static String getRegionPath(final String regionName) {
-    return (regionName.startsWith(Region.SEPARATOR) ? regionName
-        : String.format("%1$s%2$s", Region.SEPARATOR, regionName));
-  }
-
-  private static String toString(final Result result) {
-    assert result != null : "The Result object from the command execution was null!";
-
-    StringBuilder buffer = new StringBuilder(System.getProperty("line.separator"));
-
-    while (result.hasNextLine()) {
-      buffer.append(result.nextLine());
-      buffer.append(System.getProperty("line.separator"));
-    }
-
-    return buffer.toString();
-  }
-
-  private void setupGemFire() throws Exception {
-    initializePeer(
-        createPeer(getHost(0).getVM(1), createDistributedSystemProperties(GEMFIRE_SERVER_NAME)));
-  }
-
-  private Properties createDistributedSystemProperties(final String gemfireName) {
-    Properties distributedSystemProperties = new Properties();
-
-    distributedSystemProperties.setProperty(LOG_LEVEL, GEMFIRE_LOG_LEVEL);
-    distributedSystemProperties.setProperty(NAME, gemfireName);
-
-    return distributedSystemProperties;
-  }
-
-  private Peer createPeer(final VM vm, final Properties distributedSystemProperties) {
-    return new Peer(vm, distributedSystemProperties);
-  }
-
-  private void initializePeer(final Peer peer) throws Exception {
-    peer.run(new SerializableRunnable(
-        String.format("Initializes the '%1$s' with the '%2$s' Region having a CacheLoader.",
-            GEMFIRE_SERVER_NAME, USERS_REGION_NAME)) {
-      @Override
-      public void run() {
-        // create the GemFire Distributed System with custom distribution configuration properties
-        // and settings
-        getSystem(peer.getConfiguration());
-
-        Cache cache = getCache();
-        RegionFactory<String, User> regionFactory =
-            cache.createRegionFactory(RegionShortcut.REPLICATE);
-
-        regionFactory.setCacheLoader(new UserDataStoreCacheLoader());
-        regionFactory.setInitialCapacity(51);
-        regionFactory.setKeyConstraint(String.class);
-        regionFactory.setLoadFactor(0.75f);
-        regionFactory.setStatisticsEnabled(false);
-        regionFactory.setValueConstraint(User.class);
-
-        Region<String, User> users = regionFactory.create(USERS_REGION_NAME);
-
-        assertNotNull(users);
-        assertEquals("Users", users.getName());
-        assertEquals("/Users", users.getFullPath());
-        assertTrue(users.isEmpty());
-        assertNull(users.put("jonbloom", new User("jonbloom")));
-        assertFalse(users.isEmpty());
-        assertEquals(1, users.size());
-        assertEquals(new User("jonbloom"), users.get("jonbloom"));
-      }
-    });
-  }
-
-  private void verifyGemFireSetup(final Peer manager) throws Exception {
-    manager.run(new SerializableRunnable(
-        "Verifies the GemFire Cluster was properly configured and initialized!") {
-      @Override
-      public void run() {
-        final ManagementService managementService =
-            ManagementService.getExistingManagementService(getCache());
-
-        WaitCriterion waitOnManagerCriterion = new WaitCriterion() {
-          @Override
-          public boolean done() {
-            ManagerMXBean managerBean = managementService.getManagerMXBean();
-            DistributedRegionMXBean usersRegionBean =
-                managementService.getDistributedRegionMXBean(getRegionPath(USERS_REGION_NAME));
-
-            return !(managerBean == null || usersRegionBean == null);
-          }
-
-          @Override
-          public String description() {
-            return String.format(
-                "Probing for the GemFire Manager '%1$s' and '%2$s' Region MXBeans...",
-                manager.getName(), USERS_REGION_NAME);
-          }
-        };
-
-        waitForCriterion(waitOnManagerCriterion, 30000, 2000, true);
-      }
-    });
-  }
-
-  private void doHousekeeping() {
-    runCommand(CliStrings.LIST_MEMBER);
-
-    runCommand(new CommandStringBuilder(CliStrings.DESCRIBE_MEMBER)
-        .addOption(CliStrings.DESCRIBE_MEMBER__IDENTIFIER, GEMFIRE_SERVER_NAME).toString());
-
-    runCommand(CliStrings.LIST_REGION);
-
-    runCommand(new CommandStringBuilder(CliStrings.DESCRIBE_REGION)
-        .addOption(CliStrings.DESCRIBE_REGION__NAME, USERS_REGION_NAME).toString());
-  }
-
-  private void log(final Result result) {
-    log("Result", toString(result));
-  }
-
-  private void log(final String tag, final String message) {
-    // System.out.printf("%1$s (%2$s)%n", tag, message);
-    getLogWriter().info(String.format("%1$s (%2$s)%n", tag, message));
-  }
-
-  private CommandResult runCommand(final String command) {
-    CommandResult result = executeCommand(command);
-
-    assertNotNull(result);
-    assertEquals(Result.Status.OK, result.getStatus());
-
-    log(result);
-
-    return result;
-  }
-
-  private void assertResult(final boolean expectedResult, final CommandResult commandResult) {
-    if (ResultData.TYPE_COMPOSITE.equals(commandResult.getType())) {
-      boolean actualResult = (Boolean) ((CompositeResultData) commandResult.getResultData())
-          .retrieveSectionByIndex(0).retrieveObject("Result");
-      assertEquals(expectedResult, actualResult);
-    } else {
-      fail(String.format("Expected composite result data; but was '%1$s'!%n",
-          commandResult.getType()));
-    }
-  }
-
-  private static class Peer implements Serializable {
-
-    private final Properties distributedSystemProperties;
-    private final VM vm;
-
-    public Peer(final VM vm, final Properties distributedSystemProperties) {
-      assert distributedSystemProperties != null : "The GemFire Distributed System configuration properties and settings cannot be null!";
-      this.vm = vm;
-      this.distributedSystemProperties = distributedSystemProperties;
-    }
-
-    public Properties getConfiguration() {
-      return this.distributedSystemProperties;
-    }
-
-    public String getName() {
-      return getConfiguration().getProperty(NAME);
-    }
-
-    public VM getVm() {
-      return vm;
-    }
-
-    public void run(final SerializableRunnableIF runnable) throws Exception {
-      if (getVm() == null) {
-        runnable.run();
-      } else {
-        getVm().invoke(runnable);
-      }
-    }
-
-    @Override
-    public String toString() {
-      StringBuilder buffer = new StringBuilder(getClass().getSimpleName());
-
-      buffer.append(" {configuration = ").append(getConfiguration());
-      buffer.append(", name = ").append(getName());
-      buffer.append(", pid = ").append(getVm().getId());
-      buffer.append("}");
-
-      return buffer.toString();
-    }
-  }
-
-  private static class User implements Serializable {
-
-    private final String username;
-
-    public User(final String username) {
-      assert username != null : "The username cannot be null!";
-      this.username = username;
-    }
-
-    public String getUsername() {
-      return username;
-    }
-
-    @Override
-    public boolean equals(final Object obj) {
-      if (obj == this) {
-        return true;
-      }
-
-      if (!(obj instanceof User)) {
-        return false;
-      }
-
-      User that = (User) obj;
-
-      return this.getUsername().equals(that.getUsername());
-    }
-
-    @Override
-    public int hashCode() {
-      int hashValue = 17;
-      hashValue = 37 * hashValue + getUsername().hashCode();
-      return hashValue;
-    }
-
-    @Override
-    public String toString() {
-      return getUsername();
-    }
-  }
-
-  private static class UserDataStoreCacheLoader implements CacheLoader<String, User>, Serializable {
-
-    private static final Map<String, User> userDataStore = new HashMap<String, User>(5);
-
-    static {
-      userDataStore.put("jackhandy", createUser("jackhandy"));
-      userDataStore.put("janedoe", createUser("janedoe"));
-      userDataStore.put("jondoe", createUser("jondoe"));
-      userDataStore.put("piedoe", createUser("piedoe"));
-      userDataStore.put("supertool", createUser("supertool"));
-    }
-
-    protected static User createUser(final String username) {
-      return new User(username);
-    }
-
-    @Override
-    public User load(final LoaderHelper<String, User> helper) throws CacheLoaderException {
-      return userDataStore.get(helper.getKey());
-    }
-
-    @Override
-    public void close() {
-      userDataStore.clear();
-    }
-  }
-}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/PutCommandIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/PutCommandIntegrationTest.java
new file mode 100644
index 0000000000..4dae79f73c
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/PutCommandIntegrationTest.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+import org.junit.rules.RuleChain;
+
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.ServerStarterRule;
+
+
+@Category(IntegrationTest.class)
+public class PutCommandIntegrationTest {
+
+  private static ServerStarterRule server =
+      new ServerStarterRule().withJMXManager().withRegion(RegionShortcut.REPLICATE, "testRegion");
+
+  private static GfshShellConnectionRule gfsh =
+      new GfshShellConnectionRule(server::getJmxPort, GfshShellConnectionRule.PortType.jmxManager);
+
+  @ClassRule
+  public static RuleChain chain = RuleChain.outerRule(server).around(gfsh);
+
+
+  @Test
+  public void putWithoutSlash() throws Exception {
+    gfsh.executeAndVerifyCommand("put --region=testRegion --key=key1 --value=value1");
+  }
+
+
+  @Test
+  public void putWithSlash() throws Exception {
+    gfsh.executeAndVerifyCommand("put --region=/testRegion --key=key1 --value=value1");
+  }
+}
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpDUnitTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpDUnitTest.java
index 08be1d50bf..97a5112a38 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpDUnitTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpDUnitTest.java
@@ -28,7 +28,6 @@
 @RunWith(SuiteRunner.class)
 @Suite.SuiteClasses({ChangeLogLevelCommandDUnitTest.class, DeployWithGroupsDUnitTest.class,
     DiskStoreCommandsDUnitTest.class, GcCommandDUnitTest.class, GemfireDataCommandsDUnitTest.class,
-    GetCommandOnRegionWithCacheLoaderDuringCacheMissDUnitTest.class,
     ListAndDescribeDiskStoreCommandsDUnitTest.class, ShutdownCommandDUnitTest.class,
     QueueCommandsDUnitTest.class, ShellCommandsDUnitTest.class, ShowDeadlockDUnitTest.class,
     ShowLogCommandDUnitTest.class, ShowMetricsDUnitTest.class, ShowStackTraceDUnitTest.class})


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 419378790055a654010146d2b0431c7ae80b59e7 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=4193787 ]

GEODE-3539: add tests for GetCommand and PutCommand (#966)

* GEODE-3539: add tests for GetCommand and PutCommand

Commit 419378790055a654010146d2b0431c7ae80b59e7 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=4193787 ]

GEODE-3539: add tests for GetCommand and PutCommand (#966)

* GEODE-3539: add tests for GetCommand and PutCommand

jinmeiliao opened a new pull request #992: GEODE-3539: Consolidate CliUtil and DataCommandUtils, DataCommandsUtil
URL: https://github.com/apache/geode/pull/992
 
 
   * remove DataCommandsUtil
   * move methods from DataCommandUtils to CliUtil if applicable.
   * move methods from DataCommandUtils to individual command if only used by one command
   
   This is the work triggered by the effort to refactor GemfireDataCommandsDUnitTest. Thought I should stop here to make the change set small.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jdeppe-pivotal commented on a change in pull request #992: GEODE-3539: Consolidate CliUtil and DataCommandUtils, DataCommandsUtil
URL: https://github.com/apache/geode/pull/992#discussion_r147811482
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GemfireDataCommandsDUnitTest.java
 ##########
 @@ -589,14 +588,14 @@ public void doTestBug48013() {
   public void testSelectCommand() {
     setupForSelect();
     doTestGetRegionAssociatedMembersForSelect();
-    doTestSelectWithGfshEnvVariables(true);
-    doTestSelectWithGfshEnvVariables(false);
-    doTestSelectProjection();
-    doTestBug48013();
-    doTestSelectProjectionProcessCommand();
-    doTestSelectProjectionWithNestedField();
-    doTestSelectBeansAsResult();
-    doTestSelectBeansWithNestedFieldAsResult();
+    // doTestSelectWithGfshEnvVariables(true);
+    // doTestSelectWithGfshEnvVariables(false);
+    // doTestSelectProjection();
+    // doTestBug48013();
+    // doTestSelectProjectionProcessCommand();
+    // doTestSelectProjectionWithNestedField();
+    // doTestSelectBeansAsResult();
+    // doTestSelectBeansWithNestedFieldAsResult();
 
 Review comment:
   Can these be deleted? If they need to stay, could you add a comment as to why they're commented out.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jdeppe-pivotal commented on a change in pull request #992: GEODE-3539: Consolidate CliUtil and DataCommandUtils, DataCommandsUtil
URL: https://github.com/apache/geode/pull/992#discussion_r147811171
 
 

 ##########
 File path: geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportDataCommand.java
 ##########
 @@ -107,4 +107,24 @@ private String defaultFileName(String dirPath, String regionName) {
     }
     return Optional.empty();
   }
+
+  static Result getFunctionResult(ResultCollector<?, ?> rc, String commandName) {
 
 Review comment:
   Can this also be moved to CliUtil?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on a change in pull request #992: GEODE-3539: Consolidate CliUtil and DataCommandUtils, DataCommandsUtil
URL: https://github.com/apache/geode/pull/992#discussion_r147841644
 
 

 ##########
 File path: geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportDataCommand.java
 ##########
 @@ -107,4 +107,24 @@ private String defaultFileName(String dirPath, String regionName) {
     }
     return Optional.empty();
   }
+
+  static Result getFunctionResult(ResultCollector<?, ?> rc, String commandName) {
 
 Review comment:
   moved.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on a change in pull request #992: GEODE-3539: Consolidate CliUtil and DataCommandUtils, DataCommandsUtil
URL: https://github.com/apache/geode/pull/992#discussion_r147841649
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GemfireDataCommandsDUnitTest.java
 ##########
 @@ -589,14 +588,14 @@ public void doTestBug48013() {
   public void testSelectCommand() {
     setupForSelect();
     doTestGetRegionAssociatedMembersForSelect();
-    doTestSelectWithGfshEnvVariables(true);
-    doTestSelectWithGfshEnvVariables(false);
-    doTestSelectProjection();
-    doTestBug48013();
-    doTestSelectProjectionProcessCommand();
-    doTestSelectProjectionWithNestedField();
-    doTestSelectBeansAsResult();
-    doTestSelectBeansWithNestedFieldAsResult();
+    // doTestSelectWithGfshEnvVariables(true);
+    // doTestSelectWithGfshEnvVariables(false);
+    // doTestSelectProjection();
+    // doTestBug48013();
+    // doTestSelectProjectionProcessCommand();
+    // doTestSelectProjectionWithNestedField();
+    // doTestSelectBeansAsResult();
+    // doTestSelectBeansWithNestedFieldAsResult();
 
 Review comment:
   this is an accidental change that needs to be reverted.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao closed pull request #992: GEODE-3539: Consolidate CliUtil and DataCommandUtils, DataCommandsUtil
URL: https://github.com/apache/geode/pull/992
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/main/java/org/apache/geode/distributed/internal/ClusterConfigurationService.java b/geode-core/src/main/java/org/apache/geode/distributed/internal/ClusterConfigurationService.java
index d990015a5c..2eefb89ea8 100644
--- a/geode-core/src/main/java/org/apache/geode/distributed/internal/ClusterConfigurationService.java
+++ b/geode-core/src/main/java/org/apache/geode/distributed/internal/ClusterConfigurationService.java
@@ -18,10 +18,41 @@
 import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_MANAGER;
 import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_POST_PROCESSOR;
 
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileFilter;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.nio.file.Path;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.Properties;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.stream.Collectors;
+
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.TransformerFactoryConfigurationError;
+
 import org.apache.commons.io.FileUtils;
 import org.apache.commons.io.FilenameUtils;
 import org.apache.commons.io.filefilter.DirectoryFileFilter;
 import org.apache.commons.lang.StringUtils;
+import org.apache.logging.log4j.Logger;
+import org.w3c.dom.Document;
+import org.xml.sax.SAXException;
+
 import org.apache.geode.CancelException;
 import org.apache.geode.cache.AttributesFactory;
 import org.apache.geode.cache.CacheLoaderException;
@@ -53,34 +84,6 @@
 import org.apache.geode.management.internal.configuration.messages.ConfigurationResponse;
 import org.apache.geode.management.internal.configuration.messages.SharedConfigurationStatusResponse;
 import org.apache.geode.management.internal.configuration.utils.XmlUtils;
-import org.apache.logging.log4j.Logger;
-import org.w3c.dom.Document;
-import org.xml.sax.SAXException;
-
-import java.io.BufferedWriter;
-import java.io.File;
-import java.io.FileFilter;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.nio.file.Path;
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Objects;
-import java.util.Properties;
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.stream.Collectors;
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.transform.TransformerException;
-import javax.xml.transform.TransformerFactoryConfigurationError;
 
 @SuppressWarnings({"deprecation", "unchecked"})
 public class ClusterConfigurationService {
@@ -671,8 +674,9 @@ private void unlockSharedConfiguration() {
 
   private byte[] downloadJarFromLocator(DistributedMember locator, String groupName,
       String jarName) {
-    ResultCollector<byte[], List<byte[]>> rc = (ResultCollector<byte[], List<byte[]>>) CliUtil
-        .executeFunction(new UploadJarFunction(), new Object[] {groupName, jarName}, locator);
+    ResultCollector<byte[], List<byte[]>> rc =
+        (ResultCollector<byte[], List<byte[]>>) CliUtil.executeFunction(new UploadJarFunction(),
+            new Object[] {groupName, jarName}, Collections.singleton(locator));
 
     List<byte[]> result = rc.getResult();
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/beans/QueryDataFunction.java b/geode-core/src/main/java/org/apache/geode/management/internal/beans/QueryDataFunction.java
index 0b4470d6e9..0771f33fe7 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/beans/QueryDataFunction.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/beans/QueryDataFunction.java
@@ -14,7 +14,21 @@
  */
 package org.apache.geode.management.internal.beans;
 
+import java.io.Serializable;
+import java.io.StringWriter;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+import java.util.StringTokenizer;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
 import org.apache.commons.lang.StringUtils;
+import org.apache.logging.log4j.Logger;
+
 import org.apache.geode.SystemFailure;
 import org.apache.geode.cache.CacheFactory;
 import org.apache.geode.cache.DataPolicy;
@@ -46,23 +60,10 @@
 import org.apache.geode.management.internal.ManagementConstants;
 import org.apache.geode.management.internal.ManagementStrings;
 import org.apache.geode.management.internal.SystemManagementService;
-import org.apache.geode.management.internal.cli.commands.DataCommandsUtils;
+import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.json.GfJsonException;
 import org.apache.geode.management.internal.cli.json.GfJsonObject;
 import org.apache.geode.management.internal.cli.json.TypedJson;
-import org.apache.logging.log4j.Logger;
-
-import java.io.Serializable;
-import java.io.StringWriter;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-import java.util.StringTokenizer;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
 /**
  * This function is executed on one or multiple members based on the member input to
@@ -365,7 +366,7 @@ public static Object queryData(final String query, final String members, final i
                     .toString();
           } else {
             Set<DistributedMember> associatedMembers =
-                DataCommandsUtils.getRegionAssociatedMembers(regionPath, cache, true);
+                CliUtil.getRegionAssociatedMembers(regionPath, cache, true);
 
             if (inputMembers != null && inputMembers.size() > 0) {
               if (!associatedMembers.containsAll(inputMembers)) {
@@ -396,10 +397,9 @@ public static Object queryData(final String query, final String members, final i
 
       String randomRegion = regionsInQuery.iterator().next();
 
+      // get the first available member
       Set<DistributedMember> associatedMembers =
-          DataCommandsUtils.getQueryRegionsAssociatedMembers(regionsInQuery, cache, false);// First
-      // available
-      // member
+          CliUtil.getQueryRegionsAssociatedMembers(regionsInQuery, cache, false);
 
       if (associatedMembers != null && associatedMembers.size() > 0) {
         Object[] functionArgs = new Object[6];
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java
index 4848f8b265..c6ab85259d 100755
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java
@@ -31,13 +31,13 @@
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
+import java.util.Collections;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
+import java.util.stream.Collectors;
 import java.util.zip.DataFormatException;
 import java.util.zip.Deflater;
 import java.util.zip.Inflater;
@@ -58,11 +58,13 @@
 import org.apache.geode.internal.cache.execute.AbstractExecution;
 import org.apache.geode.internal.cache.tier.sockets.CacheClientProxy;
 import org.apache.geode.internal.util.IOUtils;
-import org.apache.geode.management.DistributedSystemMXBean;
+import org.apache.geode.management.DistributedRegionMXBean;
 import org.apache.geode.management.ManagementService;
 import org.apache.geode.management.cli.Result;
+import org.apache.geode.management.internal.MBeanJMXAdapter;
 import org.apache.geode.management.internal.cli.functions.MembersForRegionFunction;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
+import org.apache.geode.management.internal.cli.result.ResultBuilder;
 import org.apache.geode.management.internal.cli.shell.Gfsh;
 
 /**
@@ -386,6 +388,26 @@ public static String stackTraceAsString(Throwable e) {
     return instance;
   }
 
+  public static Result getFunctionResult(ResultCollector<?, ?> rc, String commandName) {
+    Result result;
+    List<Object> results = (List<Object>) rc.getResult();
+    if (results != null) {
+      Object resultObj = results.get(0);
+      if (resultObj instanceof String) {
+        result = ResultBuilder.createInfoResult((String) resultObj);
+      } else if (resultObj instanceof Exception) {
+        result = ResultBuilder.createGemFireErrorResult(((Exception) resultObj).getMessage());
+      } else {
+        result = ResultBuilder.createGemFireErrorResult(
+            CliStrings.format(CliStrings.COMMAND_FAILURE_MESSAGE, commandName));
+      }
+    } else {
+      result = ResultBuilder.createGemFireErrorResult(
+          CliStrings.format(CliStrings.COMMAND_FAILURE_MESSAGE, commandName));
+    }
+    return result;
+  }
+
   static class CustomFileFilter implements FileFilter {
     private String extensionWithDot;
 
@@ -492,8 +514,7 @@ public static boolean contains(Object[] array, Object object) {
    */
   @SuppressWarnings("unchecked")
   public static Set<DistributedMember> getAllMembers(InternalCache cache) {
-    return new HashSet<DistributedMember>(
-        cache.getInternalDistributedSystem().getDistributionManager().getDistributionManagerIds());
+    return getAllMembers(cache.getInternalDistributedSystem());
   }
 
   @SuppressWarnings("unchecked")
@@ -502,19 +523,6 @@ public static boolean contains(Object[] array, Object object) {
         internalDS.getDistributionManager().getDistributionManagerIds());
   }
 
-  /**
-   * Returns a set of all the members of the distributed system for the given groups.
-   */
-  public static Set<DistributedMember> getDistributedMembersByGroup(InternalCache cache,
-      String[] groups) {
-    Set<DistributedMember> groupMembers = new HashSet<>();
-    for (String group : groups) {
-      groupMembers.addAll(
-          cache.getInternalDistributedSystem().getDistributionManager().getGroupMembers(group));
-    }
-    return groupMembers;
-  }
-
   /***
    * Executes a function with arguments on a set of members , ignores the departed members.
    * 
@@ -539,29 +547,6 @@ public static boolean contains(Object[] array, Object object) {
     return execution.execute(function);
   }
 
-  /***
-   * Executes a function with arguments on a member , ignores the departed member.
-   * 
-   * @param function Function to be executed
-   * @param args Arguments passed to the function, pass null if you wish to pass no arguments to the
-   *        function.
-   * @param targetMember Member on which the function is to be executed.
-   * @return ResultCollector
-   */
-  public static ResultCollector<?, ?> executeFunction(final Function function, Object args,
-      final DistributedMember targetMember) {
-    Execution execution;
-
-    if (args != null) {
-      execution = FunctionService.onMember(targetMember).setArguments(args);
-    } else {
-      execution = FunctionService.onMember(targetMember);
-    }
-
-    ((AbstractExecution) execution).setIgnoreDepartedMembers(true);
-    return execution.execute(function);
-  }
-
   /**
    * Returns a Set of DistributedMember for members that have the specified <code>region</code>.
    * <code>returnAll</code> indicates whether to return all members or only the first member we
@@ -569,39 +554,69 @@ public static boolean contains(Object[] array, Object object) {
    *
    * @param region region path for which members that have this region are required
    * @param cache cache instance to use to find members
+   * @param returnAll if true, returns all matching members, else returns only first one found.
    * @return a Set of DistributedMember for members that have the specified <code>region</code>.
    */
   public static Set<DistributedMember> getRegionAssociatedMembers(String region,
-      final InternalCache cache) {
+      final InternalCache cache, boolean returnAll) {
     if (region == null || region.isEmpty()) {
-      return null;
+      return Collections.emptySet();
     }
 
     if (!region.startsWith(Region.SEPARATOR)) {
       region = Region.SEPARATOR + region;
     }
 
-    ManagementService managementService = ManagementService.getExistingManagementService(cache);
-    DistributedSystemMXBean distributedSystemMXBean =
-        managementService.getDistributedSystemMXBean();
-    Set<DistributedMember> matchedMembers = new HashSet<>();
+    DistributedRegionMXBean regionMXBean =
+        ManagementService.getManagementService(cache).getDistributedRegionMXBean(region);
 
+    if (regionMXBean == null) {
+      return Collections.emptySet();
+    }
+
+    String[] regionAssociatedMemberNames = regionMXBean.getMembers();
+    Set<DistributedMember> matchedMembers = new HashSet<>();
     Set<DistributedMember> allClusterMembers = new HashSet<>();
     allClusterMembers.addAll(cache.getMembers());
     allClusterMembers.add(cache.getDistributedSystem().getDistributedMember());
 
     for (DistributedMember member : allClusterMembers) {
-      try {
-        if (distributedSystemMXBean.fetchRegionObjectName(CliUtil.getMemberNameOrId(member),
-            region) != null) {
+      for (String regionAssociatedMemberName : regionAssociatedMemberNames) {
+        String name = MBeanJMXAdapter.getMemberNameOrId(member);
+        if (name.equals(regionAssociatedMemberName)) {
           matchedMembers.add(member);
+          if (!returnAll) {
+            return matchedMembers;
+          }
         }
-      } catch (Exception ignored) {
       }
     }
     return matchedMembers;
   }
 
+  /**
+   * this finds the member that hosts all the regions passed in.
+   * 
+   * @param regions
+   * @param cache
+   * @param returnAll: if true, returns all matching members, otherwise, returns only one.
+   */
+  public static Set<DistributedMember> getQueryRegionsAssociatedMembers(Set<String> regions,
+      final InternalCache cache, boolean returnAll) {
+    Set<DistributedMember> results = regions.stream()
+        .map(region -> getRegionAssociatedMembers(region, cache, true)).reduce((s1, s2) -> {
+          s1.retainAll(s2);
+          return s1;
+        }).get();
+
+    if (returnAll || results.size() <= 1) {
+      return results;
+    }
+
+    // returns a set of only one item
+    return Collections.singleton(results.iterator().next());
+  }
+
   public static String getMemberNameOrId(DistributedMember distributedMember) {
     String nameOrId = null;
     if (distributedMember != null) {
@@ -611,41 +626,11 @@ public static String getMemberNameOrId(DistributedMember distributedMember) {
     return nameOrId;
   }
 
-  public static String collectionToString(Collection<?> col, int newlineAfter) {
-    if (col != null) {
-      StringBuilder builder = new StringBuilder();
-      int lastNewlineAt = 0;
-
-      for (Iterator<?> it = col.iterator(); it.hasNext();) {
-        Object object = it.next();
-        builder.append(String.valueOf(object));
-        if (it.hasNext()) {
-          builder.append(", ");
-        }
-        if (newlineAfter > 0 && (builder.length() - lastNewlineAt) / newlineAfter >= 1) {
-          builder.append(GfshParser.LINE_SEPARATOR);
-        }
-      }
-      return builder.toString();
-    } else {
-      return "" + null;
-    }
-  }
-
   public static <T> String arrayToString(T[] array) {
-    if (array != null) {
-      StringBuilder builder = new StringBuilder();
-      for (int i = 0; i < array.length; i++) {
-        Object object = array[i];
-        builder.append(String.valueOf(object));
-        if (i < array.length - 1) {
-          builder.append(", ");
-        }
-      }
-      return builder.toString();
-    } else {
-      return "" + null;
+    if (array == null) {
+      return "null";
     }
+    return Arrays.stream(array).map(String::valueOf).collect(Collectors.joining(", "));
   }
 
   public static String decodeWithDefaultCharSet(String urlToDecode) {
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommand.java
index 0555ad5fa9..139f29639d 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommand.java
@@ -407,12 +407,11 @@ RegionAttributes getRegionAttributes(InternalCache cache, String regionPath) {
 
     if (attributes == null) {
       // find first member which has the region
-      Set<DistributedMember> regionAssociatedMembers =
-          CliUtil.getRegionAssociatedMembers(regionPath, cache);
+      Set<DistributedMember> regionAssociatedMembers = findMembersForRegion(cache, regionPath);
       if (regionAssociatedMembers != null && !regionAssociatedMembers.isEmpty()) {
         DistributedMember distributedMember = regionAssociatedMembers.iterator().next();
-        ResultCollector<?, ?> resultCollector = CliUtil
-            .executeFunction(FetchRegionAttributesFunction.INSTANCE, regionPath, distributedMember);
+        ResultCollector<?, ?> resultCollector =
+            executeFunction(FetchRegionAttributesFunction.INSTANCE, regionPath, distributedMember);
         List<?> resultsList = (List<?>) resultCollector.getResult();
 
         if (resultsList != null && !resultsList.isEmpty()) {
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DataCommandUtil.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DataCommandUtil.java
deleted file mode 100644
index b15a958207..0000000000
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DataCommandUtil.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- *
- * * Licensed to the Apache Software Foundation (ASF) under one or more contributor license *
- * agreements. See the NOTICE file distributed with this work for additional information regarding *
- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
- * * "License"); you may not use this file except in compliance with the License. You may obtain a *
- * copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by
- * applicable law or agreed to in writing, software distributed under the License * is distributed
- * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express * or implied.
- * See the License for the specific language governing permissions and limitations under * the
- * License. *
- *
- */
-
-package org.apache.geode.management.internal.cli.commands;
-
-import java.util.List;
-
-import org.apache.geode.cache.execute.ResultCollector;
-import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.i18n.CliStrings;
-import org.apache.geode.management.internal.cli.result.ResultBuilder;
-
-public class DataCommandUtil {
-  public static Result getFunctionResult(ResultCollector<?, ?> rc, String commandName) {
-    Result result;
-    List<Object> results = (List<Object>) rc.getResult();
-    if (results != null) {
-      Object resultObj = results.get(0);
-      if (resultObj instanceof String) {
-        result = ResultBuilder.createInfoResult((String) resultObj);
-      } else if (resultObj instanceof Exception) {
-        result = ResultBuilder.createGemFireErrorResult(((Exception) resultObj).getMessage());
-      } else {
-        result = ResultBuilder.createGemFireErrorResult(
-            CliStrings.format(CliStrings.COMMAND_FAILURE_MESSAGE, commandName));
-      }
-    } else {
-      result = ResultBuilder.createGemFireErrorResult(
-          CliStrings.format(CliStrings.COMMAND_FAILURE_MESSAGE, commandName));
-    }
-    return result;
-  }
-}
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DataCommandsUtils.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DataCommandsUtils.java
index bca315ffec..7a6bfbc9ab 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DataCommandsUtils.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DataCommandsUtils.java
@@ -15,153 +15,19 @@
 
 package org.apache.geode.management.internal.cli.commands;
 
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
-import java.util.StringTokenizer;
 
-import org.apache.commons.collections.CollectionUtils;
-import org.apache.commons.lang.StringUtils;
-
-import org.apache.geode.LogWriter;
-import org.apache.geode.cache.Region;
 import org.apache.geode.cache.execute.FunctionService;
 import org.apache.geode.cache.execute.ResultCollector;
 import org.apache.geode.distributed.DistributedMember;
-import org.apache.geode.internal.cache.InternalCache;
-import org.apache.geode.management.DistributedRegionMXBean;
-import org.apache.geode.management.ManagementService;
 import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.MBeanJMXAdapter;
-import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.LogWrapper;
 import org.apache.geode.management.internal.cli.domain.DataCommandRequest;
 import org.apache.geode.management.internal.cli.domain.DataCommandResult;
 import org.apache.geode.management.internal.cli.functions.DataCommandFunction;
-import org.apache.geode.management.internal.cli.i18n.CliStrings;
-import org.apache.geode.management.internal.cli.result.CompositeResultData;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
-import org.apache.geode.management.internal.cli.result.TabularResultData;
 
 public class DataCommandsUtils {
-  static boolean checkResultList(CompositeResultData rebalanceResultData, List resultList,
-      DistributedMember member) {
-    boolean toContinueForOtherMembers = false;
-    if (CollectionUtils.isNotEmpty(resultList)) {
-      for (Object object : resultList) {
-        if (object instanceof Exception) {
-          rebalanceResultData.addSection().addData(
-              CliStrings.format(CliStrings.REBALANCE__MSG__NO_EXECUTION, member.getId()),
-              ((Exception) object).getMessage());
-
-          LogWrapper.getInstance().info(CliStrings.REBALANCE__MSG__NO_EXECUTION + member.getId()
-              + " exception=" + ((Throwable) object).getMessage(), ((Throwable) object));
-
-          toContinueForOtherMembers = true;
-          break;
-        } else if (object instanceof Throwable) {
-          rebalanceResultData.addSection().addData(
-              CliStrings.format(CliStrings.REBALANCE__MSG__NO_EXECUTION, member.getId()),
-              ((Throwable) object).getMessage());
-
-          LogWrapper.getInstance().info(CliStrings.REBALANCE__MSG__NO_EXECUTION + member.getId()
-              + " exception=" + ((Throwable) object).getMessage(), ((Throwable) object));
-
-          toContinueForOtherMembers = true;
-          break;
-        }
-      }
-    } else {
-      LogWrapper.getInstance().info(
-          "Rebalancing for member=" + member.getId() + ", resultList is either null or empty");
-      rebalanceResultData.addSection().addData("Rebalancing for member=" + member.getId(),
-          ", resultList is either null or empty");
-      toContinueForOtherMembers = true;
-    }
-    return toContinueForOtherMembers;
-  }
-
-  static List<String> tokenize(String str, String separator) {
-    StringTokenizer st = new StringTokenizer(str, separator);
-    List<String> rstList = new ArrayList<>();
-    while (st.hasMoreTokens()) {
-      rstList.add(st.nextToken());
-
-    }
-    return rstList;
-  }
-
-  static CompositeResultData toCompositeResultData(CompositeResultData rebalanceResultData,
-      ArrayList<String> rstlist, int index, boolean simulate, InternalCache cache) {
-    int resultItemCount = 9;
-    // add only if there are any valid regions in results
-    if (rstlist.size() > resultItemCount && StringUtils.isNotEmpty(rstlist.get(resultItemCount))) {
-      TabularResultData table1 = rebalanceResultData.addSection().addTable("Table" + index);
-      String newLine = System.getProperty("line.separator");
-      StringBuilder resultStr = new StringBuilder();
-      resultStr.append(newLine);
-      table1.accumulate("Rebalanced Stats", CliStrings.REBALANCE__MSG__TOTALBUCKETCREATEBYTES);
-      table1.accumulate("Value", rstlist.get(0));
-      resultStr.append(CliStrings.REBALANCE__MSG__TOTALBUCKETCREATEBYTES).append(" = ")
-          .append(rstlist.get(0)).append(newLine);
-      table1.accumulate("Rebalanced Stats", CliStrings.REBALANCE__MSG__TOTALBUCKETCREATETIM);
-      table1.accumulate("Value", rstlist.get(1));
-      resultStr.append(CliStrings.REBALANCE__MSG__TOTALBUCKETCREATETIM).append(" = ")
-          .append(rstlist.get(1)).append(newLine);
-
-      table1.accumulate("Rebalanced Stats", CliStrings.REBALANCE__MSG__TOTALBUCKETCREATESCOMPLETED);
-      table1.accumulate("Value", rstlist.get(2));
-      resultStr.append(CliStrings.REBALANCE__MSG__TOTALBUCKETCREATESCOMPLETED).append(" = ")
-          .append(rstlist.get(2)).append(newLine);
-
-      table1.accumulate("Rebalanced Stats", CliStrings.REBALANCE__MSG__TOTALBUCKETTRANSFERBYTES);
-      table1.accumulate("Value", rstlist.get(3));
-      resultStr.append(CliStrings.REBALANCE__MSG__TOTALBUCKETTRANSFERBYTES).append(" = ")
-          .append(rstlist.get(3)).append(newLine);
-
-      table1.accumulate("Rebalanced Stats", CliStrings.REBALANCE__MSG__TOTALBUCKETTRANSFERTIME);
-      table1.accumulate("Value", rstlist.get(4));
-      resultStr.append(CliStrings.REBALANCE__MSG__TOTALBUCKETTRANSFERTIME).append(" = ")
-          .append(rstlist.get(4)).append(newLine);
-
-      table1.accumulate("Rebalanced Stats",
-          CliStrings.REBALANCE__MSG__TOTALBUCKETTRANSFERSCOMPLETED);
-      table1.accumulate("Value", rstlist.get(5));
-      resultStr.append(CliStrings.REBALANCE__MSG__TOTALBUCKETTRANSFERSCOMPLETED).append(" = ")
-          .append(rstlist.get(5)).append(newLine);
-
-      table1.accumulate("Rebalanced Stats", CliStrings.REBALANCE__MSG__TOTALPRIMARYTRANSFERTIME);
-      table1.accumulate("Value", rstlist.get(6));
-      resultStr.append(CliStrings.REBALANCE__MSG__TOTALPRIMARYTRANSFERTIME).append(" = ")
-          .append(rstlist.get(6)).append(newLine);
-
-      table1.accumulate("Rebalanced Stats",
-          CliStrings.REBALANCE__MSG__TOTALPRIMARYTRANSFERSCOMPLETED);
-      table1.accumulate("Value", rstlist.get(7));
-      resultStr.append(CliStrings.REBALANCE__MSG__TOTALPRIMARYTRANSFERSCOMPLETED).append(" = ")
-          .append(rstlist.get(7)).append(newLine);
-
-      table1.accumulate("Rebalanced Stats", CliStrings.REBALANCE__MSG__TOTALTIME);
-      table1.accumulate("Value", rstlist.get(8));
-      resultStr.append(CliStrings.REBALANCE__MSG__TOTALTIME).append(" = ").append(rstlist.get(8))
-          .append(newLine);
-
-      String headerText;
-      if (simulate) {
-        headerText = "Simulated partition regions ";
-      } else {
-        headerText = "Rebalanced partition regions ";
-      }
-      for (int i = resultItemCount; i < rstlist.size(); i++) {
-        headerText = headerText + " " + rstlist.get(i);
-      }
-      table1.setHeader(headerText);
-      cache.getLogger().info(headerText + resultStr);
-    }
-    return rebalanceResultData;
-  }
 
   static Result makePresentationResult(DataCommandResult dataResult) {
     if (dataResult != null) {
@@ -171,52 +37,6 @@ static Result makePresentationResult(DataCommandResult dataResult) {
     }
   }
 
-  public static Set<DistributedMember> getRegionAssociatedMembers(String region,
-      final InternalCache cache, boolean returnAll) {
-    DistributedMember member;
-    if (StringUtils.isEmpty(region)) {
-      return null;
-    }
-    DistributedRegionMXBean bean =
-        ManagementService.getManagementService(cache).getDistributedRegionMXBean(region);
-    if (bean == null) {
-      // try with slash ahead
-      bean = ManagementService.getManagementService(cache)
-          .getDistributedRegionMXBean(Region.SEPARATOR + region);
-    }
-    if (bean == null) {
-      return null;
-    }
-    String[] membersName = bean.getMembers();
-    Set<DistributedMember> dsMembers = cache.getMembers();
-    Set<DistributedMember> dsMembersWithThisMember = new HashSet<>();
-    dsMembersWithThisMember.addAll(dsMembers);
-    dsMembersWithThisMember.add(cache.getDistributedSystem().getDistributedMember());
-    Iterator it = dsMembersWithThisMember.iterator();
-    Set<DistributedMember> matchedMembers = new HashSet<>();
-
-    if (membersName.length > 0) {
-      while (it.hasNext()) {
-        DistributedMember dsmember = (DistributedMember) it.next();
-        for (String memberName : membersName) {
-          String name = MBeanJMXAdapter.getMemberNameOrId(dsmember);
-          if (name.equals(memberName)) {
-            member = dsmember;
-            matchedMembers.add(member);
-            if (!returnAll) {
-              return matchedMembers;
-            }
-          }
-        }
-      }
-    }
-    // try with function calls
-    if (matchedMembers.size() == 0) {
-      matchedMembers = CliUtil.getMembersForeRegionViaFunction(cache, region, true);
-    }
-    return matchedMembers;
-  }
-
   static DataCommandResult callFunctionForRegion(DataCommandRequest request,
       DataCommandFunction putfn, Set<DistributedMember> members) {
     if (members.size() == 1) {
@@ -259,53 +79,4 @@ static DataCommandResult callFunctionForRegion(DataCommandRequest request,
       return result;
     }
   }
-
-  public static Set<DistributedMember> getQueryRegionsAssociatedMembers(Set<String> regions,
-      final InternalCache cache, boolean returnAll) {
-    LogWriter logger = cache.getLogger();
-    Set<DistributedMember> members;
-    Set<DistributedMember> newMembers = null;
-    Iterator<String> iterator = regions.iterator();
-    String region = iterator.next();
-    members = getRegionAssociatedMembers(region, cache, true);
-    if (logger.fineEnabled()) {
-      logger.fine("Members for region " + region + " Members " + members);
-    }
-    List<String> regionAndingList = new ArrayList<>();
-    regionAndingList.add(region);
-    if (regions.size() == 1) {
-      newMembers = members;
-    } else {
-      if (CollectionUtils.isNotEmpty(members)) {
-        while (iterator.hasNext()) {
-          region = iterator.next();
-          newMembers = getRegionAssociatedMembers(region, cache, true);
-          if (newMembers == null) {
-            newMembers = new HashSet<>();
-          }
-          if (logger.fineEnabled()) {
-            logger.fine("Members for region " + region + " Members " + newMembers);
-          }
-          regionAndingList.add(region);
-          newMembers.retainAll(members);
-          members = newMembers;
-          if (logger.fineEnabled()) {
-            logger.fine(
-                "Members after anding for regions " + regionAndingList + " List : " + newMembers);
-          }
-        }
-      }
-    }
-    members = new HashSet<>();
-    if (newMembers == null) {
-      return members;
-    }
-    for (DistributedMember newMember : newMembers) {
-      members.add(newMember);
-      if (!returnAll) {
-        return members;
-      }
-    }
-    return members;
-  }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommand.java
index 824063ae6d..b7b1f088c5 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommand.java
@@ -64,7 +64,7 @@ public Result describeConfig(
       }
       if (targetMember != null) {
         ResultCollector<?, ?> rc =
-            CliUtil.executeFunction(getMemberConfigFunction, hideDefaults, targetMember);
+            executeFunction(getMemberConfigFunction, hideDefaults, targetMember);
         ArrayList<?> output = (ArrayList<?>) rc.getResult();
         Object obj = output.get(0);
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeMemberCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeMemberCommand.java
index 9f742ef55d..dfe2a57277 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeMemberCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeMemberCommand.java
@@ -56,8 +56,7 @@ public Result describeMember(@CliOption(key = CliStrings.DESCRIBE_MEMBER__IDENTI
           CliUtil.getDistributedMemberByNameOrId(memberNameOrId);
 
       if (memberToBeDescribed != null) {
-        ResultCollector<?, ?> rc =
-            CliUtil.executeFunction(getMemberInformation, null, memberToBeDescribed);
+        ResultCollector<?, ?> rc = executeFunction(getMemberInformation, null, memberToBeDescribed);
 
         ArrayList<?> output = (ArrayList<?>) rc.getResult();
         Object obj = output.get(0);
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommand.java
index 057edecd70..2c419f1d01 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommand.java
@@ -34,7 +34,6 @@
 import org.apache.geode.management.cli.ConverterHint;
 import org.apache.geode.management.cli.Result;
 import org.apache.geode.management.internal.cli.CliAroundInterceptor;
-import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.GfshParseResult;
 import org.apache.geode.management.internal.cli.functions.UserFunctionExecution;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
@@ -75,9 +74,9 @@ public Result executeFunction(
     Set<DistributedMember> dsMembers;
     if (onRegion == null) {
       // find the members based on the groups or members
-      dsMembers = CliUtil.findMembers(onGroups, onMembers);
+      dsMembers = findMembers(onGroups, onMembers);
     } else {
-      dsMembers = CliUtil.getRegionAssociatedMembers(onRegion, getCache());
+      dsMembers = findMembersForRegion(getCache(), onRegion);
     }
 
     if (dsMembers.size() == 0) {
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportDataCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportDataCommand.java
index dc74d12e3b..5f7a6d1732 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportDataCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportDataCommand.java
@@ -16,7 +16,6 @@
 package org.apache.geode.management.internal.cli.commands;
 
 import java.io.File;
-import java.util.List;
 import java.util.Optional;
 
 import org.springframework.shell.core.annotation.CliCommand;
@@ -73,8 +72,8 @@ public Result exportData(
       String path = dirPath != null ? defaultFileName(dirPath, regionName) : filePath;
       final String args[] = {regionName, path, Boolean.toString(parallel)};
 
-      ResultCollector<?, ?> rc = CliUtil.executeFunction(exportDataFunction, args, targetMember);
-      result = DataCommandUtil.getFunctionResult(rc, CliStrings.EXPORT_DATA);
+      ResultCollector<?, ?> rc = executeFunction(exportDataFunction, args, targetMember);
+      result = CliUtil.getFunctionResult(rc, CliStrings.EXPORT_DATA);
     } catch (CacheClosedException e) {
       result = ResultBuilder.createGemFireErrorResult(e.getMessage());
     } catch (FunctionInvocationTargetException e) {
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportImportClusterConfigurationCommands.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportImportClusterConfigurationCommands.java
index 8d2425088e..89e452dd90 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportImportClusterConfigurationCommands.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportImportClusterConfigurationCommands.java
@@ -206,14 +206,14 @@ public Result importSharedConfig(@CliOption(key = {CliStrings.IMPORT_SHARED_CONF
   }
 
   private Set<String> getRegionNamesOnServer(DistributedMember server) {
-    ResultCollector rc = CliUtil.executeFunction(new GetRegionNamesFunction(), null, server);
+    ResultCollector rc = executeFunction(new GetRegionNamesFunction(), null, server);
     List<Set<String>> results = (List<Set<String>>) rc.getResult();
 
     return results.get(0);
   }
 
   private CliFunctionResult reCreateCache(DistributedMember server) {
-    ResultCollector rc = CliUtil.executeFunction(new RecreateCacheFunction(), null, server);
+    ResultCollector rc = executeFunction(new RecreateCacheFunction(), null, server);
     List<CliFunctionResult> results = (List<CliFunctionResult>) rc.getResult();
 
     return results.get(0);
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommand.java
index 45b183b03e..dd56bc9c02 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommand.java
@@ -157,7 +157,7 @@ public Result exportLogs(
 
         cacheWriter.startFile(server.getName());
 
-        CliUtil.executeFunction(new ExportLogsFunction(),
+        executeFunction(new ExportLogsFunction(),
             new ExportLogsFunction.Args(start, end, logLevel, onlyLogLevel, logsOnly, statsOnly),
             server).getResult();
         Path zipFile = cacheWriter.endFile();
@@ -224,7 +224,7 @@ public Result exportLogs(
    * Wrapper to enable stubbing of static method call for unit testing
    */
   ResultCollector estimateLogSize(SizeExportLogsFunction.Args args, DistributedMember member) {
-    return CliUtil.executeFunction(new SizeExportLogsFunction(), args, member);
+    return executeFunction(new SizeExportLogsFunction(), args, member);
   }
 
   /**
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GetCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GetCommand.java
index ed7ab26c64..9f3501a8a3 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GetCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GetCommand.java
@@ -16,7 +16,6 @@
 package org.apache.geode.management.internal.cli.commands;
 
 import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.callFunctionForRegion;
-import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.getRegionAssociatedMembers;
 import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.makePresentationResult;
 
 import java.util.Set;
@@ -64,7 +63,7 @@ public Result get(
     Region region = cache.getRegion(regionPath);
     DataCommandFunction getfn = new DataCommandFunction();
     if (region == null) {
-      Set<DistributedMember> memberList = getRegionAssociatedMembers(regionPath, getCache(), false);
+      Set<DistributedMember> memberList = findAnyMembersForRegion(getCache(), regionPath);
       if (CollectionUtils.isNotEmpty(memberList)) {
         DataCommandRequest request = new DataCommandRequest();
         request.setCommand(CliStrings.GET);
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java
index a7850683d7..5e2f2d809c 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java
@@ -16,6 +16,7 @@
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 
@@ -153,7 +154,7 @@ default Execution getMembersFunctionExecutor(final Set<DistributedMember> member
   }
 
   default Set<DistributedMember> findMembersForRegion(InternalCache cache, String regionPath) {
-    return CliUtil.getRegionAssociatedMembers(regionPath, cache);
+    return CliUtil.getRegionAssociatedMembers(regionPath, cache, true);
   }
 
   default ResultCollector<?, ?> executeFunction(final Function function, Object args,
@@ -161,4 +162,12 @@ default Execution getMembersFunctionExecutor(final Set<DistributedMember> member
     return CliUtil.executeFunction(function, args, targetMembers);
   }
 
+  default ResultCollector<?, ?> executeFunction(final Function function, Object args,
+      final DistributedMember targetMember) {
+    return executeFunction(function, args, Collections.singleton(targetMember));
+  }
+
+  default Set<DistributedMember> findAnyMembersForRegion(InternalCache cache, String regionPath) {
+    return CliUtil.getRegionAssociatedMembers(regionPath, cache, false);
+  }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ImportDataCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ImportDataCommand.java
index f81c3f0846..7e4f1d70bf 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ImportDataCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ImportDataCommand.java
@@ -15,7 +15,6 @@
 
 package org.apache.geode.management.internal.cli.commands;
 
-import java.util.List;
 import java.util.Optional;
 
 import org.springframework.shell.core.annotation.CliCommand;
@@ -74,8 +73,8 @@ public Result importData(
       String path = dirPath != null ? dirPath : filePath;
       final Object args[] = {regionName, path, invokeCallbacks, parallel};
 
-      ResultCollector<?, ?> rc = CliUtil.executeFunction(importDataFunction, args, targetMember);
-      result = DataCommandUtil.getFunctionResult(rc, CliStrings.IMPORT_DATA);
+      ResultCollector<?, ?> rc = executeFunction(importDataFunction, args, targetMember);
+      result = CliUtil.getFunctionResult(rc, CliStrings.IMPORT_DATA);
     } catch (CacheClosedException e) {
       result = ResultBuilder.createGemFireErrorResult(e.getMessage());
     } catch (FunctionInvocationTargetException e) {
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/LocateEntryCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/LocateEntryCommand.java
index d3746c5cac..1d1aa4b4c9 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/LocateEntryCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/LocateEntryCommand.java
@@ -16,7 +16,6 @@
 package org.apache.geode.management.internal.cli.commands;
 
 import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.callFunctionForRegion;
-import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.getRegionAssociatedMembers;
 import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.makePresentationResult;
 
 import java.util.Set;
@@ -58,7 +57,7 @@ public Result locateEntry(
     DataCommandResult dataResult;
 
     DataCommandFunction locateEntry = new DataCommandFunction();
-    Set<DistributedMember> memberList = getRegionAssociatedMembers(regionPath, getCache(), true);
+    Set<DistributedMember> memberList = findMembersForRegion(getCache(), regionPath);
     if (CollectionUtils.isNotEmpty(memberList)) {
       DataCommandRequest request = new DataCommandRequest();
       request.setCommand(CliStrings.LOCATE_ENTRY);
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/NetstatCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/NetstatCommand.java
index a5d62faa30..0bf2d4002b 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/NetstatCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/NetstatCommand.java
@@ -18,8 +18,10 @@
 import java.text.MessageFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -102,7 +104,7 @@ public Result netstat(
         if (!notFoundMembers.isEmpty()) {
           throw new IllegalArgumentException(
               CliStrings.format(CliStrings.NETSTAT__MSG__COULD_NOT_FIND_MEMBERS_0,
-                  new Object[] {CliUtil.collectionToString(notFoundMembers, -1)}));
+                  new Object[] {collectionToString(notFoundMembers, -1)}));
         }
       } else {
         Set<DistributedMember> membersToExecuteOn;
@@ -145,7 +147,7 @@ public Result netstat(
             String remoteHost = netstatFunctionResult.getHost();
             List<String> membersList = hostMemberListMap.get(remoteHost);
             resultInfo.append(MessageFormat.format(netstatFunctionResult.getHeaderInfo(),
-                CliUtil.collectionToString(membersList, 120)));
+                collectionToString(membersList, 120)));
             CliUtil.DeflaterInflaterData uncompressedBytes = CliUtil.uncompressBytes(
                 deflaterInflaterData.getData(), deflaterInflaterData.getDataLength());
             resultInfo.append(new String(uncompressedBytes.getData()));
@@ -189,6 +191,27 @@ public Result netstat(
     return result;
   }
 
+  String collectionToString(Collection<?> col, int newlineAfter) {
+    if (col != null) {
+      StringBuilder builder = new StringBuilder();
+      int lastNewlineAt = 0;
+
+      for (Iterator<?> it = col.iterator(); it.hasNext();) {
+        Object object = it.next();
+        builder.append(String.valueOf(object));
+        if (it.hasNext()) {
+          builder.append(", ");
+        }
+        if (newlineAfter > 0 && (builder.length() - lastNewlineAt) / newlineAfter >= 1) {
+          builder.append(GfshParser.LINE_SEPARATOR);
+        }
+      }
+      return builder.toString();
+    } else {
+      return "" + null;
+    }
+  }
+
   private void buildMaps(Map<String, DistributedMember> hostMemberMap,
       Map<String, List<String>> hostMemberListMap, String memberIdOrName,
       DistributedMember distributedMember) {
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/PutCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/PutCommand.java
index b20aeb1235..ca167a9b97 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/PutCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/PutCommand.java
@@ -16,7 +16,6 @@
 package org.apache.geode.management.internal.cli.commands;
 
 import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.callFunctionForRegion;
-import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.getRegionAssociatedMembers;
 import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.makePresentationResult;
 
 import java.util.Set;
@@ -64,7 +63,7 @@ public Result put(
     Region region = cache.getRegion(regionPath);
     DataCommandFunction putfn = new DataCommandFunction();
     if (region == null) {
-      Set<DistributedMember> memberList = getRegionAssociatedMembers(regionPath, getCache(), false);
+      Set<DistributedMember> memberList = findAnyMembersForRegion(getCache(), regionPath);
       if (CollectionUtils.isNotEmpty(memberList)) {
         DataCommandRequest request = new DataCommandRequest();
         request.setCommand(CliStrings.PUT);
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/QueryCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/QueryCommand.java
index e216964758..4fd9555e42 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/QueryCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/QueryCommand.java
@@ -39,6 +39,7 @@
 import org.apache.geode.management.cli.CliMetaData;
 import org.apache.geode.management.cli.ConverterHint;
 import org.apache.geode.management.cli.Result;
+import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.domain.DataCommandRequest;
 import org.apache.geode.management.internal.cli.domain.DataCommandResult;
 import org.apache.geode.management.internal.cli.functions.DataCommandFunction;
@@ -100,7 +101,7 @@ private DataCommandResult select(String query) {
       regionsInQuery = Collections.unmodifiableSet(regions);
       if (regionsInQuery.size() > 0) {
         Set<DistributedMember> members =
-            DataCommandsUtils.getQueryRegionsAssociatedMembers(regionsInQuery, cache, false);
+            CliUtil.getQueryRegionsAssociatedMembers(regionsInQuery, cache, false);
         if (members != null && members.size() > 0) {
           DataCommandFunction function = new DataCommandFunction();
           DataCommandRequest request = new DataCommandRequest();
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/RebalanceCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/RebalanceCommand.java
index 85801ba962..d0e1fd454e 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/RebalanceCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/RebalanceCommand.java
@@ -15,11 +15,8 @@
 
 package org.apache.geode.management.internal.cli.commands;
 
-import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.checkResultList;
-import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.toCompositeResultData;
-import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.tokenize;
-
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -32,6 +29,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
+import org.apache.commons.collections.CollectionUtils;
 import org.apache.commons.lang.ArrayUtils;
 import org.apache.commons.lang.StringUtils;
 import org.springframework.shell.core.annotation.CliCommand;
@@ -77,7 +75,8 @@ public Result rebalance(
           help = CliStrings.REBALANCE__TIMEOUT__HELP) long timeout,
       @CliOption(key = CliStrings.REBALANCE__SIMULATE, specifiedDefaultValue = "true",
           unspecifiedDefaultValue = "false",
-          help = CliStrings.REBALANCE__SIMULATE__HELP) boolean simulate) {
+          help = CliStrings.REBALANCE__SIMULATE__HELP) boolean simulate)
+      throws Exception {
 
     ExecutorService commandExecutors = Executors.newSingleThreadExecutor();
     List<Future<Result>> commandResult = new ArrayList<>();
@@ -91,21 +90,125 @@ public Result rebalance(
         result = fs.get(timeout, TimeUnit.SECONDS);
       } else {
         result = fs.get();
-
       }
     } catch (TimeoutException timeoutException) {
       result = ResultBuilder.createInfoResult(CliStrings.REBALANCE__MSG__REBALANCE_WILL_CONTINUE);
-
-    } catch (Exception ex) {
-      result = ResultBuilder.createGemFireErrorResult(CliStrings.format(
-          CliStrings.REBALANCE__MSG__EXCEPTION_OCCURRED_WHILE_REBALANCING_0, ex.getMessage()));
     }
     LogWrapper.getInstance().info("Rebalance returning result >>>" + result);
     return result;
   }
 
+  private boolean checkResultList(CompositeResultData rebalanceResultData, List resultList,
+      DistributedMember member) {
+    boolean toContinueForOtherMembers = false;
+    if (CollectionUtils.isNotEmpty(resultList)) {
+      for (Object object : resultList) {
+        if (object instanceof Exception) {
+          rebalanceResultData.addSection().addData(
+              CliStrings.format(CliStrings.REBALANCE__MSG__NO_EXECUTION, member.getId()),
+              ((Exception) object).getMessage());
+
+          LogWrapper.getInstance().info(CliStrings.REBALANCE__MSG__NO_EXECUTION + member.getId()
+              + " exception=" + ((Throwable) object).getMessage(), ((Throwable) object));
+
+          toContinueForOtherMembers = true;
+          break;
+        } else if (object instanceof Throwable) {
+          rebalanceResultData.addSection().addData(
+              CliStrings.format(CliStrings.REBALANCE__MSG__NO_EXECUTION, member.getId()),
+              ((Throwable) object).getMessage());
+
+          LogWrapper.getInstance().info(CliStrings.REBALANCE__MSG__NO_EXECUTION + member.getId()
+              + " exception=" + ((Throwable) object).getMessage(), ((Throwable) object));
+
+          toContinueForOtherMembers = true;
+          break;
+        }
+      }
+    } else {
+      LogWrapper.getInstance().info(
+          "Rebalancing for member=" + member.getId() + ", resultList is either null or empty");
+      rebalanceResultData.addSection().addData("Rebalancing for member=" + member.getId(),
+          ", resultList is either null or empty");
+      toContinueForOtherMembers = true;
+    }
+    return toContinueForOtherMembers;
+  }
+
+  private CompositeResultData toCompositeResultData(CompositeResultData rebalanceResultData,
+      List<String> rstlist, int index, boolean simulate, InternalCache cache) {
+    int resultItemCount = 9;
+    // add only if there are any valid regions in results
+    if (rstlist.size() > resultItemCount && StringUtils.isNotEmpty(rstlist.get(resultItemCount))) {
+      TabularResultData table1 = rebalanceResultData.addSection().addTable("Table" + index);
+      String newLine = System.getProperty("line.separator");
+      StringBuilder resultStr = new StringBuilder();
+      resultStr.append(newLine);
+      table1.accumulate("Rebalanced Stats", CliStrings.REBALANCE__MSG__TOTALBUCKETCREATEBYTES);
+      table1.accumulate("Value", rstlist.get(0));
+      resultStr.append(CliStrings.REBALANCE__MSG__TOTALBUCKETCREATEBYTES).append(" = ")
+          .append(rstlist.get(0)).append(newLine);
+      table1.accumulate("Rebalanced Stats", CliStrings.REBALANCE__MSG__TOTALBUCKETCREATETIM);
+      table1.accumulate("Value", rstlist.get(1));
+      resultStr.append(CliStrings.REBALANCE__MSG__TOTALBUCKETCREATETIM).append(" = ")
+          .append(rstlist.get(1)).append(newLine);
+
+      table1.accumulate("Rebalanced Stats", CliStrings.REBALANCE__MSG__TOTALBUCKETCREATESCOMPLETED);
+      table1.accumulate("Value", rstlist.get(2));
+      resultStr.append(CliStrings.REBALANCE__MSG__TOTALBUCKETCREATESCOMPLETED).append(" = ")
+          .append(rstlist.get(2)).append(newLine);
+
+      table1.accumulate("Rebalanced Stats", CliStrings.REBALANCE__MSG__TOTALBUCKETTRANSFERBYTES);
+      table1.accumulate("Value", rstlist.get(3));
+      resultStr.append(CliStrings.REBALANCE__MSG__TOTALBUCKETTRANSFERBYTES).append(" = ")
+          .append(rstlist.get(3)).append(newLine);
+
+      table1.accumulate("Rebalanced Stats", CliStrings.REBALANCE__MSG__TOTALBUCKETTRANSFERTIME);
+      table1.accumulate("Value", rstlist.get(4));
+      resultStr.append(CliStrings.REBALANCE__MSG__TOTALBUCKETTRANSFERTIME).append(" = ")
+          .append(rstlist.get(4)).append(newLine);
+
+      table1.accumulate("Rebalanced Stats",
+          CliStrings.REBALANCE__MSG__TOTALBUCKETTRANSFERSCOMPLETED);
+      table1.accumulate("Value", rstlist.get(5));
+      resultStr.append(CliStrings.REBALANCE__MSG__TOTALBUCKETTRANSFERSCOMPLETED).append(" = ")
+          .append(rstlist.get(5)).append(newLine);
+
+      table1.accumulate("Rebalanced Stats", CliStrings.REBALANCE__MSG__TOTALPRIMARYTRANSFERTIME);
+      table1.accumulate("Value", rstlist.get(6));
+      resultStr.append(CliStrings.REBALANCE__MSG__TOTALPRIMARYTRANSFERTIME).append(" = ")
+          .append(rstlist.get(6)).append(newLine);
+
+      table1.accumulate("Rebalanced Stats",
+          CliStrings.REBALANCE__MSG__TOTALPRIMARYTRANSFERSCOMPLETED);
+      table1.accumulate("Value", rstlist.get(7));
+      resultStr.append(CliStrings.REBALANCE__MSG__TOTALPRIMARYTRANSFERSCOMPLETED).append(" = ")
+          .append(rstlist.get(7)).append(newLine);
+
+      table1.accumulate("Rebalanced Stats", CliStrings.REBALANCE__MSG__TOTALTIME);
+      table1.accumulate("Value", rstlist.get(8));
+      resultStr.append(CliStrings.REBALANCE__MSG__TOTALTIME).append(" = ").append(rstlist.get(8))
+          .append(newLine);
+
+      String headerText;
+      if (simulate) {
+        headerText = "Simulated partition regions ";
+      } else {
+        headerText = "Rebalanced partition regions ";
+      }
+      for (int i = resultItemCount; i < rstlist.size(); i++) {
+        headerText = headerText + " " + rstlist.get(i);
+      }
+      table1.setHeader(headerText);
+      cache.getLogger().info(headerText + resultStr);
+    }
+    return rebalanceResultData;
+  }
+
+
   // TODO EY Move this to its own class
   private class ExecuteRebalanceWithTimeout implements Callable<Result> {
+
     String[] includeRegions = null;
     String[] excludeRegions = null;
     boolean simulate;
@@ -165,8 +268,8 @@ Result executeRebalanceWithTimeout(String[] includeRegions, String[] excludeRegi
               if (simulate) {
                 List resultList;
                 try {
-                  resultList = (ArrayList) CliUtil
-                      .executeFunction(rebalanceFunction, functionArgs, member).getResult();
+                  resultList = (ArrayList) executeFunction(rebalanceFunction, functionArgs, member)
+                      .getResult();
                 } catch (Exception ex) {
                   LogWrapper.getInstance()
                       .info(CliStrings.format(
@@ -184,15 +287,15 @@ Result executeRebalanceWithTimeout(String[] includeRegions, String[] excludeRegi
                   result = ResultBuilder.buildResult(rebalanceResultData);
                   continue;
                 }
-                List<String> rstList = tokenize((String) resultList.get(0), ",");
+                List<String> rstList = Arrays.asList(((String) resultList.get(0)).split(","));
 
-                result = ResultBuilder.buildResult(toCompositeResultData(rebalanceResultData,
-                    (ArrayList) rstList, index, true, cache));
+                result = ResultBuilder.buildResult(
+                    toCompositeResultData(rebalanceResultData, rstList, index, true, cache));
               } else {
                 List resultList;
                 try {
-                  resultList = (ArrayList) CliUtil
-                      .executeFunction(rebalanceFunction, functionArgs, member).getResult();
+                  resultList = (ArrayList) executeFunction(rebalanceFunction, functionArgs, member)
+                      .getResult();
                 } catch (Exception ex) {
                   LogWrapper.getInstance()
                       .info(CliStrings.format(
@@ -210,10 +313,10 @@ Result executeRebalanceWithTimeout(String[] includeRegions, String[] excludeRegi
                   result = ResultBuilder.buildResult(rebalanceResultData);
                   continue;
                 }
-                List<String> rstList = tokenize((String) resultList.get(0), ",");
+                List<String> rstList = Arrays.asList(((String) resultList.get(0)).split(","));
 
-                result = ResultBuilder.buildResult(toCompositeResultData(rebalanceResultData,
-                    (ArrayList) rstList, index, false, cache));
+                result = ResultBuilder.buildResult(
+                    toCompositeResultData(rebalanceResultData, rstList, index, false, cache));
               }
 
             } else {
@@ -426,17 +529,17 @@ private Result executeRebalanceOnDS(InternalCache cache, String simulate,
 
             try {
               if (checkMemberPresence(dsMember, cache)) {
-                resultList = (ArrayList) CliUtil
-                    .executeFunction(rebalanceFunction, functionArgs, dsMember).getResult();
+                resultList = (ArrayList) executeFunction(rebalanceFunction, functionArgs, dsMember)
+                    .getResult();
 
                 if (checkResultList(rebalanceResultData, resultList, dsMember)) {
                   result = ResultBuilder.buildResult(rebalanceResultData);
                   continue;
                 }
 
-                List<String> rstList = tokenize((String) resultList.get(0), ",");
+                List<String> rstList = Arrays.asList(((String) resultList.get(0)).split(","));
                 result = ResultBuilder.buildResult(toCompositeResultData(rebalanceResultData,
-                    (ArrayList) rstList, index, simulate.equals("true"), cache));
+                    rstList, index, simulate.equals("true"), cache));
                 index++;
 
                 // Rebalancing for region is done so break and continue with other region
@@ -471,9 +574,9 @@ private Result executeRebalanceOnDS(InternalCache cache, String simulate,
               continue;
             }
 
-            List<String> rstList = tokenize((String) resultList.get(0), ",");
-            result = ResultBuilder.buildResult(toCompositeResultData(rebalanceResultData,
-                (ArrayList) rstList, index, simulate.equals("true"), cache));
+            List<String> rstList = Arrays.asList(((String) resultList.get(0)).split(","));
+            result = ResultBuilder.buildResult(toCompositeResultData(rebalanceResultData, rstList,
+                index, simulate.equals("true"), cache));
             index++;
           }
         }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/RemoveCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/RemoveCommand.java
index 1318cdf4e9..c34805d8db 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/RemoveCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/RemoveCommand.java
@@ -16,7 +16,6 @@
 package org.apache.geode.management.internal.cli.commands;
 
 import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.callFunctionForRegion;
-import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.getRegionAssociatedMembers;
 import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.makePresentationResult;
 import static org.apache.geode.management.internal.cli.result.ResultBuilder.createUserErrorResult;
 
@@ -70,7 +69,7 @@ public Result remove(
     DataCommandFunction removefn = new DataCommandFunction();
     DataCommandResult dataResult;
     if (region == null) {
-      Set<DistributedMember> memberList = getRegionAssociatedMembers(regionPath, getCache(), false);
+      Set<DistributedMember> memberList = findAnyMembersForRegion(getCache(), regionPath);
 
       if (CollectionUtils.isEmpty(memberList)) {
         return createUserErrorResult(String.format(REGION_NOT_FOUND, regionPath));
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/domain/DataCommandResult.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/domain/DataCommandResult.java
index 5ad88c393f..429c329da7 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/domain/DataCommandResult.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/domain/DataCommandResult.java
@@ -56,10 +56,6 @@
   private List<SelectResultRow> selectResult;
   private String queryTraceString;
 
-  public static final String QUERY_PAGE_START = "startCount";
-  public static final String QUERY_PAGE_END = "endCount";
-  public static final String QUERY_TRACE = "Query Trace";
-
   public static final String RESULT_FLAG = "Result";
   public static final String NUM_ROWS = "Rows";
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilDUnitTest.java
index fdcd888d93..6d2e9ccbed 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilDUnitTest.java
@@ -331,7 +331,7 @@ public void getRegionAssociatedMembers() {
 
     InternalCache cache = getCache();
 
-    Set<DistributedMember> set = CliUtil.getRegionAssociatedMembers(region1, cache);
+    Set<DistributedMember> set = CliUtil.getRegionAssociatedMembers(region1, cache, true);
     assertNotNull(set);
     assertEquals(4, set.size());
     assertEquals(true, containsMember(set, MEMBER_1_GROUP1));
@@ -345,13 +345,13 @@ public void getRegionAssociatedMembers() {
      * assertIndexDetailsEquals(1, set.size());
      */
 
-    set = CliUtil.getRegionAssociatedMembers(region_group1, cache);
+    set = CliUtil.getRegionAssociatedMembers(region_group1, cache, true);
     assertNotNull(set);
     assertEquals(2, set.size());
     assertEquals(true, containsMember(set, MEMBER_1_GROUP1));
     assertEquals(true, containsMember(set, MEMBER_2_GROUP1));
 
-    set = CliUtil.getRegionAssociatedMembers(region_member2_group1, cache);
+    set = CliUtil.getRegionAssociatedMembers(region_member2_group1, cache, true);
     assertNotNull(set);
     assertEquals(1, set.size());
     assertEquals(true, containsMember(set, MEMBER_2_GROUP1));
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/QueryCommandUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilTest.java
similarity index 62%
rename from geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/QueryCommandUnitTest.java
rename to geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilTest.java
index 11da4b7b55..9f049c2456 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/QueryCommandUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilTest.java
@@ -13,18 +13,27 @@
  * the License.
  */
 
-package org.apache.geode.management.internal.cli.commands;
+package org.apache.geode.management.internal.cli;
+
+import static org.assertj.core.api.Assertions.assertThat;
 
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
 import org.apache.geode.test.junit.categories.UnitTest;
 
+
 @Category(UnitTest.class)
-public class QueryCommandUnitTest {
+public class CliUtilTest {
 
   @Test
-  public void query() throws Exception {
-    QueryCommand queryCommand = new QueryCommand();
+  public void arrayToString() throws Exception {
+    assertThat(CliUtil.arrayToString(null)).isEqualTo("null");
+    String[] array1 = {"one", "two", "three"};
+    assertThat(CliUtil.arrayToString(array1)).isEqualTo("one, two, three");
+    String[] array2 = {"one", null, "three"};
+    assertThat(CliUtil.arrayToString(array2)).isEqualTo("one, null, three");
+    String[] array3 = {null};
+    assertThat(CliUtil.arrayToString(array3)).isEqualTo("null");
   }
 }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommandTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommandTest.java
index 4bf1532324..a89a918987 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommandTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommandTest.java
@@ -25,6 +25,7 @@
 import static org.mockito.Mockito.when;
 
 import java.util.Collections;
+import java.util.Set;
 
 import org.junit.Before;
 import org.junit.Ignore;
@@ -133,7 +134,7 @@ public void templateRegionAttributesNotAvailable() throws Exception {
   @Test
   public void defaultValues() throws Exception {
     ResultCollector resultCollector = mock(ResultCollector.class);
-    doReturn(resultCollector).when(command).executeFunction(any(), any(), any());
+    doReturn(resultCollector).when(command).executeFunction(any(), any(), any(Set.class));
     when(resultCollector.getResult()).thenReturn(Collections.emptyList());
     DistributedSystemMXBean dsMBean = mock(DistributedSystemMXBean.class);
     doReturn(dsMBean).when(command).getDSMBean(any());
@@ -144,7 +145,7 @@ public void defaultValues() throws Exception {
     parser.executeCommandWithInstance(command, "create region --name=A --type=REPLICATE");
     ArgumentCaptor<RegionFunctionArgs> argsCaptor =
         ArgumentCaptor.forClass(RegionFunctionArgs.class);
-    verify(command).executeFunction(any(), argsCaptor.capture(), any());
+    verify(command).executeFunction(any(), argsCaptor.capture(), any(Set.class));
     RegionFunctionArgs args = argsCaptor.getValue();
 
     assertThat(args.getRegionPath()).isEqualTo("/A");
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommandSecurityTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommandSecurityTest.java
index dd78f0cc11..428cf3b030 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommandSecurityTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommandSecurityTest.java
@@ -41,10 +41,10 @@
 import org.apache.geode.management.internal.security.TestFunctions.ReadFunction;
 import org.apache.geode.management.internal.security.TestFunctions.WriteFunction;
 import org.apache.geode.security.SimpleTestSecurityManager;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
 
 @Category(DistributedTest.class)
 public class ExecuteFunctionCommandSecurityTest implements Serializable {
@@ -152,7 +152,7 @@ public void readOnlyUserOnPartitionedRegion() throws Exception {
   private static void waitUntilRegionMBeansAreRegistered() {
     Awaitility.await().atMost(10, TimeUnit.SECONDS).until(() -> {
       Set<DistributedMember> regionMembers = CliUtil.getRegionAssociatedMembers(REPLICATED_REGION,
-          (InternalCache) CacheFactory.getAnyInstance());
+          (InternalCache) CacheFactory.getAnyInstance(), true);
       assertThat(regionMembers).hasSize(2);
     });
   }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GemfireDataCommandsDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GemfireDataCommandsDUnitTest.java
index fe7b1792f2..2e9bafe95b 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GemfireDataCommandsDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GemfireDataCommandsDUnitTest.java
@@ -17,7 +17,6 @@
 
 import static org.apache.geode.distributed.ConfigurationProperties.NAME;
 import static org.apache.geode.test.dunit.Assert.assertEquals;
-import static org.apache.geode.test.dunit.Assert.assertFalse;
 import static org.apache.geode.test.dunit.Assert.assertNotEquals;
 import static org.apache.geode.test.dunit.Assert.assertNotNull;
 import static org.apache.geode.test.dunit.Assert.assertNotSame;
@@ -421,7 +420,7 @@ private void doQueryRegionsAssociatedMembers(String queryTemplate, int expectedM
       getLogWriter().info("Region in query : " + regionsInQuery);
       if (regionsInQuery.size() > 0) {
         Set<DistributedMember> members =
-            DataCommandsUtils.getQueryRegionsAssociatedMembers(regionsInQuery, cache, returnAll);
+            CliUtil.getQueryRegionsAssociatedMembers(regionsInQuery, cache, returnAll);
         getLogWriter().info("Members for Region in query : " + members);
         if (expectedMembers != -1) {
           assertNotNull(members);
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/RemoveCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/RemoveCommandDUnitTest.java
index 986d1ae876..5a0bb17e62 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/RemoveCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/RemoveCommandDUnitTest.java
@@ -14,7 +14,6 @@
  */
 package org.apache.geode.management.internal.cli.commands;
 
-import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.getRegionAssociatedMembers;
 import static org.apache.geode.management.internal.cli.commands.RemoveCommand.REGION_NOT_FOUND;
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -35,6 +34,7 @@
 import org.apache.geode.cache.RegionShortcut;
 import org.apache.geode.distributed.DistributedMember;
 import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.test.dunit.SerializableCallableIF;
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
@@ -178,7 +178,7 @@ public void removeEmptyKey() {
   }
 
   private boolean regionMBeansAreInitialized() {
-    Set<DistributedMember> members = getRegionAssociatedMembers(REPLICATE_REGION_NAME,
+    Set<DistributedMember> members = CliUtil.getRegionAssociatedMembers(REPLICATE_REGION_NAME,
         (InternalCache) CacheFactory.getAnyInstance(), false);
 
     return CollectionUtils.isNotEmpty(members);
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/RemoveCommandJsonDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/RemoveCommandJsonDUnitTest.java
index 1f2a75703f..4137820729 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/RemoveCommandJsonDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/RemoveCommandJsonDUnitTest.java
@@ -14,7 +14,6 @@
  */
 package org.apache.geode.management.internal.cli.commands;
 
-import static org.apache.geode.management.internal.cli.commands.DataCommandsUtils.getRegionAssociatedMembers;
 import static org.assertj.core.api.Assertions.assertThat;
 
 import java.io.Serializable;
@@ -34,6 +33,7 @@
 import org.apache.geode.cache.RegionShortcut;
 import org.apache.geode.distributed.DistributedMember;
 import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.dto.Key1;
 import org.apache.geode.management.internal.cli.dto.Value2;
 import org.apache.geode.test.dunit.SerializableCallableIF;
@@ -149,7 +149,7 @@ private Key1 key(int n) {
   }
 
   private boolean regionMBeansAreInitialized() {
-    Set<DistributedMember> members = getRegionAssociatedMembers(JSON_REGION_NAME,
+    Set<DistributedMember> members = CliUtil.getRegionAssociatedMembers(JSON_REGION_NAME,
         (InternalCache) CacheFactory.getAnyInstance(), false);
 
     return CollectionUtils.isNotEmpty(members);
diff --git a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsJUnitTest.java b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsJUnitTest.java
index bb010e7aa6..d73bfc5f6e 100644
--- a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsJUnitTest.java
+++ b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsJUnitTest.java
@@ -444,7 +444,7 @@ public void testDestroySingleIndexNoRegionMembers(boolean expectedToSucceed) thr
     }
 
     doReturn(mockResultCollector).when(commands).executeFunction(
-        isA(LuceneDestroyIndexFunction.class), any(LuceneDestroyIndexInfo.class), any());
+        isA(LuceneDestroyIndexFunction.class), any(LuceneDestroyIndexInfo.class), any(Set.class));
     doReturn(cliFunctionResults).when(mockResultCollector).getResult();
 
     doReturn(Collections.emptySet()).when(commands).getNormalMembers(any());
@@ -481,7 +481,7 @@ public void testDestroySingleIndexWithRegionMembers(boolean expectedToSucceed) t
     }
 
     doReturn(mockResultCollector).when(commands).executeFunction(
-        isA(LuceneDestroyIndexFunction.class), any(LuceneDestroyIndexInfo.class), any());
+        isA(LuceneDestroyIndexFunction.class), any(LuceneDestroyIndexInfo.class), any(Set.class));
     doReturn(cliFunctionResults).when(mockResultCollector).getResult();
 
     doReturn(members).when(commands).getNormalMembers(any());
@@ -513,7 +513,7 @@ public void testDestroyAllIndexesNoRegionMembers(boolean expectedToSucceed) thro
     }
 
     doReturn(mockResultCollector).when(commands).executeFunction(
-        isA(LuceneDestroyIndexFunction.class), any(LuceneDestroyIndexInfo.class), any());
+        isA(LuceneDestroyIndexFunction.class), any(LuceneDestroyIndexInfo.class), any(Set.class));
     doReturn(cliFunctionResults).when(mockResultCollector).getResult();
 
     doReturn(Collections.emptySet()).when(commands).getNormalMembers(any());
@@ -550,7 +550,7 @@ public void testDestroyAllIndexesWithRegionMembers(boolean expectedToSucceed) th
     }
 
     doReturn(mockResultCollector).when(commands).executeFunction(
-        isA(LuceneDestroyIndexFunction.class), any(LuceneDestroyIndexInfo.class), any());
+        isA(LuceneDestroyIndexFunction.class), any(LuceneDestroyIndexInfo.class), any(Set.class));
     doReturn(cliFunctionResults).when(mockResultCollector).getResult();
 
     doReturn(Collections.emptySet()).when(commands).getNormalMembers(any());


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 19e5f8ce4995257fded70817436c3e8740115dd0 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=19e5f8c ]

GEODE-3539: Consolidate CliUtil and DataCommandUtils, DataCommandsUtil (#992)

* GEODE-3539: Consolidate CliUtil and DataCommandUtils, DataCommandsUtil

* remove DataCommandsUtil
* move method from DataCommandUtils to CliUtil if applicable.
* move moethds from DataCommandUtils to individual command if only used by one command


Commit 19e5f8ce4995257fded70817436c3e8740115dd0 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=19e5f8c ]

GEODE-3539: Consolidate CliUtil and DataCommandUtils, DataCommandsUtil (#992)

* GEODE-3539: Consolidate CliUtil and DataCommandUtils, DataCommandsUtil

* remove DataCommandsUtil
* move method from DataCommandUtils to CliUtil if applicable.
* move moethds from DataCommandUtils to individual command if only used by one command


Commit 19e5f8ce4995257fded70817436c3e8740115dd0 in geode's branch refs/heads/feature/GEODE-3637 from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=19e5f8c ]

GEODE-3539: Consolidate CliUtil and DataCommandUtils, DataCommandsUtil (#992)

* GEODE-3539: Consolidate CliUtil and DataCommandUtils, DataCommandsUtil

* remove DataCommandsUtil
* move method from DataCommandUtils to CliUtil if applicable.
* move moethds from DataCommandUtils to individual command if only used by one command


Commit 19e5f8ce4995257fded70817436c3e8740115dd0 in geode's branch refs/heads/feature/GEODE-3637 from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=19e5f8c ]

GEODE-3539: Consolidate CliUtil and DataCommandUtils, DataCommandsUtil (#992)

* GEODE-3539: Consolidate CliUtil and DataCommandUtils, DataCommandsUtil

* remove DataCommandsUtil
* move method from DataCommandUtils to CliUtil if applicable.
* move moethds from DataCommandUtils to individual command if only used by one command


jaredjstewart commented on a change in pull request #797: GEODE-3539: Add missing test coverage for 'describe connection' command.
URL: https://github.com/apache/geode/pull/797#discussion_r148665144
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/test/junit/assertions/GfshShellConnectionRuleAssert.java
 ##########
 @@ -208,6 +208,31 @@ public GfshShellConnectionRuleAssert tableHasColumnWithValuesContaining(String h
     return this;
   }
 
+  public GfshShellConnectionRuleAssert tableHasColumnWithValueMatchingOneOf(String header,
+      String... acceptedValues) {
+    GfJsonObject resultContentJSON = actual.getCommandResult().getContent();
+    Object content = resultContentJSON.get(header);
+
+    if (content == null) {
+      failWithMessage("Command result did not contain a table with column header <" + header + ">: "
+          + resultContentJSON.toString());
+    }
+
+    Object[] actualValues = toArray((JSONArray) content);
+
+    for (Object actualValue : actualValues) {
+      String actualValueString = (String) actualValue;
+      boolean actualValueContainsAnAcceptedValue =
+          Arrays.stream(acceptedValues).anyMatch(actualValueString::contains);
+
+      if (actualValueContainsAnAcceptedValue) {
+        return this;
+      }
+    }
+    failWithMessage("No accepted value found.");
+    return null;
 
 Review comment:
   I think you can still return `this` rather than returning `null`.  (For instance, someone might be using a JUnit rule that gathers up exceptions and re-throws them at the end of a sequence of operations.  We wouldn't want to give them a NPE here in that case.)

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jaredjstewart commented on a change in pull request #797: GEODE-3539: Add missing test coverage for 'describe connection' command.
URL: https://github.com/apache/geode/pull/797#discussion_r148664747
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConnectionCommandJUnitTest.java
 ##########
 @@ -0,0 +1,92 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.management.internal.cli.commands;
+
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.util.Enumeration;
+import java.util.Spliterator;
+import java.util.Spliterators;
+import java.util.stream.StreamSupport;
+
+import com.google.common.collect.Iterators;
+import org.apache.logging.log4j.Logger;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.LocatorStarterRule;
+
+/**
+ * The GfshCommandJUnitTest class is a test suite of test cases testing the contract and
+ * functionality of the GfshCommand class for implementing GemFire shell (Gfsh) commands.
+ *
+ * @see org.apache.geode.management.internal.cli.commands.GfshCommand
+ * @see org.jmock.Expectations
+ * @see org.jmock.Mockery
+ * @see org.jmock.lib.legacy.ClassImposteriser
+ * @see org.junit.Assert
+ * @see org.junit.Test
+ * @since GemFire 7.0
+ */
+
+@Category(IntegrationTest.class)
+public class DescribeConnectionCommandJUnitTest {
+  public static Logger logger = LogService.getLogger();
+
+  @ClassRule
+  public static LocatorStarterRule locator = new LocatorStarterRule().withAutoStart();
+
+  @Rule
+  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+
+  @Test
+  public void executeWhileConnected() throws Exception {
+    gfsh.connectAndVerify(locator);
+    // We must be sure to catch either IPv4 or IPv6 descriptions.
+    String[] acceptableAddresses = getNetworkAddressArray();
+    logger.info(
+        "Expecting one of the following addresses: " + String.join(", ", acceptableAddresses));
+    gfsh.executeAndAssertThat("describe connection")
+        .tableHasColumnWithValueMatchingOneOf("Connection Endpoints", acceptableAddresses);
+  }
+
+  private String[] getNetworkAddressArray() throws SocketException {
+    Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
+    NetworkInterface myInterface = networkInterfaces.nextElement();
+    Enumeration<InetAddress> myAddresses = myInterface.getInetAddresses();
+    return StreamSupport
 
 Review comment:
   Since this Enumeration will be reliably bounded (finite), I think we can turn it into a stream more concisely: 
   ```
   Collections.list(myAddresses).stream()
   .map(InetAddress::getHostAddress)
   .map(address -> formatAddressAndPort(address, locator.getJmxPort())).toArray(String[]::new);
   ```

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jaredjstewart commented on issue #797: GEODE-3539: Add missing test coverage for 'describe connection' command.
URL: https://github.com/apache/geode/pull/797#issuecomment-341563669
 
 
   Looks good overall!

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied commented on a change in pull request #797: GEODE-3539: Add missing test coverage for 'describe connection' command.
URL: https://github.com/apache/geode/pull/797#discussion_r148830916
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConnectionCommandJUnitTest.java
 ##########
 @@ -0,0 +1,92 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.management.internal.cli.commands;
+
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.util.Enumeration;
+import java.util.Spliterator;
+import java.util.Spliterators;
+import java.util.stream.StreamSupport;
+
+import com.google.common.collect.Iterators;
+import org.apache.logging.log4j.Logger;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.LocatorStarterRule;
+
+/**
+ * The GfshCommandJUnitTest class is a test suite of test cases testing the contract and
+ * functionality of the GfshCommand class for implementing GemFire shell (Gfsh) commands.
+ *
+ * @see org.apache.geode.management.internal.cli.commands.GfshCommand
+ * @see org.jmock.Expectations
+ * @see org.jmock.Mockery
+ * @see org.jmock.lib.legacy.ClassImposteriser
+ * @see org.junit.Assert
+ * @see org.junit.Test
+ * @since GemFire 7.0
+ */
+
+@Category(IntegrationTest.class)
+public class DescribeConnectionCommandJUnitTest {
+  public static Logger logger = LogService.getLogger();
+
+  @ClassRule
+  public static LocatorStarterRule locator = new LocatorStarterRule().withAutoStart();
+
+  @Rule
+  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+
+  @Test
+  public void executeWhileConnected() throws Exception {
+    gfsh.connectAndVerify(locator);
+    // We must be sure to catch either IPv4 or IPv6 descriptions.
+    String[] acceptableAddresses = getNetworkAddressArray();
+    logger.info(
+        "Expecting one of the following addresses: " + String.join(", ", acceptableAddresses));
+    gfsh.executeAndAssertThat("describe connection")
+        .tableHasColumnWithValueMatchingOneOf("Connection Endpoints", acceptableAddresses);
+  }
+
+  private String[] getNetworkAddressArray() throws SocketException {
+    Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
+    NetworkInterface myInterface = networkInterfaces.nextElement();
+    Enumeration<InetAddress> myAddresses = myInterface.getInetAddresses();
+    return StreamSupport
 
 Review comment:
   That's much less cudgel-y!  Thanks.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied commented on a change in pull request #797: GEODE-3539: Add missing test coverage for 'describe connection' command.
URL: https://github.com/apache/geode/pull/797#discussion_r148830944
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/test/junit/assertions/GfshShellConnectionRuleAssert.java
 ##########
 @@ -208,6 +208,31 @@ public GfshShellConnectionRuleAssert tableHasColumnWithValuesContaining(String h
     return this;
   }
 
+  public GfshShellConnectionRuleAssert tableHasColumnWithValueMatchingOneOf(String header,
+      String... acceptedValues) {
+    GfJsonObject resultContentJSON = actual.getCommandResult().getContent();
+    Object content = resultContentJSON.get(header);
+
+    if (content == null) {
+      failWithMessage("Command result did not contain a table with column header <" + header + ">: "
+          + resultContentJSON.toString());
+    }
+
+    Object[] actualValues = toArray((JSONArray) content);
+
+    for (Object actualValue : actualValues) {
+      String actualValueString = (String) actualValue;
+      boolean actualValueContainsAnAcceptedValue =
+          Arrays.stream(acceptedValues).anyMatch(actualValueString::contains);
+
+      if (actualValueContainsAnAcceptedValue) {
+        return this;
+      }
+    }
+    failWithMessage("No accepted value found.");
+    return null;
 
 Review comment:
   I hadn't even considered that scenario.  Done and done.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 50eb158cd863849e6546081942bff8876dda29c6 in geode's branch refs/heads/develop from [~prhomberg]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=50eb158 ]

Geode 3539: Add missing test coverage for 'version' command. (#1009)

* GEODE-3539: Add missing test coverage for 'version' command.

* Extract inner class GemFireVersion.VersionDescription to its own class
* Made static strings in this this class visible for internal use.

PurelyApplied closed pull request #797: GEODE-3539: Add missing test coverage for 'describe connection' command.
URL: https://github.com/apache/geode/pull/797
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConnectionCommandJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConnectionCommandJUnitTest.java
new file mode 100644
index 0000000000..ca93a02332
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConnectionCommandJUnitTest.java
@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.management.internal.cli.commands;
+
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.Spliterator;
+import java.util.Spliterators;
+import java.util.stream.StreamSupport;
+
+import com.google.common.collect.Iterators;
+import org.apache.logging.log4j.Logger;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.LocatorStarterRule;
+
+/**
+ * The GfshCommandJUnitTest class is a test suite of test cases testing the contract and
+ * functionality of the GfshCommand class for implementing GemFire shell (Gfsh) commands.
+ *
+ * @see org.apache.geode.management.internal.cli.commands.GfshCommand
+ * @see org.jmock.Expectations
+ * @see org.jmock.Mockery
+ * @see org.jmock.lib.legacy.ClassImposteriser
+ * @see org.junit.Assert
+ * @see org.junit.Test
+ * @since GemFire 7.0
+ */
+
+@Category(IntegrationTest.class)
+public class DescribeConnectionCommandJUnitTest {
+  public static Logger logger = LogService.getLogger();
+
+  @ClassRule
+  public static LocatorStarterRule locator = new LocatorStarterRule().withAutoStart();
+
+  @Rule
+  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+
+  @Test
+  public void executeWhileConnected() throws Exception {
+    gfsh.connectAndVerify(locator);
+    // We must be sure to catch either IPv4 or IPv6 descriptions.
+    String[] acceptableAddresses = getNetworkAddressArray();
+    logger.info(
+        "Expecting one of the following addresses: " + String.join(", ", acceptableAddresses));
+    gfsh.executeAndAssertThat("describe connection")
+        .tableHasColumnWithValueMatchingOneOf("Connection Endpoints", acceptableAddresses);
+  }
+
+  private String[] getNetworkAddressArray() throws SocketException {
+    Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
+    NetworkInterface myInterface = networkInterfaces.nextElement();
+    Enumeration<InetAddress> myAddresses = myInterface.getInetAddresses();
+    return Collections.list(myAddresses).stream().map(InetAddress::getHostAddress)
+        .map(address -> formatAddressAndPort(address, locator.getJmxPort())).toArray(String[]::new);
+  }
+
+  @Test
+  public void executeWhileNotConnected() throws Exception {
+    gfsh.executeAndAssertThat("describe connection")
+        .tableHasColumnWithValuesContaining("Connection Endpoints", "Not connected");
+  }
+
+  private String formatAddressAndPort(String address, int port) {
+    address = address.startsWith("/") ? address.substring(1) : address;
+    return address + "[" + port + "]";
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/test/junit/assertions/GfshShellConnectionRuleAssert.java b/geode-core/src/test/java/org/apache/geode/test/junit/assertions/GfshShellConnectionRuleAssert.java
index 79d54d9c86..84e979e7de 100644
--- a/geode-core/src/test/java/org/apache/geode/test/junit/assertions/GfshShellConnectionRuleAssert.java
+++ b/geode-core/src/test/java/org/apache/geode/test/junit/assertions/GfshShellConnectionRuleAssert.java
@@ -208,6 +208,31 @@ public GfshShellConnectionRuleAssert tableHasColumnWithValuesContaining(String h
     return this;
   }
 
+  public GfshShellConnectionRuleAssert tableHasColumnWithValueMatchingOneOf(String header,
+      String... acceptedValues) {
+    GfJsonObject resultContentJSON = actual.getCommandResult().getContent();
+    Object content = resultContentJSON.get(header);
+
+    if (content == null) {
+      failWithMessage("Command result did not contain a table with column header <" + header + ">: "
+          + resultContentJSON.toString());
+    }
+
+    Object[] actualValues = toArray((JSONArray) content);
+
+    for (Object actualValue : actualValues) {
+      String actualValueString = (String) actualValue;
+      boolean actualValueContainsAnAcceptedValue =
+          Arrays.stream(acceptedValues).anyMatch(actualValueString::contains);
+
+      if (actualValueContainsAnAcceptedValue) {
+        return this;
+      }
+    }
+    failWithMessage("No accepted value found.");
+    return this;
+  }
+
   public GfshShellConnectionRuleAssert hasResult() {
     containsKeyValuePair("Result", "true");
 


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit a1b9725a7cb351299a5239a79f96daed9d88865b in geode's branch refs/heads/develop from [~prhomberg]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=a1b9725 ]

GEODE-3539: Add missing test coverage for 'describe connection' command.



Commit 70b4327b196630c638a6e7aef608405d2d73db98 in geode's branch refs/heads/develop from [~prhomberg]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=70b4327 ]

Revert "GEODE-3539: Add missing test coverage for 'describe connection' command."

* Some test environments will expect the output to contain the alias given in /etc/hosts
* This reverts commit a1b9725a7cb351299a5239a79f96daed9d88865b.


jinmeiliao opened a new pull request #1021: GEODE-3539: LocatorServerStartupRule enhancement
URL: https://github.com/apache/geode/pull/1021
 
 
   * get rid of the redundant variable that refers to either a LocatorStarter or a ServerStarter
   * add methods in MemberVM to wait till the region beans are ready

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 50eb158cd863849e6546081942bff8876dda29c6 in geode's branch refs/heads/feature/GEODE-3940 from [~prhomberg]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=50eb158 ]

Geode 3539: Add missing test coverage for 'version' command. (#1009)

* GEODE-3539: Add missing test coverage for 'version' command.

* Extract inner class GemFireVersion.VersionDescription to its own class
* Made static strings in this this class visible for internal use.

Commit a1b9725a7cb351299a5239a79f96daed9d88865b in geode's branch refs/heads/feature/GEODE-3940 from [~prhomberg]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=a1b9725 ]

GEODE-3539: Add missing test coverage for 'describe connection' command.



Commit 70b4327b196630c638a6e7aef608405d2d73db98 in geode's branch refs/heads/feature/GEODE-3940 from [~prhomberg]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=70b4327 ]

Revert "GEODE-3539: Add missing test coverage for 'describe connection' command."

* Some test environments will expect the output to contain the alias given in /etc/hosts
* This reverts commit a1b9725a7cb351299a5239a79f96daed9d88865b.


Commit 50eb158cd863849e6546081942bff8876dda29c6 in geode's branch refs/heads/feature/GEODE-3930 from [~prhomberg]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=50eb158 ]

Geode 3539: Add missing test coverage for 'version' command. (#1009)

* GEODE-3539: Add missing test coverage for 'version' command.

* Extract inner class GemFireVersion.VersionDescription to its own class
* Made static strings in this this class visible for internal use.

Commit a1b9725a7cb351299a5239a79f96daed9d88865b in geode's branch refs/heads/feature/GEODE-3930 from [~prhomberg]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=a1b9725 ]

GEODE-3539: Add missing test coverage for 'describe connection' command.



Commit 70b4327b196630c638a6e7aef608405d2d73db98 in geode's branch refs/heads/feature/GEODE-3930 from [~prhomberg]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=70b4327 ]

Revert "GEODE-3539: Add missing test coverage for 'describe connection' command."

* Some test environments will expect the output to contain the alias given in /etc/hosts
* This reverts commit a1b9725a7cb351299a5239a79f96daed9d88865b.


jinmeiliao commented on issue #1021: GEODE-3539: LocatorServerStartupRule enhancement
URL: https://github.com/apache/geode/pull/1021#issuecomment-342527292
 
 
   all tests are green

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao closed pull request #1021: GEODE-3539: LocatorServerStartupRule enhancement
URL: https://github.com/apache/geode/pull/1021
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/test/java/org/apache/geode/internal/cache/extension/ExtensionClusterConfigurationDUnitTest.java b/geode-core/src/test/java/org/apache/geode/internal/cache/extension/ExtensionClusterConfigurationDUnitTest.java
index c8eb03f1ec..8fb5feb420 100644
--- a/geode-core/src/test/java/org/apache/geode/internal/cache/extension/ExtensionClusterConfigurationDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/internal/cache/extension/ExtensionClusterConfigurationDUnitTest.java
@@ -18,8 +18,6 @@
 import static org.apache.geode.test.dunit.Assert.assertTrue;
 import static org.junit.Assert.assertEquals;
 
-import java.io.Serializable;
-
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -88,7 +86,7 @@ public void testCreateExtensions() throws Exception {
     // Verify the config creation on this member
     MemberVM newMember = locatorServerStartupRule.startServerVM(2, locator.getPort());
     newMember.invoke(() -> {
-      InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+      InternalCache cache = LocatorServerStartupRule.getCache();
       assertNotNull(cache);
 
       Region<?, ?> region1 = cache.getRegion(REPLICATE_REGION);
@@ -143,7 +141,7 @@ public void testDestroyExtensions() throws Exception {
     // Verify the config creation on this member
     MemberVM newMember = locatorServerStartupRule.startServerVM(2, locator.getPort());
     newMember.invoke(() -> {
-      InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+      InternalCache cache = LocatorServerStartupRule.getCache();
       assertNotNull(cache);
 
       Region<?, ?> region1 = cache.getRegion(REPLICATE_REGION);
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommandDUnitTest.java
index 5afd11298d..7b8a5e8286 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommandDUnitTest.java
@@ -18,11 +18,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
 
-import org.json.JSONArray;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -36,7 +32,6 @@
 import org.apache.geode.compression.SnappyCompressor;
 import org.apache.geode.internal.cache.PartitionedRegion;
 import org.apache.geode.internal.cache.RegionEntryContext;
-import org.apache.geode.management.internal.cli.result.CommandResult;
 import org.apache.geode.test.compiler.JarBuilder;
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
@@ -78,7 +73,7 @@ public void testCreateRegionWithGoodCompressor() throws Exception {
         .statusIsSuccess();
 
     server.invoke(() -> {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       Region region = cache.getRegion(regionName);
       assertThat(region).isNotNull();
       assertThat(region.getAttributes().getCompressor())
@@ -94,7 +89,7 @@ public void testCreateRegionWithBadCompressor() throws Exception {
         .statusIsError();
 
     server.invoke(() -> {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       Region region = cache.getRegion(regionName);
       assertThat(region).isNull();
     });
@@ -107,7 +102,7 @@ public void testCreateRegionWithNoCompressor() throws Exception {
         .statusIsSuccess();
 
     server.invoke(() -> {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       Region region = cache.getRegion(regionName);
       assertThat(region).isNotNull();
       assertThat(region.getAttributes().getCompressor()).isNull();
@@ -133,7 +128,7 @@ public void testCreateRegionWithPartitionResolver() throws Exception {
         .statusIsSuccess();
 
     server.invoke(() -> {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       PartitionedRegion region = (PartitionedRegion) cache.getRegion(regionName);
       PartitionResolver resolver = region.getPartitionAttributes().getPartitionResolver();
       assertThat(resolver).isNotNull();
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java
index 36beb10fdc..421a005814 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java
@@ -74,7 +74,7 @@ public void before() throws Exception {
   @Test
   public void testDestroyDistributedRegion() {
     MemberVM.invokeInEveryMember(() -> {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       RegionFactory<Object, Object> factory = cache.createRegionFactory(RegionShortcut.PARTITION);
       factory.create("Customer");
 
@@ -106,7 +106,7 @@ public void testDestroyDistributedRegion() {
   @Test
   public void testDestroyLocalRegions() {
     MemberVM.invokeInEveryMember(() -> {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       RegionFactory<Object, Object> factory = cache.createRegionFactory(RegionShortcut.REPLICATE);
       factory.setScope(Scope.LOCAL);
       factory.create("Customer");
@@ -118,7 +118,7 @@ public void testDestroyLocalRegions() {
         .containsOutput("destroyed successfully");
 
     MemberVM.invokeInEveryMember(() -> {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       assertThat(cache.getRegion("Customer")).isNull();
     }, server1, server2, server3);
   }
@@ -126,7 +126,7 @@ public void testDestroyLocalRegions() {
   @Test
   public void testDestroyLocalAndDistributedRegions() {
     MemberVM.invokeInEveryMember(() -> {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       RegionFactory<Object, Object> factory = cache.createRegionFactory(RegionShortcut.PARTITION);
       factory.create("Customer");
       factory.create("Customer_2");
@@ -134,7 +134,7 @@ public void testDestroyLocalAndDistributedRegions() {
     }, server1, server2);
 
     server3.invoke(() -> {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       RegionFactory<Object, Object> factory = cache.createRegionFactory(RegionShortcut.REPLICATE);
       factory.setScope(Scope.LOCAL);
       factory.create("Customer");
@@ -154,7 +154,7 @@ public void testDestroyLocalAndDistributedRegions() {
         .containsOutput("destroyed successfully");
 
     MemberVM.invokeInEveryMember(() -> {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       assertThat(cache.getRegion("Customer")).isNull();
       assertThat(cache.getRegion("Customer_2")).isNull();
       assertThat(cache.getRegion("Customer_3")).isNull();
@@ -175,7 +175,7 @@ public void testDestroyRegionWithSharedConfig() throws IOException {
 
     // make sure region does exists
     MemberVM.invokeInEveryMember(() -> {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       assertThat(cache.getRegion("Customer")).isNotNull();
     }, server1, server2, server3);
 
@@ -197,7 +197,7 @@ public void testDestroyRegionWithSharedConfig() throws IOException {
 
     // make sure region does not exist
     MemberVM.invokeInEveryMember(() -> {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       assertThat(cache.getRegion("Customer")).isNull();
     }, server1, server2, server3);
   }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommandSecurityTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommandSecurityTest.java
index 428cf3b030..5247daece5 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommandSecurityTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommandSecurityTest.java
@@ -76,7 +76,7 @@ public static void beforeClass() throws Exception {
       FunctionService.registerFunction(new ReadFunction());
       FunctionService.registerFunction(new WriteFunction());
 
-      InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+      InternalCache cache = LocatorServerStartupRule.getCache();
       cache.createRegionFactory(RegionShortcut.REPLICATE).create(REPLICATED_REGION);
       cache.createRegionFactory(RegionShortcut.PARTITION).create(PARTITIONED_REGION);
     }));
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/FunctionCommandsDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/FunctionCommandsDUnitTest.java
index 9b3af7f0ee..cc5227f975 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/FunctionCommandsDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/FunctionCommandsDUnitTest.java
@@ -17,14 +17,12 @@
 
 import static org.apache.geode.internal.cache.functions.TestFunction.TEST_FUNCTION1;
 import static org.apache.geode.internal.cache.functions.TestFunction.TEST_FUNCTION_RETURN_ARGS;
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.awaitility.Awaitility.await;
 
 import java.util.Properties;
 import java.util.concurrent.TimeUnit;
 
 import org.assertj.core.util.Strings;
-import org.json.JSONArray;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -39,8 +37,6 @@
 import org.apache.geode.internal.cache.functions.TestFunction;
 import org.apache.geode.management.DistributedSystemMXBean;
 import org.apache.geode.management.ManagementService;
-import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.result.CommandResult;
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
@@ -71,7 +67,7 @@ public void before() throws Exception {
     server2 = lsRule.startServerVM(2, locator.getPort());
 
     server1.invoke(() -> {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
 
       RegionFactory<Integer, Integer> dataRegionFactory =
           cache.createRegionFactory(RegionShortcut.PARTITION);
@@ -86,7 +82,7 @@ public void before() throws Exception {
     });
 
     server2.invoke(() -> {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       RegionFactory<Integer, Integer> dataRegionFactory =
           cache.createRegionFactory(RegionShortcut.PARTITION);
       Region region = dataRegionFactory.create(REGION_ONE);
@@ -103,7 +99,7 @@ public void before() throws Exception {
     registerFunction(new TestFunction(true, TEST_FUNCTION_RETURN_ARGS), locator, server1, server2);
 
     locator.invoke(() -> {
-      Cache cache = LocatorServerStartupRule.locatorStarter.getLocator().getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       ManagementService managementService = ManagementService.getManagementService(cache);
       DistributedSystemMXBean dsMXBean = managementService.getDistributedSystemMXBean();
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/IndexCommandsShareConfigurationDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/IndexCommandsShareConfigurationDUnitTest.java
index 15d83c2543..54d03ae7b8 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/IndexCommandsShareConfigurationDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/IndexCommandsShareConfigurationDUnitTest.java
@@ -92,7 +92,7 @@ public void before() throws Exception {
     props.setProperty(GROUPS, groupName);
     serverVM = startupRule.startServerVM(1, props, locator.getPort());
     serverVM.invoke(() -> {
-      InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+      InternalCache cache = LocatorServerStartupRule.getCache();
       Region parReg =
           createPartitionedRegion(partitionedRegionName, cache, String.class, Stock.class);
       parReg.put("VMW", new Stock("VMW", 98));
@@ -148,7 +148,7 @@ public void testCreateAndDestroyUpdatesSharedConfiguration() throws Exception {
     serverVM = startupRule.startServerVM(1, props, locator.getPort());
 
     serverVM.invoke(() -> {
-      InternalCache restartedCache = LocatorServerStartupRule.serverStarter.getCache();
+      InternalCache restartedCache = LocatorServerStartupRule.getCache();
       assertNotNull(restartedCache);
       Region region = restartedCache.getRegion(partitionedRegionName);
       assertNotNull(region);
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListIndexCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListIndexCommandDUnitTest.java
index 959d50c9e9..8857625df5 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListIndexCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListIndexCommandDUnitTest.java
@@ -15,8 +15,6 @@
 
 package org.apache.geode.management.internal.cli.commands;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -54,7 +52,7 @@ public void before() throws Exception {
     server = lsRule.startServerVM(1, locator.getPort());
 
     server.invoke(() -> {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       RegionFactory factory = cache.createRegionFactory(RegionShortcut.REPLICATE);
       Region region = factory.create(REGION_1);
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowDeadlockDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowDeadlockDUnitTest.java
index 5b8c14c636..885370ba47 100755
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowDeadlockDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowDeadlockDUnitTest.java
@@ -133,7 +133,7 @@ private static void lockRemoteVM(MemberVM vmToLock) {
   }
 
   private static InternalDistributedMember getInternalDistributedMember(MemberVM memberVM) {
-    return memberVM.getVM().invoke(() -> LocatorServerStartupRule.serverStarter.getCache()
+    return memberVM.getVM().invoke(() -> LocatorServerStartupRule.getCache()
         .getInternalDistributedSystem().getDistributedMember());
   }
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowMetricsDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowMetricsDUnitTest.java
index a155731495..1a34a3e69a 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowMetricsDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowMetricsDUnitTest.java
@@ -63,7 +63,7 @@ public void before() throws Exception {
     server = lsRule.startServerVM(1, locator.getPort());
     int serverPort = server.getPort();
     server.invoke(() -> {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       RegionFactory<Integer, Integer> dataRegionFactory =
           cache.createRegionFactory(RegionShortcut.REPLICATE);
       dataRegionFactory.create("REGION1");
@@ -73,7 +73,7 @@ public void before() throws Exception {
     });
 
     locator.invoke(() -> {
-      Cache cache = LocatorServerStartupRule.locatorStarter.getLocator().getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       // Wait for all of the relevant beans to be ready
       await().atMost(120, SECONDS).until(() -> isBeanReady(cache, 1, "", null, 0));
       await().atMost(120, SECONDS).until(() -> isBeanReady(cache, 2, "REGION1", null, 0));
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfig.java b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfig.java
index 9833b2d6e4..9cee719b1f 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfig.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfig.java
@@ -92,7 +92,7 @@ public void verifyLocator(MemberVM locatorVM) {
 
     // verify info exists in memory
     locatorVM.invoke(() -> {
-      InternalLocator internalLocator = LocatorServerStartupRule.locatorStarter.getLocator();
+      InternalLocator internalLocator = LocatorServerStartupRule.getLocator();
       ClusterConfigurationService sc = internalLocator.getSharedConfiguration();
 
       // verify no extra configs exist in memory
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigDistributionDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigDistributionDUnitTest.java
index 82e72820a8..99d40e1fa1 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigDistributionDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigDistributionDUnitTest.java
@@ -122,7 +122,7 @@ public void testIndexAndAsyncEventQueueCommands() throws Exception {
     MemberVM server = lsRule.startServerVM(2, new Properties(), locator.getPort());
 
     server.invoke(() -> {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       assertNotNull(cache);
       assertTrue(cache.getCopyOnRead());
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigImportDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigImportDUnitTest.java
index 28fe1686c9..b70c71bc57 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigImportDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigImportDUnitTest.java
@@ -69,7 +69,7 @@ public void testImportWithRunningServerWithRegion() throws Exception {
     String regionName = "regionA";
     server1.invoke(() -> {
       // this region will be created on both servers, but we should only be getting the name once.
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       cache.createRegionFactory(RegionShortcut.REPLICATE).create(regionName);
     });
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigWithSecurityDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigWithSecurityDUnitTest.java
index 8312c315b6..2c763621ae 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigWithSecurityDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigWithSecurityDUnitTest.java
@@ -79,7 +79,7 @@ public void testSecurityPropsInheritanceOnLocator() throws Exception {
 
     // the second locator should inherit the first locator's security props
     locator1.invoke(() -> {
-      InternalLocator locator = LocatorServerStartupRule.locatorStarter.getLocator();
+      InternalLocator locator = LocatorServerStartupRule.getLocator();
       ClusterConfigurationService sc = locator.getSharedConfiguration();
       Properties clusterConfigProps = sc.getConfiguration("cluster").getGemfireProperties();
       assertThat(clusterConfigProps.getProperty(SECURITY_MANAGER))
@@ -99,7 +99,7 @@ public void testImportNotOverwriteSecurity() throws Exception {
         .statusIsSuccess();
 
     locator0.invoke(() -> {
-      InternalLocator locator = LocatorServerStartupRule.locatorStarter.getLocator();
+      InternalLocator locator = LocatorServerStartupRule.getLocator();
       ClusterConfigurationService sc = locator.getSharedConfiguration();
       Properties properties = sc.getConfiguration("cluster").getGemfireProperties();
       assertThat(properties.getProperty(MCAST_PORT)).isEqualTo("0");
@@ -121,7 +121,7 @@ public void testSecurityPropsInheritanceOnServer() throws Exception {
 
     // cluster config specifies a security-manager so integrated security should be enabled
     server.invoke(() -> {
-      InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+      InternalCache cache = LocatorServerStartupRule.getCache();
       Properties properties = cache.getDistributedSystem().getSecurityProperties();
       assertThat(properties.getProperty(SECURITY_MANAGER))
           .isEqualTo(SimpleTestSecurityManager.class.getName());
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ImportOldClusterConfigDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ImportOldClusterConfigDUnitTest.java
index c78545a29c..8ef523d4aa 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ImportOldClusterConfigDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ImportOldClusterConfigDUnitTest.java
@@ -96,7 +96,7 @@ private static void regionTwoExists() {
   }
 
   private static void regionExists(String regionName) {
-    Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+    Cache cache = LocatorServerStartupRule.getCache();
     assertThat(cache).isNotNull();
     Region<Object, Object> one = cache.getRegion(regionName);
     assertThat(one).isNotNull();
diff --git a/geode-core/src/test/java/org/apache/geode/security/PDXGfshPostProcessorOnRemoteServerTest.java b/geode-core/src/test/java/org/apache/geode/security/PDXGfshPostProcessorOnRemoteServerTest.java
index 03b73afb22..b747d73012 100644
--- a/geode-core/src/test/java/org/apache/geode/security/PDXGfshPostProcessorOnRemoteServerTest.java
+++ b/geode-core/src/test/java/org/apache/geode/security/PDXGfshPostProcessorOnRemoteServerTest.java
@@ -18,7 +18,6 @@
 import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_POST_PROCESSOR;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
 
 import java.util.Properties;
 import java.util.concurrent.TimeUnit;
@@ -74,7 +73,7 @@ public void testGfshCommand() throws Exception {
     MemberVM serverVM = lsRule.startServerVM(1, serverProps, locatorVM.getPort());
 
     serverVM.invoke(() -> {
-      InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+      InternalCache cache = LocatorServerStartupRule.getCache();
       assertThat(cache.getSecurityService()).isNotNull();
       assertThat(cache.getSecurityService().getSecurityManager()).isNotNull();
       assertThat(cache.getSecurityService().getPostProcessor()).isNotNull();
@@ -107,7 +106,7 @@ public void testGfshCommand() throws Exception {
     gfsh.executeAndAssertThat("query --query=\"select * from /AuthRegion\"").statusIsSuccess();
 
     serverVM.invoke(() -> {
-      PDXPostProcessor pp = (PDXPostProcessor) LocatorServerStartupRule.serverStarter.getCache()
+      PDXPostProcessor pp = (PDXPostProcessor) LocatorServerStartupRule.getCache()
           .getSecurityService().getPostProcessor();
       // verify that the post processor is called 6 times. (5 for the query, 1 for the get)
       assertEquals(pp.getCount(), 6);
diff --git a/geode-core/src/test/java/org/apache/geode/security/PeerAuthenticatorDUnitTest.java b/geode-core/src/test/java/org/apache/geode/security/PeerAuthenticatorDUnitTest.java
index 6264b04f8f..705d412067 100644
--- a/geode-core/src/test/java/org/apache/geode/security/PeerAuthenticatorDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/security/PeerAuthenticatorDUnitTest.java
@@ -62,7 +62,7 @@ public void testPeerAuthenticator() throws Exception {
 
     server2.invoke(() -> {
       ServerStarterRule serverStarter = new ServerStarterRule();
-      LocatorServerStartupRule.serverStarter = serverStarter;
+      LocatorServerStartupRule.memberStarter = serverStarter;
       assertThatThrownBy(() -> serverStarter.startServer(server2Props, locatorPort))
           .isInstanceOf(GemFireSecurityException.class).hasMessageContaining("Invalid user name");
 
diff --git a/geode-core/src/test/java/org/apache/geode/security/PeerSecurityWithEmbeddedLocatorDUnitTest.java b/geode-core/src/test/java/org/apache/geode/security/PeerSecurityWithEmbeddedLocatorDUnitTest.java
index 9233bdce4a..dc920589bb 100644
--- a/geode-core/src/test/java/org/apache/geode/security/PeerSecurityWithEmbeddedLocatorDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/security/PeerSecurityWithEmbeddedLocatorDUnitTest.java
@@ -63,7 +63,7 @@ public void testPeerSecurityManager() throws Exception {
     VM server2 = getHost(0).getVM(2);
     server2.invoke(() -> {
       ServerStarterRule serverStarter = new ServerStarterRule();
-      LocatorServerStartupRule.serverStarter = serverStarter;
+      LocatorServerStartupRule.memberStarter = serverStarter;
       assertThatThrownBy(() -> serverStarter.startServer(server2Props, locatorPort))
           .isInstanceOf(GemFireSecurityException.class)
           .hasMessageContaining("Security check failed. Authentication error");
@@ -94,7 +94,7 @@ public void testPeerAuthenticator() throws Exception {
     VM server2 = getHost(0).getVM(2);
     server2.invoke(() -> {
       ServerStarterRule serverStarter = new ServerStarterRule();
-      LocatorServerStartupRule.serverStarter = serverStarter;
+      LocatorServerStartupRule.memberStarter = serverStarter;
       assertThatThrownBy(() -> serverStarter.startServer(server2Props, locatorPort))
           .isInstanceOf(GemFireSecurityException.class).hasMessageContaining("Invalid user name");
     });
diff --git a/geode-core/src/test/java/org/apache/geode/test/dunit/rules/LocatorServerStartupRule.java b/geode-core/src/test/java/org/apache/geode/test/dunit/rules/LocatorServerStartupRule.java
index 400a38da37..ca55d8e0a0 100644
--- a/geode-core/src/test/java/org/apache/geode/test/dunit/rules/LocatorServerStartupRule.java
+++ b/geode-core/src/test/java/org/apache/geode/test/dunit/rules/LocatorServerStartupRule.java
@@ -30,7 +30,10 @@
 import org.junit.rules.ExternalResource;
 import org.junit.rules.TemporaryFolder;
 
+import org.apache.geode.cache.server.CacheServer;
+import org.apache.geode.distributed.internal.InternalLocator;
 import org.apache.geode.internal.AvailablePortHelper;
+import org.apache.geode.internal.cache.InternalCache;
 import org.apache.geode.test.dunit.VM;
 import org.apache.geode.test.dunit.standalone.DUnitLauncher;
 import org.apache.geode.test.junit.rules.Locator;
@@ -52,12 +55,19 @@
   /**
    * This is only available in each Locator/Server VM, not in the controller (test) VM.
    */
-  public static ServerStarterRule serverStarter;
+  public static MemberStarterRule memberStarter;
 
-  /**
-   * This is only available in each Locator/Server VM, not in the controller (test) VM.
-   */
-  public static LocatorStarterRule locatorStarter;
+  public static InternalCache getCache() {
+    return memberStarter.getCache();
+  }
+
+  public static InternalLocator getLocator() {
+    return ((LocatorStarterRule) memberStarter).getLocator();
+  }
+
+  public static CacheServer getServer() {
+    return ((ServerStarterRule) memberStarter).getServer();
+  }
 
   private DistributedRestoreSystemProperties restoreSystemProperties =
       new DistributedRestoreSystemProperties();
@@ -141,7 +151,8 @@ public MemberVM startLocatorVM(int index, Properties specifiedProperties) throws
 
     VM locatorVM = getVM(index);
     Locator locator = locatorVM.invoke(() -> {
-      locatorStarter = new LocatorStarterRule();
+      memberStarter = new LocatorStarterRule();
+      LocatorStarterRule locatorStarter = (LocatorStarterRule) memberStarter;
       if (useTempWorkingDir()) {
         File workingDirFile = createWorkingDirForMember(name);
         locatorStarter.withWorkingDir(workingDirFile);
@@ -191,7 +202,8 @@ public MemberVM startServerVM(int index, Properties specifiedProperties, int loc
 
     VM serverVM = getVM(index);
     Server server = serverVM.invoke(() -> {
-      serverStarter = new ServerStarterRule();
+      memberStarter = new ServerStarterRule();
+      ServerStarterRule serverStarter = (ServerStarterRule) memberStarter;
       if (useTempWorkingDir()) {
         File workingDirFile = createWorkingDirForMember(name);
         serverStarter.withWorkingDir(workingDirFile);
@@ -230,7 +242,8 @@ public MemberVM startServerAsEmbededLocator(int index, Properties properties) th
 
     VM serverVM = getVM(index);
     Server server = serverVM.invoke(() -> {
-      serverStarter = new ServerStarterRule();
+      memberStarter = new ServerStarterRule();
+      ServerStarterRule serverStarter = (ServerStarterRule) memberStarter;
       if (useTempWorkingDir()) {
         File workingDirFile = createWorkingDirForMember(name);
         serverStarter.withWorkingDir(workingDirFile);
@@ -282,13 +295,9 @@ public File getWorkingDirRoot() {
   }
 
   public static void stopMemberInThisVM() {
-    if (serverStarter != null) {
-      serverStarter.after();
-      serverStarter = null;
-    }
-    if (locatorStarter != null) {
-      locatorStarter.after();
-      locatorStarter = null;
+    if (memberStarter != null) {
+      memberStarter.after();
+      memberStarter = null;
     }
   }
 
diff --git a/geode-core/src/test/java/org/apache/geode/test/dunit/rules/MemberVM.java b/geode-core/src/test/java/org/apache/geode/test/dunit/rules/MemberVM.java
index 71aa58e7f8..bedd65a4cb 100644
--- a/geode-core/src/test/java/org/apache/geode/test/dunit/rules/MemberVM.java
+++ b/geode-core/src/test/java/org/apache/geode/test/dunit/rules/MemberVM.java
@@ -122,4 +122,14 @@ public void stopMember() {
   public static void invokeInEveryMember(SerializableRunnableIF runnableIF, MemberVM... members) {
     Arrays.stream(members).forEach(member -> member.invoke(runnableIF));
   }
+
+  /**
+   * this should called on a locatorVM or a serverVM with jmxManager enabled
+   */
+  public void waitTillRegionsAreReadyOnServers(String regionPath, int serverCount) {
+    vm.invoke(() -> {
+      LocatorServerStartupRule.memberStarter.waitTillRegionIsReadyOnServers(regionPath,
+          serverCount);
+    });
+  }
 }
diff --git a/geode-core/src/test/java/org/apache/geode/test/junit/rules/Locator.java b/geode-core/src/test/java/org/apache/geode/test/junit/rules/Locator.java
index 7c1223760a..a0b16e3b3b 100644
--- a/geode-core/src/test/java/org/apache/geode/test/junit/rules/Locator.java
+++ b/geode-core/src/test/java/org/apache/geode/test/junit/rules/Locator.java
@@ -15,8 +15,10 @@
 package org.apache.geode.test.junit.rules;
 
 import org.apache.geode.distributed.internal.InternalLocator;
+import org.apache.geode.internal.cache.InternalCache;
 
 public interface Locator extends Member {
+  InternalCache getCache();
 
   InternalLocator getLocator();
 }
diff --git a/geode-core/src/test/java/org/apache/geode/test/junit/rules/LocatorStarterRule.java b/geode-core/src/test/java/org/apache/geode/test/junit/rules/LocatorStarterRule.java
index 0a46871921..e3af3271cd 100644
--- a/geode-core/src/test/java/org/apache/geode/test/junit/rules/LocatorStarterRule.java
+++ b/geode-core/src/test/java/org/apache/geode/test/junit/rules/LocatorStarterRule.java
@@ -25,6 +25,7 @@
 
 import org.apache.geode.distributed.internal.DistributionConfig;
 import org.apache.geode.distributed.internal.InternalLocator;
+import org.apache.geode.internal.cache.InternalCache;
 
 /**
  * This is a rule to start up a locator in your current VM. It's useful for your Integration Tests.
@@ -45,7 +46,6 @@
  * use {@code LocatorServerStartupRule}.
  */
 public class LocatorStarterRule extends MemberStarterRule<LocatorStarterRule> implements Locator {
-
   private transient InternalLocator locator;
 
   @Override
@@ -90,4 +90,9 @@ public void startLocator() {
           .until(() -> assertTrue(locator.isSharedConfigurationRunning()));
     }
   }
+
+  @Override
+  public InternalCache getCache() {
+    return locator.getCache();
+  }
 }
diff --git a/geode-core/src/test/java/org/apache/geode/test/junit/rules/Member.java b/geode-core/src/test/java/org/apache/geode/test/junit/rules/Member.java
index e40ebf5e5a..96b189c92c 100644
--- a/geode-core/src/test/java/org/apache/geode/test/junit/rules/Member.java
+++ b/geode-core/src/test/java/org/apache/geode/test/junit/rules/Member.java
@@ -18,7 +18,6 @@
 import java.io.Serializable;
 
 public interface Member extends Serializable {
-
   File getWorkingDir();
 
   int getPort();
diff --git a/geode-core/src/test/java/org/apache/geode/test/junit/rules/MemberStarterRule.java b/geode-core/src/test/java/org/apache/geode/test/junit/rules/MemberStarterRule.java
index 350f627517..722a4c4bab 100644
--- a/geode-core/src/test/java/org/apache/geode/test/junit/rules/MemberStarterRule.java
+++ b/geode-core/src/test/java/org/apache/geode/test/junit/rules/MemberStarterRule.java
@@ -24,17 +24,22 @@
 import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;
 import static org.apache.geode.distributed.ConfigurationProperties.NAME;
 import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_MANAGER;
+import static org.awaitility.Awaitility.await;
 
 import java.io.File;
 import java.io.IOException;
 import java.util.Properties;
+import java.util.concurrent.TimeUnit;
 
 import org.junit.rules.TemporaryFolder;
 
 import org.apache.geode.distributed.DistributedSystem;
 import org.apache.geode.distributed.internal.InternalDistributedSystem;
 import org.apache.geode.internal.AvailablePortHelper;
+import org.apache.geode.internal.cache.InternalCache;
 import org.apache.geode.internal.net.SocketCreatorFactory;
+import org.apache.geode.management.DistributedRegionMXBean;
+import org.apache.geode.management.ManagementService;
 import org.apache.geode.security.SecurityManager;
 import org.apache.geode.test.junit.rules.serializable.SerializableExternalResource;
 
@@ -220,6 +225,27 @@ protected void normalizeProperties() {
     }
   }
 
+  public DistributedRegionMXBean getRegionMBean(String regionName) {
+    return getManagementService().getDistributedRegionMXBean(regionName);
+  }
+
+  public ManagementService getManagementService() {
+    ManagementService managementService =
+        ManagementService.getExistingManagementService(getCache());
+    if (managementService == null) {
+      throw new IllegalStateException("Management service is not available on this member");
+    }
+    return managementService;
+  }
+
+  public abstract InternalCache getCache();
+
+  public void waitTillRegionIsReadyOnServers(String regionName, int serverCount) {
+    await().atMost(2, TimeUnit.SECONDS).until(() -> getRegionMBean(regionName) != null);
+    await().atMost(2, TimeUnit.SECONDS)
+        .until(() -> getRegionMBean(regionName).getMembers().length == serverCount);
+  }
+
   abstract void stopMember();
 
   @Override
diff --git a/geode-core/src/test/java/org/apache/geode/test/junit/rules/Server.java b/geode-core/src/test/java/org/apache/geode/test/junit/rules/Server.java
index 42a6971490..639cf27b61 100644
--- a/geode-core/src/test/java/org/apache/geode/test/junit/rules/Server.java
+++ b/geode-core/src/test/java/org/apache/geode/test/junit/rules/Server.java
@@ -14,12 +14,11 @@
  */
 package org.apache.geode.test.junit.rules;
 
-import org.apache.geode.cache.Cache;
 import org.apache.geode.cache.server.CacheServer;
+import org.apache.geode.internal.cache.InternalCache;
 
 public interface Server extends Member {
-
-  Cache getCache();
+  InternalCache getCache();
 
   CacheServer getServer();
 
diff --git a/geode-core/src/test/java/org/apache/geode/test/junit/rules/ServerStarterRule.java b/geode-core/src/test/java/org/apache/geode/test/junit/rules/ServerStarterRule.java
index cff999be97..c15c3765a7 100644
--- a/geode-core/src/test/java/org/apache/geode/test/junit/rules/ServerStarterRule.java
+++ b/geode-core/src/test/java/org/apache/geode/test/junit/rules/ServerStarterRule.java
@@ -51,7 +51,6 @@
  * use {@code LocatorServerStartupRule}.
  */
 public class ServerStarterRule extends MemberStarterRule<ServerStarterRule> implements Server {
-
   private transient InternalCache cache;
   private transient CacheServer server;
   private int embeddedLocatorPort = -1;
diff --git a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsDUnitTest.java b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsDUnitTest.java
index 5418f97e63..2aa38041fe 100755
--- a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsDUnitTest.java
+++ b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsDUnitTest.java
@@ -18,7 +18,6 @@
 import static org.apache.geode.cache.lucene.test.LuceneTestUtilities.REGION_NAME;
 import static org.apache.geode.test.dunit.Assert.assertArrayEquals;
 import static org.apache.geode.test.dunit.Assert.assertEquals;
-import static org.apache.geode.test.dunit.Assert.assertTrue;
 import static org.assertj.core.api.Assertions.assertThat;
 
 import java.io.Serializable;
@@ -663,8 +662,7 @@ private void createRegion() {
 
   private void createIndex() {
     serverVM.invoke(() -> {
-      LuceneService luceneService =
-          LuceneServiceProvider.get(LocatorServerStartupRule.serverStarter.getCache());
+      LuceneService luceneService = LuceneServiceProvider.get(LocatorServerStartupRule.getCache());
       Map<String, Analyzer> fieldAnalyzers = new HashMap();
       fieldAnalyzers.put("field1", new StandardAnalyzer());
       fieldAnalyzers.put("field2", new KeywordAnalyzer());
@@ -676,8 +674,7 @@ private void createIndex() {
 
   private void createIndexWithoutRegion() {
     serverVM.invoke(() -> {
-      LuceneService luceneService =
-          LuceneServiceProvider.get(LocatorServerStartupRule.serverStarter.getCache());
+      LuceneService luceneService = LuceneServiceProvider.get(LocatorServerStartupRule.getCache());
       Map<String, Analyzer> fieldAnalyzers = new HashMap();
       fieldAnalyzers.put("field1", new StandardAnalyzer());
       fieldAnalyzers.put("field2", new KeywordAnalyzer());
@@ -720,7 +717,7 @@ private String getRegionNotFoundErrorMessage(String regionPath) {
   }
 
   private static Cache getCache() {
-    return LocatorServerStartupRule.serverStarter.getCache();
+    return LocatorServerStartupRule.getCache();
   }
 
   protected class TestObject implements Serializable {
diff --git a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/configuration/LuceneClusterConfigurationDUnitTest.java b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/configuration/LuceneClusterConfigurationDUnitTest.java
index 7e6cdc66b6..0c0f8ff94a 100755
--- a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/configuration/LuceneClusterConfigurationDUnitTest.java
+++ b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/configuration/LuceneClusterConfigurationDUnitTest.java
@@ -83,8 +83,7 @@ public void indexGetsCreatedUsingClusterConfiguration() throws Exception {
     // configuration.
     MemberVM vm2 = ls.startServerVM(2, locator.getPort());
     vm2.invoke(() -> {
-      LuceneService luceneService =
-          LuceneServiceProvider.get(LocatorServerStartupRule.serverStarter.getCache());
+      LuceneService luceneService = LuceneServiceProvider.get(LocatorServerStartupRule.getCache());
       final LuceneIndex index = luceneService.getIndex(INDEX_NAME, REGION_NAME);
       assertNotNull(index);
       validateIndexFields(new String[] {"field1", "field2", "field3"}, index);
@@ -108,8 +107,7 @@ public void indexWithAnalyzerGetsCreatedUsingClusterConfiguration() throws Excep
     // configuration.
     MemberVM vm2 = ls.startServerVM(2, locator.getPort());
     vm2.invoke(() -> {
-      LuceneService luceneService =
-          LuceneServiceProvider.get(LocatorServerStartupRule.serverStarter.getCache());
+      LuceneService luceneService = LuceneServiceProvider.get(LocatorServerStartupRule.getCache());
       final LuceneIndex index = luceneService.getIndex(INDEX_NAME, REGION_NAME);
       assertNotNull(index);
       String[] fields = new String[] {"field1", "field2", "field3"};
@@ -139,8 +137,7 @@ public void indexWithSerializerGetsCreatedUsingClusterConfiguration() throws Exc
     // configuration.
     MemberVM vm2 = ls.startServerVM(2, locator.getPort());
     vm2.invoke(() -> {
-      LuceneService luceneService =
-          LuceneServiceProvider.get(LocatorServerStartupRule.serverStarter.getCache());
+      LuceneService luceneService = LuceneServiceProvider.get(LocatorServerStartupRule.getCache());
       final LuceneIndex index = luceneService.getIndex(INDEX_NAME, REGION_NAME);
       assertNotNull(index);
       String[] fields = new String[] {"field1", "field2", "field3"};
@@ -242,7 +239,7 @@ private void createAndAddIndexes() throws Exception {
 
   private SerializableRunnableIF verifyClusterConfiguration(boolean verifyIndexesExist) {
     return () -> {
-      InternalLocator internalLocator = LocatorServerStartupRule.locatorStarter.getLocator();
+      InternalLocator internalLocator = LocatorServerStartupRule.getLocator();
       ClusterConfigurationService sc = internalLocator.getSharedConfiguration();
       Configuration config = sc.getConfiguration(ClusterConfigurationService.CLUSTER_CONFIG);
       String xmlContent = config.getCacheXmlContent();
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/WANCommandUtils.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/WANCommandUtils.java
index a3699a683e..5a35fd908e 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/WANCommandUtils.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/WANCommandUtils.java
@@ -60,7 +60,7 @@ public static void createSender(String dsName, int remoteDsId, boolean isParalle
     File persistentDirectory =
         new File(dsName + "_disk_" + System.currentTimeMillis() + "_" + VM.getCurrentVMNum());
     persistentDirectory.mkdir();
-    Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+    Cache cache = LocatorServerStartupRule.getCache();
     DiskStoreFactory dsf = cache.createDiskStoreFactory();
     File[] dirs1 = new File[] {persistentDirectory};
     if (isParallel) {
@@ -105,7 +105,7 @@ public static void createSender(String dsName, int remoteDsId, boolean isParalle
   public static void startSender(String senderId) {
     final IgnoredException exln = IgnoredException.addIgnoredException("Could not connect");
     try {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       Set<GatewaySender> senders = cache.getGatewaySenders();
       AbstractGatewaySender sender = (AbstractGatewaySender) senders.stream()
           .filter(s -> s.getId().equalsIgnoreCase(senderId)).findFirst().orElse(null);
@@ -118,7 +118,7 @@ public static void startSender(String senderId) {
   public static void pauseSender(String senderId) {
     final IgnoredException exln = IgnoredException.addIgnoredException("Could not connect");
     try {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       Set<GatewaySender> senders = cache.getGatewaySenders();
       AbstractGatewaySender sender = (AbstractGatewaySender) senders.stream()
           .filter(s -> s.getId().equalsIgnoreCase(senderId)).findFirst().orElse(null);
@@ -131,8 +131,7 @@ public static void pauseSender(String senderId) {
   public static void verifySenderState(String senderId, boolean isRunning, boolean isPaused) {
     final IgnoredException exln = IgnoredException.addIgnoredException("Could not connect");
     try {
-      Set<GatewaySender> senders =
-          LocatorServerStartupRule.serverStarter.getCache().getGatewaySenders();
+      Set<GatewaySender> senders = LocatorServerStartupRule.getCache().getGatewaySenders();
       for (GatewaySender sender : senders) {
         assertEquals(isRunning, sender.isRunning());
         assertEquals(isPaused, sender.isPaused());
@@ -149,8 +148,7 @@ public static void verifySenderAttributes(String senderId, int remoteDsID, boole
       int dispatcherThreads, GatewaySender.OrderPolicy orderPolicy,
       List<String> expectedGatewayEventFilters, List<String> expectedGatewayTransportFilters) {
 
-    Set<GatewaySender> senders =
-        LocatorServerStartupRule.serverStarter.getCache().getGatewaySenders();
+    Set<GatewaySender> senders = LocatorServerStartupRule.getCache().getGatewaySenders();
     for (GatewaySender sender : senders) {
       assertEquals("remoteDistributedSystemId", remoteDsID, sender.getRemoteDSId());
       assertEquals("isParallel", isParallel, sender.isParallel());
@@ -211,7 +209,7 @@ public static void verifySenderAttributes(String senderId, int remoteDsID, boole
   }
 
   public static void verifySenderDestroyed(String senderId, boolean isParallel) {
-    Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+    Cache cache = LocatorServerStartupRule.getCache();
     Set<GatewaySender> senders = cache.getGatewaySenders();
     AbstractGatewaySender sender = (AbstractGatewaySender) senders.stream()
         .filter(s -> s.getId().equalsIgnoreCase(senderId)).findFirst().orElse(null);
@@ -232,7 +230,7 @@ public static void verifySenderDestroyed(String senderId, boolean isParallel) {
 
   public static void startReceiver() {
     try {
-      Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+      Cache cache = LocatorServerStartupRule.getCache();
       Set<GatewayReceiver> receivers = cache.getGatewayReceivers();
       for (GatewayReceiver receiver : receivers) {
         receiver.start();
@@ -245,7 +243,7 @@ public static void startReceiver() {
   }
 
   public static void stopReceiver() {
-    Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+    Cache cache = LocatorServerStartupRule.getCache();
     Set<GatewayReceiver> receivers = cache.getGatewayReceivers();
     for (GatewayReceiver receiver : receivers) {
       receiver.stop();
@@ -258,7 +256,7 @@ public static void createAndStartReceiver(int locPort) {
   }
 
   public static void createReceiver(int locPort) {
-    Cache cache = LocatorServerStartupRule.serverStarter.getCache();
+    Cache cache = LocatorServerStartupRule.getCache();
     GatewayReceiverFactory fact = cache.createGatewayReceiverFactory();
     fact.setStartPort(AvailablePort.AVAILABLE_PORTS_LOWER_BOUND);
     fact.setEndPort(AvailablePort.AVAILABLE_PORTS_UPPER_BOUND);
@@ -267,8 +265,7 @@ public static void createReceiver(int locPort) {
   }
 
   public static void verifyReceiverState(boolean isRunning) {
-    Set<GatewayReceiver> receivers =
-        LocatorServerStartupRule.serverStarter.getCache().getGatewayReceivers();
+    Set<GatewayReceiver> receivers = LocatorServerStartupRule.getCache().getGatewayReceivers();
     for (GatewayReceiver receiver : receivers) {
       assertEquals(isRunning, receiver.isRunning());
     }
@@ -288,7 +285,7 @@ public static void verifyGatewayReceiverServerLocations(int locatorPort, String
 
   public static void verifyGatewayReceiverProfile(String expected) {
     Set<GatewayReceiver> receivers =
-        ((Cache) LocatorServerStartupRule.serverStarter.getCache()).getGatewayReceivers();
+        ((Cache) LocatorServerStartupRule.getCache()).getGatewayReceivers();
     for (GatewayReceiver receiver : receivers) {
       CacheServerImpl server = (CacheServerImpl) receiver.getServer();
       CacheServerAdvisor.CacheServerProfile profile =
@@ -302,7 +299,7 @@ public static void verifyReceiverCreationWithAttributes(boolean isRunning, int s
       List<String> expectedGatewayTransportFilters, String hostnameForSenders) {
 
     Set<GatewayReceiver> receivers =
-        ((Cache) LocatorServerStartupRule.serverStarter.getCache()).getGatewayReceivers();
+        ((Cache) LocatorServerStartupRule.getCache()).getGatewayReceivers();
     assertEquals("Number of receivers is incorrect", 1, receivers.size());
     for (GatewayReceiver receiver : receivers) {
       assertEquals("isRunning", isRunning, receiver.isRunning());
@@ -337,7 +334,6 @@ public static void verifyReceiverCreationWithAttributes(boolean isRunning, int s
   }
 
   public static SerializableCallableIF<DistributedMember> getMemberIdCallable() {
-    return () -> LocatorServerStartupRule.serverStarter.getCache().getDistributedSystem()
-        .getDistributedMember();
+    return () -> LocatorServerStartupRule.getCache().getDistributedSystem().getDistributedMember();
   }
 }
diff --git a/geode-wan/src/test/java/org/apache/geode/management/internal/configuration/WANClusterConfigurationDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/management/internal/configuration/WANClusterConfigurationDUnitTest.java
index af793319ff..e42573d60f 100644
--- a/geode-wan/src/test/java/org/apache/geode/management/internal/configuration/WANClusterConfigurationDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/management/internal/configuration/WANClusterConfigurationDUnitTest.java
@@ -121,7 +121,7 @@ public void testCreateGatewaySenderReceiver() throws Exception {
     // verify GatewayReceiver attributes saved in cluster config
     newMember.invoke(() -> {
       Set<GatewayReceiver> gatewayReceivers =
-          LocatorServerStartupRule.serverStarter.getCache().getGatewayReceivers();
+          LocatorServerStartupRule.getCache().getGatewayReceivers();
       assertNotNull(gatewayReceivers);
       assertFalse(gatewayReceivers.isEmpty());
       assertTrue(gatewayReceivers.size() == 1);
@@ -136,7 +136,7 @@ public void testCreateGatewaySenderReceiver() throws Exception {
 
     // verify GatewaySender attributes saved in cluster config
     newMember.invoke(() -> {
-      GatewaySender gs = LocatorServerStartupRule.serverStarter.getCache().getGatewaySender(gsId);
+      GatewaySender gs = LocatorServerStartupRule.getCache().getGatewaySender(gsId);
       assertNotNull(gs);
       assertTrue(alertThreshold.equals(Integer.toString(gs.getAlertThreshold())));
       assertTrue(batchSize.equals(Integer.toString(gs.getBatchSize())));
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/AlterRuntimeCommandDUnitTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/AlterRuntimeCommandDUnitTest.java
index d01629b528..c748b94e40 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/AlterRuntimeCommandDUnitTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/AlterRuntimeCommandDUnitTest.java
@@ -59,7 +59,7 @@
   private void verifyDefaultConfig(MemberVM[] servers) {
     for (MemberVM server : servers) {
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogLevel()).isEqualTo(LogWriterImpl.ERROR_LEVEL);
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
@@ -103,7 +103,7 @@ public void testAlterRuntimeConfig(final boolean connectOverHttp) throws Excepti
     gfsh.executeAndAssertThat(csb.toString()).statusIsSuccess();
 
     server0.invoke(() -> {
-      InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+      InternalCache cache = LocatorServerStartupRule.getCache();
       DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
       assertThat(config.getLogLevel()).isEqualTo(LogWriterImpl.INFO_LEVEL);
       assertThat(config.getLogFileSizeLimit()).isEqualTo(50);
@@ -149,7 +149,7 @@ public void alterLogDiskSpaceLimitWithFileSizeLimitNotSet_OK(final boolean conne
 
     for (MemberVM server : new MemberVM[] {server1, server2}) {
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
         assertThat(config.getArchiveDiskSpaceLimit()).isEqualTo(0);
@@ -184,7 +184,7 @@ public void alterLogDiskSpaceLimitWithFileSizeLimitSet_OK(final boolean connectO
     gfsh.executeAndAssertThat(csbSetFileSizeLimit.toString()).statusIsSuccess();
 
     server2.invoke(() -> {
-      InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+      InternalCache cache = LocatorServerStartupRule.getCache();
       DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
       assertThat(config.getLogFileSizeLimit()).isEqualTo(50);
       assertThat(config.getLogDiskSpaceLimit()).isEqualTo(0);
@@ -198,7 +198,7 @@ public void alterLogDiskSpaceLimitWithFileSizeLimitSet_OK(final boolean connectO
 
     for (MemberVM server : new MemberVM[] {server1, server2}) {
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(50);
         assertThat(config.getLogDiskSpaceLimit()).isEqualTo(10);
@@ -240,7 +240,7 @@ public void alterLogDiskSpaceLimitOnMember_OK(final boolean connectOverHttp) thr
         expectedLimit = 0;
       }
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
         assertThat(config.getLogDiskSpaceLimit()).isEqualTo(expectedLimit);
@@ -289,7 +289,7 @@ public void alterLogDiskSpaceLimitOnGroup_OK(final boolean connectOverHttp) thro
         expectedGroup = "";
       }
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getGroups()).isEqualTo(expectedGroup);
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
@@ -326,7 +326,7 @@ public void alterLogFileSizeLimit_changesConfigOnAllServers(final boolean connec
 
     for (MemberVM server : new MemberVM[] {server1, server2}) {
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(11);
         assertThat(config.getArchiveDiskSpaceLimit()).isEqualTo(0);
@@ -436,7 +436,7 @@ public void alterStatArchiveFile_updatesAllServerConfigs(final boolean connectOv
 
     for (MemberVM server : new MemberVM[] {server1, server2}) {
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
         assertThat(config.getArchiveDiskSpaceLimit()).isEqualTo(0);
@@ -480,7 +480,7 @@ public void alterStatArchiveFileWithMember_updatesSelectedServerConfigs(
         expectedName = "";
       }
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
         assertThat(config.getArchiveDiskSpaceLimit()).isEqualTo(0);
@@ -525,7 +525,7 @@ public void alterStatArchiveFileWithGroup_updatesSelectedServerConfigs(
         expectedName = "";
       }
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
         assertThat(config.getArchiveDiskSpaceLimit()).isEqualTo(0);
@@ -561,7 +561,7 @@ public void alterStatSampleRate_updatesAllServerConfigs(final boolean connectOve
 
     for (MemberVM server : new MemberVM[] {server1, server2}) {
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
         assertThat(config.getArchiveDiskSpaceLimit()).isEqualTo(0);
@@ -606,7 +606,7 @@ public void alterStatSampleRateWithMember_updatesSelectedServerConfigs(
         expectedSampleRate = 1000;
       }
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
         assertThat(config.getArchiveDiskSpaceLimit()).isEqualTo(0);
@@ -652,7 +652,7 @@ public void alterStatSampleRateWithGroup_updatesSelectedServerConfigs(
         expectedSampleRate = 1000;
       }
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
         assertThat(config.getArchiveDiskSpaceLimit()).isEqualTo(0);
@@ -727,7 +727,7 @@ public void alterArchiveDiskSpaceLimit_updatesAllServerConfigs(final boolean con
 
     for (MemberVM server : new MemberVM[] {server1, server2}) {
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
         assertThat(config.getArchiveDiskSpaceLimit()).isEqualTo(TEST_LIMIT);
@@ -773,7 +773,7 @@ public void alterArchiveDiskSpaceLimitWithMember_updatesSelectedServerConfigs(
         expectedLimit = 0;
       }
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
         assertThat(config.getArchiveDiskSpaceLimit()).isEqualTo(expectedLimit);
@@ -820,7 +820,7 @@ public void alterArchiveDiskSpaceLimitWithGroup_updatesSelectedServerConfigs(
         expectedLimit = 0;
       }
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
         assertThat(config.getArchiveDiskSpaceLimit()).isEqualTo(expectedLimit);
@@ -870,7 +870,7 @@ public void alterArchiveDiskSpaceLimitRangeIsEnforced(final boolean connectOverH
 
     for (MemberVM server : new MemberVM[] {server1, server2}) {
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
         assertThat(config.getArchiveDiskSpaceLimit()).isEqualTo(0);
@@ -909,7 +909,7 @@ public void alterArchiveFileSizeLimit_updatesAllServerConfigs(final boolean conn
 
     for (MemberVM server : new MemberVM[] {server1, server2}) {
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
         assertThat(config.getArchiveDiskSpaceLimit()).isEqualTo(0);
@@ -955,7 +955,7 @@ public void alterArchiveFileSizeLimitWithMember_updatesSelectedServerConfigs(
         expectedLimit = 0;
       }
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
         assertThat(config.getArchiveDiskSpaceLimit()).isEqualTo(0);
@@ -1002,7 +1002,7 @@ public void alterArchiveFileSizeLimitWithGroup_updatesSelectedServerConfigs(
         expectedLimit = 0;
       }
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
         assertThat(config.getArchiveDiskSpaceLimit()).isEqualTo(0);
@@ -1076,7 +1076,7 @@ public void alterDisableStatisticSampling(final boolean connectOverHttp) throws
 
     for (MemberVM server : new MemberVM[] {server1, server2}) {
       server.invoke(() -> {
-        InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+        InternalCache cache = LocatorServerStartupRule.getCache();
         DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
         assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
         assertThat(config.getArchiveDiskSpaceLimit()).isEqualTo(0);
@@ -1111,7 +1111,7 @@ public void alterGroupWithoutOptions_needsRelevantParameter(final boolean connec
     }
 
     server2.invoke(() -> {
-      InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+      InternalCache cache = LocatorServerStartupRule.getCache();
       DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
       assertThat(config.getGroups()).isEqualTo("G1");
     });
@@ -1125,7 +1125,7 @@ public void alterGroupWithoutOptions_needsRelevantParameter(final boolean connec
         .contains(CliStrings.ALTER_RUNTIME_CONFIG__RELEVANT__OPTION__MESSAGE);
 
     server1.invoke(() -> {
-      InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+      InternalCache cache = LocatorServerStartupRule.getCache();
       DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
       assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
       assertThat(config.getLogDiskSpaceLimit()).isEqualTo(0);
@@ -1165,7 +1165,7 @@ public void alterMemberWithoutOptions_needsRelevantParameter(final boolean conne
         .contains(CliStrings.ALTER_RUNTIME_CONFIG__RELEVANT__OPTION__MESSAGE);
 
     server1.invoke(() -> {
-      InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+      InternalCache cache = LocatorServerStartupRule.getCache();
       DistributionConfig config = cache.getInternalDistributedSystem().getConfig();
       assertThat(config.getLogFileSizeLimit()).isEqualTo(0);
       assertThat(config.getLogDiskSpaceLimit()).isEqualTo(0);
@@ -1197,7 +1197,7 @@ public void testAlterUpdatesSharedConfig(final boolean connectOverHttp) throws E
 
     locator.invoke(() -> {
       ClusterConfigurationService sharedConfig =
-          LocatorServerStartupRule.locatorStarter.getLocator().getSharedConfiguration();
+          LocatorServerStartupRule.getLocator().getSharedConfiguration();
       Properties properties = sharedConfig.getConfiguration("Group1").getGemfireProperties();
       assertThat(properties.get(LOG_LEVEL)).isEqualTo("fine");
     });
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandDUnitTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandDUnitTest.java
index c2109668c5..370670b39e 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandDUnitTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandDUnitTest.java
@@ -67,7 +67,7 @@ public void testDescribeConfig(final boolean connectOverHttp) throws Exception {
     }
 
     server0.invoke(() -> {
-      InternalCache cache = LocatorServerStartupRule.serverStarter.getCache();
+      InternalCache cache = LocatorServerStartupRule.getCache();
       InternalDistributedSystem system = cache.getInternalDistributedSystem();
       DistributionConfig config = system.getConfig();
       config.setArchiveFileSizeLimit(1000);


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit d1fc1347f1411429594a9fde308d4b55a5afa966 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=d1fc134 ]

GEODE-3539: LocatorServerStartupRule enhancement (#1021)

* get rid of the redundant variable that refers to either a LocatorStarter or a ServerStarter
* add methods in MemberVM to wait till the region beans are ready
* add convenient methods to get cache and servers and locators


PurelyApplied opened a new pull request #1024: GEODE-3539: Restore test coverage for 'describe connection' command.
URL: https://github.com/apache/geode/pull/1024
 
 
   Due to a critical oversight on my part, the test committed in ``a1b9725a7cb351299a5239a79f96daed9d88865b` and reverted in `70b4327b196630c638a6e7aef608405d2d73db98` did not account for testing environments that resolve the host address to an alias given in `/etc/hosts`.
   
   This commit restores the test, accounting for this possible output.
   
   Precheckin running.
   
   --
   
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao opened a new pull request #1025: GEODE-3539: add more tests for get, put, locate entry commands
URL: https://github.com/apache/geode/pull/1025
 
 
   * clean up more methods in CliUtil
   * refactor tests out of GemfireDataCommandsDUnitTest
   * get rid of unnecessary try/catch block in commands
   
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on a change in pull request #1024: GEODE-3539: Restore test coverage for 'describe connection' command.
URL: https://github.com/apache/geode/pull/1024#discussion_r149493281
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConnectionCommandJUnitTest.java
 ##########
 @@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.management.internal.cli.commands;
+
+import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.net.UnknownHostException;
+import java.util.Collections;
+import java.util.Enumeration;
+
+import org.apache.logging.log4j.Logger;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.LocatorStarterRule;
+
+/**
+ * The GfshCommandJUnitTest class is a test suite of test cases testing the contract and
+ * functionality of the GfshCommand class for implementing GemFire shell (Gfsh) commands.
+ *
+ * @see org.apache.geode.management.internal.cli.commands.GfshCommand
+ * @see org.jmock.Expectations
+ * @see org.jmock.Mockery
+ * @see org.jmock.lib.legacy.ClassImposteriser
+ * @see org.junit.Assert
+ * @see org.junit.Test
+ * @since GemFire 7.0
+ */
+
+@Category(IntegrationTest.class)
+public class DescribeConnectionCommandJUnitTest {
+  public static Logger logger = LogService.getLogger();
+
+  @ClassRule
+  public static LocatorStarterRule locator = new LocatorStarterRule().withAutoStart();
+
+  @Rule
+  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+
+  @Test
+  public void executeWhileConnected() throws Exception {
+    // Depending on configuration, the host may resolve its local IP
+    // to the alias present in /etc/hosts or use its internal host name.
+    // Check for these first.
+    gfsh.connectAndVerify(locator);
+    try {
 
 Review comment:
   I ran the command with different connection type, and the results shows up differently:
   
   > connect --locator=localhost[60303]
   Connecting to Locator at [host=localhost, port=60303] ..
   Connecting to Manager at [host=10.118.33.214, port=21535] ..
   Successfully connected to: [host=10.118.33.214, port=21535]
   
   
   > describe connection 
   Connection Endpoints
   --------------------
   10.118.33.214[21535]
   
   > disconnect
   Disconnecting from: 10.118.33.214[21535]
   Disconnected from : 10.118.33.214[21535]
   
   
   > connect --jmx-manager=localhost[21535]
   Connecting to Manager at [host=localhost, port=21535] ..
   Successfully connected to: [host=localhost, port=21535]
   
   > describe connection
   Connection Endpoints
   --------------------
   localhost[21535]
   
   > disconnect
   Disconnecting from: localhost[21535]
   Disconnected from : localhost[21535]
   
   > connect --use-http
   Successfully connected to: GemFire Manager HTTP service @ http://localhost:28478/geode-mgmt/v1
   
   > describe connection
   Connection Endpoints
   -------------------------------------------------------------------
   GemFire Manager HTTP service @ http://localhost:28478/geode-mgmt/v1
   
   
   we will need to have tests for each of these case.
   It probably would be better if we would just assert with gfsh.getInvoker().toString (which gives us the connection string).
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied commented on a change in pull request #1024: GEODE-3539: Restore test coverage for 'describe connection' command.
URL: https://github.com/apache/geode/pull/1024#discussion_r149512169
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConnectionCommandJUnitTest.java
 ##########
 @@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.management.internal.cli.commands;
+
+import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.net.UnknownHostException;
+import java.util.Collections;
+import java.util.Enumeration;
+
+import org.apache.logging.log4j.Logger;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.LocatorStarterRule;
+
+/**
+ * The GfshCommandJUnitTest class is a test suite of test cases testing the contract and
+ * functionality of the GfshCommand class for implementing GemFire shell (Gfsh) commands.
+ *
+ * @see org.apache.geode.management.internal.cli.commands.GfshCommand
+ * @see org.jmock.Expectations
+ * @see org.jmock.Mockery
+ * @see org.jmock.lib.legacy.ClassImposteriser
+ * @see org.junit.Assert
+ * @see org.junit.Test
+ * @since GemFire 7.0
+ */
+
+@Category(IntegrationTest.class)
+public class DescribeConnectionCommandJUnitTest {
+  public static Logger logger = LogService.getLogger();
+
+  @ClassRule
+  public static LocatorStarterRule locator = new LocatorStarterRule().withAutoStart();
+
+  @Rule
+  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+
+  @Test
+  public void executeWhileConnected() throws Exception {
+    // Depending on configuration, the host may resolve its local IP
+    // to the alias present in /etc/hosts or use its internal host name.
+    // Check for these first.
+    gfsh.connectAndVerify(locator);
+    try {
 
 Review comment:
   That's much simpler!  Good call.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit d1fc1347f1411429594a9fde308d4b55a5afa966 in geode's branch refs/heads/feature/GEODE-3940 from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=d1fc134 ]

GEODE-3539: LocatorServerStartupRule enhancement (#1021)

* get rid of the redundant variable that refers to either a LocatorStarter or a ServerStarter
* add methods in MemberVM to wait till the region beans are ready
* add convenient methods to get cache and servers and locators


jinmeiliao commented on a change in pull request #1024: GEODE-3539: Restore test coverage for 'describe connection' command.
URL: https://github.com/apache/geode/pull/1024#discussion_r149549846
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConnectionCommandJUnitTest.java
 ##########
 @@ -49,13 +49,17 @@
   public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
 
   @Test
-  public void executeWhileConnected() throws Exception {
-    // Depending on configuration, the host may resolve its local IP
-    // to the alias present in /etc/hosts or use its internal host name.
-    // Check for these first.
-    gfsh.connectAndVerify(locator);
-    gfsh.executeAndAssertThat("describe connection")
-        .tableHasColumnWithValuesContaining("Connection Endpoints", gfsh.getGfsh().getOperationInvoker().toString());
+  public void describeJmxConnection() throws Exception {
+    gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+    gfsh.executeAndAssertThat("describe connection").tableHasColumnWithValuesContaining(
+        "Connection Endpoints", gfsh.getGfsh().getOperationInvoker().toString());
+  }
+
+  @Test
+  public void describeHttpConnection() throws Exception {
 
 Review comment:
   if this test is not in geode-web or geode-assembly, I think this would fail. I don't think it would necessary to test http. the assertions are all the same.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on issue #1025: GEODE-3539: add more tests for get, put, locate entry commands
URL: https://github.com/apache/geode/pull/1025#issuecomment-343015661
 
 
   all tests are green

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao closed pull request #1025: GEODE-3539: add more tests for get, put, locate entry commands
URL: https://github.com/apache/geode/pull/1025
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java
index 2358cb788f..7e4ae044df 100755
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java
@@ -34,8 +34,6 @@
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
 import java.util.Set;
 import java.util.stream.Collectors;
 import java.util.zip.DataFormatException;
@@ -62,7 +60,7 @@
 import org.apache.geode.management.ManagementService;
 import org.apache.geode.management.cli.Result;
 import org.apache.geode.management.internal.MBeanJMXAdapter;
-import org.apache.geode.management.internal.cli.functions.MembersForRegionFunction;
+import org.apache.geode.management.internal.cli.exceptions.UserErrorException;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
 import org.apache.geode.management.internal.cli.shell.Gfsh;
@@ -291,7 +289,7 @@ public static String convertStringListToString(List<String> stringList, char del
     }
 
     if ((members.length > 0) && (groups.length > 0)) {
-      throw new IllegalArgumentException(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE);
+      throw new UserErrorException(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE);
     }
 
     if (members.length == 0 && groups.length == 0) {
@@ -303,7 +301,7 @@ public static String convertStringListToString(List<String> stringList, char del
     for (String memberNameOrId : members) {
       for (DistributedMember member : membersToConsider) {
         if (memberNameOrId.equalsIgnoreCase(member.getId())
-            || memberNameOrId.equals(member.getName())) {
+            || memberNameOrId.equalsIgnoreCase(member.getName())) {
           matchingMembers.add(member);
         }
       }
@@ -327,7 +325,7 @@ public static DistributedMember getDistributedMemberByNameOrId(String memberName
       Set<DistributedMember> memberSet = CliUtil.getAllMembers(cache);
       for (DistributedMember member : memberSet) {
         if (memberNameOrId.equalsIgnoreCase(member.getId())
-            || memberNameOrId.equals(member.getName())) {
+            || memberNameOrId.equalsIgnoreCase(member.getName())) {
           memberFound = member;
           break;
         }
@@ -692,52 +690,4 @@ public static String getClientIdFromCacheClientProxy(CacheClientProxy p) {
     return buffer.toString();
   }
 
-  public static Set<DistributedMember> getMembersForeRegionViaFunction(InternalCache cache,
-      String regionPath, boolean returnAll) {
-    try {
-      Set<DistributedMember> regionMembers = new HashSet<>();
-      MembersForRegionFunction membersForRegionFunction = new MembersForRegionFunction();
-      FunctionService.registerFunction(membersForRegionFunction);
-      Set<DistributedMember> targetMembers = CliUtil.getAllMembers(cache);
-      List<?> resultList = (List<?>) CliUtil
-          .executeFunction(membersForRegionFunction, regionPath, targetMembers).getResult();
-
-      for (Object object : resultList) {
-        try {
-          if (object instanceof Exception) {
-            LogWrapper.getInstance().warning(
-                "Exception in getMembersForeRegionViaFunction " + ((Throwable) object).getMessage(),
-                ((Throwable) object));
-            continue;
-          } else if (object instanceof Throwable) {
-            LogWrapper.getInstance().warning(
-                "Exception in getMembersForeRegionViaFunction " + ((Throwable) object).getMessage(),
-                ((Throwable) object));
-            continue;
-          }
-          if (object != null) {
-            Map<String, String> memberDetails = (Map<String, String>) object;
-            for (Entry<String, String> entry : memberDetails.entrySet()) {
-              Set<DistributedMember> dsMems = CliUtil.getAllMembers(cache);
-              for (DistributedMember mem : dsMems) {
-                if (mem.getId().equals(entry.getKey())) {
-                  regionMembers.add(mem);
-                  if (!returnAll) {
-                    return regionMembers;
-                  }
-                }
-              }
-            }
-          }
-        } catch (Exception ex) {
-          LogWrapper.getInstance().warning("getMembersForeRegionViaFunction exception " + ex);
-        }
-      }
-      return regionMembers;
-    } catch (Exception e) {
-      LogWrapper.getInstance().warning("getMembersForeRegionViaFunction exception " + e);
-      return null;
-    }
-  }
-
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/GfshParseResult.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/GfshParseResult.java
index b3fd0fa450..08d7a08206 100755
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/GfshParseResult.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/GfshParseResult.java
@@ -128,4 +128,9 @@ private CliOption getCliOption(Annotation[][] parameterAnnotations, int index) {
     }
     return null;
   }
+
+  @Override
+  public String toString() {
+    return this.userInput;
+  }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeClientCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeClientCommand.java
index 9b37f12731..d8135f0dd4 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeClientCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeClientCommand.java
@@ -50,7 +50,7 @@
   @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,
       operation = ResourcePermission.Operation.READ)
   public Result describeClient(@CliOption(key = CliStrings.DESCRIBE_CLIENT__ID, mandatory = true,
-      help = CliStrings.DESCRIBE_CLIENT__ID__HELP) String clientId) {
+      help = CliStrings.DESCRIBE_CLIENT__ID__HELP) String clientId) throws Exception {
     Result result;
 
     if (clientId.startsWith("\"")) {
@@ -65,111 +65,97 @@ public Result describeClient(@CliOption(key = CliStrings.DESCRIBE_CLIENT__ID, ma
       clientId = clientId.substring(0, clientId.length() - 2);
     }
 
-    try {
-      CompositeResultData compositeResultData = ResultBuilder.createCompositeResultData();
-      CompositeResultData.SectionResultData sectionResult =
-          compositeResultData.addSection("InfoSection");
-      InternalCache cache = getCache();
-
-      ManagementService service = ManagementService.getExistingManagementService(cache);
-      ObjectName[] cacheServers = service.getDistributedSystemMXBean().listCacheServerObjectNames();
-      if (cacheServers.length == 0) {
-        return ResultBuilder.createGemFireErrorResult(
-            CliStrings.format(CliStrings.DESCRIBE_CLIENT_COULD_NOT_RETRIEVE_SERVER_LIST));
-      }
+    CompositeResultData compositeResultData = ResultBuilder.createCompositeResultData();
+    CompositeResultData.SectionResultData sectionResult =
+        compositeResultData.addSection("InfoSection");
+    InternalCache cache = getCache();
+
+    ManagementService service = ManagementService.getExistingManagementService(cache);
+    ObjectName[] cacheServers = service.getDistributedSystemMXBean().listCacheServerObjectNames();
+    if (cacheServers.length == 0) {
+      return ResultBuilder.createGemFireErrorResult(
+          CliStrings.format(CliStrings.DESCRIBE_CLIENT_COULD_NOT_RETRIEVE_SERVER_LIST));
+    }
+
+    ClientHealthStatus clientHealthStatus = null;
 
-      ClientHealthStatus clientHealthStatus = null;
-
-      for (ObjectName objName : cacheServers) {
-        CacheServerMXBean serverMbean = service.getMBeanInstance(objName, CacheServerMXBean.class);
-        List<String> listOfClient =
-            new ArrayList<>(Arrays.asList((String[]) serverMbean.getClientIds()));
-        if (listOfClient.contains(clientId)) {
-          if (clientHealthStatus == null) {
-            try {
-              clientHealthStatus = serverMbean.showClientStats(clientId);
-              if (clientHealthStatus == null) {
-                return ResultBuilder.createGemFireErrorResult(CliStrings.format(
-                    CliStrings.DESCRIBE_CLIENT_COULD_NOT_RETRIEVE_STATS_FOR_CLIENT_0, clientId));
-              }
-            } catch (Exception eee) {
+    for (ObjectName objName : cacheServers) {
+      CacheServerMXBean serverMbean = service.getMBeanInstance(objName, CacheServerMXBean.class);
+      List<String> listOfClient =
+          new ArrayList<>(Arrays.asList((String[]) serverMbean.getClientIds()));
+      if (listOfClient.contains(clientId)) {
+        if (clientHealthStatus == null) {
+          try {
+            clientHealthStatus = serverMbean.showClientStats(clientId);
+            if (clientHealthStatus == null) {
               return ResultBuilder.createGemFireErrorResult(CliStrings.format(
-                  CliStrings.DESCRIBE_CLIENT_COULD_NOT_RETRIEVE_STATS_FOR_CLIENT_0_REASON_1,
-                  clientId, eee.getMessage()));
+                  CliStrings.DESCRIBE_CLIENT_COULD_NOT_RETRIEVE_STATS_FOR_CLIENT_0, clientId));
             }
+          } catch (Exception eee) {
+            return ResultBuilder.createGemFireErrorResult(CliStrings.format(
+                CliStrings.DESCRIBE_CLIENT_COULD_NOT_RETRIEVE_STATS_FOR_CLIENT_0_REASON_1, clientId,
+                eee.getMessage()));
           }
         }
       }
+    }
 
-      if (clientHealthStatus == null) {
-        return ResultBuilder.createGemFireErrorResult(
-            CliStrings.format(CliStrings.DESCRIBE_CLIENT__CLIENT__ID__NOT__FOUND__0, clientId));
-      }
+    if (clientHealthStatus == null) {
+      return ResultBuilder.createGemFireErrorResult(
+          CliStrings.format(CliStrings.DESCRIBE_CLIENT__CLIENT__ID__NOT__FOUND__0, clientId));
+    }
 
-      Set<DistributedMember> dsMembers = CliUtil.getAllMembers(cache);
-      String isDurable = null;
-      List<String> primaryServers = new ArrayList<>();
-      List<String> secondaryServers = new ArrayList<>();
-
-      if (dsMembers.size() > 0) {
-        ContinuousQueryFunction continuousQueryFunction = new ContinuousQueryFunction();
-        FunctionService.registerFunction(continuousQueryFunction);
-        List<?> resultList = (List<?>) CliUtil
-            .executeFunction(continuousQueryFunction, clientId, dsMembers).getResult();
-        for (Object aResultList : resultList) {
-          try {
-            Object object = aResultList;
-            if (object instanceof Throwable) {
-              LogWrapper.getInstance().warning(
-                  "Exception in Describe Client " + ((Throwable) object).getMessage(),
-                  ((Throwable) object));
-              continue;
+    Set<DistributedMember> dsMembers = CliUtil.getAllMembers(cache);
+    String isDurable = null;
+    List<String> primaryServers = new ArrayList<>();
+    List<String> secondaryServers = new ArrayList<>();
+
+    if (dsMembers.size() > 0) {
+      ContinuousQueryFunction continuousQueryFunction = new ContinuousQueryFunction();
+      FunctionService.registerFunction(continuousQueryFunction);
+      List<?> resultList = (List<?>) CliUtil
+          .executeFunction(continuousQueryFunction, clientId, dsMembers).getResult();
+      for (Object aResultList : resultList) {
+        Object object = aResultList;
+        if (object instanceof Throwable) {
+          LogWrapper.getInstance().warning(
+              "Exception in Describe Client " + ((Throwable) object).getMessage(),
+              ((Throwable) object));
+          continue;
+        }
+
+        if (object != null) {
+          ContinuousQueryFunction.ClientInfo objectResult =
+              (ContinuousQueryFunction.ClientInfo) object;
+          isDurable = objectResult.isDurable;
+
+          if (objectResult.primaryServer != null && objectResult.primaryServer.length() > 0) {
+            if (primaryServers.size() == 0) {
+              primaryServers.add(objectResult.primaryServer);
+            } else {
+              primaryServers.add(" ,");
+              primaryServers.add(objectResult.primaryServer);
             }
+          }
 
-            if (object != null) {
-              ContinuousQueryFunction.ClientInfo objectResult =
-                  (ContinuousQueryFunction.ClientInfo) object;
-              isDurable = objectResult.isDurable;
-
-              if (objectResult.primaryServer != null && objectResult.primaryServer.length() > 0) {
-                if (primaryServers.size() == 0) {
-                  primaryServers.add(objectResult.primaryServer);
-                } else {
-                  primaryServers.add(" ,");
-                  primaryServers.add(objectResult.primaryServer);
-                }
-              }
-
-              if (objectResult.secondaryServer != null
-                  && objectResult.secondaryServer.length() > 0) {
-                if (secondaryServers.size() == 0) {
-                  secondaryServers.add(objectResult.secondaryServer);
-                } else {
-                  secondaryServers.add(" ,");
-                  secondaryServers.add(objectResult.secondaryServer);
-                }
-              }
+          if (objectResult.secondaryServer != null && objectResult.secondaryServer.length() > 0) {
+            if (secondaryServers.size() == 0) {
+              secondaryServers.add(objectResult.secondaryServer);
+            } else {
+              secondaryServers.add(" ,");
+              secondaryServers.add(objectResult.secondaryServer);
             }
-          } catch (Exception e) {
-            LogWrapper.getInstance().info(CliStrings.DESCRIBE_CLIENT_ERROR_FETCHING_STATS_0 + " :: "
-                + CliUtil.stackTraceAsString(e));
-            return ResultBuilder.createGemFireErrorResult(CliStrings
-                .format(CliStrings.DESCRIBE_CLIENT_ERROR_FETCHING_STATS_0, e.getMessage()));
           }
         }
-
-        buildTableResult(sectionResult, clientHealthStatus, isDurable, primaryServers,
-            secondaryServers);
-        result = ResultBuilder.buildResult(compositeResultData);
-      } else {
-        return ResultBuilder.createGemFireErrorResult(CliStrings.DESCRIBE_CLIENT_NO_MEMBERS);
       }
-    } catch (Exception e) {
-      LogWrapper.getInstance()
-          .info("Error in describe clients. stack trace" + CliUtil.stackTraceAsString(e));
-      result = ResultBuilder.createGemFireErrorResult(CliStrings
-          .format(CliStrings.DESCRIBE_CLIENT_COULD_NOT_RETRIEVE_CLIENT_0, e.getMessage()));
+
+      buildTableResult(sectionResult, clientHealthStatus, isDurable, primaryServers,
+          secondaryServers);
+      result = ResultBuilder.buildResult(compositeResultData);
+    } else {
+      return ResultBuilder.createGemFireErrorResult(CliStrings.DESCRIBE_CLIENT_NO_MEMBERS);
     }
+
     LogWrapper.getInstance().info("describe client result " + result);
     return result;
   }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommand.java
index b7b1f088c5..b826918ffb 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommand.java
@@ -29,7 +29,6 @@
 import org.apache.geode.management.cli.CliMetaData;
 import org.apache.geode.management.cli.ConverterHint;
 import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.domain.MemberConfigurationInfo;
 import org.apache.geode.management.internal.cli.functions.GetMemberConfigInformationFunction;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
@@ -60,58 +59,51 @@ public Result describeConfig(
       DistributedMember targetMember = null;
 
       if (memberNameOrId != null && !memberNameOrId.isEmpty()) {
-        targetMember = CliUtil.getDistributedMemberByNameOrId(memberNameOrId);
+        targetMember = getMember(memberNameOrId);
       }
-      if (targetMember != null) {
-        ResultCollector<?, ?> rc =
-            executeFunction(getMemberConfigFunction, hideDefaults, targetMember);
-        ArrayList<?> output = (ArrayList<?>) rc.getResult();
-        Object obj = output.get(0);
 
-        if (obj != null && obj instanceof MemberConfigurationInfo) {
-          MemberConfigurationInfo memberConfigInfo = (MemberConfigurationInfo) obj;
+      ResultCollector<?, ?> rc =
+          executeFunction(getMemberConfigFunction, hideDefaults, targetMember);
+      ArrayList<?> output = (ArrayList<?>) rc.getResult();
+      Object obj = output.get(0);
 
-          CompositeResultData crd = ResultBuilder.createCompositeResultData();
-          crd.setHeader(
-              CliStrings.format(CliStrings.DESCRIBE_CONFIG__HEADER__TEXT, memberNameOrId));
+      if (obj != null && obj instanceof MemberConfigurationInfo) {
+        MemberConfigurationInfo memberConfigInfo = (MemberConfigurationInfo) obj;
 
-          List<String> jvmArgsList = memberConfigInfo.getJvmInputArguments();
-          TabularResultData jvmInputArgs = crd.addSection().addSection().addTable();
+        CompositeResultData crd = ResultBuilder.createCompositeResultData();
+        crd.setHeader(CliStrings.format(CliStrings.DESCRIBE_CONFIG__HEADER__TEXT, memberNameOrId));
 
-          for (String jvmArg : jvmArgsList) {
-            jvmInputArgs.accumulate("JVM command line arguments", jvmArg);
-          }
+        List<String> jvmArgsList = memberConfigInfo.getJvmInputArguments();
+        TabularResultData jvmInputArgs = crd.addSection().addSection().addTable();
 
-          addSection(crd, memberConfigInfo.getGfePropsSetUsingApi(),
-              "GemFire properties defined using the API");
-          addSection(crd, memberConfigInfo.getGfePropsRuntime(),
-              "GemFire properties defined at the runtime");
-          addSection(crd, memberConfigInfo.getGfePropsSetFromFile(),
-              "GemFire properties defined with the property file");
-          addSection(crd, memberConfigInfo.getGfePropsSetWithDefaults(),
-              "GemFire properties using default values");
-          addSection(crd, memberConfigInfo.getCacheAttributes(), "Cache attributes");
-
-          List<Map<String, String>> cacheServerAttributesList =
-              memberConfigInfo.getCacheServerAttributes();
-
-          if (cacheServerAttributesList != null && !cacheServerAttributesList.isEmpty()) {
-            CompositeResultData.SectionResultData cacheServerSection = crd.addSection();
-            cacheServerSection.setHeader("Cache-server attributes");
-
-            for (Map<String, String> cacheServerAttributes : cacheServerAttributesList) {
-              addSubSection(cacheServerSection, cacheServerAttributes);
-            }
-          }
-          result = ResultBuilder.buildResult(crd);
+        for (String jvmArg : jvmArgsList) {
+          jvmInputArgs.accumulate("JVM command line arguments", jvmArg);
         }
 
-      } else {
-        ErrorResultData erd = ResultBuilder.createErrorResultData();
-        erd.addLine(CliStrings.format(CliStrings.DESCRIBE_CONFIG__MEMBER__NOT__FOUND,
-            new Object[] {memberNameOrId}));
-        result = ResultBuilder.buildResult(erd);
+        addSection(crd, memberConfigInfo.getGfePropsSetUsingApi(),
+            "GemFire properties defined using the API");
+        addSection(crd, memberConfigInfo.getGfePropsRuntime(),
+            "GemFire properties defined at the runtime");
+        addSection(crd, memberConfigInfo.getGfePropsSetFromFile(),
+            "GemFire properties defined with the property file");
+        addSection(crd, memberConfigInfo.getGfePropsSetWithDefaults(),
+            "GemFire properties using default values");
+        addSection(crd, memberConfigInfo.getCacheAttributes(), "Cache attributes");
+
+        List<Map<String, String>> cacheServerAttributesList =
+            memberConfigInfo.getCacheServerAttributes();
+
+        if (cacheServerAttributesList != null && !cacheServerAttributesList.isEmpty()) {
+          CompositeResultData.SectionResultData cacheServerSection = crd.addSection();
+          cacheServerSection.setHeader("Cache-server attributes");
+
+          for (Map<String, String> cacheServerAttributes : cacheServerAttributesList) {
+            addSubSection(cacheServerSection, cacheServerAttributes);
+          }
+        }
+        result = ResultBuilder.buildResult(crd);
       }
+
     } catch (FunctionInvocationTargetException e) {
       result = ResultBuilder.createGemFireErrorResult(CliStrings
           .format(CliStrings.COULD_NOT_EXECUTE_COMMAND_TRY_AGAIN, CliStrings.DESCRIBE_CONFIG));
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommand.java
index 4efd97383e..f56e591a70 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommand.java
@@ -71,7 +71,7 @@ public Result describeDiskStore(
   }
 
   DiskStoreDetails getDiskStoreDescription(final String memberName, final String diskStoreName) {
-    final DistributedMember member = getMember(getCache(), memberName);
+    final DistributedMember member = getMember(memberName);
 
     final ResultCollector<?, ?> resultCollector =
         getMembersFunctionExecutor(Collections.singleton(member)).setArguments(diskStoreName)
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeMemberCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeMemberCommand.java
index dfe2a57277..9aec188822 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeMemberCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeMemberCommand.java
@@ -52,75 +52,67 @@ public Result describeMember(@CliOption(key = CliStrings.DESCRIBE_MEMBER__IDENTI
     Result result = null;
 
     try {
-      DistributedMember memberToBeDescribed =
-          CliUtil.getDistributedMemberByNameOrId(memberNameOrId);
-
-      if (memberToBeDescribed != null) {
-        ResultCollector<?, ?> rc = executeFunction(getMemberInformation, null, memberToBeDescribed);
-
-        ArrayList<?> output = (ArrayList<?>) rc.getResult();
-        Object obj = output.get(0);
-
-        if (obj != null && (obj instanceof MemberInformation)) {
-
-          CompositeResultData crd = ResultBuilder.createCompositeResultData();
-
-          MemberInformation memberInformation = (MemberInformation) obj;
-          memberInformation.setName(memberToBeDescribed.getName());
-          memberInformation.setId(memberToBeDescribed.getId());
-          memberInformation.setHost(memberToBeDescribed.getHost());
-          memberInformation.setProcessId("" + memberToBeDescribed.getProcessId());
-
-          CompositeResultData.SectionResultData section = crd.addSection();
-          section.addData("Name", memberInformation.getName());
-          section.addData("Id", memberInformation.getId());
-          section.addData("Host", memberInformation.getHost());
-          section.addData("Regions",
-              CliUtil.convertStringSetToString(memberInformation.getHostedRegions(), '\n'));
-          section.addData("PID", memberInformation.getProcessId());
-          section.addData("Groups", memberInformation.getGroups());
-          section.addData("Used Heap", memberInformation.getHeapUsage() + "M");
-          section.addData("Max Heap", memberInformation.getMaxHeapSize() + "M");
-
-          String offHeapMemorySize = memberInformation.getOffHeapMemorySize();
-          if (offHeapMemorySize != null && !offHeapMemorySize.isEmpty()) {
-            section.addData("Off Heap Size", offHeapMemorySize);
-          }
-
-          section.addData("Working Dir", memberInformation.getWorkingDirPath());
-          section.addData("Log file", memberInformation.getLogFilePath());
+      DistributedMember memberToBeDescribed = getMember(memberNameOrId);
+
+      ResultCollector<?, ?> rc = executeFunction(getMemberInformation, null, memberToBeDescribed);
+
+      ArrayList<?> output = (ArrayList<?>) rc.getResult();
+      Object obj = output.get(0);
+
+      if (obj != null && (obj instanceof MemberInformation)) {
+        CompositeResultData crd = ResultBuilder.createCompositeResultData();
+
+        MemberInformation memberInformation = (MemberInformation) obj;
+        memberInformation.setName(memberToBeDescribed.getName());
+        memberInformation.setId(memberToBeDescribed.getId());
+        memberInformation.setHost(memberToBeDescribed.getHost());
+        memberInformation.setProcessId("" + memberToBeDescribed.getProcessId());
+
+        CompositeResultData.SectionResultData section = crd.addSection();
+        section.addData("Name", memberInformation.getName());
+        section.addData("Id", memberInformation.getId());
+        section.addData("Host", memberInformation.getHost());
+        section.addData("Regions",
+            CliUtil.convertStringSetToString(memberInformation.getHostedRegions(), '\n'));
+        section.addData("PID", memberInformation.getProcessId());
+        section.addData("Groups", memberInformation.getGroups());
+        section.addData("Used Heap", memberInformation.getHeapUsage() + "M");
+        section.addData("Max Heap", memberInformation.getMaxHeapSize() + "M");
+
+        String offHeapMemorySize = memberInformation.getOffHeapMemorySize();
+        if (offHeapMemorySize != null && !offHeapMemorySize.isEmpty()) {
+          section.addData("Off Heap Size", offHeapMemorySize);
+        }
 
-          section.addData("Locators", memberInformation.getLocators());
+        section.addData("Working Dir", memberInformation.getWorkingDirPath());
+        section.addData("Log file", memberInformation.getLogFilePath());
 
-          if (memberInformation.isServer()) {
-            CompositeResultData.SectionResultData clientServiceSection = crd.addSection();
-            List<CacheServerInfo> csList = memberInformation.getCacheServeInfo();
+        section.addData("Locators", memberInformation.getLocators());
 
-            if (csList != null) {
-              Iterator<CacheServerInfo> iters = csList.iterator();
-              clientServiceSection.setHeader("Cache Server Information");
+        if (memberInformation.isServer()) {
+          CompositeResultData.SectionResultData clientServiceSection = crd.addSection();
+          List<CacheServerInfo> csList = memberInformation.getCacheServeInfo();
 
-              while (iters.hasNext()) {
-                CacheServerInfo cacheServerInfo = iters.next();
-                clientServiceSection.addData("Server Bind", cacheServerInfo.getBindAddress());
-                clientServiceSection.addData("Server Port", cacheServerInfo.getPort());
-                clientServiceSection.addData("Running", cacheServerInfo.isRunning());
-              }
+          if (csList != null) {
+            Iterator<CacheServerInfo> iters = csList.iterator();
+            clientServiceSection.setHeader("Cache Server Information");
 
-              clientServiceSection.addData("Client Connections",
-                  memberInformation.getClientCount());
+            while (iters.hasNext()) {
+              CacheServerInfo cacheServerInfo = iters.next();
+              clientServiceSection.addData("Server Bind", cacheServerInfo.getBindAddress());
+              clientServiceSection.addData("Server Port", cacheServerInfo.getPort());
+              clientServiceSection.addData("Running", cacheServerInfo.isRunning());
             }
-          }
-          result = ResultBuilder.buildResult(crd);
 
-        } else {
-          result = ResultBuilder.createInfoResult(CliStrings.format(
-              CliStrings.DESCRIBE_MEMBER__MSG__INFO_FOR__0__COULD_NOT_BE_RETRIEVED,
-              new Object[] {memberNameOrId}));
+            clientServiceSection.addData("Client Connections", memberInformation.getClientCount());
+          }
         }
+        result = ResultBuilder.buildResult(crd);
+
       } else {
-        result = ResultBuilder.createInfoResult(CliStrings
-            .format(CliStrings.DESCRIBE_MEMBER__MSG__NOT_FOUND, new Object[] {memberNameOrId}));
+        result = ResultBuilder.createInfoResult(
+            CliStrings.format(CliStrings.DESCRIBE_MEMBER__MSG__INFO_FOR__0__COULD_NOT_BE_RETRIEVED,
+                new Object[] {memberNameOrId}));
       }
     } catch (CacheClosedException ignored) {
     } catch (Exception e) {
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DestroyFunctionCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DestroyFunctionCommand.java
index f36c15402b..81dfc2bd46 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DestroyFunctionCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DestroyFunctionCommand.java
@@ -72,7 +72,7 @@ public Result destroyFunction(
         return results;
       } else if (memberId != null) {
         // execute on member
-        dsMembers.add(getMember(cache, memberId));
+        dsMembers.add(getMember(memberId));
         @SuppressWarnings("unchecked")
         Result results = executeFunction(cache, dsMembers, functionId);
         return results;
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportDataCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportDataCommand.java
index 5f7a6d1732..9c5a41baa3 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportDataCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportDataCommand.java
@@ -56,11 +56,7 @@ public Result exportData(
           help = CliStrings.EXPORT_DATA__PARALLEL_HELP) boolean parallel) {
 
     getSecurityService().authorize(Resource.DATA, Operation.READ, regionName);
-    final DistributedMember targetMember = CliUtil.getDistributedMemberByNameOrId(memberNameOrId);
-    if (targetMember == null) {
-      return ResultBuilder.createUserErrorResult(
-          CliStrings.format(CliStrings.EXPORT_DATA__MEMBER__NOT__FOUND, memberNameOrId));
-    }
+    final DistributedMember targetMember = getMember(memberNameOrId);
 
     Optional<Result> validationResult = validatePath(filePath, dirPath, parallel);
     if (validationResult.isPresent()) {
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GCCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GCCommand.java
index 4884d6da8c..9a039bd557 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GCCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GCCommand.java
@@ -57,11 +57,7 @@ public Result gc(
     resultTable.setHeader(headerText);
     Set<DistributedMember> dsMembers = new HashSet<>();
     if (memberId != null && memberId.length() > 0) {
-      DistributedMember member = CliUtil.getDistributedMemberByNameOrId(memberId);
-      if (member == null) {
-        return ResultBuilder
-            .createGemFireErrorResult(memberId + CliStrings.GC__MSG__MEMBER_NOT_FOUND);
-      }
+      DistributedMember member = getMember(memberId);
       dsMembers.add(member);
       result = executeAndBuildResult(resultTable, dsMembers);
     } else if (groups != null && groups.length > 0) {
@@ -82,42 +78,38 @@ public Result gc(
 
   private Result executeAndBuildResult(TabularResultData resultTable,
       Set<DistributedMember> dsMembers) {
-    try {
-      List<?> resultList;
-      Function garbageCollectionFunction = new GarbageCollectionFunction();
-      resultList =
-          (List<?>) CliUtil.executeFunction(garbageCollectionFunction, null, dsMembers).getResult();
 
-      for (Object object : resultList) {
-        if (object instanceof Exception) {
-          LogWrapper.getInstance().fine("Exception in GC " + ((Throwable) object).getMessage(),
-              ((Throwable) object));
-          continue;
-        } else if (object instanceof Throwable) {
-          LogWrapper.getInstance().fine("Exception in GC " + ((Throwable) object).getMessage(),
-              ((Throwable) object));
-          continue;
-        }
+    List<?> resultList;
+    Function garbageCollectionFunction = new GarbageCollectionFunction();
+    resultList =
+        (List<?>) CliUtil.executeFunction(garbageCollectionFunction, null, dsMembers).getResult();
 
-        if (object != null) {
-          if (object instanceof String) {
-            // unexpected exception string - cache may be closed or something
-            return ResultBuilder.createUserErrorResult((String) object);
-          } else {
-            Map<String, String> resultMap = (Map<String, String>) object;
-            toTabularResultData(resultTable, resultMap.get("MemberId"),
-                resultMap.get("HeapSizeBeforeGC"), resultMap.get("HeapSizeAfterGC"),
-                resultMap.get("TimeSpentInGC"));
-          }
+    for (Object object : resultList) {
+      if (object instanceof Exception) {
+        LogWrapper.getInstance().fine("Exception in GC " + ((Throwable) object).getMessage(),
+            ((Throwable) object));
+        continue;
+      } else if (object instanceof Throwable) {
+        LogWrapper.getInstance().fine("Exception in GC " + ((Throwable) object).getMessage(),
+            ((Throwable) object));
+        continue;
+      }
+
+      if (object != null) {
+        if (object instanceof String) {
+          // unexpected exception string - cache may be closed or something
+          return ResultBuilder.createUserErrorResult((String) object);
         } else {
-          LogWrapper.getInstance().fine("ResultMap was null ");
+          Map<String, String> resultMap = (Map<String, String>) object;
+          toTabularResultData(resultTable, resultMap.get("MemberId"),
+              resultMap.get("HeapSizeBeforeGC"), resultMap.get("HeapSizeAfterGC"),
+              resultMap.get("TimeSpentInGC"));
         }
+      } else {
+        LogWrapper.getInstance().fine("ResultMap was null ");
       }
-    } catch (Exception e) {
-      String stack = CliUtil.stackTraceAsString(e);
-      LogWrapper.getInstance().info("GC exception is " + stack);
-      return ResultBuilder.createGemFireErrorResult(e.getMessage() + ": " + stack);
     }
+
     return ResultBuilder.buildResult(resultTable);
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GatewayCommandsUtils.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GatewayCommandsUtils.java
index d6e03c1985..2e317cbf38 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GatewayCommandsUtils.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GatewayCommandsUtils.java
@@ -15,12 +15,6 @@
 
 package org.apache.geode.management.internal.cli.commands;
 
-import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.LogWrapper;
-import org.apache.geode.management.internal.cli.i18n.CliStrings;
-import org.apache.geode.management.internal.cli.result.CommandResultException;
-import org.apache.geode.management.internal.cli.result.ResultBuilder;
 import org.apache.geode.management.internal.cli.result.TabularResultData;
 
 public class GatewayCommandsUtils {
@@ -32,15 +26,4 @@ public static void accumulateStartResult(TabularResultData resultData, String me
     resultData.accumulate("Result", Status);
     resultData.accumulate("Message", message);
   }
-
-  static Result handleCommandResultException(CommandResultException crex) {
-    Result result;
-    if (crex.getResult() != null) {
-      result = crex.getResult();
-    } else {
-      LogWrapper.getInstance().warning(CliStrings.GATEWAY_ERROR + CliUtil.stackTraceAsString(crex));
-      result = ResultBuilder.createGemFireErrorResult(CliStrings.GATEWAY_ERROR + crex.getMessage());
-    }
-    return result;
-  }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java
index 5e2f2d809c..449b42a4e1 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java
@@ -17,7 +17,6 @@
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.Collections;
-import java.util.HashSet;
 import java.util.Set;
 
 import org.apache.commons.lang.StringUtils;
@@ -117,32 +116,31 @@ default Gfsh getGfsh() {
     return Gfsh.getCurrentInstance();
   }
 
-  @SuppressWarnings("deprecated")
-  default DistributedMember getMember(final InternalCache cache, final String memberName) {
-    for (final DistributedMember member : getMembers(cache)) {
-      if (memberName.equalsIgnoreCase(member.getName())
-          || memberName.equalsIgnoreCase(member.getId())) {
-        return member;
-      }
+  /**
+   * this either returns a non-null member or throw an exception if member is not found.
+   */
+  default DistributedMember getMember(final String memberName) {
+    DistributedMember member = CliUtil.getDistributedMemberByNameOrId(memberName);
+
+    if (member == null) {
+      throw new MemberNotFoundException(
+          CliStrings.format(CliStrings.MEMBER_NOT_FOUND_ERROR_MESSAGE, memberName));
     }
+    return member;
+  }
 
-    throw new MemberNotFoundException(
-        CliStrings.format(CliStrings.MEMBER_NOT_FOUND_ERROR_MESSAGE, memberName));
+  /**
+   * Gets all members in the GemFire distributed system/cache, including locators
+   */
+  default Set<DistributedMember> getAllMembers(final InternalCache cache) {
+    return CliUtil.getAllMembers(cache);
   }
 
   /**
-   * Gets all members in the GemFire distributed system/cache.
-   *
-   * @param cache the GemFire cache.
-   * @return all members in the GemFire distributed system/cache.
-   * @see org.apache.geode.management.internal.cli.CliUtil#getAllMembers(org.apache.geode.internal.cache.InternalCache)
-   * @deprecated use CliUtil.getAllMembers(org.apache.geode.cache.Cache) instead
+   * Get All members, exclusing locators
    */
-  @Deprecated
-  default Set<DistributedMember> getMembers(final InternalCache cache) {
-    Set<DistributedMember> members = new HashSet<>(cache.getMembers());
-    members.add(cache.getDistributedSystem().getDistributedMember());
-    return members;
+  default Set<DistributedMember> getAllNormalMembers(InternalCache cache) {
+    return CliUtil.getAllNormalMembers(cache);
   }
 
   default Execution getMembersFunctionExecutor(final Set<DistributedMember> members) {
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/HistoryCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/HistoryCommand.java
index aad046b9d9..30bc4b470b 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/HistoryCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/HistoryCommand.java
@@ -27,9 +27,7 @@
 
 import org.apache.geode.management.cli.CliMetaData;
 import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.GfshParser;
-import org.apache.geode.management.internal.cli.LogWrapper;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.result.ErrorResultData;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
@@ -128,14 +126,8 @@ public Result history(
   }
 
   private Result executeClearHistory() {
-    try {
-      Gfsh gfsh = Gfsh.getCurrentInstance();
-      gfsh.clearHistory();
-    } catch (Exception e) {
-      LogWrapper.getInstance().info(CliUtil.stackTraceAsString(e));
-      return ResultBuilder
-          .createGemFireErrorResult("Exception occurred while clearing history " + e.getMessage());
-    }
+    Gfsh gfsh = Gfsh.getCurrentInstance();
+    gfsh.clearHistory();
     return ResultBuilder.createInfoResult(CliStrings.HISTORY__MSG__CLEARED_HISTORY);
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ImportDataCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ImportDataCommand.java
index 7e4f1d70bf..608b888b11 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ImportDataCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ImportDataCommand.java
@@ -57,11 +57,7 @@ public Result importData(
 
     getSecurityService().authorize(Resource.DATA, Operation.WRITE, regionName);
 
-    final DistributedMember targetMember = CliUtil.getDistributedMemberByNameOrId(memberNameOrId);
-    if (targetMember == null) {
-      return ResultBuilder.createUserErrorResult(
-          CliStrings.format(CliStrings.IMPORT_DATA__MEMBER__NOT__FOUND, memberNameOrId));
-    }
+    final DistributedMember targetMember = getMember(memberNameOrId);
 
     Optional<Result> validationResult = validatePath(filePath, dirPath, parallel);
     if (validationResult.isPresent()) {
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListClientCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListClientCommand.java
index c2b6425a99..3f76b2ca9a 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListClientCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListClientCommand.java
@@ -29,7 +29,6 @@
 import org.apache.geode.management.ManagementService;
 import org.apache.geode.management.cli.CliMetaData;
 import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.LogWrapper;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.result.CompositeResultData;
@@ -43,83 +42,75 @@
   @CliMetaData(relatedTopic = {CliStrings.TOPIC_CLIENT})
   @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,
       operation = ResourcePermission.Operation.READ)
-  public Result listClient() {
+  public Result listClient() throws Exception {
     Result result;
+    CompositeResultData compositeResultData = ResultBuilder.createCompositeResultData();
+    CompositeResultData.SectionResultData section = compositeResultData.addSection("section1");
 
-    try {
-      CompositeResultData compositeResultData = ResultBuilder.createCompositeResultData();
-      CompositeResultData.SectionResultData section = compositeResultData.addSection("section1");
+    TabularResultData resultTable = section.addTable("TableForClientList");
+    String headerText = "ClientList";
+    resultTable = resultTable.setHeader(headerText);
 
-      TabularResultData resultTable = section.addTable("TableForClientList");
-      String headerText = "ClientList";
-      resultTable = resultTable.setHeader(headerText);
+    InternalCache cache = getCache();
+    ManagementService service = ManagementService.getExistingManagementService(cache);
+    ObjectName[] cacheServers = service.getDistributedSystemMXBean().listCacheServerObjectNames();
 
-      InternalCache cache = getCache();
-      ManagementService service = ManagementService.getExistingManagementService(cache);
-      ObjectName[] cacheServers = service.getDistributedSystemMXBean().listCacheServerObjectNames();
-
-      if (cacheServers.length == 0) {
-        return ResultBuilder.createGemFireErrorResult(
-            CliStrings.format(CliStrings.LIST_CLIENT_COULD_NOT_RETRIEVE_SERVER_LIST));
-      }
+    if (cacheServers.length == 0) {
+      return ResultBuilder.createGemFireErrorResult(
+          CliStrings.format(CliStrings.LIST_CLIENT_COULD_NOT_RETRIEVE_SERVER_LIST));
+    }
 
-      Map<String, List<String>> clientServerMap = new HashMap<>();
+    Map<String, List<String>> clientServerMap = new HashMap<>();
 
-      for (ObjectName objName : cacheServers) {
-        CacheServerMXBean serverMbean = service.getMBeanInstance(objName, CacheServerMXBean.class);
-        String[] listOfClient = serverMbean.getClientIds();
+    for (ObjectName objName : cacheServers) {
+      CacheServerMXBean serverMbean = service.getMBeanInstance(objName, CacheServerMXBean.class);
+      String[] listOfClient = serverMbean.getClientIds();
 
-        if (listOfClient == null || listOfClient.length == 0) {
-          continue;
-        }
+      if (listOfClient == null || listOfClient.length == 0) {
+        continue;
+      }
 
 
-        for (String clientName : listOfClient) {
-          String serverDetails = "member=" + objName.getKeyProperty("member") + ",port="
-              + objName.getKeyProperty("port");
-          if (clientServerMap.containsKey(clientName)) {
-            List<String> listServers = clientServerMap.get(clientName);
-            listServers.add(serverDetails);
-          } else {
-            List<String> listServer = new ArrayList<>();
-            listServer.add(serverDetails);
-            clientServerMap.put(clientName, listServer);
-          }
+      for (String clientName : listOfClient) {
+        String serverDetails = "member=" + objName.getKeyProperty("member") + ",port="
+            + objName.getKeyProperty("port");
+        if (clientServerMap.containsKey(clientName)) {
+          List<String> listServers = clientServerMap.get(clientName);
+          listServers.add(serverDetails);
+        } else {
+          List<String> listServer = new ArrayList<>();
+          listServer.add(serverDetails);
+          clientServerMap.put(clientName, listServer);
         }
       }
+    }
 
-      if (clientServerMap.size() == 0) {
-        return ResultBuilder.createGemFireErrorResult(
-            CliStrings.format(CliStrings.LIST_COULD_NOT_RETRIEVE_CLIENT_LIST));
-      }
+    if (clientServerMap.size() == 0) {
+      return ResultBuilder.createGemFireErrorResult(
+          CliStrings.format(CliStrings.LIST_COULD_NOT_RETRIEVE_CLIENT_LIST));
+    }
 
-      String memberSeparator = ";  ";
-
-      for (Map.Entry<String, List<String>> pairs : clientServerMap.entrySet()) {
-        String client = pairs.getKey();
-        List<String> servers = pairs.getValue();
-        StringBuilder serverListForClient = new StringBuilder();
-        int serversSize = servers.size();
-        int i = 0;
-        for (String server : servers) {
-          serverListForClient.append(server);
-          if (i < serversSize - 1) {
-            serverListForClient.append(memberSeparator);
-          }
-          i++;
+    String memberSeparator = ";  ";
+
+    for (Map.Entry<String, List<String>> pairs : clientServerMap.entrySet()) {
+      String client = pairs.getKey();
+      List<String> servers = pairs.getValue();
+      StringBuilder serverListForClient = new StringBuilder();
+      int serversSize = servers.size();
+      int i = 0;
+      for (String server : servers) {
+        serverListForClient.append(server);
+        if (i < serversSize - 1) {
+          serverListForClient.append(memberSeparator);
         }
-        resultTable.accumulate(CliStrings.LIST_CLIENT_COLUMN_Clients, client);
-        resultTable.accumulate(CliStrings.LIST_CLIENT_COLUMN_SERVERS,
-            serverListForClient.toString());
+        i++;
       }
-      result = ResultBuilder.buildResult(compositeResultData);
-
-    } catch (Exception e) {
-      LogWrapper.getInstance()
-          .warning("Error in list clients. stack trace" + CliUtil.stackTraceAsString(e));
-      result = ResultBuilder.createGemFireErrorResult(CliStrings
-          .format(CliStrings.LIST_CLIENT_COULD_NOT_RETRIEVE_CLIENT_LIST_0, e.getMessage()));
+      resultTable.accumulate(CliStrings.LIST_CLIENT_COLUMN_Clients, client);
+      resultTable.accumulate(CliStrings.LIST_CLIENT_COLUMN_SERVERS, serverListForClient.toString());
     }
+    result = ResultBuilder.buildResult(compositeResultData);
+
+
 
     LogWrapper.getInstance().info("list client result " + result);
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListGatewayCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListGatewayCommand.java
index 81fa02740d..24b2efd317 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListGatewayCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListGatewayCommand.java
@@ -35,8 +35,6 @@
 import org.apache.geode.management.cli.Result;
 import org.apache.geode.management.internal.MBeanJMXAdapter;
 import org.apache.geode.management.internal.SystemManagementService;
-import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.LogWrapper;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.result.CompositeResultData;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
@@ -55,71 +53,66 @@ public Result listGateway(
           help = CliStrings.LIST_GATEWAY__MEMBER__HELP) String[] onMember,
       @CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},
           optionContext = ConverterHint.MEMBERGROUP,
-          help = CliStrings.LIST_GATEWAY__GROUP__HELP) String[] onGroup) {
+          help = CliStrings.LIST_GATEWAY__GROUP__HELP) String[] onGroup)
+      throws Exception {
 
     Result result;
     InternalCache cache = getCache();
-    try {
-      SystemManagementService service =
-          (SystemManagementService) ManagementService.getExistingManagementService(cache);
+    SystemManagementService service =
+        (SystemManagementService) ManagementService.getExistingManagementService(cache);
 
-      Set<DistributedMember> dsMembers = CliUtil.findMembers(onGroup, onMember);
+    Set<DistributedMember> dsMembers = findMembers(onGroup, onMember);
 
-      if (dsMembers.isEmpty()) {
-        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
-      }
+    if (dsMembers.isEmpty()) {
+      return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    }
 
-      Map<String, Map<String, GatewaySenderMXBean>> gatewaySenderBeans = new TreeMap<>();
-      Map<String, GatewayReceiverMXBean> gatewayReceiverBeans = new TreeMap<>();
+    Map<String, Map<String, GatewaySenderMXBean>> gatewaySenderBeans = new TreeMap<>();
+    Map<String, GatewayReceiverMXBean> gatewayReceiverBeans = new TreeMap<>();
 
-      DistributedSystemMXBean dsMXBean = service.getDistributedSystemMXBean();
-      for (DistributedMember member : dsMembers) {
-        String memberName = member.getName();
-        String memberNameOrId =
-            (memberName != null && !memberName.isEmpty()) ? memberName : member.getId();
-        ObjectName gatewaySenderObjectNames[] =
-            dsMXBean.listGatewaySenderObjectNames(memberNameOrId);
-        // gateway senders : a member can have multiple gateway senders defined
-        // on it
-        if (gatewaySenderObjectNames != null) {
-          for (ObjectName name : gatewaySenderObjectNames) {
-            GatewaySenderMXBean senderBean = service.getMBeanProxy(name, GatewaySenderMXBean.class);
-            if (senderBean != null) {
-              if (gatewaySenderBeans.containsKey(senderBean.getSenderId())) {
-                Map<String, GatewaySenderMXBean> memberToBeanMap =
-                    gatewaySenderBeans.get(senderBean.getSenderId());
-                memberToBeanMap.put(member.getId(), senderBean);
-              } else {
-                Map<String, GatewaySenderMXBean> memberToBeanMap = new TreeMap<>();
-                memberToBeanMap.put(member.getId(), senderBean);
-                gatewaySenderBeans.put(senderBean.getSenderId(), memberToBeanMap);
-              }
+    DistributedSystemMXBean dsMXBean = service.getDistributedSystemMXBean();
+    for (DistributedMember member : dsMembers) {
+      String memberName = member.getName();
+      String memberNameOrId =
+          (memberName != null && !memberName.isEmpty()) ? memberName : member.getId();
+      ObjectName gatewaySenderObjectNames[] = dsMXBean.listGatewaySenderObjectNames(memberNameOrId);
+      // gateway senders : a member can have multiple gateway senders defined
+      // on it
+      if (gatewaySenderObjectNames != null) {
+        for (ObjectName name : gatewaySenderObjectNames) {
+          GatewaySenderMXBean senderBean = service.getMBeanProxy(name, GatewaySenderMXBean.class);
+          if (senderBean != null) {
+            if (gatewaySenderBeans.containsKey(senderBean.getSenderId())) {
+              Map<String, GatewaySenderMXBean> memberToBeanMap =
+                  gatewaySenderBeans.get(senderBean.getSenderId());
+              memberToBeanMap.put(member.getId(), senderBean);
+            } else {
+              Map<String, GatewaySenderMXBean> memberToBeanMap = new TreeMap<>();
+              memberToBeanMap.put(member.getId(), senderBean);
+              gatewaySenderBeans.put(senderBean.getSenderId(), memberToBeanMap);
             }
           }
         }
-        // gateway receivers : a member can have only one gateway receiver
-        ObjectName gatewayReceiverObjectName = MBeanJMXAdapter.getGatewayReceiverMBeanName(member);
-        if (gatewayReceiverObjectName != null) {
-          GatewayReceiverMXBean receiverBean;
-          receiverBean =
-              service.getMBeanProxy(gatewayReceiverObjectName, GatewayReceiverMXBean.class);
-          if (receiverBean != null) {
-            gatewayReceiverBeans.put(member.getId(), receiverBean);
-          }
-        }
       }
-      if (gatewaySenderBeans.isEmpty() && gatewayReceiverBeans.isEmpty()) {
-        return ResultBuilder
-            .createUserErrorResult(CliStrings.GATEWAYS_ARE_NOT_AVAILABLE_IN_CLUSTER);
+      // gateway receivers : a member can have only one gateway receiver
+      ObjectName gatewayReceiverObjectName = MBeanJMXAdapter.getGatewayReceiverMBeanName(member);
+      if (gatewayReceiverObjectName != null) {
+        GatewayReceiverMXBean receiverBean;
+        receiverBean =
+            service.getMBeanProxy(gatewayReceiverObjectName, GatewayReceiverMXBean.class);
+        if (receiverBean != null) {
+          gatewayReceiverBeans.put(member.getId(), receiverBean);
+        }
       }
-      CompositeResultData crd = ResultBuilder.createCompositeResultData();
-      crd.setHeader(CliStrings.HEADER_GATEWAYS);
-      accumulateListGatewayResult(crd, gatewaySenderBeans, gatewayReceiverBeans);
-      result = ResultBuilder.buildResult(crd);
-    } catch (Exception e) {
-      LogWrapper.getInstance().warning(CliStrings.GATEWAY_ERROR + CliUtil.stackTraceAsString(e));
-      result = ResultBuilder.createGemFireErrorResult(CliStrings.GATEWAY_ERROR + e.getMessage());
     }
+    if (gatewaySenderBeans.isEmpty() && gatewayReceiverBeans.isEmpty()) {
+      return ResultBuilder.createUserErrorResult(CliStrings.GATEWAYS_ARE_NOT_AVAILABLE_IN_CLUSTER);
+    }
+    CompositeResultData crd = ResultBuilder.createCompositeResultData();
+    crd.setHeader(CliStrings.HEADER_GATEWAYS);
+    accumulateListGatewayResult(crd, gatewaySenderBeans, gatewayReceiverBeans);
+    result = ResultBuilder.buildResult(crd);
+
     return result;
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListIndexCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListIndexCommand.java
index 48eee685e7..c5010debd2 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListIndexCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListIndexCommand.java
@@ -103,7 +103,7 @@ private Result toTabularResult(final List<IndexDetails> indexDetailsList,
   }
 
   List<IndexDetails> getIndexListing() {
-    final Execution functionExecutor = getMembersFunctionExecutor(getMembers(getCache()));
+    final Execution functionExecutor = getMembersFunctionExecutor(getAllMembers(getCache()));
 
     if (functionExecutor instanceof AbstractExecution) {
       ((AbstractExecution) functionExecutor).setIgnoreDepartedMembers(true);
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/LoadBalanceGatewaySenderCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/LoadBalanceGatewaySenderCommand.java
index c076ba221a..b091de5d71 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/LoadBalanceGatewaySenderCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/LoadBalanceGatewaySenderCommand.java
@@ -31,7 +31,6 @@
 import org.apache.geode.management.cli.Result;
 import org.apache.geode.management.internal.SystemManagementService;
 import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.LogWrapper;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
 import org.apache.geode.management.internal.cli.result.TabularResultData;
@@ -54,49 +53,43 @@ public Result loadBalanceGatewaySender(@CliOption(key = CliStrings.LOAD_BALANCE_
       senderId = senderId.trim();
     }
 
-    try {
-      InternalCache cache = getCache();
-      SystemManagementService service =
-          (SystemManagementService) ManagementService.getExistingManagementService(cache);
-      TabularResultData resultData = ResultBuilder.createTabularResultData();
-      Set<DistributedMember> dsMembers = CliUtil.getAllNormalMembers(cache);
+    InternalCache cache = getCache();
+    SystemManagementService service =
+        (SystemManagementService) ManagementService.getExistingManagementService(cache);
+    TabularResultData resultData = ResultBuilder.createTabularResultData();
+    Set<DistributedMember> dsMembers = CliUtil.getAllNormalMembers(cache);
 
-      if (dsMembers.isEmpty()) {
-        result = ResultBuilder.createInfoResult(CliStrings.GATEWAY_MSG_MEMBERS_NOT_FOUND);
-      } else {
-        boolean gatewaySenderExists = false;
-        for (DistributedMember member : dsMembers) {
-          GatewaySenderMXBean bean;
-          if (cache.getDistributedSystem().getDistributedMember().getId().equals(member.getId())) {
-            bean = service.getLocalGatewaySenderMXBean(senderId);
-          } else {
-            ObjectName objectName = service.getGatewaySenderMBeanName(member, senderId);
-            bean = service.getMBeanProxy(objectName, GatewaySenderMXBean.class);
-          }
-          if (bean != null) {
-            gatewaySenderExists = true;
-            bean.rebalance();
-            GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
-                CliStrings.GATEWAY_OK,
-                CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_REBALANCED_ON_MEMBER_1, senderId,
-                    member.getId()));
-          } else {
-            GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
-                CliStrings.GATEWAY_ERROR,
-                CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_NOT_AVAILABLE_ON_MEMBER_1,
-                    senderId, member.getId()));
-          }
+    if (dsMembers.isEmpty()) {
+      result = ResultBuilder.createInfoResult(CliStrings.GATEWAY_MSG_MEMBERS_NOT_FOUND);
+    } else {
+      boolean gatewaySenderExists = false;
+      for (DistributedMember member : dsMembers) {
+        GatewaySenderMXBean bean;
+        if (cache.getDistributedSystem().getDistributedMember().getId().equals(member.getId())) {
+          bean = service.getLocalGatewaySenderMXBean(senderId);
+        } else {
+          ObjectName objectName = service.getGatewaySenderMBeanName(member, senderId);
+          bean = service.getMBeanProxy(objectName, GatewaySenderMXBean.class);
         }
-        if (gatewaySenderExists) {
-          result = ResultBuilder.buildResult(resultData);
+        if (bean != null) {
+          gatewaySenderExists = true;
+          bean.rebalance();
+          GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
+              CliStrings.GATEWAY_OK, CliStrings.format(
+                  CliStrings.GATEWAY_SENDER_0_IS_REBALANCED_ON_MEMBER_1, senderId, member.getId()));
         } else {
-          result = ResultBuilder.createInfoResult(CliStrings.format(
-              CliStrings.GATEWAY_SENDER_0_IS_NOT_FOUND_ON_ANY_MEMBER, new Object[] {senderId}));
+          GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
+              CliStrings.GATEWAY_ERROR,
+              CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_NOT_AVAILABLE_ON_MEMBER_1, senderId,
+                  member.getId()));
         }
       }
-    } catch (Exception e) {
-      LogWrapper.getInstance().warning(CliStrings.GATEWAY_ERROR + CliUtil.stackTraceAsString(e));
-      result = ResultBuilder.createGemFireErrorResult(CliStrings.GATEWAY_ERROR + e.getMessage());
+      if (gatewaySenderExists) {
+        result = ResultBuilder.buildResult(resultData);
+      } else {
+        result = ResultBuilder.createInfoResult(CliStrings.format(
+            CliStrings.GATEWAY_SENDER_0_IS_NOT_FOUND_ON_ANY_MEMBER, new Object[] {senderId}));
+      }
     }
 
     return result;
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/LocateEntryCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/LocateEntryCommand.java
index 1d1aa4b4c9..dcccffccf2 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/LocateEntryCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/LocateEntryCommand.java
@@ -49,7 +49,7 @@ public Result locateEntry(
       @CliOption(key = {CliStrings.LOCATE_ENTRY__VALUEKLASS},
           help = CliStrings.LOCATE_ENTRY__VALUEKLASS__HELP) String valueClass,
       @CliOption(key = {CliStrings.LOCATE_ENTRY__RECURSIVE},
-          help = CliStrings.LOCATE_ENTRY__RECURSIVE__HELP,
+          help = CliStrings.LOCATE_ENTRY__RECURSIVE__HELP, specifiedDefaultValue = "true",
           unspecifiedDefaultValue = "false") boolean recursive) {
 
     getSecurityService().authorize(Resource.DATA, Operation.READ, regionPath, key);
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/PauseGatewaySenderCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/PauseGatewaySenderCommand.java
index 60124eb376..8ee9e8fcd7 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/PauseGatewaySenderCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/PauseGatewaySenderCommand.java
@@ -30,8 +30,6 @@
 import org.apache.geode.management.cli.ConverterHint;
 import org.apache.geode.management.cli.Result;
 import org.apache.geode.management.internal.SystemManagementService;
-import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.LogWrapper;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
 import org.apache.geode.management.internal.cli.result.TabularResultData;
@@ -61,59 +59,55 @@ public Result pauseGatewaySender(@CliOption(key = CliStrings.PAUSE_GATEWAYSENDER
       senderId = senderId.trim();
     }
 
-    try {
-      InternalCache cache = getCache();
-      SystemManagementService service =
-          (SystemManagementService) ManagementService.getExistingManagementService(cache);
+    InternalCache cache = getCache();
+    SystemManagementService service =
+        (SystemManagementService) ManagementService.getExistingManagementService(cache);
 
-      GatewaySenderMXBean bean;
+    GatewaySenderMXBean bean;
 
-      TabularResultData resultData = ResultBuilder.createTabularResultData();
+    TabularResultData resultData = ResultBuilder.createTabularResultData();
 
-      Set<DistributedMember> dsMembers = CliUtil.findMembers(onGroup, onMember);
+    Set<DistributedMember> dsMembers = findMembers(onGroup, onMember);
 
-      if (dsMembers.isEmpty()) {
-        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
-      }
+    if (dsMembers.isEmpty()) {
+      return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    }
 
-      for (DistributedMember member : dsMembers) {
-        if (cache.getDistributedSystem().getDistributedMember().getId().equals(member.getId())) {
-          bean = service.getLocalGatewaySenderMXBean(senderId);
-        } else {
-          ObjectName objectName = service.getGatewaySenderMBeanName(member, senderId);
-          bean = service.getMBeanProxy(objectName, GatewaySenderMXBean.class);
-        }
-        if (bean != null) {
-          if (bean.isRunning()) {
-            if (bean.isPaused()) {
-              GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
-                  CliStrings.GATEWAY_ERROR,
-                  CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_ALREADY_PAUSED_ON_MEMBER_1,
-                      senderId, member.getId()));
-            } else {
-              bean.pause();
-              GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
-                  CliStrings.GATEWAY_OK, CliStrings.format(
-                      CliStrings.GATEWAY_SENDER_0_IS_PAUSED_ON_MEMBER_1, senderId, member.getId()));
-            }
-          } else {
+    for (DistributedMember member : dsMembers) {
+      if (cache.getDistributedSystem().getDistributedMember().getId().equals(member.getId())) {
+        bean = service.getLocalGatewaySenderMXBean(senderId);
+      } else {
+        ObjectName objectName = service.getGatewaySenderMBeanName(member, senderId);
+        bean = service.getMBeanProxy(objectName, GatewaySenderMXBean.class);
+      }
+      if (bean != null) {
+        if (bean.isRunning()) {
+          if (bean.isPaused()) {
             GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
                 CliStrings.GATEWAY_ERROR,
-                CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_NOT_RUNNING_ON_MEMBER_1, senderId,
-                    member.getId()));
+                CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_ALREADY_PAUSED_ON_MEMBER_1,
+                    senderId, member.getId()));
+          } else {
+            bean.pause();
+            GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
+                CliStrings.GATEWAY_OK, CliStrings.format(
+                    CliStrings.GATEWAY_SENDER_0_IS_PAUSED_ON_MEMBER_1, senderId, member.getId()));
           }
         } else {
           GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
               CliStrings.GATEWAY_ERROR,
-              CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_NOT_AVAILABLE_ON_MEMBER_1, senderId,
+              CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_NOT_RUNNING_ON_MEMBER_1, senderId,
                   member.getId()));
         }
+      } else {
+        GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
+            CliStrings.GATEWAY_ERROR,
+            CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_NOT_AVAILABLE_ON_MEMBER_1, senderId,
+                member.getId()));
       }
-      result = ResultBuilder.buildResult(resultData);
-    } catch (Exception e) {
-      LogWrapper.getInstance().warning(CliStrings.GATEWAY_ERROR + CliUtil.stackTraceAsString(e));
-      result = ResultBuilder.createGemFireErrorResult(CliStrings.GATEWAY_ERROR + e.getMessage());
     }
+    result = ResultBuilder.buildResult(resultData);
+
     return result;
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/PutCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/PutCommand.java
index ca167a9b97..af35e7c521 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/PutCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/PutCommand.java
@@ -53,7 +53,7 @@ public Result put(
       @CliOption(key = {CliStrings.PUT__VALUEKLASS},
           help = CliStrings.PUT__VALUEKLASS__HELP) String valueClass,
       @CliOption(key = {CliStrings.PUT__PUTIFABSENT}, help = CliStrings.PUT__PUTIFABSENT__HELP,
-          unspecifiedDefaultValue = "false") boolean putIfAbsent) {
+          specifiedDefaultValue = "true", unspecifiedDefaultValue = "false") boolean putIfAbsent) {
 
     InternalCache cache = getCache();
     cache.getSecurityService().authorize(Resource.DATA, Operation.WRITE, regionPath);
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ResumeGatewaySenderCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ResumeGatewaySenderCommand.java
index b6a49c9357..3407027808 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ResumeGatewaySenderCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ResumeGatewaySenderCommand.java
@@ -31,7 +31,6 @@
 import org.apache.geode.management.cli.Result;
 import org.apache.geode.management.internal.SystemManagementService;
 import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.LogWrapper;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
 import org.apache.geode.management.internal.cli.result.TabularResultData;
@@ -60,60 +59,55 @@ public Result resumeGatewaySender(@CliOption(key = CliStrings.RESUME_GATEWAYSEND
       senderId = senderId.trim();
     }
 
-    try {
-      InternalCache cache = getCache();
-      SystemManagementService service =
-          (SystemManagementService) ManagementService.getExistingManagementService(cache);
+    InternalCache cache = getCache();
+    SystemManagementService service =
+        (SystemManagementService) ManagementService.getExistingManagementService(cache);
 
-      GatewaySenderMXBean bean;
+    GatewaySenderMXBean bean;
 
-      TabularResultData resultData = ResultBuilder.createTabularResultData();
+    TabularResultData resultData = ResultBuilder.createTabularResultData();
 
-      Set<DistributedMember> dsMembers = CliUtil.findMembers(onGroup, onMember);
+    Set<DistributedMember> dsMembers = CliUtil.findMembers(onGroup, onMember);
 
-      if (dsMembers.isEmpty()) {
-        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
-      }
+    if (dsMembers.isEmpty()) {
+      return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    }
 
-      for (DistributedMember member : dsMembers) {
-        if (cache.getDistributedSystem().getDistributedMember().getId().equals(member.getId())) {
-          bean = service.getLocalGatewaySenderMXBean(senderId);
-        } else {
-          ObjectName objectName = service.getGatewaySenderMBeanName(member, senderId);
-          bean = service.getMBeanProxy(objectName, GatewaySenderMXBean.class);
-        }
-        if (bean != null) {
-          if (bean.isRunning()) {
-            if (bean.isPaused()) {
-              bean.resume();
-              GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
-                  CliStrings.GATEWAY_OK,
-                  CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_RESUMED_ON_MEMBER_1, senderId,
-                      member.getId()));
-            } else {
-              GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
-                  CliStrings.GATEWAY_ERROR,
-                  CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_NOT_PAUSED_ON_MEMBER_1, senderId,
-                      member.getId()));
-            }
+    for (DistributedMember member : dsMembers) {
+      if (cache.getDistributedSystem().getDistributedMember().getId().equals(member.getId())) {
+        bean = service.getLocalGatewaySenderMXBean(senderId);
+      } else {
+        ObjectName objectName = service.getGatewaySenderMBeanName(member, senderId);
+        bean = service.getMBeanProxy(objectName, GatewaySenderMXBean.class);
+      }
+      if (bean != null) {
+        if (bean.isRunning()) {
+          if (bean.isPaused()) {
+            bean.resume();
+            GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
+                CliStrings.GATEWAY_OK, CliStrings.format(
+                    CliStrings.GATEWAY_SENDER_0_IS_RESUMED_ON_MEMBER_1, senderId, member.getId()));
           } else {
             GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
                 CliStrings.GATEWAY_ERROR,
-                CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_NOT_RUNNING_ON_MEMBER_1, senderId,
+                CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_NOT_PAUSED_ON_MEMBER_1, senderId,
                     member.getId()));
           }
         } else {
           GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
               CliStrings.GATEWAY_ERROR,
-              CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_NOT_AVAILABLE_ON_MEMBER_1, senderId,
+              CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_NOT_RUNNING_ON_MEMBER_1, senderId,
                   member.getId()));
         }
+      } else {
+        GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
+            CliStrings.GATEWAY_ERROR,
+            CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_NOT_AVAILABLE_ON_MEMBER_1, senderId,
+                member.getId()));
       }
-      result = ResultBuilder.buildResult(resultData);
-    } catch (Exception e) {
-      LogWrapper.getInstance().warning(CliStrings.GATEWAY_ERROR + CliUtil.stackTraceAsString(e));
-      result = ResultBuilder.createGemFireErrorResult(CliStrings.GATEWAY_ERROR + e.getMessage());
     }
+    result = ResultBuilder.buildResult(resultData);
+
     return result;
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ShowLogCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ShowLogCommand.java
index 9694ad2e53..07014694ea 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ShowLogCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ShowLogCommand.java
@@ -29,7 +29,6 @@
 import org.apache.geode.management.cli.Result;
 import org.apache.geode.management.internal.ManagementConstants;
 import org.apache.geode.management.internal.SystemManagementService;
-import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.result.ErrorResultData;
 import org.apache.geode.management.internal.cli.result.InfoResultData;
@@ -48,47 +47,33 @@ public Result showLog(
       @CliOption(key = CliStrings.SHOW_LOG_LINE_NUM, unspecifiedDefaultValue = "0",
           help = CliStrings.SHOW_LOG_LINE_NUM_HELP) int numberOfLines) {
     Result result;
-    try {
-      InternalCache cache = getCache();
 
-      DistributedMember targetMember = CliUtil.getDistributedMemberByNameOrId(memberNameOrId);
-      if (targetMember == null) {
-        ErrorResultData errorResultData =
-            ResultBuilder.createErrorResultData().setErrorCode(ResultBuilder.ERRORCODE_DEFAULT)
-                .addLine(memberNameOrId + " " + CliStrings.SHOW_LOG_MSG_MEMBER_NOT_FOUND);
-        return (ResultBuilder.buildResult(errorResultData));
-      }
-
-      MemberMXBean targetMemberMXBean = getMemberMxBean(cache, targetMember);
+    InternalCache cache = getCache();
+    DistributedMember targetMember = getMember(memberNameOrId);
+    MemberMXBean targetMemberMXBean = getMemberMxBean(cache, targetMember);
 
-      if (numberOfLines > ManagementConstants.MAX_SHOW_LOG_LINES) {
-        numberOfLines = ManagementConstants.MAX_SHOW_LOG_LINES;
-      }
-      if (numberOfLines == 0 || numberOfLines < 0) {
-        numberOfLines = ManagementConstants.DEFAULT_SHOW_LOG_LINES;
-      }
-      InfoResultData resultData = ResultBuilder.createInfoResultData();
-      if (targetMemberMXBean != null) {
-        String log = targetMemberMXBean.showLog(numberOfLines);
-        if (log != null) {
-          resultData.addLine(log);
-        } else {
-          resultData.addLine(CliStrings.SHOW_LOG_NO_LOG);
-        }
+    if (numberOfLines > ManagementConstants.MAX_SHOW_LOG_LINES) {
+      numberOfLines = ManagementConstants.MAX_SHOW_LOG_LINES;
+    }
+    if (numberOfLines == 0 || numberOfLines < 0) {
+      numberOfLines = ManagementConstants.DEFAULT_SHOW_LOG_LINES;
+    }
+    InfoResultData resultData = ResultBuilder.createInfoResultData();
+    if (targetMemberMXBean != null) {
+      String log = targetMemberMXBean.showLog(numberOfLines);
+      if (log != null) {
+        resultData.addLine(log);
       } else {
-        ErrorResultData errorResultData =
-            ResultBuilder.createErrorResultData().setErrorCode(ResultBuilder.ERRORCODE_DEFAULT)
-                .addLine(memberNameOrId + CliStrings.SHOW_LOG_MSG_MEMBER_NOT_FOUND);
-        return (ResultBuilder.buildResult(errorResultData));
+        resultData.addLine(CliStrings.SHOW_LOG_NO_LOG);
       }
-
-      result = ResultBuilder.buildResult(resultData);
-
-    } catch (Exception e) {
-      result = ResultBuilder
-          .createGemFireErrorResult(CliStrings.SHOW_LOG_ERROR + CliUtil.stackTraceAsString(e));
+    } else {
+      ErrorResultData errorResultData =
+          ResultBuilder.createErrorResultData().setErrorCode(ResultBuilder.ERRORCODE_DEFAULT)
+              .addLine(memberNameOrId + CliStrings.SHOW_LOG_MSG_MEMBER_NOT_FOUND);
+      return (ResultBuilder.buildResult(errorResultData));
     }
-    return result;
+
+    return ResultBuilder.buildResult(resultData);
   }
 
   public MemberMXBean getMemberMxBean(InternalCache cache, DistributedMember targetMember) {
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ShowMetricsCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ShowMetricsCommand.java
index 74f88ce53e..6783925533 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ShowMetricsCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ShowMetricsCommand.java
@@ -43,7 +43,6 @@
 import org.apache.geode.management.internal.MBeanJMXAdapter;
 import org.apache.geode.management.internal.SystemManagementService;
 import org.apache.geode.management.internal.cli.AbstractCliAroundInterceptor;
-import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.GfshParseResult;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.result.CompositeResultData;
@@ -78,11 +77,7 @@ public Result showMetrics(
     Result result;
     DistributedMember member = null;
     if (memberNameOrId != null) {
-      member = CliUtil.getDistributedMemberByNameOrId(memberNameOrId);
-      if (member == null) {
-        return ResultBuilder.createGemFireErrorResult(
-            CliStrings.format(CliStrings.MEMBER_NOT_FOUND_ERROR_MESSAGE, memberNameOrId));
-      }
+      member = getMember(memberNameOrId);
     }
 
     if (regionName != null) {
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ShutdownCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ShutdownCommand.java
index 3ed8b406ad..3c71bd1650 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ShutdownCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ShutdownCommand.java
@@ -63,7 +63,6 @@ public Result shutdown(
           specifiedDefaultValue = "true",
           help = CliStrings.INCLUDE_LOCATORS_HELP) boolean shutdownLocators) {
     try {
-
       if (userSpecifiedTimeout < Integer.parseInt(DEFAULT_TIME_OUT)) {
         return ResultBuilder.createInfoResult(CliStrings.SHUTDOWN__MSG__IMPROPER_TIMEOUT);
       }
@@ -82,7 +81,7 @@ public Result shutdown(
 
       String managerName = cache.getJmxManagerAdvisor().getDistributionManager().getId().getId();
 
-      final DistributedMember manager = CliUtil.getDistributedMemberByNameOrId(managerName);
+      final DistributedMember manager = getMember(managerName);
 
       dataNodes.remove(manager);
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartGatewayReceiverCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartGatewayReceiverCommand.java
index b3402f5fac..d220374edd 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartGatewayReceiverCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartGatewayReceiverCommand.java
@@ -32,9 +32,7 @@
 import org.apache.geode.management.internal.MBeanJMXAdapter;
 import org.apache.geode.management.internal.SystemManagementService;
 import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.LogWrapper;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
-import org.apache.geode.management.internal.cli.result.CommandResultException;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
 import org.apache.geode.management.internal.cli.result.TabularResultData;
 import org.apache.geode.management.internal.security.ResourceOperation;
@@ -53,47 +51,41 @@ public Result startGatewayReceiver(@CliOption(key = {CliStrings.GROUP, CliString
 
       @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},
           optionContext = ConverterHint.MEMBERIDNAME,
-          help = CliStrings.START_GATEWAYRECEIVER__MEMBER__HELP) String[] onMember) {
+          help = CliStrings.START_GATEWAYRECEIVER__MEMBER__HELP) String[] onMember)
+      throws Exception {
     Result result;
 
-    try {
-      InternalCache cache = getCache();
-      SystemManagementService service =
-          (SystemManagementService) ManagementService.getExistingManagementService(cache);
+    InternalCache cache = getCache();
+    SystemManagementService service =
+        (SystemManagementService) ManagementService.getExistingManagementService(cache);
 
-      GatewayReceiverMXBean receiverBean;
+    GatewayReceiverMXBean receiverBean;
 
-      TabularResultData resultData = ResultBuilder.createTabularResultData();
+    TabularResultData resultData = ResultBuilder.createTabularResultData();
 
-      Set<DistributedMember> dsMembers = CliUtil.findMembers(onGroup, onMember);
+    Set<DistributedMember> dsMembers = CliUtil.findMembers(onGroup, onMember);
 
-      if (dsMembers.isEmpty()) {
-        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
-      }
+    if (dsMembers.isEmpty()) {
+      return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    }
 
-      for (DistributedMember member : dsMembers) {
-        ObjectName gatewayReceiverObjectName = MBeanJMXAdapter.getGatewayReceiverMBeanName(member);
-
-        if (gatewayReceiverObjectName != null) {
-          receiverBean =
-              service.getMBeanProxy(gatewayReceiverObjectName, GatewayReceiverMXBean.class);
-          if (receiverBean != null) {
-            if (receiverBean.isRunning()) {
-              GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
-                  CliStrings.GATEWAY_ERROR,
-                  CliStrings.format(CliStrings.GATEWAY_RECEIVER_IS_ALREADY_STARTED_ON_MEMBER_0,
-                      new Object[] {member.getId()}));
-            } else {
-              receiverBean.start();
-              GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
-                  CliStrings.GATEWAY_OK,
-                  CliStrings.format(CliStrings.GATEWAY_RECEIVER_IS_STARTED_ON_MEMBER_0,
-                      new Object[] {member.getId()}));
-            }
-          } else {
+    for (DistributedMember member : dsMembers) {
+      ObjectName gatewayReceiverObjectName = MBeanJMXAdapter.getGatewayReceiverMBeanName(member);
+
+      if (gatewayReceiverObjectName != null) {
+        receiverBean =
+            service.getMBeanProxy(gatewayReceiverObjectName, GatewayReceiverMXBean.class);
+        if (receiverBean != null) {
+          if (receiverBean.isRunning()) {
             GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
                 CliStrings.GATEWAY_ERROR,
-                CliStrings.format(CliStrings.GATEWAY_RECEIVER_IS_NOT_AVAILABLE_ON_MEMBER_0,
+                CliStrings.format(CliStrings.GATEWAY_RECEIVER_IS_ALREADY_STARTED_ON_MEMBER_0,
+                    new Object[] {member.getId()}));
+          } else {
+            receiverBean.start();
+            GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
+                CliStrings.GATEWAY_OK,
+                CliStrings.format(CliStrings.GATEWAY_RECEIVER_IS_STARTED_ON_MEMBER_0,
                     new Object[] {member.getId()}));
           }
         } else {
@@ -102,14 +94,15 @@ public Result startGatewayReceiver(@CliOption(key = {CliStrings.GROUP, CliString
               CliStrings.format(CliStrings.GATEWAY_RECEIVER_IS_NOT_AVAILABLE_ON_MEMBER_0,
                   new Object[] {member.getId()}));
         }
+      } else {
+        GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
+            CliStrings.GATEWAY_ERROR,
+            CliStrings.format(CliStrings.GATEWAY_RECEIVER_IS_NOT_AVAILABLE_ON_MEMBER_0,
+                new Object[] {member.getId()}));
       }
-      result = ResultBuilder.buildResult(resultData);
-    } catch (CommandResultException crex) {
-      result = GatewayCommandsUtils.handleCommandResultException(crex);
-    } catch (Exception e) {
-      LogWrapper.getInstance().warning(CliStrings.GATEWAY_ERROR + CliUtil.stackTraceAsString(e));
-      result = ResultBuilder.createGemFireErrorResult(CliStrings.GATEWAY_ERROR + e.getMessage());
     }
+    result = ResultBuilder.buildResult(resultData);
+
     return result;
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartGatewaySenderCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartGatewaySenderCommand.java
index 986260ab23..7ea8b075bf 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartGatewaySenderCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartGatewaySenderCommand.java
@@ -40,8 +40,6 @@
 import org.apache.geode.management.cli.ConverterHint;
 import org.apache.geode.management.cli.Result;
 import org.apache.geode.management.internal.SystemManagementService;
-import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.LogWrapper;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
 import org.apache.geode.management.internal.cli.result.TabularResultData;
@@ -69,99 +67,94 @@ public Result startGatewaySender(@CliOption(key = CliStrings.START_GATEWAYSENDER
     Result result;
     final String id = senderId.trim();
 
-    try {
-      final InternalCache cache = getCache();
-      final SystemManagementService service =
-          (SystemManagementService) ManagementService.getExistingManagementService(cache);
+    final InternalCache cache = getCache();
+    final SystemManagementService service =
+        (SystemManagementService) ManagementService.getExistingManagementService(cache);
 
-      TabularResultData resultData = ResultBuilder.createTabularResultData();
+    TabularResultData resultData = ResultBuilder.createTabularResultData();
 
-      Set<DistributedMember> dsMembers = CliUtil.findMembers(onGroup, onMember);
+    Set<DistributedMember> dsMembers = findMembers(onGroup, onMember);
 
-      if (dsMembers.isEmpty()) {
-        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
-      }
+    if (dsMembers.isEmpty()) {
+      return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    }
 
-      ExecutorService execService = Executors.newCachedThreadPool(new ThreadFactory() {
-        AtomicInteger threadNum = new AtomicInteger();
+    ExecutorService execService = Executors.newCachedThreadPool(new ThreadFactory() {
+      AtomicInteger threadNum = new AtomicInteger();
 
-        public Thread newThread(final Runnable r) {
-          Thread result =
-              new Thread(r, "Start Sender Command Thread " + threadNum.incrementAndGet());
-          result.setDaemon(true);
-          return result;
-        }
-      });
+      public Thread newThread(final Runnable r) {
+        Thread result = new Thread(r, "Start Sender Command Thread " + threadNum.incrementAndGet());
+        result.setDaemon(true);
+        return result;
+      }
+    });
 
-      List<Callable<List>> callables = new ArrayList<>();
+    List<Callable<List>> callables = new ArrayList<>();
 
-      for (final DistributedMember member : dsMembers) {
+    for (final DistributedMember member : dsMembers) {
 
-        callables.add(() -> {
+      callables.add(() -> {
 
-          GatewaySenderMXBean bean;
-          ArrayList<String> statusList = new ArrayList<>();
-          if (cache.getDistributedSystem().getDistributedMember().getId().equals(member.getId())) {
-            bean = service.getLocalGatewaySenderMXBean(id);
-          } else {
-            ObjectName objectName = service.getGatewaySenderMBeanName(member, id);
-            bean = service.getMBeanProxy(objectName, GatewaySenderMXBean.class);
-          }
-          if (bean != null) {
-            if (bean.isRunning()) {
-              statusList.add(member.getId());
-              statusList.add(CliStrings.GATEWAY_ERROR);
-              statusList.add(CliStrings.format(
-                  CliStrings.GATEWAY_SENDER_0_IS_ALREADY_STARTED_ON_MEMBER_1, id, member.getId()));
-            } else {
-              bean.start();
-              statusList.add(member.getId());
-              statusList.add(CliStrings.GATEWAY_OK);
-              statusList.add(CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_STARTED_ON_MEMBER_1,
-                  id, member.getId()));
-            }
-          } else {
+        GatewaySenderMXBean bean;
+        ArrayList<String> statusList = new ArrayList<>();
+        if (cache.getDistributedSystem().getDistributedMember().getId().equals(member.getId())) {
+          bean = service.getLocalGatewaySenderMXBean(id);
+        } else {
+          ObjectName objectName = service.getGatewaySenderMBeanName(member, id);
+          bean = service.getMBeanProxy(objectName, GatewaySenderMXBean.class);
+        }
+        if (bean != null) {
+          if (bean.isRunning()) {
             statusList.add(member.getId());
             statusList.add(CliStrings.GATEWAY_ERROR);
             statusList.add(CliStrings.format(
-                CliStrings.GATEWAY_SENDER_0_IS_NOT_AVAILABLE_ON_MEMBER_1, id, member.getId()));
+                CliStrings.GATEWAY_SENDER_0_IS_ALREADY_STARTED_ON_MEMBER_1, id, member.getId()));
+          } else {
+            bean.start();
+            statusList.add(member.getId());
+            statusList.add(CliStrings.GATEWAY_OK);
+            statusList.add(CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_STARTED_ON_MEMBER_1, id,
+                member.getId()));
           }
-          return statusList;
+        } else {
+          statusList.add(member.getId());
+          statusList.add(CliStrings.GATEWAY_ERROR);
+          statusList.add(CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_NOT_AVAILABLE_ON_MEMBER_1,
+              id, member.getId()));
+        }
+        return statusList;
 
-        });
-      }
+      });
+    }
 
-      Iterator<DistributedMember> memberIterator = dsMembers.iterator();
-      List<Future<List>> futures = null;
+    Iterator<DistributedMember> memberIterator = dsMembers.iterator();
+    List<Future<List>> futures = null;
 
-      try {
-        futures = execService.invokeAll(callables);
-      } catch (InterruptedException ite) {
-        GatewayCommandsUtils.accumulateStartResult(resultData, null, CliStrings.GATEWAY_ERROR,
-            CliStrings.format(CliStrings.GATEWAY_SENDER_0_COULD_NOT_BE_INVOKED_DUE_TO_1, id,
-                ite.getMessage()));
-      }
+    try {
+      futures = execService.invokeAll(callables);
+    } catch (InterruptedException ite) {
+      GatewayCommandsUtils.accumulateStartResult(resultData, null, CliStrings.GATEWAY_ERROR,
+          CliStrings.format(CliStrings.GATEWAY_SENDER_0_COULD_NOT_BE_INVOKED_DUE_TO_1, id,
+              ite.getMessage()));
+    }
 
-      for (Future<List> future : futures) {
-        DistributedMember member = memberIterator.next();
-        List<String> memberStatus;
-        try {
-          memberStatus = future.get();
-          GatewayCommandsUtils.accumulateStartResult(resultData, memberStatus.get(0),
-              memberStatus.get(1), memberStatus.get(2));
-        } catch (InterruptedException | ExecutionException ite) {
-          GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
-              CliStrings.GATEWAY_ERROR,
-              CliStrings.format(CliStrings.GATEWAY_SENDER_0_COULD_NOT_BE_STARTED_ON_MEMBER_DUE_TO_1,
-                  id, ite.getMessage()));
-        }
+    for (Future<List> future : futures) {
+      DistributedMember member = memberIterator.next();
+      List<String> memberStatus;
+      try {
+        memberStatus = future.get();
+        GatewayCommandsUtils.accumulateStartResult(resultData, memberStatus.get(0),
+            memberStatus.get(1), memberStatus.get(2));
+      } catch (InterruptedException | ExecutionException ite) {
+        GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
+            CliStrings.GATEWAY_ERROR,
+            CliStrings.format(CliStrings.GATEWAY_SENDER_0_COULD_NOT_BE_STARTED_ON_MEMBER_DUE_TO_1,
+                id, ite.getMessage()));
       }
-      execService.shutdown();
-      result = ResultBuilder.buildResult(resultData);
-    } catch (Exception e) {
-      LogWrapper.getInstance().warning(CliStrings.GATEWAY_ERROR + CliUtil.stackTraceAsString(e));
-      result = ResultBuilder.createGemFireErrorResult(CliStrings.GATEWAY_ERROR + e.getMessage());
     }
+    execService.shutdown();
+    result = ResultBuilder.buildResult(resultData);
+
     return result;
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StatusGatewayReceiverCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StatusGatewayReceiverCommand.java
index c1fdaafb4d..a8829d3085 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StatusGatewayReceiverCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StatusGatewayReceiverCommand.java
@@ -32,7 +32,6 @@
 import org.apache.geode.management.internal.MBeanJMXAdapter;
 import org.apache.geode.management.internal.SystemManagementService;
 import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.LogWrapper;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.result.CompositeResultData;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
@@ -56,43 +55,39 @@ public Result statusGatewayReceiver(@CliOption(key = {CliStrings.GROUP, CliStrin
 
     Result result;
 
-    try {
-      InternalCache cache = getCache();
-      SystemManagementService service =
-          (SystemManagementService) ManagementService.getExistingManagementService(cache);
+    InternalCache cache = getCache();
+    SystemManagementService service =
+        (SystemManagementService) ManagementService.getExistingManagementService(cache);
 
-      CompositeResultData crd = ResultBuilder.createCompositeResultData();
-      TabularResultData availableReceiverData =
-          crd.addSection(CliStrings.SECTION_GATEWAY_RECEIVER_AVAILABLE)
-              .addTable(CliStrings.TABLE_GATEWAY_RECEIVER);
+    CompositeResultData crd = ResultBuilder.createCompositeResultData();
+    TabularResultData availableReceiverData =
+        crd.addSection(CliStrings.SECTION_GATEWAY_RECEIVER_AVAILABLE)
+            .addTable(CliStrings.TABLE_GATEWAY_RECEIVER);
 
-      TabularResultData notAvailableReceiverData =
-          crd.addSection(CliStrings.SECTION_GATEWAY_RECEIVER_NOT_AVAILABLE)
-              .addTable(CliStrings.TABLE_GATEWAY_RECEIVER);
+    TabularResultData notAvailableReceiverData =
+        crd.addSection(CliStrings.SECTION_GATEWAY_RECEIVER_NOT_AVAILABLE)
+            .addTable(CliStrings.TABLE_GATEWAY_RECEIVER);
 
-      Set<DistributedMember> dsMembers = CliUtil.findMembers(onGroup, onMember);
+    Set<DistributedMember> dsMembers = CliUtil.findMembers(onGroup, onMember);
 
-      if (dsMembers.isEmpty()) {
-        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
-      }
+    if (dsMembers.isEmpty()) {
+      return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    }
 
-      for (DistributedMember member : dsMembers) {
-        ObjectName gatewayReceiverObjectName = MBeanJMXAdapter.getGatewayReceiverMBeanName(member);
-        if (gatewayReceiverObjectName != null) {
-          GatewayReceiverMXBean receiverBean =
-              service.getMBeanProxy(gatewayReceiverObjectName, GatewayReceiverMXBean.class);
-          if (receiverBean != null) {
-            buildReceiverStatus(member.getId(), receiverBean, availableReceiverData);
-            continue;
-          }
+    for (DistributedMember member : dsMembers) {
+      ObjectName gatewayReceiverObjectName = MBeanJMXAdapter.getGatewayReceiverMBeanName(member);
+      if (gatewayReceiverObjectName != null) {
+        GatewayReceiverMXBean receiverBean =
+            service.getMBeanProxy(gatewayReceiverObjectName, GatewayReceiverMXBean.class);
+        if (receiverBean != null) {
+          buildReceiverStatus(member.getId(), receiverBean, availableReceiverData);
+          continue;
         }
-        buildReceiverStatus(member.getId(), null, notAvailableReceiverData);
       }
-      result = ResultBuilder.buildResult(crd);
-    } catch (Exception e) {
-      LogWrapper.getInstance().warning(CliStrings.GATEWAY_ERROR + CliUtil.stackTraceAsString(e));
-      result = ResultBuilder.createGemFireErrorResult(CliStrings.GATEWAY_ERROR + e.getMessage());
+      buildReceiverStatus(member.getId(), null, notAvailableReceiverData);
     }
+    result = ResultBuilder.buildResult(crd);
+
     return result;
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StatusGatewaySenderCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StatusGatewaySenderCommand.java
index f694705cb8..c0ce5d8d5d 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StatusGatewaySenderCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StatusGatewaySenderCommand.java
@@ -31,7 +31,6 @@
 import org.apache.geode.management.cli.Result;
 import org.apache.geode.management.internal.SystemManagementService;
 import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.LogWrapper;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.result.CompositeResultData;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
@@ -60,46 +59,42 @@ public Result statusGatewaySender(@CliOption(key = CliStrings.STATUS_GATEWAYSEND
     if (senderId != null) {
       senderId = senderId.trim();
     }
-    try {
-      InternalCache cache = getCache();
-      SystemManagementService service =
-          (SystemManagementService) ManagementService.getExistingManagementService(cache);
 
-      GatewaySenderMXBean bean;
+    InternalCache cache = getCache();
+    SystemManagementService service =
+        (SystemManagementService) ManagementService.getExistingManagementService(cache);
 
-      CompositeResultData crd = ResultBuilder.createCompositeResultData();
-      TabularResultData availableSenderData =
-          crd.addSection(CliStrings.SECTION_GATEWAY_SENDER_AVAILABLE)
-              .addTable(CliStrings.TABLE_GATEWAY_SENDER);
+    GatewaySenderMXBean bean;
 
-      TabularResultData notAvailableSenderData =
-          crd.addSection(CliStrings.SECTION_GATEWAY_SENDER_NOT_AVAILABLE)
-              .addTable(CliStrings.TABLE_GATEWAY_SENDER);
+    CompositeResultData crd = ResultBuilder.createCompositeResultData();
+    TabularResultData availableSenderData =
+        crd.addSection(CliStrings.SECTION_GATEWAY_SENDER_AVAILABLE)
+            .addTable(CliStrings.TABLE_GATEWAY_SENDER);
 
-      Set<DistributedMember> dsMembers = CliUtil.findMembers(onGroup, onMember);
+    TabularResultData notAvailableSenderData =
+        crd.addSection(CliStrings.SECTION_GATEWAY_SENDER_NOT_AVAILABLE)
+            .addTable(CliStrings.TABLE_GATEWAY_SENDER);
 
-      if (dsMembers.isEmpty()) {
-        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
-      }
+    Set<DistributedMember> dsMembers = CliUtil.findMembers(onGroup, onMember);
 
-      for (DistributedMember member : dsMembers) {
-        if (cache.getDistributedSystem().getDistributedMember().getId().equals(member.getId())) {
-          bean = service.getLocalGatewaySenderMXBean(senderId);
-        } else {
-          ObjectName objectName = service.getGatewaySenderMBeanName(member, senderId);
-          bean = service.getMBeanProxy(objectName, GatewaySenderMXBean.class);
-        }
-        if (bean != null) {
-          buildSenderStatus(member.getId(), bean, availableSenderData);
-        } else {
-          buildSenderStatus(member.getId(), bean, notAvailableSenderData);
-        }
+    if (dsMembers.isEmpty()) {
+      return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    }
+
+    for (DistributedMember member : dsMembers) {
+      if (cache.getDistributedSystem().getDistributedMember().getId().equals(member.getId())) {
+        bean = service.getLocalGatewaySenderMXBean(senderId);
+      } else {
+        ObjectName objectName = service.getGatewaySenderMBeanName(member, senderId);
+        bean = service.getMBeanProxy(objectName, GatewaySenderMXBean.class);
+      }
+      if (bean != null) {
+        buildSenderStatus(member.getId(), bean, availableSenderData);
+      } else {
+        buildSenderStatus(member.getId(), bean, notAvailableSenderData);
       }
-      result = ResultBuilder.buildResult(crd);
-    } catch (Exception e) {
-      LogWrapper.getInstance().warning(CliStrings.GATEWAY_ERROR + CliUtil.stackTraceAsString(e));
-      result = ResultBuilder.createGemFireErrorResult(CliStrings.GATEWAY_ERROR + e.getMessage());
     }
+    result = ResultBuilder.buildResult(crd);
     return result;
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StopGatewayReceiverCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StopGatewayReceiverCommand.java
index 49b2454bb7..e183b20c43 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StopGatewayReceiverCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StopGatewayReceiverCommand.java
@@ -32,9 +32,7 @@
 import org.apache.geode.management.internal.MBeanJMXAdapter;
 import org.apache.geode.management.internal.SystemManagementService;
 import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.LogWrapper;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
-import org.apache.geode.management.internal.cli.result.CommandResultException;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
 import org.apache.geode.management.internal.cli.result.TabularResultData;
 import org.apache.geode.management.internal.security.ResourceOperation;
@@ -51,48 +49,42 @@ public Result stopGatewayReceiver(@CliOption(key = {CliStrings.GROUP, CliStrings
 
       @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},
           optionContext = ConverterHint.MEMBERIDNAME,
-          help = CliStrings.STOP_GATEWAYRECEIVER__MEMBER__HELP) String[] onMember) {
+          help = CliStrings.STOP_GATEWAYRECEIVER__MEMBER__HELP) String[] onMember)
+      throws Exception {
 
     Result result;
 
-    try {
-      InternalCache cache = getCache();
-      SystemManagementService service =
-          (SystemManagementService) ManagementService.getExistingManagementService(cache);
+    InternalCache cache = getCache();
+    SystemManagementService service =
+        (SystemManagementService) ManagementService.getExistingManagementService(cache);
 
-      GatewayReceiverMXBean receiverBean;
+    GatewayReceiverMXBean receiverBean;
 
-      TabularResultData resultData = ResultBuilder.createTabularResultData();
+    TabularResultData resultData = ResultBuilder.createTabularResultData();
 
-      Set<DistributedMember> dsMembers = CliUtil.findMembers(onGroup, onMember);
+    Set<DistributedMember> dsMembers = CliUtil.findMembers(onGroup, onMember);
 
-      if (dsMembers.isEmpty()) {
-        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
-      }
+    if (dsMembers.isEmpty()) {
+      return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    }
+
+    for (DistributedMember member : dsMembers) {
+      ObjectName gatewayReceiverObjectName = MBeanJMXAdapter.getGatewayReceiverMBeanName(member);
 
-      for (DistributedMember member : dsMembers) {
-        ObjectName gatewayReceiverObjectName = MBeanJMXAdapter.getGatewayReceiverMBeanName(member);
-
-        if (gatewayReceiverObjectName != null) {
-          receiverBean =
-              service.getMBeanProxy(gatewayReceiverObjectName, GatewayReceiverMXBean.class);
-          if (receiverBean != null) {
-            if (receiverBean.isRunning()) {
-              receiverBean.stop();
-              GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
-                  CliStrings.GATEWAY_OK,
-                  CliStrings.format(CliStrings.GATEWAY_RECEIVER_IS_STOPPED_ON_MEMBER_0,
-                      new Object[] {member.getId()}));
-            } else {
-              GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
-                  CliStrings.GATEWAY_ERROR,
-                  CliStrings.format(CliStrings.GATEWAY_RECEIVER_IS_NOT_RUNNING_ON_MEMBER_0,
-                      new Object[] {member.getId()}));
-            }
+      if (gatewayReceiverObjectName != null) {
+        receiverBean =
+            service.getMBeanProxy(gatewayReceiverObjectName, GatewayReceiverMXBean.class);
+        if (receiverBean != null) {
+          if (receiverBean.isRunning()) {
+            receiverBean.stop();
+            GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
+                CliStrings.GATEWAY_OK,
+                CliStrings.format(CliStrings.GATEWAY_RECEIVER_IS_STOPPED_ON_MEMBER_0,
+                    new Object[] {member.getId()}));
           } else {
             GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
                 CliStrings.GATEWAY_ERROR,
-                CliStrings.format(CliStrings.GATEWAY_RECEIVER_IS_NOT_AVAILABLE_ON_MEMBER_0,
+                CliStrings.format(CliStrings.GATEWAY_RECEIVER_IS_NOT_RUNNING_ON_MEMBER_0,
                     new Object[] {member.getId()}));
           }
         } else {
@@ -101,14 +93,15 @@ public Result stopGatewayReceiver(@CliOption(key = {CliStrings.GROUP, CliStrings
               CliStrings.format(CliStrings.GATEWAY_RECEIVER_IS_NOT_AVAILABLE_ON_MEMBER_0,
                   new Object[] {member.getId()}));
         }
+      } else {
+        GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
+            CliStrings.GATEWAY_ERROR,
+            CliStrings.format(CliStrings.GATEWAY_RECEIVER_IS_NOT_AVAILABLE_ON_MEMBER_0,
+                new Object[] {member.getId()}));
       }
-      result = ResultBuilder.buildResult(resultData);
-    } catch (CommandResultException crex) {
-      result = GatewayCommandsUtils.handleCommandResultException(crex);
-    } catch (Exception e) {
-      LogWrapper.getInstance().warning(CliStrings.GATEWAY_ERROR + CliUtil.stackTraceAsString(e));
-      result = ResultBuilder.createGemFireErrorResult(CliStrings.GATEWAY_ERROR + e.getMessage());
     }
+    result = ResultBuilder.buildResult(resultData);
+
     return result;
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StopGatewaySenderCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StopGatewaySenderCommand.java
index 5b20f1e5c7..cc67fc4f5e 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StopGatewaySenderCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StopGatewaySenderCommand.java
@@ -31,7 +31,6 @@
 import org.apache.geode.management.cli.Result;
 import org.apache.geode.management.internal.SystemManagementService;
 import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.LogWrapper;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
 import org.apache.geode.management.internal.cli.result.TabularResultData;
@@ -61,53 +60,49 @@ public Result stopGatewaySender(@CliOption(key = CliStrings.STOP_GATEWAYSENDER__
       senderId = senderId.trim();
     }
 
-    try {
-      InternalCache cache = getCache();
-      SystemManagementService service =
-          (SystemManagementService) ManagementService.getExistingManagementService(cache);
+    InternalCache cache = getCache();
+    SystemManagementService service =
+        (SystemManagementService) ManagementService.getExistingManagementService(cache);
 
-      GatewaySenderMXBean bean;
+    GatewaySenderMXBean bean;
 
-      TabularResultData resultData = ResultBuilder.createTabularResultData();
+    TabularResultData resultData = ResultBuilder.createTabularResultData();
 
-      Set<DistributedMember> dsMembers = CliUtil.findMembers(onGroup, onMember);
+    Set<DistributedMember> dsMembers = CliUtil.findMembers(onGroup, onMember);
 
-      if (dsMembers.isEmpty()) {
-        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    if (dsMembers.isEmpty()) {
+      return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    }
+
+    for (DistributedMember member : dsMembers) {
+      if (cache.getDistributedSystem().getDistributedMember().getId().equals(member.getId())) {
+        bean = service.getLocalGatewaySenderMXBean(senderId);
+      } else {
+        ObjectName objectName = service.getGatewaySenderMBeanName(member, senderId);
+        bean = service.getMBeanProxy(objectName, GatewaySenderMXBean.class);
       }
+      if (bean != null) {
+        if (bean.isRunning()) {
+          bean.stop();
+          GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
+              CliStrings.GATEWAY_OK, CliStrings.format(
+                  CliStrings.GATEWAY_SENDER_0_IS_STOPPED_ON_MEMBER_1, senderId, member.getId()));
 
-      for (DistributedMember member : dsMembers) {
-        if (cache.getDistributedSystem().getDistributedMember().getId().equals(member.getId())) {
-          bean = service.getLocalGatewaySenderMXBean(senderId);
-        } else {
-          ObjectName objectName = service.getGatewaySenderMBeanName(member, senderId);
-          bean = service.getMBeanProxy(objectName, GatewaySenderMXBean.class);
-        }
-        if (bean != null) {
-          if (bean.isRunning()) {
-            bean.stop();
-            GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
-                CliStrings.GATEWAY_OK, CliStrings.format(
-                    CliStrings.GATEWAY_SENDER_0_IS_STOPPED_ON_MEMBER_1, senderId, member.getId()));
-
-          } else {
-            GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
-                CliStrings.GATEWAY_ERROR,
-                CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_NOT_RUNNING_ON_MEMBER_1, senderId,
-                    member.getId()));
-          }
         } else {
           GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
               CliStrings.GATEWAY_ERROR,
-              CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_NOT_AVAILABLE_ON_MEMBER_1, senderId,
+              CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_NOT_RUNNING_ON_MEMBER_1, senderId,
                   member.getId()));
         }
+      } else {
+        GatewayCommandsUtils.accumulateStartResult(resultData, member.getId(),
+            CliStrings.GATEWAY_ERROR,
+            CliStrings.format(CliStrings.GATEWAY_SENDER_0_IS_NOT_AVAILABLE_ON_MEMBER_1, senderId,
+                member.getId()));
       }
-      result = ResultBuilder.buildResult(resultData);
-    } catch (Exception e) {
-      LogWrapper.getInstance().warning(CliStrings.GATEWAY_ERROR + CliUtil.stackTraceAsString(e));
-      result = ResultBuilder.createGemFireErrorResult(CliStrings.GATEWAY_ERROR + e.getMessage());
     }
+    result = ResultBuilder.buildResult(resultData);
+
     return result;
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/CliException.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/UserErrorException.java
similarity index 78%
rename from geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/CliException.java
rename to geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/UserErrorException.java
index 97ea7854e7..0039c85e90 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/CliException.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/UserErrorException.java
@@ -14,22 +14,24 @@
  */
 package org.apache.geode.management.internal.cli.exceptions;
 
-public abstract class CliException extends Exception {
+import org.apache.geode.GemFireException;
+
+public class UserErrorException extends GemFireException {
   private static final long serialVersionUID = -7603040667204839200L;
 
-  public CliException() {
+  public UserErrorException() {
     this(null, null);
   }
 
-  public CliException(String message) {
+  public UserErrorException(String message) {
     this(message, null);
   }
 
-  public CliException(Throwable cause) {
+  public UserErrorException(Throwable cause) {
     super(null, cause);
   }
 
-  public CliException(String message, Throwable cause) {
+  public UserErrorException(String message, Throwable cause) {
     super(message, cause);
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/DataCommandFunction.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/DataCommandFunction.java
index ba791f6505..9e51ec8541 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/DataCommandFunction.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/DataCommandFunction.java
@@ -28,7 +28,7 @@
 
 import org.apache.geode.cache.DataPolicy;
 import org.apache.geode.cache.Region;
-import org.apache.geode.cache.execute.FunctionAdapter;
+import org.apache.geode.cache.execute.Function;
 import org.apache.geode.cache.execute.FunctionContext;
 import org.apache.geode.cache.partition.PartitionRegionHelper;
 import org.apache.geode.cache.query.FunctionDomainException;
@@ -65,7 +65,7 @@
 /**
  * @since GemFire 7.0
  */
-public class DataCommandFunction extends FunctionAdapter implements InternalEntity {
+public class DataCommandFunction implements Function, InternalEntity {
   private static final Logger logger = LogService.getLogger();
 
   private static final long serialVersionUID = 1L;
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/CommandExecutor.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/CommandExecutor.java
index 0ea9764ddb..c664a58c95 100755
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/CommandExecutor.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/CommandExecutor.java
@@ -14,12 +14,12 @@
  */
 package org.apache.geode.management.internal.cli.remote;
 
-import org.apache.commons.lang.exception.ExceptionUtils;
 import org.apache.logging.log4j.Logger;
 import org.springframework.shell.event.ParseResult;
 import org.springframework.util.ReflectionUtils;
 
 import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.management.internal.cli.exceptions.UserErrorException;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
 import org.apache.geode.security.NotAuthorizedException;
 
@@ -43,6 +43,8 @@ public Object execute(ParseResult parseResult) {
     } catch (NotAuthorizedException e) {
       logger.error("Not authorized to execute \"" + parseResult + "\".", e);
       throw e;
+    } catch (UserErrorException e) {
+      return ResultBuilder.createUserErrorResult(e.getMessage());
     } catch (Exception e) {
       logger.error("Could not execute \"" + parseResult + "\".", e);
       return ResultBuilder.createGemFireErrorResult(
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/util/MemberNotFoundException.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/util/MemberNotFoundException.java
index 47837a9010..4a2ec4b9a2 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/util/MemberNotFoundException.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/util/MemberNotFoundException.java
@@ -15,7 +15,7 @@
 
 package org.apache.geode.management.internal.cli.util;
 
-import org.apache.geode.GemFireException;
+import org.apache.geode.management.internal.cli.exceptions.UserErrorException;
 
 /**
  * The MemberNotFoundException is a GemFirException indicating that a member by name could not be
@@ -27,7 +27,7 @@
  */
 // TODO this GemFireException should be moved to a more appropriate package!
 @SuppressWarnings("unused")
-public class MemberNotFoundException extends GemFireException {
+public class MemberNotFoundException extends UserErrorException {
   private static final long serialVersionUID = 5686788909239181174L;
 
   public MemberNotFoundException() {}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilDUnitTest.java
index 6d2e9ccbed..ebcd7fed10 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilDUnitTest.java
@@ -12,376 +12,179 @@
  * or implied. See the License for the specific language governing permissions and limitations under
  * the License.
  */
+
 package org.apache.geode.management.internal.cli;
 
-import static org.apache.geode.distributed.ConfigurationProperties.GROUPS;
-import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER;
-import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_PORT;
-import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_START;
-import static org.apache.geode.distributed.ConfigurationProperties.NAME;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
+import java.util.Arrays;
 import java.util.Properties;
 import java.util.Set;
+import java.util.stream.Collectors;
 
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
-import org.apache.geode.cache.CacheFactory;
-import org.apache.geode.cache.Region;
-import org.apache.geode.cache.RegionFactory;
-import org.apache.geode.cache.RegionShortcut;
-import org.apache.geode.cache.execute.FunctionAdapter;
-import org.apache.geode.cache.execute.FunctionContext;
-import org.apache.geode.cache.execute.ResultCollector;
+import org.apache.geode.distributed.ConfigurationProperties;
 import org.apache.geode.distributed.DistributedMember;
-import org.apache.geode.internal.AvailablePortHelper;
 import org.apache.geode.internal.cache.InternalCache;
-import org.apache.geode.management.DistributedRegionMXBean;
-import org.apache.geode.management.ManagementService;
-import org.apache.geode.management.RegionMXBean;
-import org.apache.geode.test.dunit.Host;
-import org.apache.geode.test.dunit.LogWriterUtils;
-import org.apache.geode.test.dunit.SerializableCallable;
-import org.apache.geode.test.dunit.SerializableRunnable;
-import org.apache.geode.test.dunit.VM;
-import org.apache.geode.test.dunit.Wait;
-import org.apache.geode.test.dunit.WaitCriterion;
-import org.apache.geode.test.dunit.cache.internal.JUnit4CacheTestCase;
+import org.apache.geode.management.internal.cli.exceptions.UserErrorException;
+import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
 
 @Category(DistributedTest.class)
-public class CliUtilDUnitTest extends JUnit4CacheTestCase {
-
-  public static final String COMMON_REGION = "region1";
-  public static final String COMMON_REGION_GROUP1 = "region_group1";
-  public static final String COMMON_REGION_GROUP2 = "region_group2";
-  public static final String REGION_MEMBER1_GROUP1 = "region_member1_group1";
-  public static final String REGION_MEMBER2_GROUP1 = "region_member2_group1";
-  public static final String REGION_MEMBER1_GROUP2 = "region_member1_group2";
-  public static final String REGION_MEMBER2_GROUP2 = "region_member2_group2";
-
-  public static final String MEMBER_1_GROUP1 = "member1_group1";
-  public static final String MEMBER_2_GROUP1 = "member2_group1";
-  public static final String MEMBER_1_GROUP2 = "member1_group2";
-  public static final String MEMBER_2_GROUP2 = "member2_group2";
-
-  public static final String GROUP1 = "group1";
-  public static final String GROUP2 = "group2";
-
-  private static final long serialVersionUID = 1L;
-
-  @Override
-  public final void preTearDownCacheTestCase() throws Exception {
-    destroySetup();
+public class CliUtilDUnitTest {
+
+  @ClassRule
+  public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
+
+  @ClassRule
+  public static GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+
+  private static MemberVM locator;
+  private static Set<DistributedMember> members;
+
+  @BeforeClass
+  public static void setUpCluster() throws Exception {
+    locator = lsRule.startLocatorVM(0);
+    gfsh.connectAndVerify(locator);
+
+    Properties properties = new Properties();
+    properties.setProperty(ConfigurationProperties.NAME, "member1");
+    properties.setProperty(ConfigurationProperties.GROUPS, "group1");
+    lsRule.startServerVM(1, properties, locator.getPort());
+
+    properties.setProperty(ConfigurationProperties.NAME, "member2");
+    properties.setProperty(ConfigurationProperties.GROUPS, "group1");
+    lsRule.startServerVM(2, properties, locator.getPort());
+
+    properties.setProperty(ConfigurationProperties.NAME, "member3");
+    properties.setProperty(ConfigurationProperties.GROUPS, "group2");
+    lsRule.startServerVM(3, properties, locator.getPort());
+
+    properties.setProperty(ConfigurationProperties.NAME, "member4");
+    properties.setProperty(ConfigurationProperties.GROUPS, "group2");
+    lsRule.startServerVM(4, properties, locator.getPort());
+
+    // create regions
+    gfsh.executeAndAssertThat("create region --name=commonRegion --type=REPLICATE")
+        .statusIsSuccess();
+    gfsh.executeAndAssertThat("create region --name=group1Region --group=group1 --type=REPLICATE")
+        .statusIsSuccess();
+    gfsh.executeAndAssertThat("create region --name=group2Region --group=group2 --type=REPLICATE")
+        .statusIsSuccess();
+
+    locator.waitTillRegionsAreReadyOnServers("/commonRegion", 4);
+    locator.waitTillRegionsAreReadyOnServers("/group1Region", 2);
+    locator.waitTillRegionsAreReadyOnServers("/group2Region", 2);
   }
 
-  protected final void destroySetup() {
-    disconnectAllFromDS();
-  }
-
-  @SuppressWarnings("serial")
-  void setupMembersWithIdsAndGroups() {
-    final VM vm1 = Host.getHost(0).getVM(0);
-    final VM vm2 = Host.getHost(0).getVM(1);
-    final VM vm3 = Host.getHost(0).getVM(2);
-    final VM vm4 = Host.getHost(0).getVM(3);
-
-    vm1.invoke(new SerializableRunnable() {
-      @Override
-      public void run() {
-        createCacheWithMemberIdAndGroup(MEMBER_1_GROUP1, GROUP1);
-        createRegion(REGION_MEMBER1_GROUP1);
-        createRegion(COMMON_REGION_GROUP1);
-        createRegion(COMMON_REGION);
-      }
-    });
-
-    vm2.invoke(new SerializableRunnable() {
-      @Override
-      public void run() {
-        createCacheWithMemberIdAndGroup(MEMBER_2_GROUP1, GROUP1);
-        createRegion(REGION_MEMBER2_GROUP1);
-        createRegion(COMMON_REGION_GROUP1);
-        createRegion(COMMON_REGION);
-      }
-    });
-
-    vm3.invoke(new SerializableRunnable() {
-      @Override
-      public void run() {
-        createCacheWithMemberIdAndGroup(MEMBER_1_GROUP2, GROUP2);
-        createRegion(REGION_MEMBER1_GROUP2);
-        createRegion(COMMON_REGION_GROUP2);
-        createRegion(COMMON_REGION);
-      }
-    });
-
-    vm4.invoke(new SerializableRunnable() {
-      @Override
-      public void run() {
-        createCacheWithMemberIdAndGroup(MEMBER_2_GROUP2, GROUP2);
-        createRegion(REGION_MEMBER2_GROUP2);
-        createRegion(COMMON_REGION_GROUP2);
-        createRegion(COMMON_REGION);
-      }
-    });
-
-    vm1.invoke(new SerializableRunnable() {
-      @Override
-      public void run() {
-        startManager();
-      }
+  @Test
+  public void findMembers() throws Exception {
+    locator.invoke(() -> {
+      // can't pass in both group and names
+      assertThatThrownBy(() -> CliUtil.findMembers("group1".split(","), "member1".split(",")))
+          .isInstanceOf(UserErrorException.class);
+
+      // finds all servers
+      members = CliUtil.findMembers(null, null);
+      assertThat(getNames(members)).containsExactlyInAnyOrder("member1", "member2", "member3",
+          "member4");
+
+      // find only one member
+      members = CliUtil.findMembers(null, "member1".split(","));
+      assertThat(getNames(members)).containsExactly("member1");
+
+      // find multiple members
+      members = CliUtil.findMembers(null, "member1,member3".split(","));
+      assertThat(getNames(members)).containsExactlyInAnyOrder("member1", "member3");
+
+      // find multiple members
+      members = CliUtil.findMembers(null, "MembER1,member3".split(","));
+      assertThat(getNames(members)).containsExactlyInAnyOrder("member1", "member3");
+
+      // find only one group
+      members = CliUtil.findMembers("group1".split(","), null);
+      assertThat(getNames(members)).containsExactlyInAnyOrder("member1", "member2");
+
+      // find multiple groups
+      members = CliUtil.findMembers("group1,group2".split(","), null);
+      assertThat(getNames(members)).containsExactlyInAnyOrder("member1", "member2", "member3",
+          "member4");
     });
   }
 
-  private void startManager() {
-    final ManagementService service = ManagementService.getManagementService(getCache());
-    service.startManager();
-    assertEquals(true, service.isManager());
-    assertNotNull(service.getManagerMXBean());
-    assertTrue(service.getManagerMXBean().isRunning());
-    final WaitCriterion waitForMaangerMBean = new WaitCriterion() {
-      @Override
-      public boolean done() {
-        boolean flag = checkBean(COMMON_REGION, 4) && checkBean(COMMON_REGION_GROUP1, 2)
-            && checkBean(COMMON_REGION_GROUP2, 2) && checkBean(REGION_MEMBER1_GROUP1, 1)
-            && checkBean(REGION_MEMBER2_GROUP1, 1) && checkBean(REGION_MEMBER1_GROUP2, 1)
-            && checkBean(REGION_MEMBER2_GROUP2, 1);
-        if (!flag) {
-          LogWriterUtils.getLogWriter().info("Still probing for mbeans");
-          return false;
-        } else {
-          LogWriterUtils.getLogWriter()
-              .info("All distributed region mbeans are federated to manager.");
-          return true;
-        }
-      }
-
-      private boolean checkBean(String string, int memberCount) {
-        DistributedRegionMXBean bean2 =
-            service.getDistributedRegionMXBean(Region.SEPARATOR + string);
-        LogWriterUtils.getLogWriter()
-            .info("DistributedRegionMXBean for region=" + string + " is " + bean2);
-        if (bean2 == null)
-          return false;
-        else {
-          int members = bean2.getMemberCount();
-          LogWriterUtils.getLogWriter().info("DistributedRegionMXBean for region=" + string
-              + " is aggregated for " + memberCount + " expected count=" + memberCount);
-          if (members < memberCount) {
-            return false;
-          } else {
-            return true;
-          }
-        }
-      }
-
-      @Override
-      public String description() {
-        return "Probing for ManagerMBean";
-      }
-    };
-
-    Wait.waitForCriterion(waitForMaangerMBean, 120000, 2000, true);
-    LogWriterUtils.getLogWriter().info("Manager federation is complete");
-  }
-
-  @SuppressWarnings("rawtypes")
-  private Region createRegion(String regionName) {
-    RegionFactory regionFactory = getCache().createRegionFactory(RegionShortcut.REPLICATE);
-    Region region = regionFactory.create(regionName);
-    final ManagementService service = ManagementService.getManagementService(getCache());
-    assertNotNull(service.getMemberMXBean());
-    RegionMXBean bean = service.getLocalRegionMBean(Region.SEPARATOR + regionName);
-    assertNotNull(bean);
-    LogWriterUtils.getLogWriter().info("Created region=" + regionName + " Bean=" + bean);
-    return region;
-  }
-
-  public void createCacheWithMemberIdAndGroup(String memberName, String groupName) {
-    Properties localProps = new Properties();
-    localProps.setProperty(NAME, memberName);
-    localProps.setProperty(GROUPS, groupName);
-    localProps.setProperty(JMX_MANAGER, "true");
-    localProps.setProperty(JMX_MANAGER_START, "false");
-    int jmxPort = AvailablePortHelper.getRandomAvailableTCPPort();
-    localProps.setProperty(JMX_MANAGER_PORT, "" + jmxPort);
-    LogWriterUtils.getLogWriter().info("Set jmx-port=" + jmxPort);
-    getSystem(localProps);
-    getCache();
-    final ManagementService service = ManagementService.getManagementService(getCache());
-    assertNotNull(service.getMemberMXBean());
+  public void getMember() throws Exception {
+    locator.invoke(() -> {
+      assertThat(CliUtil.getDistributedMemberByNameOrId("notValidName")).isNull();
+      assertThat(CliUtil.getDistributedMemberByNameOrId("member1").getName()).isEqualTo("member1");
+      assertThat(CliUtil.getDistributedMemberByNameOrId("MembER1").getName()).isEqualTo("member1");
+    });
   }
 
-  @SuppressWarnings("serial")
   @Test
-  public void testCliUtilMethods() {
-    setupMembersWithIdsAndGroups();
-
-    final VM vm1 = Host.getHost(0).getVM(0);
-
-    LogWriterUtils.getLogWriter().info("testFor - findMembersOrThrow");
-    vm1.invoke(new SerializableRunnable() {
-      @Override
-      public void run() {
-        verifyFindAllMatchingMembers();
-      }
-    });
-
-    final String id = (String) vm1.invoke(new SerializableCallable() {
-      @Override
-      public Object call() throws Exception {
-        InternalCache cache = getCache();
-        return cache.getDistributedSystem().getDistributedMember().getId();
-      }
-    });
-
-    LogWriterUtils.getLogWriter().info("testFor - getDistributedMemberByNameOrId");
-    vm1.invoke(new SerializableRunnable() {
-      @Override
-      public void run() {
-        getDistributedMemberByNameOrId(MEMBER_1_GROUP1, id);
-      }
-    });
-
-    LogWriterUtils.getLogWriter().info("testFor - executeFunction");
-    vm1.invoke(new SerializableRunnable() {
-      @Override
-      public void run() {
-        verifyExecuteFunction();
-      }
-    });
-
-    LogWriterUtils.getLogWriter().info("testFor - getRegionAssociatedMembers");
-    vm1.invoke(new SerializableRunnable() {
-      @Override
-      public void run() {
-        getRegionAssociatedMembers();
-      }
+  public void getAllMembers() throws Exception {
+    locator.invoke(() -> {
+      InternalCache cache = LocatorServerStartupRule.getCache();
+      members = CliUtil.getAllMembers(cache);
+      assertThat(getNames(members)).containsExactlyInAnyOrder("locator-0", "member1", "member2",
+          "member3", "member4");
+
+      members = CliUtil.getAllNormalMembers(cache);
+      assertThat(getNames(members)).containsExactlyInAnyOrder("member1", "member2", "member3",
+          "member4");
     });
   }
 
-  public void verifyFindAllMatchingMembers() {
-    Set<DistributedMember> set = CliUtil.findMembers(GROUP1.split(","), null);
-    assertNotNull(set);
-    assertEquals(2, set.size());
-    assertEquals(true, containsMember(set, MEMBER_1_GROUP1));
-    assertEquals(true, containsMember(set, MEMBER_2_GROUP1));
-
-    set = CliUtil.findMembers(new String[] {"group1", "group2"}, null);
-    assertNotNull(set);
-    assertEquals(4, set.size());
-    assertEquals(true, containsMember(set, MEMBER_1_GROUP1));
-    assertEquals(true, containsMember(set, MEMBER_2_GROUP1));
-    assertEquals(true, containsMember(set, MEMBER_1_GROUP2));
-    assertEquals(true, containsMember(set, MEMBER_2_GROUP2));
-
-    set = CliUtil.findMembers(null, MEMBER_1_GROUP1.split(","));
-    assertNotNull(set);
-    assertEquals(1, set.size());
-    assertEquals(true, containsMember(set, MEMBER_1_GROUP1));
-
-    set = CliUtil.findMembers(null, new String[] {"member1_group1", "member2_group2"});
-    assertNotNull(set);
-    assertEquals(2, set.size());
-    assertEquals(true, containsMember(set, MEMBER_1_GROUP1));
-    assertEquals(true, containsMember(set, MEMBER_2_GROUP2));
-  }
-
-  private Object containsMember(Set<DistributedMember> set, String string) {
-    boolean returnValue = false;
-    for (DistributedMember member : set)
-      if (member.getName().equals(string))
-        return true;
-    return returnValue;
+  @Test
+  public void getRegionAssociatedMembers() throws Exception {
+    locator.invoke(() -> {
+      InternalCache cache = LocatorServerStartupRule.getCache();
+      members = CliUtil.getRegionAssociatedMembers("commonRegion", cache, true);
+      assertThat(getNames(members)).containsExactlyInAnyOrder("member1", "member2", "member3",
+          "member4");
+
+      members = CliUtil.getRegionAssociatedMembers("group1Region", cache, true);
+      assertThat(getNames(members)).containsExactlyInAnyOrder("member1", "member2");
+    });
   }
 
-  public void getDistributedMemberByNameOrId(String name, String id) {
-    DistributedMember member = CliUtil.getDistributedMemberByNameOrId(name);
-    assertNotNull(member);
-
-    member = CliUtil.getDistributedMemberByNameOrId(id);
-    assertNotNull(member);
+  @Test
+  public void getRegionsAssociatedMembers() throws Exception {
+    locator.invoke(() -> {
+      InternalCache cache = LocatorServerStartupRule.getCache();
+      // this finds the members that host both these two regions
+      Set<String> regions =
+          Arrays.stream("commonRegion,group1Region".split(",")).collect(Collectors.toSet());
+      members = CliUtil.getQueryRegionsAssociatedMembers(regions, cache, true);
+      assertThat(getNames(members)).containsExactlyInAnyOrder("member1", "member2");
+
+      regions = Arrays.stream("group1Region,group2Region".split(",")).collect(Collectors.toSet());
+      members = CliUtil.getQueryRegionsAssociatedMembers(regions, cache, true);
+      assertThat(getNames(members)).isEmpty();
+    });
   }
 
-  public void verifyExecuteFunction() {
-    DunitFunction function = new DunitFunction("myfunction");
-    Set<DistributedMember> set;
-    @SuppressWarnings("rawtypes")
-    Region region1 = getCache().getRegion(COMMON_REGION);
-    region1.clear();
-    set = CliUtil.findMembers(GROUP1.split(","), null);
-    assertEquals(2, set.size());
-    ResultCollector collector = CliUtil.executeFunction(function, "executeOnGroup", set);
-    collector.getResult();
-    assertEquals(2, region1.size());
-    assertTrue(region1.containsKey(MEMBER_1_GROUP1));
-    assertTrue(region1.containsKey(MEMBER_2_GROUP1));
-    assertEquals("executeOnGroup", region1.get(MEMBER_1_GROUP1));
-    assertEquals("executeOnGroup", region1.get(MEMBER_2_GROUP1));
+  @Test
+  public void getMemberByNameOrId() throws Exception {
+    locator.invoke(() -> {
+      DistributedMember member = CliUtil.getDistributedMemberByNameOrId("member1");
+      assertThat(member.getName()).isEqualTo("member1");
+      assertThat(member.getId()).contains("member1:");
+      assertThat(member.getGroups()).containsExactly("group1");
+
+      member = CliUtil.getDistributedMemberByNameOrId("member100");
+      assertThat(member).isNull();
+    });
   }
 
-  public void getRegionAssociatedMembers() {
-    String region_group1 = "/region_group1";
-    String region1 = "/region1";
-    String region_member2_group1 = "/region_member2_group1";
-
-    InternalCache cache = getCache();
-
-    Set<DistributedMember> set = CliUtil.getRegionAssociatedMembers(region1, cache, true);
-    assertNotNull(set);
-    assertEquals(4, set.size());
-    assertEquals(true, containsMember(set, MEMBER_1_GROUP1));
-    assertEquals(true, containsMember(set, MEMBER_2_GROUP1));
-    assertEquals(true, containsMember(set, MEMBER_1_GROUP2));
-    assertEquals(true, containsMember(set, MEMBER_2_GROUP2));
-
-    /*
-     * TODO: This is failing because last param is not considered in method set =
-     * CliUtil.getRegionAssociatedMembers(region1, cache, false); assertNotNull(set);
-     * assertIndexDetailsEquals(1, set.size());
-     */
-
-    set = CliUtil.getRegionAssociatedMembers(region_group1, cache, true);
-    assertNotNull(set);
-    assertEquals(2, set.size());
-    assertEquals(true, containsMember(set, MEMBER_1_GROUP1));
-    assertEquals(true, containsMember(set, MEMBER_2_GROUP1));
-
-    set = CliUtil.getRegionAssociatedMembers(region_member2_group1, cache, true);
-    assertNotNull(set);
-    assertEquals(1, set.size());
-    assertEquals(true, containsMember(set, MEMBER_2_GROUP1));
-  }
 
-  public static class DunitFunction extends FunctionAdapter {
-
-    private static final long serialVersionUID = 1L;
-    private String id;
-
-    public DunitFunction(String fid) {
-      this.id = fid;
-    }
-
-    @Override
-    public void execute(FunctionContext context) {
-      Object object = context.getArguments();
-      InternalCache cache = (InternalCache) CacheFactory.getAnyInstance();
-      @SuppressWarnings("rawtypes")
-      Region region = cache.getRegion(COMMON_REGION);
-      String id = cache.getDistributedSystem().getDistributedMember().getName();
-      region.put(id, object);
-      LogWriterUtils.getLogWriter().info("Completed executeFunction on member : " + id);
-      context.getResultSender().lastResult(true);
-    }
-
-    @Override
-    public String getId() {
-      return id;
-    }
+  private static Set<String> getNames(Set<DistributedMember> members) {
+    return members.stream().map(DistributedMember::getName).collect(Collectors.toSet());
   }
-
 }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandIntegrationTest.java
similarity index 73%
rename from geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandJUnitTest.java
rename to geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandIntegrationTest.java
index 094ff4f041..cdbdf2d4b8 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandIntegrationTest.java
@@ -14,8 +14,7 @@
  */
 package org.apache.geode.management.internal.cli.commands;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
+import org.junit.ClassRule;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
@@ -27,30 +26,29 @@
 import org.apache.geode.test.junit.rules.ServerStarterRule;
 
 @Category(IntegrationTest.class)
-public class DescribeConfigCommandJUnitTest {
+public class DescribeConfigCommandIntegrationTest {
   private static final String[] EXPECTED_BASE_CONFIGURATION_DATA = {"Configuration of member :",
       "JVM command line arguments", "GemFire properties defined using the API"};
 
   private static final String[] EXPECTED_EXPANDED_CONFIGURATION_DATA =
       {"Cache attributes", "GemFire properties using default values"};
 
-  @Rule
-  public ServerStarterRule server = new ServerStarterRule().withJMXManager().withName("server")
-      .withRegion(RegionShortcut.PARTITION, "region").withAutoStart();
+  @ClassRule
+  public static ServerStarterRule server = new ServerStarterRule().withJMXManager()
+      .withName("server").withRegion(RegionShortcut.PARTITION, "region").withAutoStart();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshShellConnectionRule gfsh =
+      new GfshShellConnectionRule(server::getJmxPort, PortType.jmxManager);
 
   @Test
   public void describeConfig() throws Exception {
-    gfsh.connectAndVerify(server.getJmxPort(), PortType.jmxManager);
     gfsh.executeAndAssertThat("describe config --member=" + server.getName()).statusIsSuccess()
         .containsOutput(EXPECTED_BASE_CONFIGURATION_DATA);
   }
 
   @Test
   public void describeConfigAndShowDefaults() throws Exception {
-    gfsh.connectAndVerify(server.getJmxPort(), PortType.jmxManager);
     gfsh.executeAndAssertThat("describe config --hide-defaults=false --member=" + server.getName())
         .statusIsSuccess().containsOutput(EXPECTED_BASE_CONFIGURATION_DATA)
         .containsOutput(EXPECTED_EXPANDED_CONFIGURATION_DATA);
@@ -58,6 +56,7 @@ public void describeConfigAndShowDefaults() throws Exception {
 
   @Test
   public void describeConfigWhenNotConnected() throws Exception {
+    gfsh.disconnect();
     gfsh.executeAndAssertThat("describe config --member=" + server.getName()).statusIsError()
         .containsOutput("was found but is not currently available");
   }
@@ -65,19 +64,8 @@ public void describeConfigWhenNotConnected() throws Exception {
   @Test
   public void describeConfigOnInvalidMember() throws Exception {
     String invalidMemberName = "invalid-member-name";
-    String expectedErrorString = String.format("Member \"%s\" not found", invalidMemberName);
-
-    gfsh.connectAndVerify(server.getJmxPort(), PortType.jmxManager);
+    String expectedErrorString = String.format("Member %s could not be found", invalidMemberName);
     gfsh.executeAndAssertThat("describe config --member=" + invalidMemberName).statusIsError()
         .containsOutput(expectedErrorString);
   }
-
-  @Test
-  public void describeConfigWithoutMemberName() throws Exception {
-    String expectedErrorString = "You should specify option ";
-
-    gfsh.connectAndVerify(server.getJmxPort(), PortType.jmxManager);
-    gfsh.executeAndAssertThat("describe config").statusIsError()
-        .containsOutput(expectedErrorString);
-  }
 }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandTest.java
new file mode 100644
index 0000000000..d94707a784
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandTest.java
@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.test.junit.categories.UnitTest;
+import org.apache.geode.test.junit.rules.GfshParserRule;
+
+
+@Category(UnitTest.class)
+public class DescribeConfigCommandTest {
+
+  @ClassRule
+  public static GfshParserRule parser = new GfshParserRule();
+
+  @Test
+  public void describeConfigWithoutMemberName() throws Exception {
+    assertThat(parser.parse("describe config")).isNull();
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeMembersCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeMembersCommandDUnitTest.java
index cfd2780a85..9db128e001 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeMembersCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeMembersCommandDUnitTest.java
@@ -15,7 +15,6 @@
 package org.apache.geode.management.internal.cli.commands;
 
 import static org.apache.geode.management.internal.cli.i18n.CliStrings.DESCRIBE_MEMBER;
-import static org.assertj.core.api.Assertions.assertThat;
 
 import org.junit.BeforeClass;
 import org.junit.ClassRule;
@@ -46,8 +45,8 @@ public static void setup() throws Exception {
   @Test
   public void describeInvalidMember() throws Exception {
     gfsh.connectAndVerify(locator);
-    gfsh.executeAndAssertThat(DESCRIBE_MEMBER + " --name=foo").statusIsSuccess()
-        .containsOutput("Member \"foo\" not found");
+    gfsh.executeAndAssertThat(DESCRIBE_MEMBER + " --name=foo").statusIsError()
+        .containsOutput("Member foo could not be found");
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java
index 421a005814..c5c3ee0e32 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java
@@ -16,16 +16,10 @@
 package org.apache.geode.management.internal.cli.commands;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.awaitility.Awaitility.waitAtMost;
 
 import java.io.IOException;
-import java.text.MessageFormat;
-import java.util.concurrent.TimeUnit;
-
-import javax.management.MBeanServer;
-import javax.management.MalformedObjectNameException;
-import javax.management.ObjectName;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.ClassRule;
@@ -41,8 +35,6 @@
 import org.apache.geode.distributed.Locator;
 import org.apache.geode.distributed.internal.ClusterConfigurationService;
 import org.apache.geode.distributed.internal.InternalLocator;
-import org.apache.geode.management.internal.MBeanJMXAdapter;
-import org.apache.geode.management.internal.ManagementConstants;
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
@@ -71,6 +63,15 @@ public void before() throws Exception {
     gfsh.connectAndVerify(locator);
   }
 
+  @After
+  public void after() throws Exception {
+    // destroy regions
+    gfsh.execute("destroy region --name=/Customer --if-exists");
+    gfsh.execute("destroy region --name=/Order --if-exists");
+    gfsh.execute("destroy region --name=/Customer_2 --if-exists");
+    gfsh.execute("destroy region --name=/Customer_3 --if-exists");
+  }
+
   @Test
   public void testDestroyDistributedRegion() {
     MemberVM.invokeInEveryMember(() -> {
@@ -84,8 +85,8 @@ public void testDestroyDistributedRegion() {
       factory.create("Order");
     }, server1, server2);
 
-    locator.invoke(() -> waitForRegionMBeanCreation("/Customer", 2));
-    locator.invoke(() -> waitForRegionMBeanCreation("/Order", 2));
+    locator.waitTillRegionsAreReadyOnServers("/Customer", 2);
+    locator.waitTillRegionsAreReadyOnServers("/Order", 2);
 
     // Test unable to destroy with co-location
     gfsh.executeAndAssertThat("destroy region --name=/Customer").statusIsError()
@@ -112,7 +113,7 @@ public void testDestroyLocalRegions() {
       factory.create("Customer");
     }, server1, server2, server3);
 
-    locator.invoke(() -> waitForRegionMBeanCreation("/Customer", 3));
+    locator.waitTillRegionsAreReadyOnServers("/Customer", 3);
 
     gfsh.executeAndAssertThat("destroy region --name=Customer").statusIsSuccess()
         .containsOutput("destroyed successfully");
@@ -142,9 +143,9 @@ public void testDestroyLocalAndDistributedRegions() {
       factory.create("Customer_3");
     });
 
-    locator.invoke(() -> waitForRegionMBeanCreation("/Customer", 3));
-    locator.invoke(() -> waitForRegionMBeanCreation("/Customer_2", 3));
-    locator.invoke(() -> waitForRegionMBeanCreation("/Customer_3", 3));
+    locator.waitTillRegionsAreReadyOnServers("/Customer", 3);
+    locator.waitTillRegionsAreReadyOnServers("/Customer_2", 3);
+    locator.waitTillRegionsAreReadyOnServers("/Customer_3", 3);
 
     gfsh.executeAndAssertThat("destroy region --name=Customer").statusIsSuccess()
         .containsOutput("destroyed successfully");
@@ -201,18 +202,4 @@ public void testDestroyRegionWithSharedConfig() throws IOException {
       assertThat(cache.getRegion("Customer")).isNull();
     }, server1, server2, server3);
   }
-
-  private static void waitForRegionMBeanCreation(String regionPath, int mbeanCount) {
-    waitAtMost(5, TimeUnit.SECONDS).until(() -> {
-      try {
-        MBeanServer mbeanServer = MBeanJMXAdapter.mbeanServer;
-        String queryExp =
-            MessageFormat.format(ManagementConstants.OBJECTNAME__REGION_MXBEAN, regionPath, "*");
-        ObjectName queryExpON = new ObjectName(queryExp);
-        return mbeanServer.queryNames(queryExpON, null).size() == mbeanCount;
-      } catch (MalformedObjectNameException mone) {
-        throw new RuntimeException(mone);
-      }
-    });
-  }
 }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsJUnitTest.java
index f8cd657fa6..f5eb7800f3 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsJUnitTest.java
@@ -47,7 +47,6 @@
 import org.apache.geode.management.internal.cli.functions.ListDiskStoresFunction;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.util.DiskStoreNotFoundException;
-import org.apache.geode.management.internal.cli.util.MemberNotFoundException;
 import org.apache.geode.test.junit.categories.UnitTest;
 
 /**
@@ -124,10 +123,6 @@ public void testGetDiskStoreDescription() {
 
     mockContext.checking(new Expectations() {
       {
-        oneOf(mockMember).getName();
-        will(returnValue(null));
-        oneOf(mockMember).getId();
-        will(returnValue(memberId));
         oneOf(mockFunctionExecutor).setArguments(with(equal(diskStoreName)));
         will(returnValue(mockFunctionExecutor));
         oneOf(mockFunctionExecutor).execute(with(aNonNull(DescribeDiskStoreFunction.class)));
@@ -147,37 +142,6 @@ public void testGetDiskStoreDescription() {
     assertEquals(expectedDiskStoredDetails, actualDiskStoreDetails);
   }
 
-  @Test(expected = MemberNotFoundException.class)
-  public void testGetDiskStoreDescriptionThrowsMemberNotFoundException() {
-    final String diskStoreName = "mockDiskStore";
-    final String memberId = "mockMember";
-
-    final InternalCache mockCache = mockContext.mock(InternalCache.class, "InternalCache");
-
-    final DistributedMember mockMember =
-        mockContext.mock(DistributedMember.class, "DistributedMember");
-
-    mockContext.checking(new Expectations() {
-      {
-        oneOf(mockMember).getName();
-        will(returnValue(null));
-        oneOf(mockMember).getId();
-        will(returnValue("testMember"));
-      }
-    });
-
-    final DescribeDiskStoreCommand describeCommand =
-        createDescribeDiskStoreCommand(mockCache, mockMember, null);
-
-    try {
-      describeCommand.getDiskStoreDescription(memberId, diskStoreName);
-    } catch (MemberNotFoundException expected) {
-      assertEquals(CliStrings.format(CliStrings.MEMBER_NOT_FOUND_ERROR_MESSAGE, memberId),
-          expected.getMessage());
-      throw expected;
-    }
-  }
-
   @Test(expected = DiskStoreNotFoundException.class)
   public void testGetDiskStoreDescriptionThrowsDiskStoreNotFoundException() {
     final String diskStoreName = "mockDiskStore";
@@ -192,10 +156,6 @@ public void testGetDiskStoreDescriptionThrowsDiskStoreNotFoundException() {
 
     mockContext.checking(new Expectations() {
       {
-        oneOf(mockMember).getName();
-        will(returnValue(null));
-        oneOf(mockMember).getId();
-        will(returnValue(memberId));
         oneOf(mockFunctionExecutor).setArguments(with(equal(diskStoreName)));
         will(returnValue(mockFunctionExecutor));
         oneOf(mockFunctionExecutor).execute(with(aNonNull(DescribeDiskStoreFunction.class)));
@@ -228,10 +188,6 @@ public void testGetDiskStoreDescriptionThrowsRuntimeException() {
 
     mockContext.checking(new Expectations() {
       {
-        oneOf(mockMember).getName();
-        will(returnValue(null));
-        oneOf(mockMember).getId();
-        will(returnValue(memberId));
         oneOf(mockFunctionExecutor).setArguments(with(equal(diskStoreName)));
         will(returnValue(mockFunctionExecutor));
         oneOf(mockFunctionExecutor).execute(with(aNonNull(DescribeDiskStoreFunction.class)));
@@ -267,10 +223,6 @@ public void testGetDiskStoreDescriptionWithInvalidFunctionResultReturnType() {
 
     mockContext.checking(new Expectations() {
       {
-        oneOf(mockMember).getName();
-        will(returnValue(null));
-        oneOf(mockMember).getId();
-        will(returnValue(memberId));
         oneOf(mockFunctionExecutor).setArguments(with(equal(diskStoreName)));
         will(returnValue(mockFunctionExecutor));
         oneOf(mockFunctionExecutor).execute(with(aNonNull(DescribeDiskStoreFunction.class)));
@@ -434,12 +386,18 @@ public InternalCache getCache() {
     }
 
     @Override
-    public Set<DistributedMember> getMembers(final InternalCache cache) {
+    public Set<DistributedMember> getAllMembers(final InternalCache cache) {
       assertSame(getCache(), cache);
       return Collections.singleton(this.distributedMember);
     }
 
     @Override
+    public DistributedMember getMember(String nameOrId) {
+      assertSame(getCache(), cache);
+      return this.distributedMember;
+    }
+
+    @Override
     public Execution getMembersFunctionExecutor(final Set<DistributedMember> members) {
       Assert.assertNotNull(members);
       return this.functionExecutor;
@@ -447,7 +405,6 @@ public Execution getMembersFunctionExecutor(final Set<DistributedMember> members
   }
 
   private static class TestListDiskStoresCommand extends ListDiskStoresCommand {
-
     private final InternalCache cache;
     private final DistributedMember distributedMember;
     private final Execution functionExecutor;
@@ -466,12 +423,18 @@ public InternalCache getCache() {
     }
 
     @Override
-    public Set<DistributedMember> getMembers(final InternalCache cache) {
+    public Set<DistributedMember> getAllMembers(final InternalCache cache) {
       assertSame(getCache(), cache);
       return Collections.singleton(this.distributedMember);
     }
 
     @Override
+    public DistributedMember getMember(String nameOrId) {
+      assertSame(getCache(), cache);
+      return this.distributedMember;
+    }
+
+    @Override
     public Execution getMembersFunctionExecutor(final Set<DistributedMember> members) {
       Assert.assertNotNull(members);
       return this.functionExecutor;
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportDataCommandTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportDataCommandTest.java
new file mode 100644
index 0000000000..601ba844fa
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportDataCommandTest.java
@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.management.internal.cli.GfshParseResult;
+import org.apache.geode.test.junit.categories.UnitTest;
+import org.apache.geode.test.junit.rules.GfshParserRule;
+
+
+@Category(UnitTest.class)
+public class ExportDataCommandTest {
+
+  @ClassRule
+  public static GfshParserRule parser = new GfshParserRule();
+
+  @Test
+  public void missingMember() throws Exception {
+    GfshParseResult result = parser.parse("export data --region=regionA --file=test");
+    assertThat(result).isNull();
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportDataIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportDataIntegrationTest.java
index 8d36d19416..cefc685092 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportDataIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportDataIntegrationTest.java
@@ -18,7 +18,6 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
 
 import java.nio.file.Files;
 import java.nio.file.Path;
@@ -95,8 +94,8 @@ public void testInvalidMember() throws Exception {
         .addOption(CliStrings.MEMBER, invalidMemberName)
         .addOption(CliStrings.EXPORT_DATA__REGION, TEST_REGION_NAME)
         .addOption(CliStrings.EXPORT_DATA__FILE, snapshotFile.toString()).getCommandString();
-    gfsh.executeCommand(invalidMemberCommand);
-    assertThat(gfsh.getGfshOutput()).contains("Member " + invalidMemberName + " not found");
+    gfsh.executeAndAssertThat(invalidMemberCommand)
+        .containsOutput("Member " + invalidMemberName + " could not be found");
   }
 
   @Test
@@ -129,15 +128,6 @@ public void testMissingRegion() throws Exception {
   }
 
   @Test
-  public void testMissingMember() throws Exception {
-    String missingMemberCommand = new CommandStringBuilder(CliStrings.EXPORT_DATA)
-        .addOption(CliStrings.EXPORT_DATA__REGION, TEST_REGION_NAME)
-        .addOption(CliStrings.EXPORT_DATA__FILE, snapshotFile.toString()).getCommandString();
-    gfsh.executeCommand(missingMemberCommand);
-    assertThat(gfsh.getGfshOutput()).contains("You should specify option");
-  }
-
-  @Test
   public void testMissingFileAndDirectory() throws Exception {
     String missingFileAndDirCommand = buildBaseExportCommand().getCommandString();
     gfsh.executeCommand(missingFileAndDirCommand);
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GemfireDataCommandsDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GemfireDataCommandsDUnitTest.java
index 3b242fcdc2..4d2c0b9421 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GemfireDataCommandsDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GemfireDataCommandsDUnitTest.java
@@ -26,15 +26,10 @@
 import static org.apache.geode.test.dunit.LogWriterUtils.getLogWriter;
 import static org.apache.geode.test.dunit.Wait.waitForCriterion;
 
-import java.io.File;
-import java.io.IOException;
 import java.io.Serializable;
-import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.Properties;
 import java.util.Random;
 import java.util.Set;
@@ -70,12 +65,8 @@
 import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.HeadlessGfsh;
 import org.apache.geode.management.internal.cli.domain.DataCommandRequest;
-import org.apache.geode.management.internal.cli.dto.Car;
-import org.apache.geode.management.internal.cli.dto.Key1;
-import org.apache.geode.management.internal.cli.dto.ObjectWithCharAttr;
 import org.apache.geode.management.internal.cli.dto.Value1;
 import org.apache.geode.management.internal.cli.dto.Value2;
-import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.json.GfJsonArray;
 import org.apache.geode.management.internal.cli.json.GfJsonException;
 import org.apache.geode.management.internal.cli.result.CommandResult;
@@ -83,7 +74,6 @@
 import org.apache.geode.management.internal.cli.result.CompositeResultData.SectionResultData;
 import org.apache.geode.management.internal.cli.result.ResultData;
 import org.apache.geode.management.internal.cli.result.TabularResultData;
-import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
 import org.apache.geode.test.dunit.Host;
 import org.apache.geode.test.dunit.IgnoredException;
 import org.apache.geode.test.dunit.SerializableCallable;
@@ -584,7 +574,7 @@ public void doTestBug48013() {
     validateResult(cmdResult, true);
   }
 
-  @Test // FlakyTest: GEODE-2006
+  @Test
   public void testSelectCommand() {
     setupForSelect();
     doTestGetRegionAssociatedMembersForSelect();
@@ -752,58 +742,6 @@ public void run() {
     }
   }
 
-  @Test
-  public void testSimplePutCommand() {
-    final String keyPrefix = "testKey";
-    final String valuePrefix = "testValue";
-
-    setupForGetPutRemoveLocateEntry("tesSimplePut");
-
-    final VM vm1 = Host.getHost(0).getVM(1);
-    final VM vm2 = Host.getHost(0).getVM(2);
-
-    for (int i = 0; i < COUNT; i++) {
-      String command = "put";
-      String key = keyPrefix + i;
-      String value = valuePrefix + i;
-      command = command + " " + "--key=" + key + " --value=" + value + " --region="
-          + DATA_REGION_NAME_PATH;
-      CommandResult cmdResult = executeCommand(command);
-      printCommandOutput(cmdResult);
-      validateResult(cmdResult, true);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-    }
-
-    // Bug : 51587 : GFSH command failing when ; is present in either key or value in put operation
-    String command = "put";
-    String key = keyPrefix + "\\;" + COUNT;
-    String value = valuePrefix + "\\;" + COUNT;
-    command =
-        command + " " + "--key=" + key + " --value=" + value + " --region=" + DATA_REGION_NAME_PATH;
-    CommandResult cmdResult = executeCommand(command);
-    printCommandOutput(cmdResult);
-    validateResult(cmdResult, true);
-    assertEquals(Result.Status.OK, cmdResult.getStatus());
-
-    SerializableRunnable checkPutKeys = new SerializableRunnable() {
-      @Override
-      public void run() {
-        Cache cache = getCache();
-        Region region = cache.getRegion(DATA_REGION_NAME_PATH);
-        assertNotNull(region);
-        for (int i = 0; i < COUNT; i++) {
-          String key = keyPrefix + i;
-          assertEquals(true, region.containsKey(key));
-        }
-        // Validation for Bug 51587
-        String key = keyPrefix + "\\;" + COUNT;
-        assertEquals(true, region.containsKey(key));
-      }
-    };
-
-    vm1.invoke(checkPutKeys);
-    vm2.invoke(checkPutKeys);
-  }
 
   private void validateResult(CommandResult cmdResult, boolean expected) {
     if (ResultData.TYPE_COMPOSITE.equals(cmdResult.getType())) {
@@ -909,598 +847,6 @@ private void validateSelectResult(CommandResult cmdResult, boolean expectedFlag,
       fail("Expected CompositeResult Returned Result Type " + cmdResult.getType());
   }
 
-  @Test // FlakyTest: GEODE-1249
-  public void testSimplePutIfAbsentCommand() {
-    final String keyPrefix = "testKey";
-    final String valuePrefix = "testValue";
-
-    setupForGetPutRemoveLocateEntry("testSimplePutIfAbsent");
-
-    final VM vm1 = Host.getHost(0).getVM(1);
-    final VM vm2 = Host.getHost(0).getVM(2);
-
-    // Seed the region with some keys
-    SerializableRunnable putKeys = new SerializableRunnable() {
-      @Override
-      public void run() {
-        Cache cache = getCache();
-        Region region = cache.getRegion(DATA_REGION_NAME_PATH);
-        assertNotNull(region);
-        region.clear();
-        for (int i = 0; i < COUNT; i++) {
-          String key = keyPrefix + i;
-          String value = valuePrefix + i;
-          region.put(key, value);
-        }
-        assertEquals(COUNT, region.size());
-      }
-    };
-    vm1.invoke(putKeys);
-
-    // Now try to replace all existing keys with new values to test --skip-if-exists. Values should
-    // not be replaced if the key is present.
-    for (int i = 0; i < COUNT; i++) {
-      String command = "put";
-      String key = keyPrefix + i;
-      String value = valuePrefix + i + i;
-      command = command + " " + "--key=" + key + " --value=" + value + " --region="
-          + DATA_REGION_NAME_PATH + " --skip-if-exists=true";
-      CommandResult cmdResult = executeCommand(command);
-      printCommandOutput(cmdResult);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-      validateResult(cmdResult, true);
-    }
-
-    // Verify that none of the values were replaced
-    SerializableRunnable checkPutIfAbsentKeys = new SerializableRunnable() {
-      @Override
-      public void run() {
-        Cache cache = getCache();
-        Region region = cache.getRegion(DATA_REGION_NAME_PATH);
-        assertNotNull(region);
-        for (int i = 0; i < COUNT; i++) {
-          String key = keyPrefix + i;
-          String expected = valuePrefix + i;
-          String actual = (String) region.get(key);
-          assertEquals("--skip-if-exists=true failed to preserve value", expected, actual);
-        }
-      }
-    };
-
-    vm1.invoke(checkPutIfAbsentKeys);
-    vm2.invoke(checkPutIfAbsentKeys);
-  }
-
-  @Test
-  public void testSimpleGetLocateEntryCommand() {
-    final String keyPrefix = "testKey";
-    final String valuePrefix = "testValue";
-
-    setupForGetPutRemoveLocateEntry("testSimpleGetLocateEntry");
-
-    final VM vm1 = Host.getHost(0).getVM(1);
-    final VM vm2 = Host.getHost(0).getVM(2);
-
-    SerializableRunnable putKeys = new SerializableRunnable() {
-      @Override
-      public void run() {
-        Cache cache = getCache();
-        Region region = cache.getRegion(DATA_REGION_NAME_PATH);
-        assertNotNull(region);
-        region.clear();
-        for (int i = 0; i < COUNT; i++) {
-          String key = keyPrefix + i;
-          String value = valuePrefix + i;
-          region.put(key, value);
-        }
-      }
-    };
-
-    vm1.invoke(putKeys);
-    for (int i = 0; i < COUNT; i++) {
-      String command = "get";
-      String key = keyPrefix + i;
-      String value = valuePrefix + i;
-      command = command + " " + "--key=" + key + " --region=" + DATA_REGION_NAME_PATH;
-      CommandResult cmdResult = executeCommand(command);
-      printCommandOutput(cmdResult);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-      validateResult(cmdResult, true);
-
-      command = "locate entry";
-      command = command + " " + "--key=" + key + " --region=" + DATA_REGION_NAME_PATH;
-      cmdResult = executeCommand(command);
-      printCommandOutput(cmdResult);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-      validateResult(cmdResult, true);
-
-    }
-
-  }
-
-  @Test
-  public void testRecursiveLocateEntryCommand() {
-    final String keyPrefix = "testKey";
-    final String valuePrefix = "testValue";
-
-    setupForGetPutRemoveLocateEntry("testRecursiveLocateEntry");
-
-    final VM vm1 = Host.getHost(0).getVM(1);
-    final VM vm2 = Host.getHost(0).getVM(2);
-
-    SerializableRunnable putKeys = new SerializableRunnable() {
-      @Override
-      public void run() {
-        Cache cache = getCache();
-        Region region = cache.getRegion(DATA_REGION_NAME_PATH);
-        Region region2 = cache.getRegion(DATA_REGION_NAME_CHILD_1_PATH);
-        Region region3 = cache.getRegion(DATA_REGION_NAME_CHILD_1_2_PATH);
-        assertNotNull(region);
-        region.clear();
-        for (int i = 0; i < COUNT; i++) {
-          String key = keyPrefix + i;
-          String value = valuePrefix + i;
-          region.put(key, value);
-          region2.put(key, value);
-          region3.put(key, value);
-        }
-      }
-    };
-
-    vm1.invoke(putKeys);
-    for (int i = 0; i < COUNT; i++) {
-      String key = keyPrefix + i;
-      String command = "locate entry";
-      command = command + " " + "--key=" + key + " --region=" + DATA_REGION_NAME_PATH
-          + " --recursive=true";
-      CommandResult cmdResult = executeCommand(command);
-      printCommandOutput(cmdResult);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-      validateResult(cmdResult, true);
-      validateLocationsResult(cmdResult, 6); // 3 Regions X 2 members = 6
-    }
-  }
-
-  @Test
-  public void testGetLocateEntryFromRegionOnDifferentVM() {
-    final String keyPrefix = "testKey";
-    final String valuePrefix = "testValue";
-
-    setupForGetPutRemoveLocateEntry("testGetLocateEntryFromRegionOnDifferentVM");
-
-    final VM vm1 = Host.getHost(0).getVM(1);
-    final VM vm2 = Host.getHost(0).getVM(2);
-
-    SerializableRunnable putKeys1 = new SerializableRunnable() {
-      @Override
-      public void run() {
-        Cache cache = getCache();
-        Region region = cache.getRegion(DATA_REGION_NAME_VM1_PATH);
-        Region parRegion = cache.getRegion(DATA_PAR_REGION_NAME_VM1_PATH);
-        assertNotNull(region);
-        region.clear();
-        for (int i = 0; i < COUNT; i++) {
-          if (i % 2 == 0) {
-            String key = keyPrefix + i;
-            String value = valuePrefix + i;
-            region.put(key, value);
-            parRegion.put(key, value);
-          }
-        }
-      }
-    };
-
-    SerializableRunnable putKeys2 = new SerializableRunnable() {
-      @Override
-      public void run() {
-        Cache cache = getCache();
-        Region region = cache.getRegion(DATA_REGION_NAME_VM2_PATH);
-        Region parRegion = cache.getRegion(DATA_PAR_REGION_NAME_VM2_PATH);
-        assertNotNull(region);
-        region.clear();
-        for (int i = 0; i < COUNT; i++) {
-          if (i % 2 != 0) {
-            String key = keyPrefix + i;
-            String value = valuePrefix + i;
-            region.put(key, value);
-            parRegion.put(key, value);
-          }
-        }
-      }
-    };
-
-    vm1.invoke(putKeys1);
-    vm2.invoke(putKeys2);
-    for (int i = 0; i < COUNT; i++) {
-      String command = "get";
-      String key = keyPrefix + i;
-      String value = valuePrefix + i;
-      if (i % 2 == 0)
-        command = command + " " + "--key=" + key + " --region=" + DATA_REGION_NAME_VM1_PATH;
-      else if (i % 2 == 1)
-        command = command + " " + "--key=" + key + " --region=" + DATA_REGION_NAME_VM2_PATH;
-      CommandResult cmdResult = executeCommand(command);
-      printCommandOutput(cmdResult);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-      validateResult(cmdResult, true);
-
-      command = "locate entry";
-      if (i % 2 == 0)
-        command = command + " " + "--key=" + key + " --region=" + DATA_REGION_NAME_VM1_PATH;
-      else if (i % 2 == 1)
-        command = command + " " + "--key=" + key + " --region=" + DATA_REGION_NAME_VM2_PATH;
-      cmdResult = executeCommand(command);
-      printCommandOutput(cmdResult);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-      validateResult(cmdResult, true);
-
-
-      command = "locate entry";
-      if (i % 2 == 0)
-        command = command + " " + "--key=" + key + " --region=" + DATA_PAR_REGION_NAME_VM1_PATH;
-      else if (i % 2 == 1)
-        command = command + " " + "--key=" + key + " --region=" + DATA_PAR_REGION_NAME_VM2_PATH;
-      cmdResult = executeCommand(command);
-      printCommandOutput(cmdResult);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-      validateResult(cmdResult, true);
-      validateLocationsResult(cmdResult, 1); // 1 Regions X (2-1) 2 Copies but redundancy not
-                                             // satisfied = 1
-    }
-  }
-
-  @Test // FlakyTest: GEODE-1822
-  public void testGetLocateEntryLocationsForPR() {
-    final String keyPrefix = "testKey";
-    final String valuePrefix = "testValue";
-
-    setupForGetPutRemoveLocateEntry("testGetLocateEntryLocationsForPR");
-    final VM vm1 = Host.getHost(0).getVM(1);
-
-    SerializableRunnable putKeys1 = new SerializableRunnable() {
-      @Override
-      public void run() {
-        Cache cache = getCache();
-        Region region = cache.getRegion(DATA_PAR_REGION_NAME_PATH);
-        assertNotNull(region);
-        for (int i = 0; i < COUNT; i++) {
-          String key = keyPrefix + i;
-          String value = valuePrefix + i;
-          region.put(key, value);
-        }
-      }
-    };
-
-    vm1.invoke(putKeys1);
-
-    for (int i = 0; i < COUNT; i++) {
-      String key = keyPrefix + i;
-      String command = "locate entry";
-      command = command + " " + "--key=" + key + " --region=" + DATA_PAR_REGION_NAME_PATH;
-      CommandResult cmdResult = executeCommand(command);
-      printCommandOutput(cmdResult);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-      validateResult(cmdResult, true);
-      validateLocationsResult(cmdResult, 2); // 2 Members
-    }
-  }
-
-  @Test
-  public void testPutFromRegionOnDifferentVM() {
-    final String keyPrefix = "testKey";
-    final String valuePrefix = "testValue";
-
-    setupForGetPutRemoveLocateEntry("testPutFromRegionOnDifferentVM");
-
-    final VM vm1 = Host.getHost(0).getVM(1);
-    final VM vm2 = Host.getHost(0).getVM(2);
-
-    for (int i = 0; i < COUNT; i++) {
-      String command = "put";
-      String key = keyPrefix + i;
-      String value = valuePrefix + i;
-      if (i % 2 == 0)
-        command = command + " " + "--key=" + key + " --value=" + value + " --region="
-            + DATA_REGION_NAME_VM1_PATH;
-      else
-        command = command + " " + "--key=" + key + " --value=" + value + " --region="
-            + DATA_REGION_NAME_VM2_PATH;
-      CommandResult cmdResult = executeCommand(command);
-      printCommandOutput(cmdResult);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-      validateResult(cmdResult, true);
-    }
-
-    SerializableRunnable checkPutKeysInVM1 = new SerializableRunnable() {
-      @Override
-      public void run() {
-        Cache cache = getCache();
-        Region region = cache.getRegion(DATA_REGION_NAME_VM1_PATH);
-        assertNotNull(region);
-        for (int i = 0; i < COUNT; i++) {
-          if (i % 2 == 0) {
-            String key = keyPrefix + i;
-            assertEquals(true, region.containsKey(key));
-          }
-        }
-      }
-    };
-
-    SerializableRunnable checkPutKeysInVM2 = new SerializableRunnable() {
-      @Override
-      public void run() {
-        Cache cache = getCache();
-        Region region = cache.getRegion(DATA_REGION_NAME_VM2_PATH);
-        assertNotNull(region);
-        for (int i = 0; i < COUNT; i++) {
-          if (i % 2 != 0) {
-            String key = keyPrefix + i;
-            assertEquals(true, region.containsKey(key));
-          }
-        }
-      }
-    };
-
-    vm1.invoke(checkPutKeysInVM1);
-    vm2.invoke(checkPutKeysInVM2);
-  }
-
-  @Test // FlakyTest: GEODE-1182
-  public void testGetLocateEntryJsonKeys() {
-    final String keyPrefix = "testKey";
-
-    setupForGetPutRemoveLocateEntry("testGetLocateEntryJsonKeys");
-
-    final VM vm1 = Host.getHost(0).getVM(1);
-    final VM vm2 = Host.getHost(0).getVM(2);
-
-    SerializableRunnable putKeys = new SerializableRunnable() {
-      @Override
-      public void run() {
-        Cache cache = getCache();
-        Region region = cache.getRegion(DATA_REGION_NAME_PATH);
-        assertNotNull(region);
-        region.clear();
-        for (int i = 0; i < COUNT; i++) {
-          String keyString = keyPrefix + i;
-          Key1 key = new Key1();
-          key.setId(keyString);
-          key.setName("name" + keyString);
-          Value2 value2 = new Value2();
-          value2.setStateName("State" + keyString);
-          value2.setCapitalCity("capital" + keyString);
-          value2.setPopulation(i * 100);
-          value2.setAreaInSqKm(i * 100.4365);
-          region.put(key, value2);
-        }
-
-        // Added for Bug #51175
-        List<String> colors = new ArrayList<String>();
-        colors.add("White");
-        colors.add("Red");
-        colors.add("Blue");
-        Map<String, String> attrMap = new HashMap<String, String>();
-        attrMap.put("power", "90hp");
-        attrMap.put("turningRadius", "4mtr");
-        attrMap.put("engineCapacity", "1248cc");
-        attrMap.put("turboGeometry", "VGT");
-
-        Set<String> attrSet = new HashSet<String>();
-        attrSet.add("power");
-        attrSet.add("turningRadius");
-
-        for (int i = COUNT; i < COUNT + 5; i++) {
-          String keyString = keyPrefix + i;
-          Key1 key = new Key1();
-          key.setId(keyString);
-          key.setName("name" + keyString);
-          Car car = new Car();
-          car.setMake("Make" + keyString);
-          car.setModel("Model" + keyString);
-          car.setColors(colors);
-          car.setAttributes(attrMap);
-          car.setAttributeSet(attrSet);
-          region.put(key, car);
-        }
-      }
-    };
-
-    String expectedCols[] = {"id", "name", "stateName", "capitalCity", "population", "areaInSqKm"};
-    vm1.invoke(putKeys);
-    for (int i = 0; i < COUNT; i++) {
-      String command = "get";
-      String keyString = keyPrefix + i;
-      String population = "" + i * 100;
-      String area = "" + i * (100.4365);
-      String keyJson = keyTemplate.replaceAll("\\?", keyString);
-      String valueJson = valueTemplate.replaceAll("\\?1", population);
-      valueJson = valueJson.replaceAll("\\?2", area);
-      valueJson = valueJson.replaceAll("\\?", keyString);
-      getLogWriter().info("Getting key with json key : " + keyJson);
-      command = command + " " + "--key=" + keyJson + " --region=" + DATA_REGION_NAME_PATH
-          + " --key-class=" + Key1.class.getCanonicalName();
-      command = command + " --value-class=" + Value2.class.getCanonicalName();
-      CommandResult cmdResult = executeCommand(command);
-      printCommandOutput(cmdResult);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-      validateResult(cmdResult, true);
-      validateJSONGetResult(cmdResult, expectedCols);
-
-      command = "locate entry";
-      command = command + " " + "--key=" + keyJson + " --region=" + DATA_REGION_NAME_PATH
-          + " --key-class=" + Key1.class.getCanonicalName();
-      command = command + " --value-class=" + Value2.class.getCanonicalName();
-      cmdResult = executeCommand(command);
-      printCommandOutput(cmdResult);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-      validateResult(cmdResult, true);
-    }
-
-    // Added for Bug #51175
-    expectedCols =
-        new String[] {"id", "name", "attributes", "make", "model", "colors", "attributeSet"};
-    for (int i = COUNT; i < COUNT + 5; i++) {
-      String command = "get";
-      String keyString = keyPrefix + i;
-      String population = "" + i * 100;
-      String area = "" + i * (100.4365);
-      String keyJson = keyTemplate.replaceAll("\\?", keyString);
-      String valueJson = valueTemplate.replaceAll("\\?1", population);
-      valueJson = valueJson.replaceAll("\\?2", area);
-      valueJson = valueJson.replaceAll("\\?", keyString);
-      getLogWriter().info("Getting key with json key : " + keyJson);
-      command = command + " " + "--key=" + keyJson + " --region=" + DATA_REGION_NAME_PATH
-          + " --key-class=" + Key1.class.getCanonicalName();
-      command = command + " --value-class=" + Value2.class.getCanonicalName();
-      CommandResult cmdResult = executeCommand(command);
-      printCommandOutput(cmdResult);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-      validateResult(cmdResult, true);
-      // validateJSONGetResult(cmdResult, expectedCols);
-      validateJSONGetResultValues(cmdResult, expectedCols);
-
-      command = "locate entry";
-      command = command + " " + "--key=" + keyJson + " --region=" + DATA_REGION_NAME_PATH
-          + " --key-class=" + Key1.class.getCanonicalName();
-      command = command + " --value-class=" + Value2.class.getCanonicalName();
-      cmdResult = executeCommand(command);
-      printCommandOutput(cmdResult);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-      validateResult(cmdResult, true);
-    }
-  }
-
-  @Test // FlakyTest: GEODE-1430
-  public void testPutJsonKeys() {
-    final String keyPrefix = "testKey";
-
-    setupForGetPutRemoveLocateEntry("testPutJsonKeys");
-
-    final VM vm1 = Host.getHost(0).getVM(1);
-    final VM vm2 = Host.getHost(0).getVM(2);
-
-    for (int i = 0; i < COUNT; i++) {
-      String command = "put";
-      String keyString = keyPrefix + i;
-      String population = "" + i * 100;
-      String area = "" + i * (100.4365);
-      String keyJson = keyTemplate.replaceAll("\\?", keyString);
-      String valueJson = valueTemplate.replaceAll("\\?1", population);
-      valueJson = valueJson.replaceAll("\\?2", area);
-      valueJson = valueJson.replaceAll("\\?", keyString);
-      getLogWriter().info("Putting key with json key : " + keyJson);
-      getLogWriter().info("Putting key with json valye : " + valueJson);
-      command = command + " " + "--key=" + keyJson + " --value=" + valueJson + " --region="
-          + DATA_REGION_NAME_PATH;
-      command = command + " --key-class=" + Key1.class.getCanonicalName() + " --value-class="
-          + Value2.class.getCanonicalName();
-      CommandResult cmdResult = executeCommand(command);
-      printCommandOutput(cmdResult);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-      validateResult(cmdResult, true);
-    }
-
-    // Bug #51175
-    for (int i = COUNT; i < COUNT + 5; i++) {
-      String command = "put";
-      String keyString = keyPrefix + i;
-      String id = "" + i * 100;
-      String make = "" + i * (100.4365);
-      String model = "" + i * (100.4365);
-      String list = "['red','white','blue']";
-      String set = "['red','white','blue']";
-      String map = "{'power':'90hp'}";
-      String keyJson = keyTemplate.replaceAll("\\?", keyString);
-
-      String valueJson = carTemplate.replaceAll("\\?make", make);
-      valueJson = valueJson.replaceAll("\\?model", model);
-      valueJson = valueJson.replaceAll("\\?list", list);
-      valueJson = valueJson.replaceAll("\\?set", set);
-      valueJson = valueJson.replaceAll("\\?map", map);
-
-      getLogWriter().info("Putting key with json key : " + keyJson);
-      getLogWriter().info("Putting key with json valye : " + valueJson);
-      command = command + " " + "--key=" + keyJson + " --value=" + valueJson + " --region="
-          + DATA_REGION_NAME_PATH;
-      command = command + " --key-class=" + Key1.class.getCanonicalName() + " --value-class="
-          + Car.class.getCanonicalName();
-      CommandResult cmdResult = executeCommand(command);
-      printCommandOutput(cmdResult);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-      validateResult(cmdResult, true);
-    }
-
-    SerializableRunnable checkPutKeys = new SerializableRunnable() {
-      @Override
-      public void run() {
-        Cache cache = getCache();
-        Region region = cache.getRegion(DATA_REGION_NAME_PATH);
-        assertNotNull(region);
-        for (int i = 0; i < COUNT + 5; i++) {
-          String keyString = keyPrefix + i;
-          Key1 key = new Key1();
-          key.setId(keyString);
-          key.setName("name" + keyString);
-          assertEquals(true, region.containsKey(key));
-
-          // Bug #51175
-          if (i >= COUNT) {
-            Car car = (Car) region.get(key);
-            assertNotNull(car.getAttributes());
-            assertNotNull(car.getAttributeSet());
-            assertNotNull(car.getColors());
-          }
-
-        }
-      }
-    };
-
-    vm1.invoke(checkPutKeys);
-    vm2.invoke(checkPutKeys);
-
-    doBugCheck50449();
-  }
-
-  public void doBugCheck50449() {
-    String command = "put --key-class=" + ObjectWithCharAttr.class.getCanonicalName()
-        + " --value=456 --key=\"('name':'hesdfdsfy2','t':456, 'c':'d')\"" + " --region="
-        + DATA_REGION_NAME_PATH;
-    CommandResult cmdResult = executeCommand(command);
-    printCommandOutput(cmdResult);
-    assertEquals(Result.Status.OK, cmdResult.getStatus());
-    validateResult(cmdResult, true);
-
-    command = "put --key-class=" + ObjectWithCharAttr.class.getCanonicalName()
-        + " --value=123 --key=\"('name':'hesdfdsfy2','t':123, 'c':'d')\"" + " --region="
-        + DATA_REGION_NAME_PATH;
-    cmdResult = executeCommand(command);
-    printCommandOutput(cmdResult);
-    assertEquals(Result.Status.OK, cmdResult.getStatus());
-    validateResult(cmdResult, true);
-
-    command = "get --key-class=" + ObjectWithCharAttr.class.getCanonicalName()
-        + " --key=\"('name':'','t':123, 'c':'d')\"" + " --region=" + DATA_REGION_NAME_PATH;
-    cmdResult = executeCommand(command);
-    printCommandOutput(cmdResult);
-    assertEquals(Result.Status.OK, cmdResult.getStatus());
-    validateResult(cmdResult, true);
-
-    command = "get --key-class=" + ObjectWithCharAttr.class.getCanonicalName()
-        + " --key=\"('name':'','t':456, 'c':'d')\"" + " --region=" + DATA_REGION_NAME_PATH;
-    cmdResult = executeCommand(command);
-    printCommandOutput(cmdResult);
-    assertEquals(Result.Status.OK, cmdResult.getStatus());
-    validateResult(cmdResult, true);
-
-    // check wrong key
-    command = "get --key-class=" + ObjectWithCharAttr.class.getCanonicalName()
-        + " --key=\"('name':'','t':999, 'c':'d')\"" + " --region=" + DATA_REGION_NAME_PATH;
-    cmdResult = executeCommand(command);
-    printCommandOutput(cmdResult);
-    assertEquals(Result.Status.OK, cmdResult.getStatus());
-    validateResult(cmdResult, false);
-  }
-
   private Region<?, ?> createParReg(String regionName, Cache cache) {
     RegionFactory regionFactory = cache.createRegionFactory();
     regionFactory.setDataPolicy(DataPolicy.PARTITION);
@@ -1513,164 +859,6 @@ public void doBugCheck50449() {
     return regionFactory.create(regionName);
   }
 
-  @Test // FlakyTest: GEODE-1404
-  public void testImportExportData() throws InterruptedException, IOException {
-    final String regionName = "Region1";
-    final String exportFileName = "export.gfd";
-    final VM manager = Host.getHost(0).getVM(0);
-    final VM vm1 = Host.getHost(0).getVM(1);
-    final File exportFile = new File(exportFileName);
-    final String filePath = exportFile.getCanonicalPath();
-
-    try {
-      if (!exportFile.exists()) {
-        exportFile.createNewFile();
-      }
-      exportFile.deleteOnExit();
-
-      setUpJmxManagerOnVm0ThenConnect(null);
-
-      manager.invoke(new SerializableRunnable() {
-        public void run() {
-          createParReg(regionName, getCache());
-        }
-      });
-
-      vm1.invoke(new SerializableRunnable() {
-        @Override
-        public void run() throws Exception {
-          Region region = createParReg(regionName, getCache());
-          for (int i = 0; i < 100; i++) {
-            region.put(i, i);
-          }
-        }
-      });
-
-      CommandStringBuilder csb = new CommandStringBuilder(CliStrings.EXPORT_DATA);
-      csb.addOption(CliStrings.EXPORT_DATA__REGION, regionName);
-      csb.addOption(CliStrings.MEMBER, "Manager");
-      csb.addOption(CliStrings.EXPORT_DATA__FILE, filePath);
-      String commandString = csb.toString();
-
-      CommandResult cmdResult = executeCommand(commandString);
-      String resultAsString = commandResultToString(cmdResult);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-      getLogWriter().info("Command Output");
-      getLogWriter().info(resultAsString);
-
-      vm1.invoke(new SerializableRunnable() {
-        public void run() {
-          Region region = getCache().getRegion(regionName);
-          for (int i = 0; i < 100; i++) {
-            region.destroy(i);
-          }
-        }
-      });
-
-      /*
-       * Add CacheListener
-       */
-
-      manager.invoke(addCacheListenerInvocations(regionName));
-      vm1.invoke(addCacheListenerInvocations(regionName));
-
-      /*
-       * Import the data
-       */
-
-      csb = new CommandStringBuilder(CliStrings.IMPORT_DATA);
-      csb.addOption(CliStrings.IMPORT_DATA__REGION, regionName);
-      csb.addOption(CliStrings.IMPORT_DATA__FILE, filePath);
-      csb.addOption(CliStrings.MEMBER, "Manager");
-
-      commandString = csb.toString();
-      cmdResult = executeCommand(commandString);
-      resultAsString = commandResultToString(cmdResult);
-
-      getLogWriter().info("Result of import data");
-      getLogWriter().info(resultAsString);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-
-      /*
-       * Validate the region entries after import They must match the entries before export
-       */
-
-      manager.invoke(new SerializableRunnable() {
-        public void run() {
-          Region region = getCache().getRegion(regionName);
-          for (int i = 0; i < 100; i++) {
-            assertEquals(i, region.get(i));
-          }
-        }
-      });
-
-      /*
-       * Verify callbacks were not invoked
-       */
-
-      manager.invoke(verifyCacheListenerInvocations(regionName, false));
-      vm1.invoke(verifyCacheListenerInvocations(regionName, false));
-
-      /*
-       * Import the data with invokeCallbacks=true
-       */
-
-      vm1.invoke(new SerializableRunnable() {
-        public void run() {
-          Region region = getCache().getRegion(regionName);
-          for (int i = 0; i < 100; i++) {
-            region.destroy(i);
-          }
-        }
-      });
-
-      csb = new CommandStringBuilder(CliStrings.IMPORT_DATA);
-      csb.addOption(CliStrings.IMPORT_DATA__REGION, regionName);
-      csb.addOption(CliStrings.IMPORT_DATA__FILE, filePath);
-      csb.addOption(CliStrings.MEMBER, "Manager");
-      csb.addOption(CliStrings.IMPORT_DATA__INVOKE_CALLBACKS, "true");
-      commandString = csb.toString();
-      cmdResult = executeCommand(commandString);
-      commandResultToString(cmdResult);
-      assertEquals(Result.Status.OK, cmdResult.getStatus());
-
-      /*
-       * Verify callbacks were invoked
-       */
-
-      manager.invoke(verifyCacheListenerInvocations(regionName, true));
-      vm1.invoke(verifyCacheListenerInvocations(regionName, true));
-
-      // Test for bad input
-      csb = new CommandStringBuilder(CliStrings.EXPORT_DATA);
-      csb.addOption(CliStrings.EXPORT_DATA__REGION, "FDSERW");
-      csb.addOption(CliStrings.EXPORT_DATA__FILE, filePath);
-      csb.addOption(CliStrings.MEMBER, "Manager");
-      commandString = csb.getCommandString();
-
-      cmdResult = executeCommand(commandString);
-      resultAsString = commandResultToString(cmdResult);
-      getLogWriter().info("Result of import data with wrong region name");
-      getLogWriter().info(resultAsString);
-      assertEquals(Result.Status.ERROR, cmdResult.getStatus());
-
-      csb = new CommandStringBuilder(CliStrings.IMPORT_DATA);
-      csb.addOption(CliStrings.IMPORT_DATA__REGION, regionName);
-      csb.addOption(CliStrings.IMPORT_DATA__FILE, "#WEQW");
-      csb.addOption(CliStrings.MEMBER, "Manager");
-      commandString = csb.getCommandString();
-
-      cmdResult = executeCommand(commandString);
-      resultAsString = commandResultToString(cmdResult);
-      getLogWriter().info("Result of import data with wrong file");
-      getLogWriter().info(resultAsString);
-      assertEquals(Result.Status.ERROR, cmdResult.getStatus());
-
-    } finally {
-      exportFile.delete();
-    }
-  }
-
   private SerializableRunnable addCacheListenerInvocations(final String regionName) {
     return new SerializableRunnable() {
       public void run() {
@@ -2141,9 +1329,8 @@ public Object call() {
     String memSizeFromFunctionCall = (String) manager.invoke(new SerializableCallable() {
       public Object call() {
         InternalCache cache = GemFireCacheImpl.getInstance();
-        CliUtil.getMembersForeRegionViaFunction(cache, DATA_REGION_NAME_PATH, true);
-        return ""
-            + CliUtil.getMembersForeRegionViaFunction(cache, DATA_REGION_NAME_PATH, true).size();
+        CliUtil.getRegionAssociatedMembers(DATA_REGION_NAME_PATH, cache, true);
+        return "" + CliUtil.getRegionAssociatedMembers(DATA_REGION_NAME_PATH, cache, true).size();
       }
     });
 
@@ -2184,8 +1371,7 @@ public Object call() {
     String memSizeFromFunctionCall = (String) manager.invoke(new SerializableCallable() {
       public Object call() {
         InternalCache cache = GemFireCacheImpl.getInstance();
-        return ""
-            + CliUtil.getMembersForeRegionViaFunction(cache, REBALANCE_REGION_NAME, true).size();
+        return "" + CliUtil.getRegionAssociatedMembers(REBALANCE_REGION_NAME, cache, true).size();
       }
     });
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GfshCommandJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GfshCommandJUnitTest.java
index 894a7738d7..27c41427cc 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GfshCommandJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GfshCommandJUnitTest.java
@@ -24,7 +24,6 @@
 import static org.apache.geode.distributed.ConfigurationProperties.START_DEV_REST_API;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
@@ -33,10 +32,8 @@
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Properties;
-import java.util.Set;
 
 import org.jmock.Expectations;
 import org.jmock.Mockery;
@@ -50,14 +47,10 @@
 import org.apache.geode.cache.execute.Function;
 import org.apache.geode.cache.execute.FunctionService;
 import org.apache.geode.distributed.DistributedMember;
-import org.apache.geode.distributed.DistributedSystem;
 import org.apache.geode.distributed.internal.DistributionConfig;
 import org.apache.geode.internal.cache.InternalCache;
 import org.apache.geode.internal.lang.StringUtils;
-import org.apache.geode.internal.util.CollectionUtils;
 import org.apache.geode.management.cli.CliMetaData;
-import org.apache.geode.management.internal.cli.i18n.CliStrings;
-import org.apache.geode.management.internal.cli.util.MemberNotFoundException;
 import org.apache.geode.test.junit.categories.UnitTest;
 
 /**
@@ -139,182 +132,6 @@ public void testConvertDefaultValue() {
   }
 
   @Test
-  public void testGetMemberWithMatchingMemberId() {
-    final InternalCache mockCache = mockContext.mock(InternalCache.class, "InternalCache");
-
-    final DistributedSystem mockDistributedSystem =
-        mockContext.mock(DistributedSystem.class, "DistributedSystem");
-
-    final DistributedMember mockMemberSelf = createMockMember("S", "Self");
-    final DistributedMember mockMemberOne = createMockMember("1", "One");
-    final DistributedMember mockMemberTwo = createMockMember("2", "Two");
-
-    mockContext.checking(new Expectations() {
-      {
-        oneOf(mockCache).getMembers();
-        will(returnValue(CollectionUtils.asSet(mockMemberOne, mockMemberTwo)));
-        oneOf(mockCache).getDistributedSystem();
-        will(returnValue(mockDistributedSystem));
-        oneOf(mockDistributedSystem).getDistributedMember();
-        will(returnValue(mockMemberSelf));
-      }
-    });
-
-    final GfshCommand commands = createAbstractCommandsSupport(mockCache);
-
-    assertSame(mockMemberTwo, commands.getMember(mockCache, "2"));
-  }
-
-  @Test
-  public void testGetMemberWithMatchingMemberName() {
-    final InternalCache mockCache = mockContext.mock(InternalCache.class, "InternalCache");
-
-    final DistributedSystem mockDistributedSystem =
-        mockContext.mock(DistributedSystem.class, "DistributedSystem");
-
-    final DistributedMember mockMemberSelf = createMockMember("S", "Self");
-    final DistributedMember mockMemberOne = createMockMember("1", "One");
-    final DistributedMember mockMemberTwo = createMockMember("2", "Two");
-
-    mockContext.checking(new Expectations() {
-      {
-        oneOf(mockCache).getMembers();
-        will(returnValue(CollectionUtils.asSet(mockMemberOne, mockMemberTwo)));
-        oneOf(mockCache).getDistributedSystem();
-        will(returnValue(mockDistributedSystem));
-        oneOf(mockDistributedSystem).getDistributedMember();
-        will(returnValue(mockMemberSelf));
-      }
-    });
-
-    final GfshCommand commands = createAbstractCommandsSupport(mockCache);
-
-    assertSame(mockMemberOne, commands.getMember(mockCache, "One"));
-  }
-
-  @Test
-  public void testGetMemberWithMatchingMemberNameCaseInsensitive() {
-    final InternalCache mockCache = mockContext.mock(InternalCache.class, "InternalCache");
-
-    final DistributedSystem mockDistributedSystem =
-        mockContext.mock(DistributedSystem.class, "DistributedSystem");
-
-    final DistributedMember mockMemberSelf = createMockMember("S", "Self");
-    final DistributedMember mockMemberOne = createMockMember("1", "One");
-    final DistributedMember mockMemberTwo = createMockMember("2", "Two");
-
-    mockContext.checking(new Expectations() {
-      {
-        oneOf(mockCache).getMembers();
-        will(returnValue(CollectionUtils.asSet(mockMemberOne, mockMemberTwo)));
-        oneOf(mockCache).getDistributedSystem();
-        will(returnValue(mockDistributedSystem));
-        oneOf(mockDistributedSystem).getDistributedMember();
-        will(returnValue(mockMemberSelf));
-      }
-    });
-
-    final GfshCommand commands = createAbstractCommandsSupport(mockCache);
-
-    assertSame(mockMemberSelf, commands.getMember(mockCache, "self"));
-  }
-
-  @Test(expected = MemberNotFoundException.class)
-  public void testGetMemberThrowsMemberNotFoundException() {
-    final InternalCache mockCache = mockContext.mock(InternalCache.class, "InternalCache");
-
-    final DistributedSystem mockDistributedSystem =
-        mockContext.mock(DistributedSystem.class, "DistributedSystem");
-
-    final DistributedMember mockMemberSelf = createMockMember("S", "Self");
-    final DistributedMember mockMemberOne = createMockMember("1", "One");
-    final DistributedMember mockMemberTwo = createMockMember("2", "Two");
-
-    mockContext.checking(new Expectations() {
-      {
-        oneOf(mockCache).getMembers();
-        will(returnValue(CollectionUtils.asSet(mockMemberOne, mockMemberTwo)));
-        oneOf(mockCache).getDistributedSystem();
-        will(returnValue(mockDistributedSystem));
-        oneOf(mockDistributedSystem).getDistributedMember();
-        will(returnValue(mockMemberSelf));
-      }
-    });
-
-    final GfshCommand commands = createAbstractCommandsSupport(mockCache);
-
-    try {
-      commands.getMember(mockCache, "zero");
-    } catch (MemberNotFoundException expected) {
-      assertEquals(CliStrings.format(CliStrings.MEMBER_NOT_FOUND_ERROR_MESSAGE, "zero"),
-          expected.getMessage());
-      throw expected;
-    }
-  }
-
-  @Test
-  public void testGetMembers() {
-    final InternalCache mockCache = mockContext.mock(InternalCache.class, "InternalCache");
-
-    final DistributedSystem mockDistributedSystem =
-        mockContext.mock(DistributedSystem.class, "DistributedSystem");
-
-    final DistributedMember mockMemberSelf = createMockMember("S", "Self");
-    final DistributedMember mockMemberOne = createMockMember("1", "One");
-    final DistributedMember mockMemberTwo = createMockMember("2", "Two");
-
-    mockContext.checking(new Expectations() {
-      {
-        oneOf(mockCache).getMembers();
-        will(returnValue(CollectionUtils.asSet(mockMemberOne, mockMemberTwo)));
-        oneOf(mockCache).getDistributedSystem();
-        will(returnValue(mockDistributedSystem));
-        oneOf(mockDistributedSystem).getDistributedMember();
-        will(returnValue(mockMemberSelf));
-      }
-    });
-
-    final GfshCommand commands = createAbstractCommandsSupport(mockCache);
-
-    final Set<DistributedMember> expectedMembers =
-        CollectionUtils.asSet(mockMemberOne, mockMemberTwo, mockMemberSelf);
-    final Set<DistributedMember> actualMembers = commands.getMembers(mockCache);
-
-    assertNotNull(actualMembers);
-    assertEquals(expectedMembers.size(), actualMembers.size());
-    assertTrue(actualMembers.containsAll(expectedMembers));
-  }
-
-  @Test
-  public void testGetMembersContainsOnlySelf() {
-    final InternalCache mockCache = mockContext.mock(InternalCache.class, "InternalCache");
-
-    final DistributedSystem mockDistributedSystem =
-        mockContext.mock(DistributedSystem.class, "DistributedSystem");
-    final DistributedMember mockMemberSelf = createMockMember("S", "Self");
-
-    mockContext.checking(new Expectations() {
-      {
-        oneOf(mockCache).getMembers();
-        will(returnValue(Collections.emptySet()));
-        oneOf(mockCache).getDistributedSystem();
-        will(returnValue(mockDistributedSystem));
-        oneOf(mockDistributedSystem).getDistributedMember();
-        will(returnValue(mockMemberSelf));
-      }
-    });
-
-    final GfshCommand commands = createAbstractCommandsSupport(mockCache);
-
-    final Set<DistributedMember> expectedMembers = CollectionUtils.asSet(mockMemberSelf);
-    final Set<DistributedMember> actualMembers = commands.getMembers(mockCache);
-
-    assertNotNull(actualMembers);
-    assertEquals(expectedMembers.size(), actualMembers.size());
-    assertTrue(actualMembers.containsAll(expectedMembers));
-  }
-
-  @Test
   public void testRegister() {
     try {
       final Function mockFunction = mockContext.mock(Function.class, "Function");
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ImportDataCommandTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ImportDataCommandTest.java
new file mode 100644
index 0000000000..f2f837eb27
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ImportDataCommandTest.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.test.junit.categories.UnitTest;
+import org.apache.geode.test.junit.rules.GfshParserRule;
+
+
+@Category(UnitTest.class)
+public class ImportDataCommandTest {
+
+  @ClassRule
+  public static GfshParserRule gfsh = new GfshParserRule();
+
+  @Test
+  public void manditaryOptions() throws Exception {
+    assertThat(gfsh.parse("import data --region=regionA --file=test")).isNull();
+    assertThat(gfsh.parse("import data --member=regionA --file=test")).isNull();
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ImportDataIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ImportDataIntegrationTest.java
index 5dfbc83a14..d599a6d0f8 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ImportDataIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ImportDataIntegrationTest.java
@@ -128,7 +128,8 @@ public void testInvalidMember() throws Exception {
         .addOption(CliStrings.IMPORT_DATA__REGION, TEST_REGION_NAME)
         .addOption(CliStrings.IMPORT_DATA__FILE, snapshotFile.toString()).getCommandString();
     gfsh.executeCommand(invalidMemberCommand);
-    assertThat(gfsh.getGfshOutput()).contains("Member " + invalidMemberName + " not found");
+    assertThat(gfsh.getGfshOutput())
+        .contains("Member " + invalidMemberName + " could not be found");
   }
 
   @Test
@@ -152,24 +153,6 @@ public void testInvalidFile() throws Exception {
   }
 
   @Test
-  public void testMissingRegion() throws Exception {
-    String missingRegionCommand = new CommandStringBuilder(CliStrings.IMPORT_DATA)
-        .addOption(CliStrings.MEMBER, server.getName())
-        .addOption(CliStrings.IMPORT_DATA__FILE, snapshotFile.toString()).getCommandString();
-    gfsh.executeCommand(missingRegionCommand);
-    assertThat(gfsh.getGfshOutput()).contains("You should specify option");
-  }
-
-  @Test
-  public void testMissingMember() throws Exception {
-    String missingMemberCommand = new CommandStringBuilder(CliStrings.EXPORT_DATA)
-        .addOption(CliStrings.IMPORT_DATA__REGION, TEST_REGION_NAME)
-        .addOption(CliStrings.IMPORT_DATA__FILE, snapshotFile.toString()).getCommandString();
-    gfsh.executeCommand(missingMemberCommand);
-    assertThat(gfsh.getGfshOutput()).contains("You should specify option");
-  }
-
-  @Test
   public void testMissingFileAndDirectory() throws Exception {
     String missingFileAndDirCommand = buildBaseImportCommand().getCommandString();
     gfsh.executeCommand(missingFileAndDirCommand);
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListIndexCommandJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListIndexCommandJUnitTest.java
index d874c4191f..60d9168cf8 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListIndexCommandJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListIndexCommandJUnitTest.java
@@ -209,7 +209,7 @@ public InternalCache getCache() {
     }
 
     @Override
-    public Set<DistributedMember> getMembers(final InternalCache cache) {
+    public Set<DistributedMember> getAllMembers(final InternalCache cache) {
       assertSame(getCache(), cache);
       return Collections.emptySet();
     }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/LocateEntryDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/LocateEntryDUnitTest.java
new file mode 100644
index 0000000000..573fc63c2e
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/LocateEntryDUnitTest.java
@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.management.internal.cli.dto.Key;
+import org.apache.geode.management.internal.cli.dto.Value;
+import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
+import org.apache.geode.test.junit.categories.DistributedTest;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+
+
+@Category(DistributedTest.class)
+public class LocateEntryDUnitTest {
+  @ClassRule
+  public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
+
+  @ClassRule
+  public static GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+
+  private static MemberVM locator, server1, server2;
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    locator = lsRule.startLocatorVM(0);
+    server1 = lsRule.startServerVM(1, locator.getPort());
+    server2 = lsRule.startServerVM(2, locator.getPort());
+
+    gfsh.connectAndVerify(locator);
+
+    // create a partitioned region and put an entry
+    gfsh.executeAndAssertThat("create region --name=regionA --type=PARTITION").statusIsSuccess();
+    gfsh.executeAndAssertThat("put --region=regionA --key=key --value=value").statusIsSuccess();
+
+    // create a replicate region and put an entry
+    gfsh.executeAndAssertThat("create region --name=regionB --type=REPLICATE").statusIsSuccess();
+    gfsh.executeAndAssertThat("put --region=regionB --key=key --value=value").statusIsSuccess();
+
+    // create a child replicate region
+    gfsh.executeAndAssertThat("create region --name=regionB/regionBB --type=REPLICATE")
+        .statusIsSuccess();
+    gfsh.executeAndAssertThat("put --region=regionB/regionBB --key=key --value=value")
+        .statusIsSuccess();
+
+    locator.waitTillRegionsAreReadyOnServers("/regionA", 2);
+    locator.waitTillRegionsAreReadyOnServers("/regionB", 2);
+    locator.waitTillRegionsAreReadyOnServers("/regionB/regionBB", 2);
+  }
+
+  @Test
+  public void locateEntryForPartitionedRegion() throws Exception {
+    gfsh.executeAndAssertThat("locate entry --region=regionA --key=key").statusIsSuccess()
+        .containsKeyValuePair("Locations Found", "1");
+  }
+
+  @Test
+  public void locateEntryForReplicateRegion() throws Exception {
+    gfsh.executeAndAssertThat("locate entry --region=regionB --key=key").statusIsSuccess()
+        .containsKeyValuePair("Locations Found", "2");
+  }
+
+  @Test
+  public void recursiveLocate() throws Exception {
+    gfsh.executeAndAssertThat("locate entry --region=regionB --key=key  --recursive=true")
+        .statusIsSuccess().containsKeyValuePair("Locations Found", "4");
+  }
+
+  @Test
+  public void jsonKeyValue() throws Exception {
+    gfsh.executeAndAssertThat(
+        "put --region=regionA --key=('key':'1') --value=('value':'1') " + "--key-class="
+            + Key.class.getCanonicalName() + " --value-class=" + Value.class.getCanonicalName())
+        .statusIsSuccess();
+    gfsh.executeAndAssertThat("locate entry --region=regionA --key=('key':'1') " + "--key-class="
+        + Key.class.getCanonicalName()).statusIsSuccess()
+        .containsKeyValuePair("Locations Found", "1");
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/PutCommandIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/PutCommandIntegrationTest.java
index e50adb7dc5..8ec785a61f 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/PutCommandIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/PutCommandIntegrationTest.java
@@ -15,12 +15,21 @@
 
 package org.apache.geode.management.internal.cli.commands;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.junit.After;
 import org.junit.ClassRule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 import org.junit.rules.RuleChain;
 
 import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.management.internal.cli.dto.Car;
+import org.apache.geode.management.internal.cli.dto.Key;
+import org.apache.geode.management.internal.cli.dto.Key1;
+import org.apache.geode.management.internal.cli.dto.ObjectWithCharAttr;
+import org.apache.geode.management.internal.cli.dto.Value;
+import org.apache.geode.management.internal.cli.dto.Value2;
 import org.apache.geode.test.junit.categories.IntegrationTest;
 import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
 import org.apache.geode.test.junit.rules.ServerStarterRule;
@@ -39,16 +48,81 @@
   public static RuleChain chain = RuleChain.outerRule(server).around(gfsh);
 
 
+  @After
+  public void after() throws Exception {
+    // clear the region after each test
+    server.getCache().getRegion("testRegion").clear();
+  }
+
   @Test
   public void putWithoutSlash() throws Exception {
     gfsh.executeAndAssertThat("put --region=testRegion --key=key1 --value=value1")
         .statusIsSuccess();
+    assertThat(server.getCache().getRegion("testRegion").get("key1")).isEqualTo("value1");
   }
 
 
   @Test
   public void putWithSlash() throws Exception {
     gfsh.executeAndAssertThat("put --region=/testRegion --key=key1 --value=value1")
+        .statusIsSuccess().containsKeyValuePair("Result", "true");
+    assertThat(server.getCache().getRegion("testRegion").get("key1")).isEqualTo("value1");
+  }
+
+  @Test
+  // Bug : 51587 : GFSH command failing when ; is present in either key or value in put operation
+  public void putWithSemicoln() throws Exception {
+    gfsh.executeAndAssertThat("put --region=/testRegion --key=key1;key1 --value=value1;value1")
+        .statusIsSuccess().containsKeyValuePair("Result", "true");
+    assertThat(server.getCache().getRegion("testRegion").get("key1;key1"))
+        .isEqualTo("value1;value1");
+  }
+
+  @Test
+  public void putIfAbsent() throws Exception {
+    gfsh.executeAndAssertThat("put --region=/testRegion --key=key1 --value=value1")
+        .statusIsSuccess().containsKeyValuePair("Result", "true");
+    gfsh.executeAndAssertThat("put --region=/testRegion --key=key1 --value=value2 --skip-if-exists")
         .statusIsSuccess();
+    assertThat(server.getCache().getRegion("testRegion").get("key1")).isEqualTo("value1");
+  }
+
+  @Test
+  public void putWithSimpleJson() throws Exception {
+    gfsh.executeAndAssertThat(
+        "put --region=testRegion --key=('key':'1') --value=('value':'1') " + "--key-class="
+            + Key.class.getCanonicalName() + " --value-class=" + Value.class.getCanonicalName())
+        .statusIsSuccess().containsKeyValuePair("Result", "true");
+  }
+
+  @Test
+  public void putWithComplicatedJson() throws Exception {
+    String keyJson = "('id':'1','name':'name1')";
+    String stateJson =
+        "('stateName':'State1','population':10,'capitalCity':'capital1','areaInSqKm':100)";
+    String carJson =
+        "\"('attributes':?map,'make':'make1','model':'modle1','colors':?list,'attributeSet':?set)\"";
+
+    // put the state json
+    String command =
+        "put --region=testRegion --key=" + keyJson + " --value=" + stateJson + " --key-class="
+            + Key1.class.getCanonicalName() + " --value-class=" + Value2.class.getCanonicalName();
+    gfsh.executeAndAssertThat(command).statusIsSuccess();
+
+    // put the car json
+    String list = "['red','white','blue']";
+    String set = "['red','white','blue']";
+    String map = "{'power':'90hp'}";
+    String valueJson = carJson.replaceAll("\\?list", list);
+    valueJson = valueJson.replaceAll("\\?set", set);
+    valueJson = valueJson.replaceAll("\\?map", map);
+    command = "put --region=testRegion --key=" + keyJson + " --value=" + valueJson + " --key-class="
+        + Key1.class.getCanonicalName() + " --value-class=" + Car.class.getCanonicalName();
+    gfsh.executeAndAssertThat(command).statusIsSuccess();
+
+    // put with json with single character field
+    command = "put --region=testRegion --key-class=" + ObjectWithCharAttr.class.getCanonicalName()
+        + " --value=456 --key=('name':'hesdfdsfy2','t':456,'c':'d')";
+    gfsh.executeAndAssertThat(command).statusIsSuccess();
   }
 }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowLogCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowLogCommandDUnitTest.java
index 6f9dd88e2e..233fb71ef1 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowLogCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowLogCommandDUnitTest.java
@@ -155,8 +155,7 @@ public void testShowLogInvalidMember() throws Exception {
     assertThat(result.getStatus()).isEqualTo(Result.Status.ERROR);
 
     String output = gfsh.getGfshOutput();
-    assertThat(output).contains("Member not found");
-
+    assertThat(output).contains("Member NotAValidMember could not be found");
   }
 
   private static boolean allMembersAreConnected() {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/dto/Key.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/dto/Key.java
new file mode 100644
index 0000000000..ce2d102a1b
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/dto/Key.java
@@ -0,0 +1,41 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.dto;
+
+import java.io.Serializable;
+
+public class Key implements Serializable {
+  private int key;
+
+  public int getKey() {
+    return key;
+  }
+
+  public void setKey(int id) {
+    this.key = id;
+  }
+
+  public boolean equals(Object other) {
+    if (!(other instanceof Key)) {
+      return false;
+    }
+    return ((Key) other).key == this.key;
+  }
+
+  public int hashCode() {
+    return key;
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/dto/Value.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/dto/Value.java
new file mode 100644
index 0000000000..9bf3bf7951
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/dto/Value.java
@@ -0,0 +1,30 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.dto;
+
+import java.io.Serializable;
+
+public class Value implements Serializable {
+  private String value;
+
+  public String getValue() {
+    return value;
+  }
+
+  public void setValue(String value) {
+    this.value = value;
+  }
+}
diff --git a/geode-core/src/test/resources/org/apache/geode/codeAnalysis/excludedClasses.txt b/geode-core/src/test/resources/org/apache/geode/codeAnalysis/excludedClasses.txt
index cbeb2a1a28..583f77e2d4 100644
--- a/geode-core/src/test/resources/org/apache/geode/codeAnalysis/excludedClasses.txt
+++ b/geode-core/src/test/resources/org/apache/geode/codeAnalysis/excludedClasses.txt
@@ -287,6 +287,7 @@ org/apache/geode/internal/cache/InitialImageOperation$GIITestHook
 org/apache/geode/internal/AvailablePort$Keeper
 org/apache/geode/admin/internal/BackupStatusImpl
 org/apache/geode/management/internal/BackupStatusImpl
+org/apache/geode/management/internal/cli/exceptions/UserErrorException
 org/apache/geode/pdx/JSONFormatter$states
 org/apache/geode/internal/memcached/Command
 org/apache/geode/internal/memcached/Command$1
diff --git a/geode-lucene/src/main/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommands.java b/geode-lucene/src/main/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommands.java
index ffe891c2c2..971293b27a 100755
--- a/geode-lucene/src/main/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommands.java
+++ b/geode-lucene/src/main/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommands.java
@@ -107,7 +107,7 @@ public Result listIndex(@CliOption(key = LuceneCliStrings.LUCENE_LIST_INDEX__STA
 
   @SuppressWarnings("unchecked")
   protected List<LuceneIndexDetails> getIndexListing() {
-    final Execution functionExecutor = getMembersFunctionExecutor(getMembers(getCache()));
+    final Execution functionExecutor = getMembersFunctionExecutor(getAllMembers(getCache()));
 
     if (functionExecutor instanceof AbstractExecution) {
       ((AbstractExecution) functionExecutor).setIgnoreDepartedMembers(true);
@@ -365,8 +365,8 @@ private XmlEntity executeDestroyIndexFunction(List<CliFunctionResult> accumulate
     // the index has been created, but not the region
     XmlEntity xmlEntity = null;
     InternalCache cache = getCache();
-    Set<DistributedMember> regionMembers = getRegionMembers(cache, regionPath);
-    Set<DistributedMember> normalMembers = getNormalMembers(cache);
+    Set<DistributedMember> regionMembers = findMembersForRegion(cache, regionPath);
+    Set<DistributedMember> normalMembers = getAllNormalMembers(cache);
     LuceneDestroyIndexInfo indexInfo = new LuceneDestroyIndexInfo(indexName, regionPath);
     ResultCollector<?, ?> rc;
     if (regionMembers.isEmpty()) {
@@ -403,14 +403,6 @@ private XmlEntity executeDestroyIndexFunction(List<CliFunctionResult> accumulate
     return xmlEntity;
   }
 
-  protected Set<DistributedMember> getRegionMembers(InternalCache cache, String regionPath) {
-    return CliUtil.getMembersForeRegionViaFunction(cache, regionPath, true);
-  }
-
-  protected Set<DistributedMember> getNormalMembers(InternalCache cache) {
-    return CliUtil.getAllNormalMembers(cache);
-  }
-
   private Result getDestroyIndexResult(List<CliFunctionResult> cliFunctionResults, String indexName,
       String regionPath) {
     final TabularResultData tabularResult = ResultBuilder.createTabularResultData();
@@ -553,8 +545,8 @@ private Result getResults(int fromIndex, int toIndex, boolean keysonly) throws E
 
   protected ResultCollector<?, ?> executeFunctionOnRegion(Function function,
       LuceneFunctionSerializable functionArguments, boolean returnAllMembers) {
-    Set<DistributedMember> targetMembers = CliUtil.getMembersForeRegionViaFunction(getCache(),
-        functionArguments.getRegionPath(), returnAllMembers);
+    Set<DistributedMember> targetMembers = CliUtil.getRegionAssociatedMembers(
+        functionArguments.getRegionPath(), getCache(), returnAllMembers);
     if (targetMembers.isEmpty()) {
       throw new IllegalArgumentException(CliStrings.format(
           LuceneCliStrings.LUCENE_DESTROY_INDEX__MSG__COULDNOT_FIND_MEMBERS_FOR_REGION_0,
@@ -563,11 +555,6 @@ private Result getResults(int fromIndex, int toIndex, boolean keysonly) throws E
     return executeFunction(function, functionArguments, targetMembers);
   }
 
-  protected ResultCollector<?, ?> executeFunction(Function function,
-      LuceneFunctionSerializable functionArguments, Set<DistributedMember> targetMembers) {
-    return CliUtil.executeFunction(function, functionArguments, targetMembers);
-  }
-
   @CliAvailabilityIndicator({LuceneCliStrings.LUCENE_SEARCH_INDEX,
       LuceneCliStrings.LUCENE_CREATE_INDEX, LuceneCliStrings.LUCENE_DESCRIBE_INDEX,
       LuceneCliStrings.LUCENE_LIST_INDEX, LuceneCliStrings.LUCENE_DESTROY_INDEX})
diff --git a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsJUnitTest.java b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsJUnitTest.java
index d73bfc5f6e..48fdde1ec6 100644
--- a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsJUnitTest.java
+++ b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsJUnitTest.java
@@ -447,8 +447,8 @@ public void testDestroySingleIndexNoRegionMembers(boolean expectedToSucceed) thr
         isA(LuceneDestroyIndexFunction.class), any(LuceneDestroyIndexInfo.class), any(Set.class));
     doReturn(cliFunctionResults).when(mockResultCollector).getResult();
 
-    doReturn(Collections.emptySet()).when(commands).getNormalMembers(any());
-    doReturn(Collections.emptySet()).when(commands).getRegionMembers(any(), any());
+    doReturn(Collections.emptySet()).when(commands).getAllNormalMembers(any());
+    doReturn(Collections.emptySet()).when(commands).findMembersForRegion(any(), any());
 
     CommandResult result = (CommandResult) commands.destroyIndex(indexName, regionPath);
     verifyDestroyIndexCommandResult(result, cliFunctionResults, expectedStatus);
@@ -484,8 +484,8 @@ public void testDestroySingleIndexWithRegionMembers(boolean expectedToSucceed) t
         isA(LuceneDestroyIndexFunction.class), any(LuceneDestroyIndexInfo.class), any(Set.class));
     doReturn(cliFunctionResults).when(mockResultCollector).getResult();
 
-    doReturn(members).when(commands).getNormalMembers(any());
-    doReturn(members).when(commands).getRegionMembers(any(), any());
+    doReturn(members).when(commands).getAllNormalMembers(any());
+    doReturn(members).when(commands).findMembersForRegion(any(), any());
 
     CommandResult result = (CommandResult) commands.destroyIndex(indexName, regionPath);
     verifyDestroyIndexCommandResult(result, cliFunctionResults, expectedStatus);
@@ -516,8 +516,8 @@ public void testDestroyAllIndexesNoRegionMembers(boolean expectedToSucceed) thro
         isA(LuceneDestroyIndexFunction.class), any(LuceneDestroyIndexInfo.class), any(Set.class));
     doReturn(cliFunctionResults).when(mockResultCollector).getResult();
 
-    doReturn(Collections.emptySet()).when(commands).getNormalMembers(any());
-    doReturn(Collections.emptySet()).when(commands).getRegionMembers(any(), any());
+    doReturn(Collections.emptySet()).when(commands).getAllNormalMembers(any());
+    doReturn(Collections.emptySet()).when(commands).findMembersForRegion(any(), any());
 
     CommandResult result = (CommandResult) commands.destroyIndex(indexName, regionPath);
     verifyDestroyIndexCommandResult(result, cliFunctionResults, expectedStatus);
@@ -553,8 +553,8 @@ public void testDestroyAllIndexesWithRegionMembers(boolean expectedToSucceed) th
         isA(LuceneDestroyIndexFunction.class), any(LuceneDestroyIndexInfo.class), any(Set.class));
     doReturn(cliFunctionResults).when(mockResultCollector).getResult();
 
-    doReturn(Collections.emptySet()).when(commands).getNormalMembers(any());
-    doReturn(Collections.emptySet()).when(commands).getRegionMembers(any(), any());
+    doReturn(Collections.emptySet()).when(commands).getAllNormalMembers(any());
+    doReturn(Collections.emptySet()).when(commands).findMembersForRegion(any(), any());
 
     CommandResult result = (CommandResult) commands.destroyIndex(indexName, regionPath);
     verifyDestroyIndexCommandResult(result, cliFunctionResults, expectedStatus);
@@ -664,7 +664,7 @@ public InternalCache getCache() {
     }
 
     @Override
-    public Set<DistributedMember> getMembers(final InternalCache cache) {
+    public Set<DistributedMember> getAllMembers(final InternalCache cache) {
       assertSame(getCache(), cache);
       return Collections.emptySet();
     }
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/PauseGatewaySenderCommandDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/PauseGatewaySenderCommandDUnitTest.java
index dd6dfd29ad..1b2e3f8ec1 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/PauseGatewaySenderCommandDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/PauseGatewaySenderCommandDUnitTest.java
@@ -79,29 +79,13 @@ public void before() throws Exception {
 
   @Test
   public void testPauseGatewaySender_ErrorConditions() throws Exception {
-
-    Integer locator1Port = locatorSite1.getPort();
-
-    // setup servers in Site #1
-    server1 = locatorServerStartupRule.startServerVM(3, locator1Port);
-    server2 = locatorServerStartupRule.startServerVM(4, locator1Port);
-    server3 = locatorServerStartupRule.startServerVM(5, locator1Port);
-    server3.invoke(() -> createSender("ln", 2, false, 100, 400, false, false, null, true));
-
-    final DistributedMember vm1Member = (DistributedMember) server1.invoke(getMemberIdCallable());
+    server1 = locatorServerStartupRule.startServerVM(3, locatorSite1.getPort());
+    final DistributedMember vm1Member = server1.invoke(getMemberIdCallable());
     String command = CliStrings.PAUSE_GATEWAYSENDER + " --" + CliStrings.PAUSE_GATEWAYSENDER__ID
         + "=ln --" + CliStrings.MEMBER + "=" + vm1Member.getId() + " --" + CliStrings.GROUP
         + "=SenderGroup1";
-    CommandResult cmdResult = gfsh.executeCommand(command);
-
-    if (cmdResult != null) {
-      String strCmdResult = cmdResult.toString();
-      getLogWriter().info("testPauseGatewaySender stringResult : " + strCmdResult + ">>>>");
-      assertEquals(Result.Status.ERROR, cmdResult.getStatus());
-      assertTrue(strCmdResult.contains(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE));
-    } else {
-      fail("testPauseGatewaySender failed as did not get CommandResult");
-    }
+    gfsh.executeAndAssertThat(command).statusIsError()
+        .containsOutput(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE);
   }
 
   /**
@@ -120,7 +104,7 @@ public void testPauseGatewaySender_onMember() throws Exception {
     server1.invoke(() -> startSender("ln"));
     server1.invoke(() -> verifySenderState("ln", true, false));
 
-    final DistributedMember vm1Member = (DistributedMember) server1.invoke(getMemberIdCallable());
+    final DistributedMember vm1Member = server1.invoke(getMemberIdCallable());
     pause(10000);
     String command = CliStrings.PAUSE_GATEWAYSENDER + " --" + CliStrings.PAUSE_GATEWAYSENDER__ID
         + "=ln --" + CliStrings.MEMBER + "=" + vm1Member.getId();
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/ResumeGatewaySenderCommandDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/ResumeGatewaySenderCommandDUnitTest.java
index 576c846c54..a85604e263 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/ResumeGatewaySenderCommandDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/ResumeGatewaySenderCommandDUnitTest.java
@@ -89,21 +89,12 @@ public void testResumeGatewaySender_ErrorConditions() throws Exception {
 
     server1.invoke(() -> createSender("ln", 2, false, 100, 400, false, false, null, true));
 
-    final DistributedMember vm1Member = (DistributedMember) server1.invoke(getMemberIdCallable());
+    final DistributedMember vm1Member = server1.invoke(getMemberIdCallable());
     String command = CliStrings.RESUME_GATEWAYSENDER + " --" + CliStrings.RESUME_GATEWAYSENDER__ID
         + "=ln --" + CliStrings.MEMBER + "=" + vm1Member.getId() + " --" + CliStrings.GROUP
         + "=SenderGroup1";
-    CommandResult cmdResult = gfsh.executeCommand(command);
-
-    if (cmdResult != null) {
-      String strCmdResult = cmdResult.toString();
-      getLogWriter()
-          .info("testResumeGatewaySender_ErrorConditions stringResult : " + strCmdResult + ">>>>");
-      assertEquals(Result.Status.ERROR, cmdResult.getStatus());
-      assertTrue(strCmdResult.contains(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE));
-    } else {
-      fail("testPauseGatewaySender failed as did not get CommandResult");
-    }
+    gfsh.executeAndAssertThat(command).statusIsError()
+        .containsOutput(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE);
   }
 
   @Test
@@ -262,21 +253,6 @@ public void testResumeGatewaySender_MultipleGroup() throws Exception {
 
     Integer locator1Port = locatorSite1.getPort();
 
-    // setup servers in Site #1
-    /*
-     * String group = "SenderGroup1"; Properties props = new Properties(); props.setProperty(GROUPS,
-     * group); server1 = locatorServerStartupRule.startServerVM(3, props, locator1Port); server2 =
-     * locatorServerStartupRule.startServerVM(4, props, locator1Port);
-     *
-     * props.setProperty(GROUPS, "SenderGroup1, SenderGroup2"); server3 =
-     * locatorServerStartupRule.startServerVM(5, props, locator1Port);
-     *
-     * props.setProperty(GROUPS, "SenderGroup2"); server4 =
-     * locatorServerStartupRule.startServerVM(6, props, locator1Port);
-     *
-     * props.setProperty(GROUPS, "SenderGroup3"); server5 =
-     * locatorServerStartupRule.startServerVM(7, props, locator1Port);
-     */
     server1 = startServerWithGroups(3, "SenderGroup1", locator1Port);
     server2 = startServerWithGroups(4, "SenderGroup1", locator1Port);
     server3 = startServerWithGroups(5, "SenderGroup1, SenderGroup2", locator1Port);
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StartGatewayReceiverCommandDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StartGatewayReceiverCommandDUnitTest.java
index 109a04a863..17b8106496 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StartGatewayReceiverCommandDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StartGatewayReceiverCommandDUnitTest.java
@@ -91,17 +91,8 @@ public void testStartGatewayReceiver_ErrorConditions() throws Exception {
     final DistributedMember vm1Member = (DistributedMember) server1.invoke(getMemberIdCallable());
     String command = CliStrings.START_GATEWAYRECEIVER + " --" + CliStrings.MEMBER + "="
         + vm1Member.getId() + " --" + CliStrings.GROUP + "=RG1";
-    CommandResult cmdResult = gfsh.executeCommand(command);
-
-    if (cmdResult != null) {
-      String strCmdResult = cmdResult.toString();
-      getLogWriter()
-          .info("testStartGatewayReceiver_ErrorConditions stringResult : " + strCmdResult + ">>>>");
-      assertEquals(Result.Status.ERROR, cmdResult.getStatus());
-      assertTrue(strCmdResult.contains(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE));
-    } else {
-      fail("testStartGatewayReceiver_ErrorConditions failed as did not get CommandResult");
-    }
+    gfsh.executeAndAssertThat(command).statusIsError()
+        .containsOutput(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE);
   }
 
   @Test
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StartGatewaySenderCommandDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StartGatewaySenderCommandDUnitTest.java
index f43f38f8ba..2a41db35e4 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StartGatewaySenderCommandDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StartGatewaySenderCommandDUnitTest.java
@@ -95,16 +95,8 @@ public void testStartGatewaySender_ErrorConditions() throws Exception {
     String command = CliStrings.START_GATEWAYSENDER + " --" + CliStrings.START_GATEWAYSENDER__ID
         + "=ln --" + CliStrings.MEMBER + "=" + vm1Member.getId() + " --" + CliStrings.GROUP
         + "=SenserGroup1";
-    CommandResult cmdResult = executeCommandWithIgnoredExceptions(command);
-
-    if (cmdResult != null) {
-      String strCmdResult = cmdResult.toString();
-      getLogWriter().info("testStartGatewaySender stringResult : " + strCmdResult + ">>>>");
-      assertEquals(Result.Status.ERROR, cmdResult.getStatus());
-      assertTrue(strCmdResult.contains(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE));
-    } else {
-      fail("testStartGatewaySender failed as did not get CommandResult");
-    }
+    gfsh.executeAndAssertThat(command).statusIsError()
+        .containsOutput(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE);
   }
 
   @Test
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StopGatewayReceiverCommandDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StopGatewayReceiverCommandDUnitTest.java
index edf2aa94d7..f3cd6768bf 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StopGatewayReceiverCommandDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StopGatewayReceiverCommandDUnitTest.java
@@ -91,19 +91,11 @@ public void testStopGatewayReceiver_ErrorConditions() throws Exception {
 
     server1.invoke(() -> createReceiver(locator1Port));
 
-    final DistributedMember server1DM = (DistributedMember) server1.invoke(getMemberIdCallable());
+    final DistributedMember server1DM = server1.invoke(getMemberIdCallable());
     String command = CliStrings.STOP_GATEWAYRECEIVER + " --" + CliStrings.MEMBER + "="
         + server1DM.getId() + " --" + CliStrings.GROUP + "=RG1";
-    CommandResult cmdResult = gfsh.executeCommand(command);
-    if (cmdResult != null) {
-      String strCmdResult = cmdResult.toString();
-      getLogWriter()
-          .info("testStopGatewayReceiver_ErrorConditions stringResult : " + strCmdResult + ">>>>");
-      assertEquals(Result.Status.ERROR, cmdResult.getStatus());
-      assertTrue(strCmdResult.contains(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE));
-    } else {
-      fail("testStopGatewayReceiver_ErrorConditions failed as did not get CommandResult");
-    }
+    gfsh.executeAndAssertThat(command).statusIsError()
+        .containsOutput(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE);
   }
 
   @Test
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StopGatewaySenderCommandDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StopGatewaySenderCommandDUnitTest.java
index f8ad5f8e51..01bbddad3c 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StopGatewaySenderCommandDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StopGatewaySenderCommandDUnitTest.java
@@ -88,19 +88,12 @@ public void testStopGatewaySender_ErrorConditions() throws Exception {
 
     server1.invoke(() -> createSender("ln", 2, false, 100, 400, false, false, null, true));
 
-    final DistributedMember server1DM = (DistributedMember) server1.invoke(getMemberIdCallable());
+    final DistributedMember server1DM = server1.invoke(getMemberIdCallable());
     String command = CliStrings.STOP_GATEWAYSENDER + " --" + CliStrings.STOP_GATEWAYSENDER__ID
         + "=ln --" + CliStrings.MEMBER + "=" + server1DM.getId() + " --" + CliStrings.GROUP
         + "=SenderGroup1";
-    CommandResult cmdResult = executeCommandWithIgnoredExceptions(command);
-    if (cmdResult != null) {
-      String strCmdResult = cmdResult.toString();
-      getLogWriter().info("testStopGatewaySender stringResult : " + strCmdResult + ">>>>");
-      assertEquals(Result.Status.ERROR, cmdResult.getStatus());
-      assertTrue(strCmdResult.contains(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE));
-    } else {
-      fail("testStopGatewaySender failed as did not get CommandResult");
-    }
+    gfsh.executeAndAssertThat(command).statusIsError()
+        .containsOutput(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE);
   }
 
   @Test


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit c1c6e74740f71756b2e6e97171bd06a8eac13bad in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=c1c6e74 ]

GEODE-3539: add more tests for get, put, locate entry commands (#1025)

* GEODE-3539: add more tests for get, put, locate entry commands

* clean up more methods in CliUtil
* refactor tests out of GemfireDataCommandsDUnitTest
* get rid of unnecessary try/catch block in commands


Commit c1c6e74740f71756b2e6e97171bd06a8eac13bad in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=c1c6e74 ]

GEODE-3539: add more tests for get, put, locate entry commands (#1025)

* GEODE-3539: add more tests for get, put, locate entry commands

* clean up more methods in CliUtil
* refactor tests out of GemfireDataCommandsDUnitTest
* get rid of unnecessary try/catch block in commands


jinmeiliao opened a new pull request #1040: GEODE-3539: cleanup GfshCommand and refactor tests
URL: https://github.com/apache/geode/pull/1040
 
 
   * remove more try catch blocks in commands
   * make GfshCommand a pure wrapper around CliUtil for easy mocking
   
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pdxrunner commented on a change in pull request #1040: GEODE-3539: cleanup GfshCommand and refactor tests
URL: https://github.com/apache/geode/pull/1040#discussion_r150099937
 
 

 ##########
 File path: geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandTest.java
 ##########
 @@ -144,4 +159,55 @@ private void addJvmOptionsForOutOfMemoryErrors(final List<String> commandLine) {
       commandLine.add("-XXexitOnOutOfMemory");
     }
   }
+
+  private static final String FAKE_HOSTNAME = "someFakeHostname";
+
+  @Rule
+  public GfshParserRule commandRule = new GfshParserRule();
+
+  @Rule
+  public ExpectedException thrown = ExpectedException.none();
+
+  @Rule
+  public TemporaryFolder temporaryFolder = new TemporaryFolder();
+
+  private StartLocatorCommand spy;
+
+  @Before
+  public void before() throws Exception {
+    spy = Mockito.spy(StartLocatorCommand.class);
+    doReturn(mock(Gfsh.class)).when(spy).getGfsh();
+  }
+
 
 Review comment:
   I'd prefer to see these new @Rule & @Before methods moved to the top of the file with the original @Before method.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pdxrunner commented on a change in pull request #1040: GEODE-3539: cleanup GfshCommand and refactor tests
URL: https://github.com/apache/geode/pull/1040#discussion_r150100257
 
 

 ##########
 File path: geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartServerCommandTest.java
 ##########
 @@ -141,4 +156,54 @@ public void testCreateServerCommandLineWithRestAPI() throws Exception {
     assertTrue(String.format("Expected ([]); but was (%1$s)", expectedCommandLineElements),
         expectedCommandLineElements.isEmpty());
   }
+
+  private static final String FAKE_HOSTNAME = "someFakeHostname";
+
+  @Rule
+  public GfshParserRule commandRule = new GfshParserRule();
+
+  @Rule
+  public TemporaryFolder temporaryFolder = new TemporaryFolder();
+
+  @Rule
+  public ExpectedException thrown = ExpectedException.none();
+
+  private StartServerCommand spy;
+
+  @Before
+  public void before() throws Exception {
+    spy = Mockito.spy(StartServerCommand.class);
+    doReturn(mock(Gfsh.class)).when(spy).getGfsh();
+  }
 
 Review comment:
   See above comments on StartLocatorCommandTest

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pdxrunner commented on a change in pull request #1040: GEODE-3539: cleanup GfshCommand and refactor tests
URL: https://github.com/apache/geode/pull/1040#discussion_r150098870
 
 

 ##########
 File path: geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandTest.java
 ##########
 @@ -144,4 +159,55 @@ private void addJvmOptionsForOutOfMemoryErrors(final List<String> commandLine) {
       commandLine.add("-XXexitOnOutOfMemory");
     }
   }
+
+  private static final String FAKE_HOSTNAME = "someFakeHostname";
+
+  @Rule
+  public GfshParserRule commandRule = new GfshParserRule();
+
+  @Rule
+  public ExpectedException thrown = ExpectedException.none();
+
+  @Rule
+  public TemporaryFolder temporaryFolder = new TemporaryFolder();
+
 
 Review comment:
   Unused rule, should be deleted along with the import for `TemporaryFolder`

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pdxrunner commented on a change in pull request #1040: GEODE-3539: cleanup GfshCommand and refactor tests
URL: https://github.com/apache/geode/pull/1040#discussion_r150106964
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandTest.java
 ##########
 @@ -73,4 +83,35 @@ public void whenNoRegionIsFoundOnAnyMembers() throws Exception {
     result = parser.executeCommandWithInstance(command, "destroy region --name=test --if-exists");
     assertThat(result.getStatus()).isEqualTo(Result.Status.OK);
   }
+
+  @Test
+  public void multipleResultReturnedWithOneError() throws Exception {
+    // mock this to pass the member search call
+    doReturn(Collections.singleton(DistributedMember.class)).when(command)
+        .findMembersForRegion(any(), any());
+
+    ResultCollector collector = mock(ResultCollector.class);
+    doReturn(collector).when(command).executeFunction(any(), any(), any(Set.class));
+
+    List<CliFunctionResult> functionResults = new ArrayList<>();
+    doReturn(functionResults).when(collector).getResult();
+    CliFunctionResult result1 = mock(CliFunctionResult.class);
+    CliFunctionResult result2 = mock(CliFunctionResult.class);
+    functionResults.add(result1);
+    functionResults.add(result2);
+
+    when(result1.isSuccessful()).thenReturn(true);
+    when(result1.getMessage()).thenReturn("result1 message");
+    when(result1.getXmlEntity()).thenReturn(mock(XmlEntity.class));
+
+    when(result2.isSuccessful()).thenReturn(false);
+    when(result2.getMessage()).thenReturn("result2 message");
+
+    result = parser.executeCommandWithInstance(command, "destroy region --name=test");
+    assertThat(result.getStatus()).isEqualTo(Result.Status.ERROR);
+    assertThat(result.getContent().toString()).contains("result2 message");
+
+    // verify that xmlEntiry returned by the result1 is not saved to Cluster config
+    verify(command, never()).persistClusterConfiguration(any(), any());
+  }
 
 Review comment:
   Could have a couple more tests, this one multiple-results tests looks like it misses coverage of some conditional clauses in the foreach in `DestroyRegionCommand.destroyRegion`: 1) a result contains a throwable 2) a not-successfull result has a null message.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on issue #1040: GEODE-3539: cleanup GfshCommand and refactor tests
URL: https://github.com/apache/geode/pull/1040#issuecomment-343377984
 
 
   precheckin green

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao closed pull request #1040: GEODE-3539: cleanup GfshCommand and refactor tests
URL: https://github.com/apache/geode/pull/1040
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandIntegrationTest.java b/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandIntegrationTest.java
deleted file mode 100644
index 6fa05c7b33..0000000000
--- a/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandIntegrationTest.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.apache.geode.management.internal.cli.commands;
-
-import static org.apache.geode.distributed.ConfigurationProperties.ENABLE_CLUSTER_CONFIGURATION;
-import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_HOSTNAME_FOR_CLIENTS;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-import java.util.Properties;
-
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.experimental.categories.Category;
-import org.junit.rules.TemporaryFolder;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mockito;
-
-import org.apache.geode.management.internal.cli.shell.Gfsh;
-import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
-import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshParserRule;
-
-@Category(IntegrationTest.class)
-public class StartLocatorCommandIntegrationTest {
-  private static final String FAKE_HOSTNAME = "someFakeHostname";
-
-  @Rule
-  public GfshParserRule commandRule = new GfshParserRule();
-
-  @Rule
-  public TemporaryFolder temporaryFolder = new TemporaryFolder();
-
-  private StartLocatorCommand spy;
-
-  @Before
-  public void before() throws Exception {
-    spy = Mockito.spy(StartLocatorCommand.class);
-    doReturn(mock(Gfsh.class)).when(spy).getGfsh();
-  }
-
-  @Test
-  public void startLocatorWorksWithNoOptions() throws Exception {
-    commandRule.executeCommandWithInstance(spy, "start locator");
-
-    ArgumentCaptor<Properties> gemfirePropertiesCaptor = ArgumentCaptor.forClass(Properties.class);
-    verify(spy).createStartLocatorCommandLine(any(), any(), any(),
-        gemfirePropertiesCaptor.capture(), any(), any(), any(), any(), any());
-
-    Properties gemfireProperties = gemfirePropertiesCaptor.getValue();
-    assertThat(gemfireProperties).containsKey(ENABLE_CLUSTER_CONFIGURATION);
-    assertThat(gemfireProperties.get(ENABLE_CLUSTER_CONFIGURATION)).isEqualTo("true");
-  }
-
-  @Test
-  public void startLocatorRespectsJmxManagerHostnameForClients() throws Exception {
-    String startLocatorCommand = new CommandStringBuilder("start locator")
-        .addOption(JMX_MANAGER_HOSTNAME_FOR_CLIENTS, FAKE_HOSTNAME).toString();
-
-    commandRule.executeCommandWithInstance(spy, startLocatorCommand);
-
-    ArgumentCaptor<Properties> gemfirePropertiesCaptor = ArgumentCaptor.forClass(Properties.class);
-    verify(spy).createStartLocatorCommandLine(any(), any(), any(),
-        gemfirePropertiesCaptor.capture(), any(), any(), any(), any(), any());
-
-    Properties gemfireProperties = gemfirePropertiesCaptor.getValue();
-    assertThat(gemfireProperties).containsKey(JMX_MANAGER_HOSTNAME_FOR_CLIENTS);
-    assertThat(gemfireProperties.get(JMX_MANAGER_HOSTNAME_FOR_CLIENTS)).isEqualTo(FAKE_HOSTNAME);
-  }
-
-}
diff --git a/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandTest.java b/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandTest.java
index 5a7c11cb50..227562eb05 100644
--- a/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandTest.java
+++ b/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandTest.java
@@ -15,11 +15,18 @@
 
 package org.apache.geode.management.internal.cli.commands;
 
+import static org.apache.geode.distributed.ConfigurationProperties.ENABLE_CLUSTER_CONFIGURATION;
 import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_BIND_ADDRESS;
 import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_PORT;
+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_HOSTNAME_FOR_CLIENTS;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
 
 import java.io.File;
 import java.util.ArrayList;
@@ -28,28 +35,36 @@
 import java.util.Properties;
 import java.util.Set;
 
-import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
+import org.junit.rules.ExpectedException;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mockito;
 
 import org.apache.geode.distributed.LocatorLauncher;
 import org.apache.geode.distributed.internal.DistributionConfig;
 import org.apache.geode.internal.lang.SystemUtils;
+import org.apache.geode.management.internal.cli.shell.Gfsh;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
 import org.apache.geode.test.junit.categories.UnitTest;
+import org.apache.geode.test.junit.rules.GfshParserRule;
 
 @Category(UnitTest.class)
 public class StartLocatorCommandTest {
-  private StartLocatorCommand locatorCommands;
+  private static final String FAKE_HOSTNAME = "someFakeHostname";
+  @Rule
+  public GfshParserRule commandRule = new GfshParserRule();
+  @Rule
+  public ExpectedException thrown = ExpectedException.none();
+
+  private StartLocatorCommand spy;
 
   @Before
   public void setup() {
-    locatorCommands = new StartLocatorCommand();
-  }
-
-  @After
-  public void tearDown() {
-    locatorCommands = null;
+    spy = Mockito.spy(StartLocatorCommand.class);
+    doReturn(mock(Gfsh.class)).when(spy).getGfsh();
   }
 
   @Test
@@ -59,7 +74,7 @@ public void testLocatorClasspathOrder() {
         StartMemberUtils.getGemFireJarPath().concat(File.pathSeparator).concat(userClasspath)
             .concat(File.pathSeparator).concat(System.getProperty("java.class.path"))
             .concat(File.pathSeparator).concat(StartMemberUtils.CORE_DEPENDENCIES_JAR_PATHNAME);
-    String actualClasspath = locatorCommands.getLocatorClasspath(true, userClasspath);
+    String actualClasspath = spy.getLocatorClasspath(true, userClasspath);
     assertEquals(expectedClasspath, actualClasspath);
   }
 
@@ -74,8 +89,8 @@ public void testLocatorCommandLineWithRestAPI() throws Exception {
     gemfireProperties.setProperty(HTTP_SERVICE_PORT, "8089");
     gemfireProperties.setProperty(HTTP_SERVICE_BIND_ADDRESS, "localhost");
 
-    String[] commandLineElements = locatorCommands.createStartLocatorCommandLine(locatorLauncher,
-        null, null, gemfireProperties, null, false, new String[0], null, null);
+    String[] commandLineElements = spy.createStartLocatorCommandLine(locatorLauncher, null, null,
+        gemfireProperties, null, false, new String[0], null, null);
 
     assertNotNull(commandLineElements);
     assertTrue(commandLineElements.length > 0);
@@ -144,4 +159,36 @@ private void addJvmOptionsForOutOfMemoryErrors(final List<String> commandLine) {
       commandLine.add("-XXexitOnOutOfMemory");
     }
   }
+
+  @Test
+  public void startLocatorWorksWithNoOptions() throws Exception {
+    thrown.expect(NullPointerException.class);
+    commandRule.executeCommandWithInstance(spy, "start locator");
+
+    ArgumentCaptor<Properties> gemfirePropertiesCaptor = ArgumentCaptor.forClass(Properties.class);
+    verify(spy).createStartLocatorCommandLine(any(), any(), any(),
+        gemfirePropertiesCaptor.capture(), any(), any(), any(), any(), any());
+
+    Properties gemfireProperties = gemfirePropertiesCaptor.getValue();
+    assertThat(gemfireProperties).containsKey(ENABLE_CLUSTER_CONFIGURATION);
+    assertThat(gemfireProperties.get(ENABLE_CLUSTER_CONFIGURATION)).isEqualTo("true");
+  }
+
+  @Test
+  public void startLocatorRespectsJmxManagerHostnameForClients() throws Exception {
+    String startLocatorCommand = new CommandStringBuilder("start locator")
+        .addOption(JMX_MANAGER_HOSTNAME_FOR_CLIENTS, FAKE_HOSTNAME).toString();
+
+    thrown.expect(NullPointerException.class);
+    commandRule.executeCommandWithInstance(spy, startLocatorCommand);
+
+
+    ArgumentCaptor<Properties> gemfirePropertiesCaptor = ArgumentCaptor.forClass(Properties.class);
+    verify(spy).createStartLocatorCommandLine(any(), any(), any(),
+        gemfirePropertiesCaptor.capture(), any(), any(), any(), any(), any());
+
+    Properties gemfireProperties = gemfirePropertiesCaptor.getValue();
+    assertThat(gemfireProperties).containsKey(JMX_MANAGER_HOSTNAME_FOR_CLIENTS);
+    assertThat(gemfireProperties.get(JMX_MANAGER_HOSTNAME_FOR_CLIENTS)).isEqualTo(FAKE_HOSTNAME);
+  }
 }
diff --git a/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartServerCommandIntegrationTest.java b/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartServerCommandIntegrationTest.java
deleted file mode 100644
index 2a8807e4ab..0000000000
--- a/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartServerCommandIntegrationTest.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.apache.geode.management.internal.cli.commands;
-
-import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_HOSTNAME_FOR_CLIENTS;
-import static org.apache.geode.distributed.ConfigurationProperties.USE_CLUSTER_CONFIGURATION;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-import java.util.Properties;
-
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.experimental.categories.Category;
-import org.junit.rules.TemporaryFolder;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mockito;
-
-import org.apache.geode.management.internal.cli.shell.Gfsh;
-import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
-import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshParserRule;
-
-@Category(IntegrationTest.class)
-public class StartServerCommandIntegrationTest {
-  private static final String FAKE_HOSTNAME = "someFakeHostname";
-
-  @Rule
-  public GfshParserRule commandRule = new GfshParserRule();
-
-  @Rule
-  public TemporaryFolder temporaryFolder = new TemporaryFolder();
-
-  private StartServerCommand spy;
-
-  @Before
-  public void before() throws Exception {
-    spy = Mockito.spy(StartServerCommand.class);
-    doReturn(mock(Gfsh.class)).when(spy).getGfsh();
-  }
-
-  @Test
-  public void startServerWorksWithNoOptions() throws Exception {
-    commandRule.executeCommandWithInstance(spy, "start server");
-
-    ArgumentCaptor<Properties> gemfirePropertiesCaptor = ArgumentCaptor.forClass(Properties.class);
-    verify(spy).createStartServerCommandLine(any(), any(), any(), gemfirePropertiesCaptor.capture(),
-        any(), any(), any(), any(), any(), any());
-
-    Properties gemfireProperties = gemfirePropertiesCaptor.getValue();
-    assertThat(gemfireProperties).containsKey(USE_CLUSTER_CONFIGURATION);
-    assertThat(gemfireProperties.get(USE_CLUSTER_CONFIGURATION)).isEqualTo("true");
-  }
-
-  @Test
-  public void startServerRespectsJmxManagerHostnameForClients() throws Exception {
-    String startServerCommand = new CommandStringBuilder("start server")
-        .addOption(JMX_MANAGER_HOSTNAME_FOR_CLIENTS, FAKE_HOSTNAME).toString();
-
-    commandRule.executeCommandWithInstance(spy, startServerCommand);
-
-    ArgumentCaptor<Properties> gemfirePropertiesCaptor = ArgumentCaptor.forClass(Properties.class);
-    verify(spy).createStartServerCommandLine(any(), any(), any(), gemfirePropertiesCaptor.capture(),
-        any(), any(), any(), any(), any(), any());
-
-    Properties gemfireProperties = gemfirePropertiesCaptor.getValue();
-    assertThat(gemfireProperties).containsKey(JMX_MANAGER_HOSTNAME_FOR_CLIENTS);
-    assertThat(gemfireProperties.get(JMX_MANAGER_HOSTNAME_FOR_CLIENTS)).isEqualTo(FAKE_HOSTNAME);
-  }
-
-}
diff --git a/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartServerCommandTest.java b/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartServerCommandTest.java
index e704248481..a71d7883a1 100644
--- a/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartServerCommandTest.java
+++ b/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartServerCommandTest.java
@@ -17,37 +17,54 @@
 
 import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_BIND_ADDRESS;
 import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_PORT;
+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_HOSTNAME_FOR_CLIENTS;
 import static org.apache.geode.distributed.ConfigurationProperties.START_DEV_REST_API;
+import static org.apache.geode.distributed.ConfigurationProperties.USE_CLUSTER_CONFIGURATION;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
 
 import java.io.File;
 import java.util.HashSet;
 import java.util.Properties;
 import java.util.Set;
 
-import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
+import org.junit.rules.ExpectedException;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mockito;
 
 import org.apache.geode.distributed.ServerLauncher;
 import org.apache.geode.distributed.internal.DistributionConfig;
+import org.apache.geode.management.internal.cli.shell.Gfsh;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
 import org.apache.geode.test.junit.categories.UnitTest;
+import org.apache.geode.test.junit.rules.GfshParserRule;
 
 @Category(UnitTest.class)
 public class StartServerCommandTest {
-  private StartServerCommand serverCommands;
+  private static final String FAKE_HOSTNAME = "someFakeHostname";
 
-  @Before
-  public void setup() {
-    serverCommands = new StartServerCommand();
-  }
+  @Rule
+  public GfshParserRule commandRule = new GfshParserRule();
+
+  @Rule
+  public ExpectedException thrown = ExpectedException.none();
+
+  private StartServerCommand spy;
 
-  @After
-  public void tearDown() {
-    serverCommands = null;
+  @Before
+  public void before() throws Exception {
+    spy = Mockito.spy(StartServerCommand.class);
+    doReturn(mock(Gfsh.class)).when(spy).getGfsh();
   }
 
   @Test
@@ -56,7 +73,7 @@ public void testServerClasspathOrder() {
     String expectedClasspath =
         StartMemberUtils.getGemFireJarPath().concat(File.pathSeparator).concat(userClasspath)
             .concat(File.pathSeparator).concat(StartMemberUtils.CORE_DEPENDENCIES_JAR_PATHNAME);
-    String actualClasspath = serverCommands.getServerClasspath(false, userClasspath);
+    String actualClasspath = spy.getServerClasspath(false, userClasspath);
     assertEquals(expectedClasspath, actualClasspath);
   }
 
@@ -68,8 +85,8 @@ public void testCreateServerCommandLine() throws Exception {
         .setCriticalHeapPercentage(95.5f).setEvictionHeapPercentage(85.0f)
         .setSocketBufferSize(1024 * 1024).setMessageTimeToLive(93).build();
 
-    String[] commandLineElements = serverCommands.createStartServerCommandLine(serverLauncher, null,
-        null, new Properties(), null, false, new String[0], false, null, null);
+    String[] commandLineElements = spy.createStartServerCommandLine(serverLauncher, null, null,
+        new Properties(), null, false, new String[0], false, null, null);
 
     assertNotNull(commandLineElements);
     assertTrue(commandLineElements.length > 0);
@@ -109,8 +126,8 @@ public void testCreateServerCommandLineWithRestAPI() throws Exception {
     gemfireProperties.setProperty(HTTP_SERVICE_PORT, "8080");
     gemfireProperties.setProperty(HTTP_SERVICE_BIND_ADDRESS, "localhost");
 
-    String[] commandLineElements = serverCommands.createStartServerCommandLine(serverLauncher, null,
-        null, gemfireProperties, null, false, new String[0], false, null, null);
+    String[] commandLineElements = spy.createStartServerCommandLine(serverLauncher, null, null,
+        gemfireProperties, null, false, new String[0], false, null, null);
 
     assertNotNull(commandLineElements);
     assertTrue(commandLineElements.length > 0);
@@ -141,4 +158,35 @@ public void testCreateServerCommandLineWithRestAPI() throws Exception {
     assertTrue(String.format("Expected ([]); but was (%1$s)", expectedCommandLineElements),
         expectedCommandLineElements.isEmpty());
   }
+
+  @Test
+  public void startServerWorksWithNoOptions() throws Exception {
+    thrown.expect(NullPointerException.class);
+    commandRule.executeCommandWithInstance(spy, "start server");
+
+    ArgumentCaptor<Properties> gemfirePropertiesCaptor = ArgumentCaptor.forClass(Properties.class);
+    verify(spy).createStartServerCommandLine(any(), any(), any(), gemfirePropertiesCaptor.capture(),
+        any(), any(), any(), any(), any(), any());
+
+    Properties gemfireProperties = gemfirePropertiesCaptor.getValue();
+    assertThat(gemfireProperties).containsKey(USE_CLUSTER_CONFIGURATION);
+    assertThat(gemfireProperties.get(USE_CLUSTER_CONFIGURATION)).isEqualTo("true");
+  }
+
+  @Test
+  public void startServerRespectsJmxManagerHostnameForClients() throws Exception {
+    String startServerCommand = new CommandStringBuilder("start server")
+        .addOption(JMX_MANAGER_HOSTNAME_FOR_CLIENTS, FAKE_HOSTNAME).toString();
+
+    thrown.expect(NullPointerException.class);
+    commandRule.executeCommandWithInstance(spy, startServerCommand);
+
+    ArgumentCaptor<Properties> gemfirePropertiesCaptor = ArgumentCaptor.forClass(Properties.class);
+    verify(spy).createStartServerCommandLine(any(), any(), any(), gemfirePropertiesCaptor.capture(),
+        any(), any(), any(), any(), any(), any());
+
+    Properties gemfireProperties = gemfirePropertiesCaptor.getValue();
+    assertThat(gemfireProperties).containsKey(JMX_MANAGER_HOSTNAME_FOR_CLIENTS);
+    assertThat(gemfireProperties.get(JMX_MANAGER_HOSTNAME_FOR_CLIENTS)).isEqualTo(FAKE_HOSTNAME);
+  }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommand.java
index f56e591a70..cdb7d2780b 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommand.java
@@ -21,8 +21,6 @@
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
-import org.apache.geode.cache.execute.FunctionInvocationTargetException;
 import org.apache.geode.cache.execute.ResultCollector;
 import org.apache.geode.distributed.DistributedMember;
 import org.apache.geode.internal.lang.ClassUtils;
@@ -30,13 +28,12 @@
 import org.apache.geode.management.cli.ConverterHint;
 import org.apache.geode.management.cli.Result;
 import org.apache.geode.management.internal.cli.domain.DiskStoreDetails;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
 import org.apache.geode.management.internal.cli.functions.DescribeDiskStoreFunction;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.result.CompositeResultData;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
 import org.apache.geode.management.internal.cli.result.TabularResultData;
-import org.apache.geode.management.internal.cli.util.DiskStoreNotFoundException;
-import org.apache.geode.management.internal.cli.util.MemberNotFoundException;
 import org.apache.geode.management.internal.security.ResourceOperation;
 import org.apache.geode.security.ResourcePermission;
 
@@ -52,22 +49,9 @@ public Result describeDiskStore(
       @CliOption(key = CliStrings.DESCRIBE_DISK_STORE__NAME, mandatory = true,
           optionContext = ConverterHint.DISKSTORE,
           help = CliStrings.DESCRIBE_DISK_STORE__NAME__HELP) final String diskStoreName) {
-    try {
-      return toCompositeResult(getDiskStoreDescription(memberName, diskStoreName));
-    } catch (DiskStoreNotFoundException | MemberNotFoundException e) {
-      return ResultBuilder.createShellClientErrorResult(e.getMessage());
-    } catch (FunctionInvocationTargetException ignore) {
-      return ResultBuilder.createGemFireErrorResult(CliStrings
-          .format(CliStrings.COULD_NOT_EXECUTE_COMMAND_TRY_AGAIN, CliStrings.DESCRIBE_DISK_STORE));
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      return ResultBuilder
-          .createGemFireErrorResult(String.format(CliStrings.DESCRIBE_DISK_STORE__ERROR_MESSAGE,
-              memberName, diskStoreName, toString(t, isDebugging())));
-    }
+
+    return toCompositeResult(getDiskStoreDescription(memberName, diskStoreName));
+
   }
 
   DiskStoreDetails getDiskStoreDescription(final String memberName, final String diskStoreName) {
@@ -81,8 +65,8 @@ DiskStoreDetails getDiskStoreDescription(final String memberName, final String d
 
     if (result instanceof DiskStoreDetails) { // disk store details in hand...
       return (DiskStoreDetails) result;
-    } else if (result instanceof DiskStoreNotFoundException) { // bad disk store name...
-      throw (DiskStoreNotFoundException) result;
+    } else if (result instanceof EntityNotFoundException) { // bad disk store name...
+      throw (EntityNotFoundException) result;
     } else { // unknown and unexpected return type...
       final Throwable cause = (result instanceof Throwable ? (Throwable) result : null);
 
@@ -117,9 +101,8 @@ private Result toCompositeResult(final DiskStoreDetails diskStoreDetails) {
     diskStoreSection.addData("Member ID", diskStoreDetails.getMemberId());
     diskStoreSection.addData("Member Name", diskStoreDetails.getMemberName());
     diskStoreSection.addData("Allow Force Compaction",
-        toString(diskStoreDetails.isAllowForceCompaction(), "Yes", "No"));
-    diskStoreSection.addData("Auto Compaction",
-        toString(diskStoreDetails.isAutoCompact(), "Yes", "No"));
+        diskStoreDetails.isAllowForceCompaction() ? "Yes" : "No");
+    diskStoreSection.addData("Auto Compaction", diskStoreDetails.isAutoCompact() ? "Yes" : "No");
     diskStoreSection.addData("Compaction Threshold", diskStoreDetails.getCompactionThreshold());
     diskStoreSection.addData("Max Oplog Size", diskStoreDetails.getMaxOplogSize());
     diskStoreSection.addData("Queue Size", diskStoreDetails.getQueueSize());
@@ -130,7 +113,7 @@ private Result toCompositeResult(final DiskStoreDetails diskStoreDetails) {
     diskStoreSection.addData("Disk Usage Critical Percentage",
         diskStoreDetails.getDiskUsageCriticalPercentage());
     diskStoreSection.addData("PDX Serialization Meta-Data Stored",
-        toString(diskStoreDetails.isPdxSerializationMetaDataStored(), "Yes", "No"));
+        diskStoreDetails.isPdxSerializationMetaDataStored() ? "Yes" : "No");
 
     final TabularResultData diskDirTable = diskStoreData.addSection().addTable();
 
@@ -144,9 +127,8 @@ private Result toCompositeResult(final DiskStoreDetails diskStoreDetails) {
     for (DiskStoreDetails.RegionDetails regionDetails : diskStoreDetails.iterateRegions()) {
       regionTable.accumulate("Region Path", regionDetails.getFullPath());
       regionTable.accumulate("Region Name", regionDetails.getName());
-      regionTable.accumulate("Persistent", toString(regionDetails.isPersistent(), "Yes", "No"));
-      regionTable.accumulate("Overflow To Disk",
-          toString(regionDetails.isOverflowToDisk(), "Yes", "No"));
+      regionTable.accumulate("Persistent", regionDetails.isPersistent() ? "Yes" : "No");
+      regionTable.accumulate("Overflow To Disk", regionDetails.isOverflowToDisk() ? "Yes" : "No");
     }
 
     final TabularResultData cacheServerTable = diskStoreData.addSection().addTable();
@@ -162,7 +144,7 @@ private Result toCompositeResult(final DiskStoreDetails diskStoreDetails) {
 
     for (DiskStoreDetails.GatewayDetails gatewayDetails : diskStoreDetails.iterateGateways()) {
       gatewayTable.accumulate("Gateway ID", gatewayDetails.getId());
-      gatewayTable.accumulate("Persistent", toString(gatewayDetails.isPersistent(), "Yes", "No"));
+      gatewayTable.accumulate("Persistent", gatewayDetails.isPersistent() ? "Yes" : "No");
     }
 
     final TabularResultData asyncEventQueueTable = diskStoreData.addSection().addTable();
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommand.java
index 821eb64c3b..13947ec469 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommand.java
@@ -26,8 +26,6 @@
 import org.apache.geode.management.cli.CliMetaData;
 import org.apache.geode.management.cli.ConverterHint;
 import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.LogWrapper;
 import org.apache.geode.management.internal.cli.functions.CliFunctionResult;
 import org.apache.geode.management.internal.cli.functions.RegionDestroyFunction;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
@@ -45,10 +43,10 @@ public Result destroyRegion(
       @CliOption(key = CliStrings.DESTROY_REGION__REGION, optionContext = ConverterHint.REGION_PATH,
           mandatory = true, help = CliStrings.DESTROY_REGION__REGION__HELP) String regionPath,
       @CliOption(key = CliStrings.IFEXISTS, help = CliStrings.IFEXISTS_HELP,
-          specifiedDefaultValue = "true", unspecifiedDefaultValue = "false") boolean ifExists) {
+          specifiedDefaultValue = "true", unspecifiedDefaultValue = "false") boolean ifExists)
+      throws Throwable {
 
     // regionPath should already be converted to have "/" in front of it.
-    Result result;
     AtomicReference<XmlEntity> xmlEntity = new AtomicReference<>();
 
     Set<DistributedMember> regionMembersList = findMembersForRegion(getCache(), regionPath);
@@ -63,45 +61,40 @@ public Result destroyRegion(
       }
     }
 
-    CliFunctionResult destroyRegionResult;
-
     ResultCollector<?, ?> resultCollector =
-        CliUtil.executeFunction(RegionDestroyFunction.INSTANCE, regionPath, regionMembersList);
+        executeFunction(RegionDestroyFunction.INSTANCE, regionPath, regionMembersList);
     List<CliFunctionResult> resultsList = (List<CliFunctionResult>) resultCollector.getResult();
-    String message =
-        CliStrings.format(CliStrings.DESTROY_REGION__MSG__REGION_0_1_DESTROYED, regionPath, "");
 
-    // Only if there is an error is this set to false
-    boolean isRegionDestroyed = true;
-    for (CliFunctionResult aResultsList : resultsList) {
-      destroyRegionResult = aResultsList;
-      if (destroyRegionResult.isSuccessful()) {
-        xmlEntity.set(destroyRegionResult.getXmlEntity());
-      } else if (destroyRegionResult.getThrowable() != null) {
-        Throwable t = destroyRegionResult.getThrowable();
-        LogWrapper.getInstance().info(t.getMessage(), t);
-        message = CliStrings.format(
-            CliStrings.DESTROY_REGION__MSG__ERROR_OCCURRED_WHILE_DESTROYING_0_REASON_1, regionPath,
-            t.getMessage());
-        isRegionDestroyed = false;
+    // destroy is called on each member, if any error happens in any one of the member, we should
+    // deem the destroy not successful.
+    String errorMessage = null;
+    for (CliFunctionResult functionResult : resultsList) {
+      if (functionResult.isSuccessful()) {
+        xmlEntity.set(functionResult.getXmlEntity());
       } else {
-        message = CliStrings.format(
-            CliStrings.DESTROY_REGION__MSG__UNKNOWN_RESULT_WHILE_DESTROYING_REGION_0_REASON_1,
-            regionPath, destroyRegionResult.getMessage());
-        isRegionDestroyed = false;
+        if (functionResult.getThrowable() != null) {
+          throw functionResult.getThrowable();
+        }
+        if (functionResult.getMessage() != null) {
+          errorMessage = functionResult.getMessage();
+        } else {
+          errorMessage = "Destroy failed on one member";
+        }
+        // if any error occurred, break out without looking further
+        break;
       }
     }
-    if (isRegionDestroyed) {
-      result = ResultBuilder.createInfoResult(message);
-    } else {
-      result = ResultBuilder.createUserErrorResult(message);
+
+    if (errorMessage != null) {
+      return ResultBuilder.createGemFireErrorResult(errorMessage);
     }
 
+    Result result =
+        ResultBuilder.createInfoResult(String.format("\"%s\" destroyed successfully.", regionPath));
     if (xmlEntity.get() != null) {
       persistClusterConfiguration(result,
           () -> getSharedConfiguration().deleteXmlEntity(xmlEntity.get(), null));
     }
-
     return result;
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommand.java
index 20cbeac9d6..90b6fc66d0 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommand.java
@@ -39,7 +39,6 @@
 import org.apache.geode.management.cli.CliMetaData;
 import org.apache.geode.management.cli.ConverterHint;
 import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.functions.ExportLogsFunction;
 import org.apache.geode.management.internal.cli.functions.SizeExportLogsFunction;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
@@ -97,17 +96,14 @@ public Result exportLogs(
       @CliOption(key = CliStrings.EXPORT_LOGS__FILESIZELIMIT,
           unspecifiedDefaultValue = CliStrings.EXPORT_LOGS__FILESIZELIMIT__UNSPECIFIED_DEFAULT,
           specifiedDefaultValue = CliStrings.EXPORT_LOGS__FILESIZELIMIT__SPECIFIED_DEFAULT,
-          help = CliStrings.EXPORT_LOGS__FILESIZELIMIT__HELP) String fileSizeLimit) {
+          help = CliStrings.EXPORT_LOGS__FILESIZELIMIT__HELP) String fileSizeLimit)
+      throws Exception {
 
     long totalEstimatedExportSize = 0;
     Result result;
     InternalCache cache = getCache();
     try {
-      Set<DistributedMember> targetMembers = getMembers(groups, memberIds);
-
-      if (targetMembers.isEmpty()) {
-        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
-      }
+      Set<DistributedMember> targetMembers = getMembersIncludingLocators(groups, memberIds);
 
       long userSpecifiedLimit = parseFileSizeLimit(fileSizeLimit);
       if (userSpecifiedLimit > 0) {
@@ -201,9 +197,6 @@ public Result exportLogs(
       FileUtils.deleteDirectory(tempDir.toFile());
 
       result = new CommandResult(exportedLogsZipFile);
-    } catch (Exception ex) {
-      logger.error(ex.getMessage(), ex);
-      result = ResultBuilder.createGemFireErrorResult(ex.getMessage());
     } finally {
       ExportLogsFunction.destroyExportLogsRegion(cache);
     }
@@ -216,13 +209,6 @@ public Result exportLogs(
   /**
    * Wrapper to enable stubbing of static method call for unit testing
    */
-  Set<DistributedMember> getMembers(String[] groups, String[] memberIds) {
-    return CliUtil.findMembersIncludingLocators(groups, memberIds);
-  }
-
-  /**
-   * Wrapper to enable stubbing of static method call for unit testing
-   */
   ResultCollector estimateLogSize(SizeExportLogsFunction.Args args, DistributedMember member) {
     return executeFunction(new SizeExportLogsFunction(), args, member);
   }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java
index 449b42a4e1..904001f34e 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java
@@ -14,12 +14,9 @@
  */
 package org.apache.geode.management.internal.cli.commands;
 
-import java.io.PrintWriter;
-import java.io.StringWriter;
 import java.util.Collections;
 import java.util.Set;
 
-import org.apache.commons.lang.StringUtils;
 import org.springframework.shell.core.CommandMarker;
 
 import org.apache.geode.cache.CacheFactory;
@@ -32,47 +29,22 @@
 import org.apache.geode.distributed.internal.InternalLocator;
 import org.apache.geode.internal.cache.InternalCache;
 import org.apache.geode.internal.security.SecurityService;
-import org.apache.geode.management.cli.CliMetaData;
 import org.apache.geode.management.cli.Result;
 import org.apache.geode.management.internal.cli.CliUtil;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.shell.Gfsh;
-import org.apache.geode.management.internal.cli.util.MemberNotFoundException;
 
 /**
  * Encapsulates common functionality for implementing command classes for the Geode shell (gfsh).
+ * this provides wrapper around the static methods in CliUtils for easy mock of the commands
  *
- * @see org.apache.geode.cache.Cache
- * @see org.apache.geode.cache.execute.FunctionService
- * @see org.apache.geode.distributed.DistributedMember
- * @see org.apache.geode.management.internal.cli.shell.Gfsh
- * @see org.springframework.shell.core.CommandMarker
+ * this class should not have much implementation of its own other then those tested in
+ * GfshCommandJUnitTest
  */
 @SuppressWarnings("unused")
 public interface GfshCommand extends CommandMarker {
 
-  default String convertDefaultValue(final String from, final String to) {
-    return CliMetaData.ANNOTATION_DEFAULT_VALUE.equals(from) ? to : from;
-  }
-
-  default String toString(final Boolean condition, final String trueValue,
-      final String falseValue) {
-    return Boolean.TRUE.equals(condition) ? StringUtils.defaultIfBlank(trueValue, "true")
-        : StringUtils.defaultIfBlank(falseValue, "false");
-  }
-
-  default String toString(final Throwable t, final boolean printStackTrace) {
-    String message = t.getMessage();
-
-    if (printStackTrace) {
-      StringWriter writer = new StringWriter();
-      t.printStackTrace(new PrintWriter(writer));
-      message = writer.toString();
-    }
-
-    return message;
-  }
-
   default boolean isConnectedAndReady() {
     return getGfsh() != null && getGfsh().isConnectedAndReady();
   }
@@ -103,7 +75,6 @@ default boolean isLogging() {
     return getGfsh() != null;
   }
 
-
   default InternalCache getCache() {
     return (InternalCache) CacheFactory.getAnyInstance();
   }
@@ -120,16 +91,23 @@ default Gfsh getGfsh() {
    * this either returns a non-null member or throw an exception if member is not found.
    */
   default DistributedMember getMember(final String memberName) {
-    DistributedMember member = CliUtil.getDistributedMemberByNameOrId(memberName);
+    DistributedMember member = findMember(memberName);
 
     if (member == null) {
-      throw new MemberNotFoundException(
+      throw new EntityNotFoundException(
           CliStrings.format(CliStrings.MEMBER_NOT_FOUND_ERROR_MESSAGE, memberName));
     }
     return member;
   }
 
   /**
+   * this will return the member found or null if no member with that name
+   */
+  default DistributedMember findMember(final String memberName) {
+    return CliUtil.getDistributedMemberByNameOrId(memberName);
+  }
+
+  /**
    * Gets all members in the GemFire distributed system/cache, including locators
    */
   default Set<DistributedMember> getAllMembers(final InternalCache cache) {
@@ -147,10 +125,42 @@ default Execution getMembersFunctionExecutor(final Set<DistributedMember> member
     return FunctionService.onMembers(members);
   }
 
+  /**
+   * if no members matches these names, an empty set would return
+   */
   default Set<DistributedMember> findMembers(String[] groups, String[] members) {
     return CliUtil.findMembers(groups, members);
   }
 
+  /**
+   * if no members matches these names, a UserErrorException will be thrown
+   */
+  default Set<DistributedMember> getMembers(String[] groups, String[] members) {
+    Set<DistributedMember> matchingMembers = findMembers(groups, members);
+    if (matchingMembers.size() == 0) {
+      throw new EntityNotFoundException(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    }
+    return matchingMembers;
+  }
+
+  /**
+   * if no members matches these names, an empty set would return
+   */
+  default Set<DistributedMember> findMembersIncludingLocators(String[] groups, String[] members) {
+    return CliUtil.findMembersIncludingLocators(groups, members);
+  }
+
+  /**
+   * if no members matches these names, a UserErrorException will be thrown
+   */
+  default Set<DistributedMember> getMembersIncludingLocators(String[] groups, String[] members) {
+    Set<DistributedMember> matchingMembers = findMembersIncludingLocators(groups, members);
+    if (matchingMembers.size() == 0) {
+      throw new EntityNotFoundException(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    }
+    return matchingMembers;
+  }
+
   default Set<DistributedMember> findMembersForRegion(InternalCache cache, String regionPath) {
     return CliUtil.getRegionAssociatedMembers(regionPath, cache, true);
   }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListDiskStoresCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListDiskStoresCommand.java
index 5444c4d8e3..e65d4fb57d 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListDiskStoresCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListDiskStoresCommand.java
@@ -22,9 +22,7 @@
 
 import org.springframework.shell.core.annotation.CliCommand;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.cache.execute.Execution;
-import org.apache.geode.cache.execute.FunctionInvocationTargetException;
 import org.apache.geode.cache.execute.ResultCollector;
 import org.apache.geode.distributed.DistributedMember;
 import org.apache.geode.internal.cache.execute.AbstractExecution;
@@ -45,25 +43,12 @@
   @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,
       operation = ResourcePermission.Operation.READ)
   public Result listDiskStores() {
-    try {
-      Set<DistributedMember> dataMembers = DiskStoreCommandsUtils.getNormalMembers(getCache());
+    Set<DistributedMember> dataMembers = DiskStoreCommandsUtils.getNormalMembers(getCache());
 
-      if (dataMembers.isEmpty()) {
-        return ResultBuilder.createInfoResult(CliStrings.NO_CACHING_MEMBERS_FOUND_MESSAGE);
-      }
-
-      return toTabularResult(getDiskStoreListing(dataMembers));
-    } catch (FunctionInvocationTargetException ignore) {
-      return ResultBuilder.createGemFireErrorResult(CliStrings
-          .format(CliStrings.COULD_NOT_EXECUTE_COMMAND_TRY_AGAIN, CliStrings.LIST_DISK_STORE));
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      return ResultBuilder.createGemFireErrorResult(
-          String.format(CliStrings.LIST_DISK_STORE__ERROR_MESSAGE, toString(t, isDebugging())));
+    if (dataMembers.isEmpty()) {
+      return ResultBuilder.createInfoResult(CliStrings.NO_CACHING_MEMBERS_FOUND_MESSAGE);
     }
+    return toTabularResult(getDiskStoreListing(dataMembers));
   }
 
   @SuppressWarnings("unchecked")
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListIndexCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListIndexCommand.java
index c5010debd2..663d1858f4 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListIndexCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListIndexCommand.java
@@ -23,9 +23,7 @@
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.cache.execute.Execution;
-import org.apache.geode.cache.execute.FunctionInvocationTargetException;
 import org.apache.geode.cache.execute.ResultCollector;
 import org.apache.geode.internal.cache.execute.AbstractExecution;
 import org.apache.geode.internal.lang.StringUtils;
@@ -48,20 +46,8 @@
   public Result listIndex(@CliOption(key = CliStrings.LIST_INDEX__STATS,
       specifiedDefaultValue = "true", unspecifiedDefaultValue = "false",
       help = CliStrings.LIST_INDEX__STATS__HELP) final boolean showStats) {
-    try {
-      return toTabularResult(getIndexListing(), showStats);
-    } catch (FunctionInvocationTargetException ignore) {
-      return ResultBuilder.createGemFireErrorResult(
-          CliStrings.format(CliStrings.COULD_NOT_EXECUTE_COMMAND_TRY_AGAIN, CliStrings.LIST_INDEX));
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      getCache().getLogger().error(t);
-      return ResultBuilder.createGemFireErrorResult(
-          String.format(CliStrings.LIST_INDEX__ERROR_MESSAGE, toString(t, isDebugging())));
-    }
+
+    return toTabularResult(getIndexListing(), showStats);
   }
 
   private Result toTabularResult(final List<IndexDetails> indexDetailsList,
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommand.java
index 6020eca61f..1e6f5da046 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommand.java
@@ -28,13 +28,11 @@
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.distributed.AbstractLauncher;
 import org.apache.geode.distributed.ConfigurationProperties;
 import org.apache.geode.distributed.LocatorLauncher;
 import org.apache.geode.distributed.ServerLauncher;
 import org.apache.geode.internal.OSProcess;
-import org.apache.geode.internal.i18n.LocalizedStrings;
 import org.apache.geode.internal.lang.StringUtils;
 import org.apache.geode.internal.lang.SystemUtils;
 import org.apache.geode.internal.process.ProcessStreamReader;
@@ -119,219 +117,193 @@ public Result startLocator(
       @CliOption(key = CliStrings.START_LOCATOR__HTTP_SERVICE_PORT,
           help = CliStrings.START_LOCATOR__HTTP_SERVICE_PORT__HELP) final Integer httpServicePort,
       @CliOption(key = CliStrings.START_LOCATOR__HTTP_SERVICE_BIND_ADDRESS,
-          help = CliStrings.START_LOCATOR__HTTP_SERVICE_BIND_ADDRESS__HELP) final String httpServiceBindAddress) {
-    try {
-      if (StringUtils.isBlank(memberName)) {
-        // when the user doesn't give us a name, we make one up!
-        memberName = StartMemberUtils.getNameGenerator().generate('-');
-      }
+          help = CliStrings.START_LOCATOR__HTTP_SERVICE_BIND_ADDRESS__HELP) final String httpServiceBindAddress)
+      throws Exception {
+    if (StringUtils.isBlank(memberName)) {
+      // when the user doesn't give us a name, we make one up!
+      memberName = StartMemberUtils.getNameGenerator().generate('-');
+    }
 
-      workingDirectory = StartMemberUtils.resolveWorkingDir(workingDirectory, memberName);
+    workingDirectory = StartMemberUtils.resolveWorkingDir(workingDirectory, memberName);
 
-      if (gemfirePropertiesFile != null && !gemfirePropertiesFile.exists()) {
-        return ResultBuilder.createUserErrorResult(
-            CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, StringUtils.EMPTY,
-                gemfirePropertiesFile.getAbsolutePath()));
-      }
+    if (gemfirePropertiesFile != null && !gemfirePropertiesFile.exists()) {
+      return ResultBuilder.createUserErrorResult(
+          CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, StringUtils.EMPTY,
+              gemfirePropertiesFile.getAbsolutePath()));
+    }
 
-      if (gemfireSecurityPropertiesFile != null && !gemfireSecurityPropertiesFile.exists()) {
-        return ResultBuilder.createUserErrorResult(
-            CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, "Security ",
-                gemfireSecurityPropertiesFile.getAbsolutePath()));
-      }
+    if (gemfireSecurityPropertiesFile != null && !gemfireSecurityPropertiesFile.exists()) {
+      return ResultBuilder.createUserErrorResult(
+          CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, "Security ",
+              gemfireSecurityPropertiesFile.getAbsolutePath()));
+    }
 
-      File locatorPidFile = new File(workingDirectory, ProcessType.LOCATOR.getPidFileName());
-
-      final int oldPid = StartMemberUtils.readPid(locatorPidFile);
-
-      Properties gemfireProperties = new Properties();
-
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.GROUPS,
-          group);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOCATORS,
-          locators);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOG_LEVEL,
-          logLevel);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.MCAST_ADDRESS, mcastBindAddress);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.MCAST_PORT,
-          mcastPort);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.ENABLE_CLUSTER_CONFIGURATION, enableSharedConfiguration);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.LOAD_CLUSTER_CONFIGURATION_FROM_DIR,
-          loadSharedConfigurationFromDirectory);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.CLUSTER_CONFIGURATION_DIR, clusterConfigDir);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.HTTP_SERVICE_PORT, httpServicePort);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.HTTP_SERVICE_BIND_ADDRESS, httpServiceBindAddress);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.JMX_MANAGER_HOSTNAME_FOR_CLIENTS, jmxManagerHostnameForClients);
-
-      // read the OSProcess enable redirect system property here
-      // TODO: replace with new GFSH argument
-      final boolean redirectOutput =
-          Boolean.getBoolean(OSProcess.ENABLE_OUTPUT_REDIRECTION_PROPERTY);
-      LocatorLauncher.Builder locatorLauncherBuilder =
-          new LocatorLauncher.Builder().setBindAddress(bindAddress).setForce(force).setPort(port)
-              .setRedirectOutput(redirectOutput).setWorkingDirectory(workingDirectory);
-      if (hostnameForClients != null) {
-        locatorLauncherBuilder.setHostnameForClients(hostnameForClients);
-      }
-      if (memberName != null) {
-        locatorLauncherBuilder.setMemberName(memberName);
+    File locatorPidFile = new File(workingDirectory, ProcessType.LOCATOR.getPidFileName());
+
+    final int oldPid = StartMemberUtils.readPid(locatorPidFile);
+
+    Properties gemfireProperties = new Properties();
+
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.GROUPS, group);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOCATORS,
+        locators);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOG_LEVEL,
+        logLevel);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.MCAST_ADDRESS,
+        mcastBindAddress);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.MCAST_PORT,
+        mcastPort);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.ENABLE_CLUSTER_CONFIGURATION, enableSharedConfiguration);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.LOAD_CLUSTER_CONFIGURATION_FROM_DIR,
+        loadSharedConfigurationFromDirectory);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.CLUSTER_CONFIGURATION_DIR, clusterConfigDir);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.HTTP_SERVICE_PORT, httpServicePort);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.HTTP_SERVICE_BIND_ADDRESS, httpServiceBindAddress);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.JMX_MANAGER_HOSTNAME_FOR_CLIENTS, jmxManagerHostnameForClients);
+
+    // read the OSProcess enable redirect system property here
+    // TODO: replace with new GFSH argument
+    final boolean redirectOutput = Boolean.getBoolean(OSProcess.ENABLE_OUTPUT_REDIRECTION_PROPERTY);
+    LocatorLauncher.Builder locatorLauncherBuilder =
+        new LocatorLauncher.Builder().setBindAddress(bindAddress).setForce(force).setPort(port)
+            .setRedirectOutput(redirectOutput).setWorkingDirectory(workingDirectory);
+    if (hostnameForClients != null) {
+      locatorLauncherBuilder.setHostnameForClients(hostnameForClients);
+    }
+    if (memberName != null) {
+      locatorLauncherBuilder.setMemberName(memberName);
+    }
+    LocatorLauncher locatorLauncher = locatorLauncherBuilder.build();
+
+    String[] locatorCommandLine = createStartLocatorCommandLine(locatorLauncher,
+        gemfirePropertiesFile, gemfireSecurityPropertiesFile, gemfireProperties, classpath,
+        includeSystemClasspath, jvmArgsOpts, initialHeap, maxHeap);
+
+    final Process locatorProcess = new ProcessBuilder(locatorCommandLine)
+        .directory(new File(locatorLauncher.getWorkingDirectory())).start();
+
+    locatorProcess.getInputStream().close();
+    locatorProcess.getOutputStream().close();
+
+    // fix TRAC bug #51967 by using NON_BLOCKING on Windows
+    final ProcessStreamReader.ReadingMode readingMode = SystemUtils.isWindows()
+        ? ProcessStreamReader.ReadingMode.NON_BLOCKING : ProcessStreamReader.ReadingMode.BLOCKING;
+
+    final StringBuffer message = new StringBuffer(); // need thread-safe StringBuffer
+    ProcessStreamReader.InputListener inputListener = line -> {
+      message.append(line);
+      if (readingMode == ProcessStreamReader.ReadingMode.BLOCKING) {
+        message.append(StringUtils.LINE_SEPARATOR);
       }
-      LocatorLauncher locatorLauncher = locatorLauncherBuilder.build();
+    };
 
-      String[] locatorCommandLine = createStartLocatorCommandLine(locatorLauncher,
-          gemfirePropertiesFile, gemfireSecurityPropertiesFile, gemfireProperties, classpath,
-          includeSystemClasspath, jvmArgsOpts, initialHeap, maxHeap);
+    ProcessStreamReader stderrReader = new ProcessStreamReader.Builder(locatorProcess)
+        .inputStream(locatorProcess.getErrorStream()).inputListener(inputListener)
+        .readingMode(readingMode).continueReadingMillis(2 * 1000).build().start();
 
-      final Process locatorProcess = new ProcessBuilder(locatorCommandLine)
-          .directory(new File(locatorLauncher.getWorkingDirectory())).start();
+    LocatorLauncher.LocatorState locatorState;
 
-      locatorProcess.getInputStream().close();
-      locatorProcess.getOutputStream().close();
+    String previousLocatorStatusMessage = null;
 
-      // fix TRAC bug #51967 by using NON_BLOCKING on Windows
-      final ProcessStreamReader.ReadingMode readingMode = SystemUtils.isWindows()
-          ? ProcessStreamReader.ReadingMode.NON_BLOCKING : ProcessStreamReader.ReadingMode.BLOCKING;
+    LauncherSignalListener locatorSignalListener = new LauncherSignalListener();
 
-      final StringBuffer message = new StringBuffer(); // need thread-safe StringBuffer
-      ProcessStreamReader.InputListener inputListener = line -> {
-        message.append(line);
-        if (readingMode == ProcessStreamReader.ReadingMode.BLOCKING) {
-          message.append(StringUtils.LINE_SEPARATOR);
-        }
-      };
+    final boolean registeredLocatorSignalListener =
+        getGfsh().getSignalHandler().registerListener(locatorSignalListener);
 
-      ProcessStreamReader stderrReader = new ProcessStreamReader.Builder(locatorProcess)
-          .inputStream(locatorProcess.getErrorStream()).inputListener(inputListener)
-          .readingMode(readingMode).continueReadingMillis(2 * 1000).build().start();
+    try {
+      getGfsh().logInfo(String.format(CliStrings.START_LOCATOR__RUN_MESSAGE, IOUtils
+          .tryGetCanonicalPathElseGetAbsolutePath(new File(locatorLauncher.getWorkingDirectory()))),
+          null);
 
-      LocatorLauncher.LocatorState locatorState;
+      do {
+        if (locatorProcess.isAlive()) {
+          Gfsh.print(".");
 
-      String previousLocatorStatusMessage = null;
+          synchronized (this) {
+            TimeUnit.MILLISECONDS.timedWait(this, 500);
+          }
 
-      LauncherSignalListener locatorSignalListener = new LauncherSignalListener();
+          locatorState = LocatorLauncher.LocatorState.fromDirectory(workingDirectory, memberName);
 
-      final boolean registeredLocatorSignalListener =
-          getGfsh().getSignalHandler().registerListener(locatorSignalListener);
+          String currentLocatorStatusMessage = locatorState.getStatusMessage();
 
-      try {
-        getGfsh().logInfo(String.format(CliStrings.START_LOCATOR__RUN_MESSAGE,
-            IOUtils.tryGetCanonicalPathElseGetAbsolutePath(
-                new File(locatorLauncher.getWorkingDirectory()))),
-            null);
-
-        do {
-          if (locatorProcess.isAlive()) {
-            Gfsh.print(".");
-
-            synchronized (this) {
-              TimeUnit.MILLISECONDS.timedWait(this, 500);
-            }
-
-            locatorState = LocatorLauncher.LocatorState.fromDirectory(workingDirectory, memberName);
-
-            String currentLocatorStatusMessage = locatorState.getStatusMessage();
-
-            if (locatorState.isStartingOrNotResponding()
-                && !(StringUtils.isBlank(currentLocatorStatusMessage)
-                    || currentLocatorStatusMessage.equalsIgnoreCase(previousLocatorStatusMessage)
-                    || currentLocatorStatusMessage.trim().toLowerCase().equals("null"))) {
-              Gfsh.println();
-              Gfsh.println(currentLocatorStatusMessage);
-              previousLocatorStatusMessage = currentLocatorStatusMessage;
-            }
-          } else {
-            final int exitValue = locatorProcess.exitValue();
-
-            return ResultBuilder.createShellClientErrorResult(
-                String.format(CliStrings.START_LOCATOR__PROCESS_TERMINATED_ABNORMALLY_ERROR_MESSAGE,
-                    exitValue, locatorLauncher.getWorkingDirectory(), message.toString()));
+          if (locatorState.isStartingOrNotResponding()
+              && !(StringUtils.isBlank(currentLocatorStatusMessage)
+                  || currentLocatorStatusMessage.equalsIgnoreCase(previousLocatorStatusMessage)
+                  || currentLocatorStatusMessage.trim().toLowerCase().equals("null"))) {
+            Gfsh.println();
+            Gfsh.println(currentLocatorStatusMessage);
+            previousLocatorStatusMessage = currentLocatorStatusMessage;
           }
-        } while (!(registeredLocatorSignalListener && locatorSignalListener.isSignaled())
-            && locatorState.isStartingOrNotResponding());
-      } finally {
-        // stop will close
-        stderrReader.stopAsync(StartMemberUtils.PROCESS_STREAM_READER_ASYNC_STOP_TIMEOUT_MILLIS);
-
-        // ErrorStream
-        getGfsh().getSignalHandler().unregisterListener(locatorSignalListener);
-      }
+        } else {
+          final int exitValue = locatorProcess.exitValue();
 
-      Gfsh.println();
+          return ResultBuilder.createShellClientErrorResult(
+              String.format(CliStrings.START_LOCATOR__PROCESS_TERMINATED_ABNORMALLY_ERROR_MESSAGE,
+                  exitValue, locatorLauncher.getWorkingDirectory(), message.toString()));
+        }
+      } while (!(registeredLocatorSignalListener && locatorSignalListener.isSignaled())
+          && locatorState.isStartingOrNotResponding());
+    } finally {
+      // stop will close
+      stderrReader.stopAsync(StartMemberUtils.PROCESS_STREAM_READER_ASYNC_STOP_TIMEOUT_MILLIS);
 
-      final boolean asyncStart =
-          (registeredLocatorSignalListener && locatorSignalListener.isSignaled()
-              && ServerLauncher.ServerState.isStartingNotRespondingOrNull(locatorState));
+      // ErrorStream
+      getGfsh().getSignalHandler().unregisterListener(locatorSignalListener);
+    }
 
-      InfoResultData infoResultData = ResultBuilder.createInfoResultData();
+    Gfsh.println();
 
-      if (asyncStart) {
-        infoResultData.addLine(
-            String.format(CliStrings.ASYNC_PROCESS_LAUNCH_MESSAGE, CliStrings.LOCATOR_TERM_NAME));
-        return ResultBuilder.buildResult(infoResultData);
-      }
+    final boolean asyncStart =
+        (registeredLocatorSignalListener && locatorSignalListener.isSignaled()
+            && ServerLauncher.ServerState.isStartingNotRespondingOrNull(locatorState));
 
-      infoResultData.addLine(locatorState.toString());
-      String locatorHostName;
-      InetAddress bindAddr = locatorLauncher.getBindAddress();
-      if (bindAddr != null) {
-        locatorHostName = bindAddr.getCanonicalHostName();
-      } else {
-        locatorHostName = StringUtils.defaultIfBlank(locatorLauncher.getHostnameForClients(),
-            HostUtils.getLocalHost());
-      }
+    InfoResultData infoResultData = ResultBuilder.createInfoResultData();
+
+    if (asyncStart) {
+      infoResultData.addLine(
+          String.format(CliStrings.ASYNC_PROCESS_LAUNCH_MESSAGE, CliStrings.LOCATOR_TERM_NAME));
+      return ResultBuilder.buildResult(infoResultData);
+    }
 
-      int locatorPort = Integer.parseInt(locatorState.getPort());
+    infoResultData.addLine(locatorState.toString());
+    String locatorHostName;
+    InetAddress bindAddr = locatorLauncher.getBindAddress();
+    if (bindAddr != null) {
+      locatorHostName = bindAddr.getCanonicalHostName();
+    } else {
+      locatorHostName = StringUtils.defaultIfBlank(locatorLauncher.getHostnameForClients(),
+          HostUtils.getLocalHost());
+    }
 
+    int locatorPort = Integer.parseInt(locatorState.getPort());
 
-      ConnectCommand connectCommand = new ConnectCommand();
-      Properties configProperties = connectCommand.resolveSslProperties(getGfsh(), false,
-          gemfirePropertiesFile, gemfireSecurityPropertiesFile);
 
-      // AUTO-CONNECT
-      // If the connect succeeds add the connected message to the result,
-      // Else, ask the user to use the "connect" command to connect to the Locator.
-      if (shouldAutoConnect(connect)) {
-        doAutoConnect(locatorHostName, locatorPort, configProperties, infoResultData);
-      }
+    ConnectCommand connectCommand = new ConnectCommand();
+    Properties configProperties = connectCommand.resolveSslProperties(getGfsh(), false,
+        gemfirePropertiesFile, gemfireSecurityPropertiesFile);
 
-      // Report on the state of the Shared Configuration service if enabled...
-      if (enableSharedConfiguration) {
-        infoResultData.addLine(ClusterConfigurationStatusRetriever.fromLocator(locatorHostName,
-            locatorPort, configProperties));
-      }
+    // AUTO-CONNECT
+    // If the connect succeeds add the connected message to the result,
+    // Else, ask the user to use the "connect" command to connect to the Locator.
+    if (shouldAutoConnect(connect)) {
+      doAutoConnect(locatorHostName, locatorPort, configProperties, infoResultData);
+    }
 
-      return ResultBuilder.buildResult(infoResultData);
-    } catch (IllegalArgumentException e) {
-      String message = e.getMessage();
-      if (message != null && message.matches(
-          LocalizedStrings.Launcher_Builder_UNKNOWN_HOST_ERROR_MESSAGE.toLocalizedString(".+"))) {
-        message =
-            CliStrings.format(CliStrings.LAUNCHERLIFECYCLECOMMANDS__MSG__FAILED_TO_START_0_REASON_1,
-                CliStrings.LOCATOR_TERM_NAME, message);
-      }
-      return ResultBuilder.createUserErrorResult(message);
-    } catch (IllegalStateException e) {
-      return ResultBuilder.createUserErrorResult(e.getMessage());
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      String errorMessage = String.format(CliStrings.START_LOCATOR__GENERAL_ERROR_MESSAGE,
-          StringUtils.defaultIfBlank(workingDirectory, memberName),
-          HostUtils.getLocatorId(bindAddress, port), this.toString(t, getGfsh().getDebug()));
-      getGfsh().logToFile(errorMessage, t);
-      return ResultBuilder.createShellClientErrorResult(errorMessage);
-    } finally {
-      Gfsh.redirectInternalJavaLoggers();
+    // Report on the state of the Shared Configuration service if enabled...
+    if (enableSharedConfiguration) {
+      infoResultData.addLine(ClusterConfigurationStatusRetriever.fromLocator(locatorHostName,
+          locatorPort, configProperties));
     }
+
+    return ResultBuilder.buildResult(infoResultData);
+
   }
 
   // TODO should we connect implicitly when in non-interactive, headless mode (e.g. gfsh -e "start
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartServerCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartServerCommand.java
index 8080e3fa36..35227010be 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartServerCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartServerCommand.java
@@ -26,13 +26,11 @@
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.cache.server.CacheServer;
 import org.apache.geode.distributed.AbstractLauncher;
 import org.apache.geode.distributed.ConfigurationProperties;
 import org.apache.geode.distributed.ServerLauncher;
 import org.apache.geode.internal.OSProcess;
-import org.apache.geode.internal.i18n.LocalizedStrings;
 import org.apache.geode.internal.lang.StringUtils;
 import org.apache.geode.internal.lang.SystemUtils;
 import org.apache.geode.internal.process.ProcessStreamReader;
@@ -176,243 +174,221 @@ public Result startServer(
           help = CliStrings.START_SERVER__USERNAME__HELP) final String userName,
       @CliOption(key = CliStrings.START_SERVER__PASSWORD, unspecifiedDefaultValue = "",
           help = CliStrings.START_SERVER__PASSWORD__HELP) String passwordToUse)
+      throws Exception
   // NOTICE: keep the parameters in alphabetical order based on their CliStrings.START_SERVER_* text
   {
-    try {
-      if (StringUtils.isBlank(memberName)) {
-        // when the user doesn't give us a name, we make one up!
-        memberName = StartMemberUtils.getNameGenerator().generate('-');
-      }
 
-      // prompt for password is username is specified in the command
-      if (StringUtils.isNotBlank(userName)) {
-        if (StringUtils.isBlank(passwordToUse)) {
-          passwordToUse = getGfsh().readPassword(CliStrings.START_SERVER__PASSWORD + ": ");
-        }
-        if (StringUtils.isBlank(passwordToUse)) {
-          return ResultBuilder.createConnectionErrorResult(
-              CliStrings.START_SERVER__MSG__PASSWORD_MUST_BE_SPECIFIED);
-        }
+    if (StringUtils.isBlank(memberName)) {
+      // when the user doesn't give us a name, we make one up!
+      memberName = StartMemberUtils.getNameGenerator().generate('-');
+    }
+
+    // prompt for password is username is specified in the command
+    if (StringUtils.isNotBlank(userName)) {
+      if (StringUtils.isBlank(passwordToUse)) {
+        passwordToUse = getGfsh().readPassword(CliStrings.START_SERVER__PASSWORD + ": ");
+      }
+      if (StringUtils.isBlank(passwordToUse)) {
+        return ResultBuilder
+            .createConnectionErrorResult(CliStrings.START_SERVER__MSG__PASSWORD_MUST_BE_SPECIFIED);
       }
+    }
 
-      workingDirectory = StartMemberUtils.resolveWorkingDir(workingDirectory, memberName);
+    workingDirectory = StartMemberUtils.resolveWorkingDir(workingDirectory, memberName);
 
-      cacheXmlPathname = CliUtil.resolvePathname(cacheXmlPathname);
+    cacheXmlPathname = CliUtil.resolvePathname(cacheXmlPathname);
 
-      if (StringUtils.isNotBlank(cacheXmlPathname)
-          && !IOUtils.isExistingPathname(cacheXmlPathname)) {
-        return ResultBuilder.createUserErrorResult(
-            CliStrings.format(CliStrings.CACHE_XML_NOT_FOUND_MESSAGE, cacheXmlPathname));
-      }
+    if (StringUtils.isNotBlank(cacheXmlPathname) && !IOUtils.isExistingPathname(cacheXmlPathname)) {
+      return ResultBuilder.createUserErrorResult(
+          CliStrings.format(CliStrings.CACHE_XML_NOT_FOUND_MESSAGE, cacheXmlPathname));
+    }
 
-      if (gemfirePropertiesFile != null && !gemfirePropertiesFile.exists()) {
-        return ResultBuilder.createUserErrorResult(
-            CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, StringUtils.EMPTY,
-                gemfirePropertiesFile.getAbsolutePath()));
-      }
+    if (gemfirePropertiesFile != null && !gemfirePropertiesFile.exists()) {
+      return ResultBuilder.createUserErrorResult(
+          CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, StringUtils.EMPTY,
+              gemfirePropertiesFile.getAbsolutePath()));
+    }
 
-      if (gemfireSecurityPropertiesFile != null && !gemfireSecurityPropertiesFile.exists()) {
-        return ResultBuilder.createUserErrorResult(
-            CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, "Security ",
-                gemfireSecurityPropertiesFile.getAbsolutePath()));
-      }
+    if (gemfireSecurityPropertiesFile != null && !gemfireSecurityPropertiesFile.exists()) {
+      return ResultBuilder.createUserErrorResult(
+          CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, "Security ",
+              gemfireSecurityPropertiesFile.getAbsolutePath()));
+    }
 
-      File serverPidFile = new File(workingDirectory, ProcessType.SERVER.getPidFileName());
-
-      final int oldPid = StartMemberUtils.readPid(serverPidFile);
-
-      Properties gemfireProperties = new Properties();
-
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.BIND_ADDRESS,
-          bindAddress);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.CACHE_XML_FILE, cacheXmlPathname);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.ENABLE_TIME_STATISTICS, enableTimeStatistics);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.GROUPS,
-          group);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.JMX_MANAGER_HOSTNAME_FOR_CLIENTS, jmxManagerHostnameForClients);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOCATORS,
-          locators);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.LOCATOR_WAIT_TIME, locatorWaitTime);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOG_LEVEL,
-          logLevel);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.MCAST_ADDRESS, mcastBindAddress);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.MCAST_PORT,
-          mcastPort);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.MEMCACHED_PORT, memcachedPort);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.MEMCACHED_PROTOCOL, memcachedProtocol);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.MEMCACHED_BIND_ADDRESS, memcachedBindAddress);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.REDIS_PORT,
-          redisPort);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.REDIS_BIND_ADDRESS, redisBindAddress);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.REDIS_PASSWORD, redisPassword);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.STATISTIC_ARCHIVE_FILE, statisticsArchivePathname);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.USE_CLUSTER_CONFIGURATION, requestSharedConfiguration);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOCK_MEMORY,
-          lockMemory);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.OFF_HEAP_MEMORY_SIZE, offHeapMemorySize);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.START_DEV_REST_API, startRestApi);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.HTTP_SERVICE_PORT, httpServicePort);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.HTTP_SERVICE_BIND_ADDRESS, httpServiceBindAddress);
-      // if username is specified in the command line, it will overwrite what's set in the
-      // properties file
-      if (StringUtils.isNotBlank(userName)) {
-        gemfireProperties.setProperty(ResourceConstants.USER_NAME, userName);
-        gemfireProperties.setProperty(ResourceConstants.PASSWORD, passwordToUse);
-      }
+    File serverPidFile = new File(workingDirectory, ProcessType.SERVER.getPidFileName());
+
+    final int oldPid = StartMemberUtils.readPid(serverPidFile);
+
+    Properties gemfireProperties = new Properties();
+
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.BIND_ADDRESS,
+        bindAddress);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.CACHE_XML_FILE,
+        cacheXmlPathname);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.ENABLE_TIME_STATISTICS, enableTimeStatistics);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.GROUPS, group);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.JMX_MANAGER_HOSTNAME_FOR_CLIENTS, jmxManagerHostnameForClients);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOCATORS,
+        locators);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.LOCATOR_WAIT_TIME, locatorWaitTime);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOG_LEVEL,
+        logLevel);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.MCAST_ADDRESS,
+        mcastBindAddress);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.MCAST_PORT,
+        mcastPort);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.MEMCACHED_PORT,
+        memcachedPort);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.MEMCACHED_PROTOCOL, memcachedProtocol);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.MEMCACHED_BIND_ADDRESS, memcachedBindAddress);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.REDIS_PORT,
+        redisPort);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.REDIS_BIND_ADDRESS, redisBindAddress);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.REDIS_PASSWORD,
+        redisPassword);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.STATISTIC_ARCHIVE_FILE, statisticsArchivePathname);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.USE_CLUSTER_CONFIGURATION, requestSharedConfiguration);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOCK_MEMORY,
+        lockMemory);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.OFF_HEAP_MEMORY_SIZE, offHeapMemorySize);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.START_DEV_REST_API, startRestApi);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.HTTP_SERVICE_PORT, httpServicePort);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.HTTP_SERVICE_BIND_ADDRESS, httpServiceBindAddress);
+    // if username is specified in the command line, it will overwrite what's set in the
+    // properties file
+    if (StringUtils.isNotBlank(userName)) {
+      gemfireProperties.setProperty(ResourceConstants.USER_NAME, userName);
+      gemfireProperties.setProperty(ResourceConstants.PASSWORD, passwordToUse);
+    }
 
-      // read the OSProcess enable redirect system property here -- TODO: replace with new GFSH
-      // argument
-      final boolean redirectOutput =
-          Boolean.getBoolean(OSProcess.ENABLE_OUTPUT_REDIRECTION_PROPERTY);
-
-      ServerLauncher.Builder serverLauncherBuilder = new ServerLauncher.Builder()
-          .setAssignBuckets(assignBuckets).setDisableDefaultServer(disableDefaultServer)
-          .setForce(force).setRebalance(rebalance).setRedirectOutput(redirectOutput)
-          .setServerBindAddress(serverBindAddress).setServerPort(serverPort)
-          .setSpringXmlLocation(springXmlLocation).setWorkingDirectory(workingDirectory)
-          .setCriticalHeapPercentage(criticalHeapPercentage)
-          .setEvictionHeapPercentage(evictionHeapPercentage)
-          .setCriticalOffHeapPercentage(criticalOffHeapPercentage)
-          .setEvictionOffHeapPercentage(evictionOffHeapPercentage).setMaxConnections(maxConnections)
-          .setMaxMessageCount(maxMessageCount).setMaxThreads(maxThreads)
-          .setMessageTimeToLive(messageTimeToLive).setSocketBufferSize(socketBufferSize);
-      if (hostNameForClients != null) {
-        serverLauncherBuilder.setHostNameForClients(hostNameForClients);
-      }
-      if (memberName != null) {
-        serverLauncherBuilder.setMemberName(memberName);
-      }
-      ServerLauncher serverLauncher = serverLauncherBuilder.build();
+    // read the OSProcess enable redirect system property here -- TODO: replace with new GFSH
+    // argument
+    final boolean redirectOutput = Boolean.getBoolean(OSProcess.ENABLE_OUTPUT_REDIRECTION_PROPERTY);
+
+    ServerLauncher.Builder serverLauncherBuilder = new ServerLauncher.Builder()
+        .setAssignBuckets(assignBuckets).setDisableDefaultServer(disableDefaultServer)
+        .setForce(force).setRebalance(rebalance).setRedirectOutput(redirectOutput)
+        .setServerBindAddress(serverBindAddress).setServerPort(serverPort)
+        .setSpringXmlLocation(springXmlLocation).setWorkingDirectory(workingDirectory)
+        .setCriticalHeapPercentage(criticalHeapPercentage)
+        .setEvictionHeapPercentage(evictionHeapPercentage)
+        .setCriticalOffHeapPercentage(criticalOffHeapPercentage)
+        .setEvictionOffHeapPercentage(evictionOffHeapPercentage).setMaxConnections(maxConnections)
+        .setMaxMessageCount(maxMessageCount).setMaxThreads(maxThreads)
+        .setMessageTimeToLive(messageTimeToLive).setSocketBufferSize(socketBufferSize);
+    if (hostNameForClients != null) {
+      serverLauncherBuilder.setHostNameForClients(hostNameForClients);
+    }
+    if (memberName != null) {
+      serverLauncherBuilder.setMemberName(memberName);
+    }
+    ServerLauncher serverLauncher = serverLauncherBuilder.build();
 
-      String[] serverCommandLine = createStartServerCommandLine(serverLauncher,
-          gemfirePropertiesFile, gemfireSecurityPropertiesFile, gemfireProperties, classpath,
-          includeSystemClasspath, jvmArgsOpts, disableExitWhenOutOfMemory, initialHeap, maxHeap);
+    String[] serverCommandLine = createStartServerCommandLine(serverLauncher, gemfirePropertiesFile,
+        gemfireSecurityPropertiesFile, gemfireProperties, classpath, includeSystemClasspath,
+        jvmArgsOpts, disableExitWhenOutOfMemory, initialHeap, maxHeap);
 
-      if (getGfsh().getDebug()) {
-        getGfsh().logInfo(StringUtils.join(serverCommandLine, StringUtils.SPACE), null);
-      }
+    if (getGfsh().getDebug()) {
+      getGfsh().logInfo(StringUtils.join(serverCommandLine, StringUtils.SPACE), null);
+    }
 
-      Process serverProcess = new ProcessBuilder(serverCommandLine)
-          .directory(new File(serverLauncher.getWorkingDirectory())).start();
+    Process serverProcess = new ProcessBuilder(serverCommandLine)
+        .directory(new File(serverLauncher.getWorkingDirectory())).start();
 
-      serverProcess.getInputStream().close();
-      serverProcess.getOutputStream().close();
+    serverProcess.getInputStream().close();
+    serverProcess.getOutputStream().close();
 
-      // fix TRAC bug #51967 by using NON_BLOCKING on Windows
-      final ProcessStreamReader.ReadingMode readingMode = SystemUtils.isWindows()
-          ? ProcessStreamReader.ReadingMode.NON_BLOCKING : ProcessStreamReader.ReadingMode.BLOCKING;
+    // fix TRAC bug #51967 by using NON_BLOCKING on Windows
+    final ProcessStreamReader.ReadingMode readingMode = SystemUtils.isWindows()
+        ? ProcessStreamReader.ReadingMode.NON_BLOCKING : ProcessStreamReader.ReadingMode.BLOCKING;
 
-      final StringBuffer message = new StringBuffer(); // need thread-safe StringBuffer
-      ProcessStreamReader.InputListener inputListener = line -> {
-        message.append(line);
-        if (readingMode == ProcessStreamReader.ReadingMode.BLOCKING) {
-          message.append(StringUtils.LINE_SEPARATOR);
-        }
-      };
+    final StringBuffer message = new StringBuffer(); // need thread-safe StringBuffer
+    ProcessStreamReader.InputListener inputListener = line -> {
+      message.append(line);
+      if (readingMode == ProcessStreamReader.ReadingMode.BLOCKING) {
+        message.append(StringUtils.LINE_SEPARATOR);
+      }
+    };
 
-      ProcessStreamReader stderrReader = new ProcessStreamReader.Builder(serverProcess)
-          .inputStream(serverProcess.getErrorStream()).inputListener(inputListener)
-          .readingMode(readingMode).continueReadingMillis(2 * 1000).build().start();
+    ProcessStreamReader stderrReader = new ProcessStreamReader.Builder(serverProcess)
+        .inputStream(serverProcess.getErrorStream()).inputListener(inputListener)
+        .readingMode(readingMode).continueReadingMillis(2 * 1000).build().start();
 
-      ServerLauncher.ServerState serverState;
+    ServerLauncher.ServerState serverState;
 
-      String previousServerStatusMessage = null;
+    String previousServerStatusMessage = null;
 
-      LauncherSignalListener serverSignalListener = new LauncherSignalListener();
+    LauncherSignalListener serverSignalListener = new LauncherSignalListener();
 
-      final boolean registeredServerSignalListener =
-          getGfsh().getSignalHandler().registerListener(serverSignalListener);
+    final boolean registeredServerSignalListener =
+        getGfsh().getSignalHandler().registerListener(serverSignalListener);
 
-      try {
-        getGfsh().logInfo(String.format(CliStrings.START_SERVER__RUN_MESSAGE,
-            IOUtils.tryGetCanonicalPathElseGetAbsolutePath(
-                new File(serverLauncher.getWorkingDirectory()))),
-            null);
+    try {
+      getGfsh().logInfo(String.format(CliStrings.START_SERVER__RUN_MESSAGE, IOUtils
+          .tryGetCanonicalPathElseGetAbsolutePath(new File(serverLauncher.getWorkingDirectory()))),
+          null);
 
-        serverState = ServerLauncher.ServerState.fromDirectory(workingDirectory, memberName);
-        do {
-          if (serverProcess.isAlive()) {
-            Gfsh.print(".");
+      serverState = ServerLauncher.ServerState.fromDirectory(workingDirectory, memberName);
+      do {
+        if (serverProcess.isAlive()) {
+          Gfsh.print(".");
 
-            synchronized (this) {
-              TimeUnit.MILLISECONDS.timedWait(this, 500);
-            }
+          synchronized (this) {
+            TimeUnit.MILLISECONDS.timedWait(this, 500);
+          }
 
-            serverState = ServerLauncher.ServerState.fromDirectory(workingDirectory, memberName);
+          serverState = ServerLauncher.ServerState.fromDirectory(workingDirectory, memberName);
 
-            String currentServerStatusMessage = serverState.getStatusMessage();
+          String currentServerStatusMessage = serverState.getStatusMessage();
 
-            if (serverState.isStartingOrNotResponding()
-                && !(StringUtils.isBlank(currentServerStatusMessage)
-                    || currentServerStatusMessage.equalsIgnoreCase(previousServerStatusMessage)
-                    || currentServerStatusMessage.trim().toLowerCase().equals("null"))) {
-              Gfsh.println();
-              Gfsh.println(currentServerStatusMessage);
-              previousServerStatusMessage = currentServerStatusMessage;
-            }
-          } else {
-            final int exitValue = serverProcess.exitValue();
+          if (serverState.isStartingOrNotResponding()
+              && !(StringUtils.isBlank(currentServerStatusMessage)
+                  || currentServerStatusMessage.equalsIgnoreCase(previousServerStatusMessage)
+                  || currentServerStatusMessage.trim().toLowerCase().equals("null"))) {
+            Gfsh.println();
+            Gfsh.println(currentServerStatusMessage);
+            previousServerStatusMessage = currentServerStatusMessage;
+          }
+        } else {
+          final int exitValue = serverProcess.exitValue();
 
-            return ResultBuilder.createShellClientErrorResult(
-                String.format(CliStrings.START_SERVER__PROCESS_TERMINATED_ABNORMALLY_ERROR_MESSAGE,
-                    exitValue, serverLauncher.getWorkingDirectory(), message.toString()));
+          return ResultBuilder.createShellClientErrorResult(
+              String.format(CliStrings.START_SERVER__PROCESS_TERMINATED_ABNORMALLY_ERROR_MESSAGE,
+                  exitValue, serverLauncher.getWorkingDirectory(), message.toString()));
 
-          }
-        } while (!(registeredServerSignalListener && serverSignalListener.isSignaled())
-            && serverState.isStartingOrNotResponding());
-      } finally {
-        stderrReader.stopAsync(StartMemberUtils.PROCESS_STREAM_READER_ASYNC_STOP_TIMEOUT_MILLIS); // stop
-                                                                                                  // will
-                                                                                                  // close
-        // ErrorStream
-        getGfsh().getSignalHandler().unregisterListener(serverSignalListener);
-      }
+        }
+      } while (!(registeredServerSignalListener && serverSignalListener.isSignaled())
+          && serverState.isStartingOrNotResponding());
+    } finally {
+      stderrReader.stopAsync(StartMemberUtils.PROCESS_STREAM_READER_ASYNC_STOP_TIMEOUT_MILLIS); // stop
+                                                                                                // will
+                                                                                                // close
+      // ErrorStream
+      getGfsh().getSignalHandler().unregisterListener(serverSignalListener);
+    }
 
-      Gfsh.println();
+    Gfsh.println();
 
-      final boolean asyncStart =
-          ServerLauncher.ServerState.isStartingNotRespondingOrNull(serverState);
+    final boolean asyncStart =
+        ServerLauncher.ServerState.isStartingNotRespondingOrNull(serverState);
 
-      if (asyncStart) { // async start
-        Gfsh.print(String.format(CliStrings.ASYNC_PROCESS_LAUNCH_MESSAGE, SERVER_TERM_NAME));
-        return ResultBuilder.createInfoResult("");
-      } else {
-        return ResultBuilder.createInfoResult(serverState.toString());
-      }
-    } catch (IllegalArgumentException e) {
-      String message = e.getMessage();
-      if (message != null && message.matches(
-          LocalizedStrings.Launcher_Builder_UNKNOWN_HOST_ERROR_MESSAGE.toLocalizedString(".+"))) {
-        message =
-            CliStrings.format(CliStrings.LAUNCHERLIFECYCLECOMMANDS__MSG__FAILED_TO_START_0_REASON_1,
-                SERVER_TERM_NAME, message);
-      }
-      return ResultBuilder.createUserErrorResult(message);
-    } catch (IllegalStateException e) {
-      return ResultBuilder.createUserErrorResult(e.getMessage());
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      return ResultBuilder.createShellClientErrorResult(String.format(
-          CliStrings.START_SERVER__GENERAL_ERROR_MESSAGE, this.toString(t, getGfsh().getDebug())));
+    if (asyncStart) { // async start
+      Gfsh.print(String.format(CliStrings.ASYNC_PROCESS_LAUNCH_MESSAGE, SERVER_TERM_NAME));
+      return ResultBuilder.createInfoResult("");
+    } else {
+      return ResultBuilder.createInfoResult(serverState.toString());
     }
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartJConsoleCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartJConsoleCommand.java
index 1bcbbae893..0e27bfdb0b 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartJConsoleCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartJConsoleCommand.java
@@ -108,7 +108,7 @@ public Result startJConsole(
     } catch (Throwable t) {
       SystemFailure.checkFailure();
       return ResultBuilder.createShellClientErrorResult(
-          String.format(CliStrings.START_JCONSOLE__CATCH_ALL_ERROR_MESSAGE, toString(t, false)));
+          String.format(CliStrings.START_JCONSOLE__CATCH_ALL_ERROR_MESSAGE, t.getMessage()));
     }
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartJVisualVMCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartJVisualVMCommand.java
index 699a4825f3..48a711f020 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartJVisualVMCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartJVisualVMCommand.java
@@ -72,7 +72,7 @@ public Result startJVisualVM(
     } catch (Throwable t) {
       SystemFailure.checkFailure();
       return ResultBuilder.createShellClientErrorResult(
-          String.format(CliStrings.START_JVISUALVM__ERROR_MESSAGE, toString(t, false)));
+          String.format(CliStrings.START_JVISUALVM__ERROR_MESSAGE, t.getMessage()));
     }
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartPulseCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartPulseCommand.java
index fbf32d88fa..f07a90fb4e 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartPulseCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartPulseCommand.java
@@ -81,7 +81,7 @@ public Result startPulse(@CliOption(key = CliStrings.START_PULSE__URL,
     } catch (Throwable t) {
       SystemFailure.checkFailure();
       return ResultBuilder.createShellClientErrorResult(
-          String.format(CliStrings.START_PULSE__ERROR, toString(t, false)));
+          String.format(CliStrings.START_PULSE__ERROR, t.getMessage()));
     }
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartVsdCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartVsdCommand.java
index 7719611779..36b56147cb 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartVsdCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartVsdCommand.java
@@ -85,7 +85,7 @@ public Result startVsd(@CliOption(key = CliStrings.START_VSD__FILE,
     } catch (Throwable t) {
       SystemFailure.checkFailure();
       return ResultBuilder.createShellClientErrorResult(
-          String.format(CliStrings.START_VSD__ERROR_MESSAGE, toString(t, false)));
+          String.format(CliStrings.START_VSD__ERROR_MESSAGE, t.getMessage()));
     }
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StatusLocatorCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StatusLocatorCommand.java
index 06f835034c..fac8ad2a23 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StatusLocatorCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StatusLocatorCommand.java
@@ -16,18 +16,15 @@
 
 import static org.apache.geode.management.internal.cli.i18n.CliStrings.LOCATOR_TERM_NAME;
 import static org.apache.geode.management.internal.cli.shell.MXBeanProvider.getMemberMXBean;
-import static org.apache.geode.management.internal.cli.util.HostUtils.getLocatorId;
 
 import java.io.IOException;
 
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.distributed.AbstractLauncher;
 import org.apache.geode.distributed.LocatorLauncher;
 import org.apache.geode.internal.lang.StringUtils;
-import org.apache.geode.internal.lang.SystemUtils;
 import org.apache.geode.management.MemberMXBean;
 import org.apache.geode.management.cli.CliMetaData;
 import org.apache.geode.management.cli.ConverterHint;
@@ -53,49 +50,39 @@ public Result statusLocator(
       @CliOption(key = CliStrings.STATUS_LOCATOR__PID,
           help = CliStrings.STATUS_LOCATOR__PID__HELP) final Integer pid,
       @CliOption(key = CliStrings.STATUS_LOCATOR__DIR,
-          help = CliStrings.STATUS_LOCATOR__DIR__HELP) final String workingDirectory) {
-    try {
-      if (StringUtils.isNotBlank(member)) {
-        if (isConnectedAndReady()) {
-          final MemberMXBean locatorProxy = getMemberMXBean(member);
+          help = CliStrings.STATUS_LOCATOR__DIR__HELP) final String workingDirectory)
+      throws Exception {
 
-          if (locatorProxy != null) {
-            LocatorLauncher.LocatorState state =
-                LocatorLauncher.LocatorState.fromJson(locatorProxy.status());
-            return createStatusLocatorResult(state);
-          } else {
-            return ResultBuilder.createUserErrorResult(CliStrings.format(
-                CliStrings.STATUS_LOCATOR__NO_LOCATOR_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
-          }
+    if (StringUtils.isNotBlank(member)) {
+      if (isConnectedAndReady()) {
+        final MemberMXBean locatorProxy = getMemberMXBean(member);
+
+        if (locatorProxy != null) {
+          LocatorLauncher.LocatorState state =
+              LocatorLauncher.LocatorState.fromJson(locatorProxy.status());
+          return createStatusLocatorResult(state);
         } else {
           return ResultBuilder.createUserErrorResult(CliStrings.format(
-              CliStrings.STATUS_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, LOCATOR_TERM_NAME));
+              CliStrings.STATUS_LOCATOR__NO_LOCATOR_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
         }
       } else {
-        final LocatorLauncher locatorLauncher =
-            new LocatorLauncher.Builder().setCommand(LocatorLauncher.Command.STATUS)
-                .setBindAddress(locatorHost).setDebug(isDebugging()).setPid(pid)
-                .setPort(locatorPort).setWorkingDirectory(workingDirectory).build();
+        return ResultBuilder.createUserErrorResult(CliStrings.format(
+            CliStrings.STATUS_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, LOCATOR_TERM_NAME));
+      }
+    } else {
+      final LocatorLauncher locatorLauncher =
+          new LocatorLauncher.Builder().setCommand(LocatorLauncher.Command.STATUS)
+              .setBindAddress(locatorHost).setDebug(isDebugging()).setPid(pid).setPort(locatorPort)
+              .setWorkingDirectory(workingDirectory).build();
 
-        final LocatorLauncher.LocatorState status = locatorLauncher.status();
-        if (status.getStatus().equals(AbstractLauncher.Status.NOT_RESPONDING)
-            || status.getStatus().equals(AbstractLauncher.Status.STOPPED)) {
-          return ResultBuilder.createShellClientErrorResult(status.toString());
-        }
-        return createStatusLocatorResult(status);
+      final LocatorLauncher.LocatorState status = locatorLauncher.status();
+      if (status.getStatus().equals(AbstractLauncher.Status.NOT_RESPONDING)
+          || status.getStatus().equals(AbstractLauncher.Status.STOPPED)) {
+        return ResultBuilder.createShellClientErrorResult(status.toString());
       }
-    } catch (IllegalArgumentException | IllegalStateException e) {
-      return ResultBuilder.createUserErrorResult(e.getMessage());
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      return ResultBuilder.createShellClientErrorResult(String.format(
-          CliStrings.STATUS_LOCATOR__GENERAL_ERROR_MESSAGE, getLocatorId(locatorHost, locatorPort),
-          StringUtils.defaultIfBlank(workingDirectory, SystemUtils.CURRENT_DIRECTORY),
-          toString(t, getGfsh().getDebug())));
+      return createStatusLocatorResult(status);
     }
+
   }
 
   protected Result createStatusLocatorResult(final LocatorLauncher.LocatorState state)
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StatusServerCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StatusServerCommand.java
index 43374ab161..0a7fb8b7bf 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StatusServerCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StatusServerCommand.java
@@ -16,10 +16,11 @@
 
 import static org.apache.geode.management.internal.cli.shell.MXBeanProvider.getMemberMXBean;
 
+import java.io.IOException;
+
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.distributed.AbstractLauncher;
 import org.apache.geode.distributed.ServerLauncher;
 import org.apache.geode.internal.lang.StringUtils;
@@ -42,52 +43,41 @@ public Result statusServer(
       @CliOption(key = CliStrings.STATUS_SERVER__PID,
           help = CliStrings.STATUS_SERVER__PID__HELP) final Integer pid,
       @CliOption(key = CliStrings.STATUS_SERVER__DIR,
-          help = CliStrings.STATUS_SERVER__DIR__HELP) final String workingDirectory) {
-    try {
-      if (StringUtils.isNotBlank(member)) {
-        if (isConnectedAndReady()) {
-          final MemberMXBean serverProxy = getMemberMXBean(member);
+          help = CliStrings.STATUS_SERVER__DIR__HELP) final String workingDirectory)
+      throws IOException {
+
+    if (StringUtils.isNotBlank(member)) {
+      if (isConnectedAndReady()) {
+        final MemberMXBean serverProxy = getMemberMXBean(member);
 
-          if (serverProxy != null) {
-            return ResultBuilder.createInfoResult(
-                ServerLauncher.ServerState.fromJson(serverProxy.status()).toString());
-          } else {
-            return ResultBuilder.createUserErrorResult(CliStrings.format(
-                CliStrings.STATUS_SERVER__NO_SERVER_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
-          }
+        if (serverProxy != null) {
+          return ResultBuilder.createInfoResult(
+              ServerLauncher.ServerState.fromJson(serverProxy.status()).toString());
         } else {
           return ResultBuilder.createUserErrorResult(CliStrings
-              .format(CliStrings.STATUS_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, "Cache Server"));
+              .format(CliStrings.STATUS_SERVER__NO_SERVER_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
         }
       } else {
-        final ServerLauncher serverLauncher = new ServerLauncher.Builder()
-            .setCommand(ServerLauncher.Command.STATUS).setDebug(isDebugging())
-            // NOTE since we do not know whether the "CacheServer" was enabled or not on the GemFire
-            // server when it was started,
-            // set the disableDefaultServer property in the ServerLauncher.Builder to default status
-            // to the MemberMBean
-            // TODO fix this hack! (how, the 'start server' loop needs it)
-            .setDisableDefaultServer(true).setPid(pid).setWorkingDirectory(workingDirectory)
-            .build();
+        return ResultBuilder.createUserErrorResult(CliStrings
+            .format(CliStrings.STATUS_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, "Cache Server"));
+      }
+    } else {
+      final ServerLauncher serverLauncher = new ServerLauncher.Builder()
+          .setCommand(ServerLauncher.Command.STATUS).setDebug(isDebugging())
+          // NOTE since we do not know whether the "CacheServer" was enabled or not on the GemFire
+          // server when it was started,
+          // set the disableDefaultServer property in the ServerLauncher.Builder to default status
+          // to the MemberMBean
+          // TODO fix this hack! (how, the 'start server' loop needs it)
+          .setDisableDefaultServer(true).setPid(pid).setWorkingDirectory(workingDirectory).build();
 
-        final ServerLauncher.ServerState status = serverLauncher.status();
+      final ServerLauncher.ServerState status = serverLauncher.status();
 
-        if (status.getStatus().equals(AbstractLauncher.Status.NOT_RESPONDING)
-            || status.getStatus().equals(AbstractLauncher.Status.STOPPED)) {
-          return ResultBuilder.createGemFireErrorResult(status.toString());
-        }
-        return ResultBuilder.createInfoResult(status.toString());
+      if (status.getStatus().equals(AbstractLauncher.Status.NOT_RESPONDING)
+          || status.getStatus().equals(AbstractLauncher.Status.STOPPED)) {
+        return ResultBuilder.createGemFireErrorResult(status.toString());
       }
-    } catch (IllegalArgumentException | IllegalStateException e) {
-
-      return ResultBuilder.createUserErrorResult(e.getMessage());
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      return ResultBuilder.createShellClientErrorResult(String.format(
-          CliStrings.STATUS_SERVER__GENERAL_ERROR_MESSAGE, toString(t, getGfsh().getDebug())));
+      return ResultBuilder.createInfoResult(status.toString());
     }
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StopLocatorCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StopLocatorCommand.java
index ec3583c09a..e435b6e2e6 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StopLocatorCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StopLocatorCommand.java
@@ -22,7 +22,6 @@
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.distributed.AbstractLauncher;
 import org.apache.geode.distributed.LocatorLauncher;
 import org.apache.geode.internal.lang.StringUtils;
@@ -49,77 +48,65 @@ public Result stopLocator(
       @CliOption(key = CliStrings.STOP_LOCATOR__PID,
           help = CliStrings.STOP_LOCATOR__PID__HELP) final Integer pid,
       @CliOption(key = CliStrings.STOP_LOCATOR__DIR,
-          help = CliStrings.STOP_LOCATOR__DIR__HELP) final String workingDirectory) {
-    LocatorLauncher.LocatorState locatorState;
-
-    try {
-      if (StringUtils.isNotBlank(member)) {
-        if (isConnectedAndReady()) {
-          final MemberMXBean locatorProxy = getMemberMXBean(member);
+          help = CliStrings.STOP_LOCATOR__DIR__HELP) final String workingDirectory)
+      throws Exception {
 
-          if (locatorProxy != null) {
-            if (!locatorProxy.isLocator()) {
-              throw new IllegalStateException(
-                  CliStrings.format(CliStrings.STOP_LOCATOR__NOT_LOCATOR_ERROR_MESSAGE, member));
-            }
+    LocatorLauncher.LocatorState locatorState;
+    if (StringUtils.isNotBlank(member)) {
+      if (isConnectedAndReady()) {
+        final MemberMXBean locatorProxy = getMemberMXBean(member);
 
-            if (locatorProxy.isServer()) {
-              throw new IllegalStateException(CliStrings
-                  .format(CliStrings.STOP_LOCATOR__LOCATOR_IS_CACHE_SERVER_ERROR_MESSAGE, member));
-            }
+        if (locatorProxy != null) {
+          if (!locatorProxy.isLocator()) {
+            throw new IllegalStateException(
+                CliStrings.format(CliStrings.STOP_LOCATOR__NOT_LOCATOR_ERROR_MESSAGE, member));
+          }
 
-            locatorState = LocatorLauncher.LocatorState.fromJson(locatorProxy.status());
-            locatorProxy.shutDownMember();
-          } else {
-            return ResultBuilder.createUserErrorResult(CliStrings.format(
-                CliStrings.STOP_LOCATOR__NO_LOCATOR_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
+          if (locatorProxy.isServer()) {
+            throw new IllegalStateException(CliStrings
+                .format(CliStrings.STOP_LOCATOR__LOCATOR_IS_CACHE_SERVER_ERROR_MESSAGE, member));
           }
+
+          locatorState = LocatorLauncher.LocatorState.fromJson(locatorProxy.status());
+          locatorProxy.shutDownMember();
         } else {
-          return ResultBuilder.createUserErrorResult(CliStrings.format(
-              CliStrings.STOP_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, LOCATOR_TERM_NAME));
+          return ResultBuilder.createUserErrorResult(CliStrings
+              .format(CliStrings.STOP_LOCATOR__NO_LOCATOR_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
         }
       } else {
-        final LocatorLauncher locatorLauncher =
-            new LocatorLauncher.Builder().setCommand(LocatorLauncher.Command.STOP)
-                .setDebug(isDebugging()).setPid(pid).setWorkingDirectory(workingDirectory).build();
-
-        locatorState = locatorLauncher.status();
-        locatorLauncher.stop();
+        return ResultBuilder.createUserErrorResult(CliStrings
+            .format(CliStrings.STOP_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, LOCATOR_TERM_NAME));
       }
+    } else {
+      final LocatorLauncher locatorLauncher =
+          new LocatorLauncher.Builder().setCommand(LocatorLauncher.Command.STOP)
+              .setDebug(isDebugging()).setPid(pid).setWorkingDirectory(workingDirectory).build();
+
+      locatorState = locatorLauncher.status();
+      locatorLauncher.stop();
+    }
 
-      if (AbstractLauncher.Status.ONLINE.equals(locatorState.getStatus())) {
-        getGfsh().logInfo(
-            String.format(CliStrings.STOP_LOCATOR__STOPPING_LOCATOR_MESSAGE,
-                locatorState.getWorkingDirectory(), locatorState.getServiceLocation(),
-                locatorState.getMemberName(), locatorState.getPid(), locatorState.getLogFile()),
-            null);
+    if (AbstractLauncher.Status.ONLINE.equals(locatorState.getStatus())) {
+      getGfsh().logInfo(
+          String.format(CliStrings.STOP_LOCATOR__STOPPING_LOCATOR_MESSAGE,
+              locatorState.getWorkingDirectory(), locatorState.getServiceLocation(),
+              locatorState.getMemberName(), locatorState.getPid(), locatorState.getLogFile()),
+          null);
 
-        StopWatch stopWatch = new StopWatch(true);
-        while (locatorState.isVmWithProcessIdRunning()) {
-          Gfsh.print(".");
-          if (stopWatch.elapsedTimeMillis() > WAITING_FOR_STOP_TO_MAKE_PID_GO_AWAY_TIMEOUT_MILLIS) {
-            break;
-          }
-          synchronized (this) {
-            TimeUnit.MILLISECONDS.timedWait(this, 500);
-          }
+      StopWatch stopWatch = new StopWatch(true);
+      while (locatorState.isVmWithProcessIdRunning()) {
+        Gfsh.print(".");
+        if (stopWatch.elapsedTimeMillis() > WAITING_FOR_STOP_TO_MAKE_PID_GO_AWAY_TIMEOUT_MILLIS) {
+          break;
+        }
+        synchronized (this) {
+          TimeUnit.MILLISECONDS.timedWait(this, 500);
         }
-
-        return ResultBuilder.createInfoResult(StringUtils.EMPTY);
-      } else {
-        return ResultBuilder.createUserErrorResult(locatorState.toString());
       }
-    } catch (IllegalArgumentException | IllegalStateException e) {
-      return ResultBuilder.createUserErrorResult(e.getMessage());
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      return ResultBuilder.createShellClientErrorResult(String.format(
-          CliStrings.STOP_LOCATOR__GENERAL_ERROR_MESSAGE, toString(t, getGfsh().getDebug())));
-    } finally {
-      Gfsh.redirectInternalJavaLoggers();
+
+      return ResultBuilder.createInfoResult(StringUtils.EMPTY);
+    } else {
+      return ResultBuilder.createUserErrorResult(locatorState.toString());
     }
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StopServerCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StopServerCommand.java
index 526dcd8952..ba05073997 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StopServerCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StopServerCommand.java
@@ -21,7 +21,6 @@
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.distributed.AbstractLauncher;
 import org.apache.geode.distributed.ServerLauncher;
 import org.apache.geode.internal.lang.StringUtils;
@@ -47,73 +46,61 @@ public Result stopServer(
       @CliOption(key = CliStrings.STOP_SERVER__PID,
           help = CliStrings.STOP_SERVER__PID__HELP) final Integer pid,
       @CliOption(key = CliStrings.STOP_SERVER__DIR,
-          help = CliStrings.STOP_SERVER__DIR__HELP) final String workingDirectory) {
+          help = CliStrings.STOP_SERVER__DIR__HELP) final String workingDirectory)
+      throws Exception {
     ServerLauncher.ServerState serverState;
 
-    try {
-      if (StringUtils.isNotBlank(member)) {
-        if (!isConnectedAndReady()) {
-          return ResultBuilder.createUserErrorResult(CliStrings
-              .format(CliStrings.STOP_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, "Cache Server"));
-        }
-
-        final MemberMXBean serverProxy = getMemberMXBean(member);
+    if (StringUtils.isNotBlank(member)) {
+      if (!isConnectedAndReady()) {
+        return ResultBuilder.createUserErrorResult(CliStrings
+            .format(CliStrings.STOP_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, "Cache Server"));
+      }
 
-        if (serverProxy != null) {
-          if (!serverProxy.isServer()) {
-            throw new IllegalStateException(CliStrings
-                .format(CliStrings.STOP_SERVER__MEMBER_IS_NOT_SERVER_ERROR_MESSAGE, member));
-          }
+      final MemberMXBean serverProxy = getMemberMXBean(member);
 
-          serverState = ServerLauncher.ServerState.fromJson(serverProxy.status());
-          serverProxy.shutDownMember();
-        } else {
-          return ResultBuilder.createUserErrorResult(CliStrings
-              .format(CliStrings.STOP_SERVER__NO_SERVER_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
+      if (serverProxy != null) {
+        if (!serverProxy.isServer()) {
+          throw new IllegalStateException(CliStrings
+              .format(CliStrings.STOP_SERVER__MEMBER_IS_NOT_SERVER_ERROR_MESSAGE, member));
         }
 
+        serverState = ServerLauncher.ServerState.fromJson(serverProxy.status());
+        serverProxy.shutDownMember();
       } else {
-        final ServerLauncher serverLauncher =
-            new ServerLauncher.Builder().setCommand(ServerLauncher.Command.STOP)
-                .setDebug(isDebugging()).setPid(pid).setWorkingDirectory(workingDirectory).build();
-
-        serverState = serverLauncher.status();
-        serverLauncher.stop();
+        return ResultBuilder.createUserErrorResult(CliStrings
+            .format(CliStrings.STOP_SERVER__NO_SERVER_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
       }
 
-      if (AbstractLauncher.Status.ONLINE.equals(serverState.getStatus())) {
-        getGfsh().logInfo(
-            String.format(CliStrings.STOP_SERVER__STOPPING_SERVER_MESSAGE,
-                serverState.getWorkingDirectory(), serverState.getServiceLocation(),
-                serverState.getMemberName(), serverState.getPid(), serverState.getLogFile()),
-            null);
-
-        StopWatch stopWatch = new StopWatch(true);
-        while (serverState.isVmWithProcessIdRunning()) {
-          Gfsh.print(".");
-          if (stopWatch.elapsedTimeMillis() > WAITING_FOR_STOP_TO_MAKE_PID_GO_AWAY_TIMEOUT_MILLIS) {
-            break;
-          }
-          synchronized (this) {
-            TimeUnit.MILLISECONDS.timedWait(this, 500);
-          }
-        }
+    } else {
+      final ServerLauncher serverLauncher =
+          new ServerLauncher.Builder().setCommand(ServerLauncher.Command.STOP)
+              .setDebug(isDebugging()).setPid(pid).setWorkingDirectory(workingDirectory).build();
 
-        return ResultBuilder.createInfoResult(StringUtils.EMPTY);
-      } else {
-        return ResultBuilder.createUserErrorResult(serverState.toString());
+      serverState = serverLauncher.status();
+      serverLauncher.stop();
+    }
+
+    if (AbstractLauncher.Status.ONLINE.equals(serverState.getStatus())) {
+      getGfsh().logInfo(
+          String.format(CliStrings.STOP_SERVER__STOPPING_SERVER_MESSAGE,
+              serverState.getWorkingDirectory(), serverState.getServiceLocation(),
+              serverState.getMemberName(), serverState.getPid(), serverState.getLogFile()),
+          null);
+
+      StopWatch stopWatch = new StopWatch(true);
+      while (serverState.isVmWithProcessIdRunning()) {
+        Gfsh.print(".");
+        if (stopWatch.elapsedTimeMillis() > WAITING_FOR_STOP_TO_MAKE_PID_GO_AWAY_TIMEOUT_MILLIS) {
+          break;
+        }
+        synchronized (this) {
+          TimeUnit.MILLISECONDS.timedWait(this, 500);
+        }
       }
-    } catch (IllegalArgumentException | IllegalStateException e) {
-      return ResultBuilder.createUserErrorResult(e.getMessage());
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      return ResultBuilder.createShellClientErrorResult(String.format(
-          CliStrings.STOP_SERVER__GENERAL_ERROR_MESSAGE, toString(t, getGfsh().getDebug())));
-    } finally {
-      Gfsh.redirectInternalJavaLoggers();
+
+      return ResultBuilder.createInfoResult(StringUtils.EMPTY);
+    } else {
+      return ResultBuilder.createUserErrorResult(serverState.toString());
     }
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/CreateSubregionException.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/EntityNotFoundException.java
similarity index 63%
rename from geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/CreateSubregionException.java
rename to geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/EntityNotFoundException.java
index 9aaf247741..3f4f173fd6 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/CreateSubregionException.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/EntityNotFoundException.java
@@ -12,27 +12,35 @@
  * or implied. See the License for the specific language governing permissions and limitations under
  * the License.
  */
+
 package org.apache.geode.management.internal.cli.exceptions;
 
-/**
- * Indicates inability to create a Subregion of a region.
- *
- * @since GemFire 8.0
- */
-// TODO - Abhishek - Include in GemFire Exception Enhancements
-public class CreateSubregionException extends RuntimeException {
+import org.apache.geode.GemFireException;
 
-  private static final long serialVersionUID = 4387344870743824916L;
+public class EntityNotFoundException extends GemFireException {
 
-  public CreateSubregionException(String message, Throwable cause) {
-    super(message, cause);
+  private boolean statusOK;
+
+  public EntityNotFoundException() {}
+
+  public EntityNotFoundException(String message) {
+    super(message);
   }
 
-  public CreateSubregionException(String message) {
+  public EntityNotFoundException(String message, boolean statusOK) {
     super(message);
+    this.statusOK = statusOK;
   }
 
-  public CreateSubregionException(Throwable cause) {
+  public EntityNotFoundException(Throwable cause) {
     super(cause);
   }
+
+  public EntityNotFoundException(String message, Throwable cause) {
+    super(message, cause);
+  }
+
+  public boolean isStatusOK() {
+    return statusOK;
+  }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/IndexNotFoundException.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/IndexNotFoundException.java
deleted file mode 100644
index 402285bddf..0000000000
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/IndexNotFoundException.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-package org.apache.geode.management.internal.cli.exceptions;
-
-import org.apache.geode.management.internal.cli.i18n.CliStrings;
-
-public class IndexNotFoundException extends Exception {
-
-  private static final long serialVersionUID = 1L;
-  final String indexName;
-  final String message;
-
-  public IndexNotFoundException(final String indexName) {
-    this.indexName = indexName;
-    this.message = CliStrings.format("Index \" {0} \" not found", indexName);
-  }
-
-  public String getMessage() {
-    return this.message;
-  }
-}
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/DescribeDiskStoreFunction.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/DescribeDiskStoreFunction.java
index 1bbc3b52fb..f8668c074e 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/DescribeDiskStoreFunction.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/DescribeDiskStoreFunction.java
@@ -40,7 +40,7 @@
 import org.apache.geode.internal.logging.LogService;
 import org.apache.geode.internal.util.ArrayUtils;
 import org.apache.geode.management.internal.cli.domain.DiskStoreDetails;
-import org.apache.geode.management.internal.cli.util.DiskStoreNotFoundException;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
 
 /**
  * The DescribeDiskStoreFunction class is an implementation of a GemFire Function used to collect
@@ -120,7 +120,7 @@ public void execute(final FunctionContext context) {
           context.getResultSender().lastResult(diskStoreDetails);
         } else {
           context.getResultSender()
-              .sendException(new DiskStoreNotFoundException(
+              .sendException(new EntityNotFoundException(
                   String.format("A disk store with name (%1$s) was not found on member (%2$s).",
                       diskStoreName, memberName)));
         }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/RegionCreateFunction.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/RegionCreateFunction.java
index e524c2de50..55344d4e74 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/RegionCreateFunction.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/RegionCreateFunction.java
@@ -44,7 +44,6 @@
 import org.apache.geode.internal.logging.LogService;
 import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.commands.RegionCommandsUtils;
-import org.apache.geode.management.internal.cli.exceptions.CreateSubregionException;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.util.RegionPath;
 import org.apache.geode.management.internal.configuration.domain.XmlEntity;
@@ -105,7 +104,7 @@ public void execute(FunctionContext context) {
                 new Object[] {String.valueOf(RegionCommandsUtils.PERSISTENT_OVERFLOW_SHORTCUTS)});
       }
       resultSender.lastResult(handleException(memberNameOrId, exceptionMsg, null/* do not log */));
-    } catch (IllegalArgumentException | CreateSubregionException e) {
+    } catch (IllegalArgumentException e) {
       resultSender.lastResult(handleException(memberNameOrId, e.getMessage(), e));
     } catch (RegionExistsException e) {
       String exceptionMsg =
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/RegionDestroyFunction.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/RegionDestroyFunction.java
index d7cf09152b..1aae3383a4 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/RegionDestroyFunction.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/RegionDestroyFunction.java
@@ -20,7 +20,6 @@
 import org.apache.geode.cache.execute.FunctionContext;
 import org.apache.geode.internal.InternalEntity;
 import org.apache.geode.internal.cache.xmlcache.CacheXml;
-import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.configuration.domain.XmlEntity;
 
 /**
@@ -44,29 +43,35 @@ public void execute(FunctionContext context) {
     String regionPath = null;
     try {
       String functionId = context.getFunctionId();
-      if (getId().equals(functionId)) {
-        Object arguments = context.getArguments();
-        if (arguments != null) {
-          regionPath = (String) arguments;
-          Cache cache = context.getCache();
-          Region<?, ?> region = cache.getRegion(regionPath);
-          region.destroyRegion();
-          String regionName =
-              regionPath.startsWith(Region.SEPARATOR) ? regionPath.substring(1) : regionPath;
-          XmlEntity xmlEntity = new XmlEntity(CacheXml.REGION, "name", regionName);
-          context.getResultSender().lastResult(new CliFunctionResult("", xmlEntity, regionPath));
-        }
+      Object arguments = context.getArguments();
+
+      if (!getId().equals(functionId) || arguments == null) {
+        context.getResultSender().lastResult(new CliFunctionResult("", false,
+            "Function Id mismatch or arguments is not available."));
+        return;
+      }
+
+      regionPath = (String) arguments;
+      Cache cache = context.getCache();
+      Region<?, ?> region = cache.getRegion(regionPath);
+      // if the region is a distributed region, and is already destroyed by another member
+      if (region == null) {
+        context.getResultSender().lastResult(new CliFunctionResult("", true, "SUCCESS"));
+        return;
       }
-      context.getResultSender().lastResult(new CliFunctionResult("", false, "FAILURE"));
-    } catch (IllegalStateException e) {
-      context.getResultSender().lastResult(new CliFunctionResult("", e, null));
+
+      region.destroyRegion();
+      String regionName =
+          regionPath.startsWith(Region.SEPARATOR) ? regionPath.substring(1) : regionPath;
+      XmlEntity xmlEntity = new XmlEntity(CacheXml.REGION, "name", regionName);
+      context.getResultSender().lastResult(new CliFunctionResult("", xmlEntity, regionPath));
+
+    } catch (IllegalStateException ex) {
+      // user is trying to destroy something that can't destroyed.
+      context.getResultSender().lastResult(new CliFunctionResult("", false, ex.getMessage()));
     } catch (Exception ex) {
       context.getResultSender()
-          .lastResult(new CliFunctionResult("",
-              new RuntimeException(CliStrings.format(
-                  CliStrings.DESTROY_REGION__MSG__ERROR_WHILE_DESTROYING_REGION_0_REASON_1,
-                  new Object[] {regionPath, ex.getMessage()})),
-              null));
+          .lastResult(new CliFunctionResult("", ex, "failed to destroy " + regionPath));
     }
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/CommandExecutor.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/CommandExecutor.java
index c664a58c95..7c1c38e657 100755
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/CommandExecutor.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/CommandExecutor.java
@@ -19,6 +19,7 @@
 import org.springframework.util.ReflectionUtils;
 
 import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
 import org.apache.geode.management.internal.cli.exceptions.UserErrorException;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
 import org.apache.geode.security.NotAuthorizedException;
@@ -45,6 +46,12 @@ public Object execute(ParseResult parseResult) {
       throw e;
     } catch (UserErrorException e) {
       return ResultBuilder.createUserErrorResult(e.getMessage());
+    } catch (EntityNotFoundException e) {
+      if (e.isStatusOK()) {
+        return ResultBuilder.createInfoResult("Skipping: " + e.getMessage());
+      } else {
+        return ResultBuilder.createUserErrorResult(e.getMessage());
+      }
     } catch (Exception e) {
       logger.error("Could not execute \"" + parseResult + "\".", e);
       return ResultBuilder.createGemFireErrorResult(
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/util/DiskStoreNotFoundException.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/util/DiskStoreNotFoundException.java
deleted file mode 100644
index 1887f8842a..0000000000
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/util/DiskStoreNotFoundException.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.apache.geode.management.internal.cli.util;
-
-import org.apache.geode.GemFireException;
-
-/**
- * The DiskStoreNotFoundException is a GemFireException class indicating that a disk store by name
- * could not be found on a member specified by name!
- * </p>
- *
- * @see org.apache.geode.GemFireException
- * @since GemFire 7.0
- */
-// TODO this GemFireException should be moved to a more appropriate package!
-@SuppressWarnings("unused")
-public class DiskStoreNotFoundException extends GemFireException {
-  private static final long serialVersionUID = -5184836041554948093L;
-
-  public DiskStoreNotFoundException() {}
-
-  public DiskStoreNotFoundException(final String message) {
-    super(message);
-  }
-
-  public DiskStoreNotFoundException(final Throwable cause) {
-    super(cause);
-  }
-
-  public DiskStoreNotFoundException(final String message, final Throwable cause) {
-    super(message, cause);
-  }
-
-}
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/util/MemberNotFoundException.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/util/MemberNotFoundException.java
deleted file mode 100644
index 4a2ec4b9a2..0000000000
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/util/MemberNotFoundException.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.apache.geode.management.internal.cli.util;
-
-import org.apache.geode.management.internal.cli.exceptions.UserErrorException;
-
-/**
- * The MemberNotFoundException is a GemFirException indicating that a member by name could not be
- * found in the GemFire distributed system.
- * </p>
- *
- * @see org.apache.geode.GemFireException
- * @since GemFire 7.0
- */
-// TODO this GemFireException should be moved to a more appropriate package!
-@SuppressWarnings("unused")
-public class MemberNotFoundException extends UserErrorException {
-  private static final long serialVersionUID = 5686788909239181174L;
-
-  public MemberNotFoundException() {}
-
-  public MemberNotFoundException(final String message) {
-    super(message);
-  }
-
-  public MemberNotFoundException(final Throwable cause) {
-    super(cause);
-  }
-
-  public MemberNotFoundException(final String message, final Throwable cause) {
-    super(message, cause);
-  }
-
-}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java
index c5c3ee0e32..cf85a8a39b 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java
@@ -19,7 +19,6 @@
 
 import java.io.IOException;
 
-import org.junit.After;
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.ClassRule;
@@ -63,15 +62,6 @@ public void before() throws Exception {
     gfsh.connectAndVerify(locator);
   }
 
-  @After
-  public void after() throws Exception {
-    // destroy regions
-    gfsh.execute("destroy region --name=/Customer --if-exists");
-    gfsh.execute("destroy region --name=/Order --if-exists");
-    gfsh.execute("destroy region --name=/Customer_2 --if-exists");
-    gfsh.execute("destroy region --name=/Customer_3 --if-exists");
-  }
-
   @Test
   public void testDestroyDistributedRegion() {
     MemberVM.invokeInEveryMember(() -> {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandTest.java
index b519c8d423..0970d1a373 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandTest.java
@@ -16,21 +16,32 @@
 package org.apache.geode.management.internal.cli.commands;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
+import java.util.ArrayList;
 import java.util.Collections;
+import java.util.List;
+import java.util.Set;
 
 import org.junit.Before;
 import org.junit.ClassRule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
+import org.apache.geode.cache.execute.ResultCollector;
+import org.apache.geode.distributed.DistributedMember;
 import org.apache.geode.internal.cache.InternalCache;
 import org.apache.geode.management.cli.Result;
+import org.apache.geode.management.internal.cli.functions.CliFunctionResult;
 import org.apache.geode.management.internal.cli.result.CommandResult;
+import org.apache.geode.management.internal.configuration.domain.XmlEntity;
 import org.apache.geode.test.junit.categories.UnitTest;
 import org.apache.geode.test.junit.rules.GfshParserRule;
 
@@ -42,11 +53,22 @@
 
   private DestroyRegionCommand command;
   private CommandResult result;
+  private CliFunctionResult result1, result2;
 
   @Before
   public void before() throws Exception {
     command = spy(DestroyRegionCommand.class);
     doReturn(mock(InternalCache.class)).when(command).getCache();
+
+    ResultCollector collector = mock(ResultCollector.class);
+    doReturn(collector).when(command).executeFunction(any(), any(), any(Set.class));
+
+    List<CliFunctionResult> functionResults = new ArrayList<>();
+    doReturn(functionResults).when(collector).getResult();
+    result1 = mock(CliFunctionResult.class);
+    result2 = mock(CliFunctionResult.class);
+    functionResults.add(result1);
+    functionResults.add(result2);
   }
 
   @Test
@@ -73,4 +95,45 @@ public void whenNoRegionIsFoundOnAnyMembers() throws Exception {
     result = parser.executeCommandWithInstance(command, "destroy region --name=test --if-exists");
     assertThat(result.getStatus()).isEqualTo(Result.Status.OK);
   }
+
+  @Test
+  public void multipleResultReturnedWithOneError() throws Exception {
+    // mock this to pass the member search call
+    doReturn(Collections.singleton(DistributedMember.class)).when(command)
+        .findMembersForRegion(any(), any());
+    when(result1.isSuccessful()).thenReturn(true);
+    when(result1.getMessage()).thenReturn("result1 message");
+    when(result1.getXmlEntity()).thenReturn(mock(XmlEntity.class));
+
+    when(result2.isSuccessful()).thenReturn(false);
+    when(result2.getMessage()).thenReturn("result2 message");
+
+    result = parser.executeCommandWithInstance(command, "destroy region --name=test");
+    assertThat(result.getStatus()).isEqualTo(Result.Status.ERROR);
+    assertThat(result.getContent().toString()).contains("result2 message");
+
+
+    // verify that xmlEntiry returned by the result1 is not saved to Cluster config
+    verify(command, never()).persistClusterConfiguration(any(), any());
+  }
+
+  @Test
+  public void multipleResultReturnedWithOneException() throws Exception {
+    // mock this to pass the member search call
+    doReturn(Collections.singleton(DistributedMember.class)).when(command)
+        .findMembersForRegion(any(), any());
+    when(result1.isSuccessful()).thenReturn(true);
+    when(result1.getMessage()).thenReturn("result1 message");
+    when(result1.getXmlEntity()).thenReturn(mock(XmlEntity.class));
+
+    when(result2.isSuccessful()).thenReturn(false);
+    when(result2.getThrowable()).thenReturn(new IllegalArgumentException("something happened"));
+
+    assertThatThrownBy(
+        () -> parser.executeCommandWithInstance(command, "destroy region --name=test"))
+            .isInstanceOf(IllegalArgumentException.class);
+
+    // verify that xmlEntiry returned by the result1 is not saved to Cluster config
+    verify(command, never()).persistClusterConfiguration(any(), any());
+  }
 }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsJUnitTest.java
index f5eb7800f3..eb15d05320 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsJUnitTest.java
@@ -43,10 +43,10 @@
 import org.apache.geode.internal.cache.execute.AbstractExecution;
 import org.apache.geode.internal.util.CollectionUtils;
 import org.apache.geode.management.internal.cli.domain.DiskStoreDetails;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
 import org.apache.geode.management.internal.cli.functions.DescribeDiskStoreFunction;
 import org.apache.geode.management.internal.cli.functions.ListDiskStoresFunction;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
-import org.apache.geode.management.internal.cli.util.DiskStoreNotFoundException;
 import org.apache.geode.test.junit.categories.UnitTest;
 
 /**
@@ -142,8 +142,8 @@ public void testGetDiskStoreDescription() {
     assertEquals(expectedDiskStoredDetails, actualDiskStoreDetails);
   }
 
-  @Test(expected = DiskStoreNotFoundException.class)
-  public void testGetDiskStoreDescriptionThrowsDiskStoreNotFoundException() {
+  @Test(expected = EntityNotFoundException.class)
+  public void testGetDiskStoreDescriptionThrowsEntityNotFoundException() {
     final String diskStoreName = "mockDiskStore";
     final String memberId = "mockMember";
 
@@ -159,7 +159,7 @@ public void testGetDiskStoreDescriptionThrowsDiskStoreNotFoundException() {
         oneOf(mockFunctionExecutor).setArguments(with(equal(diskStoreName)));
         will(returnValue(mockFunctionExecutor));
         oneOf(mockFunctionExecutor).execute(with(aNonNull(DescribeDiskStoreFunction.class)));
-        will(throwException(new DiskStoreNotFoundException("expected")));
+        will(throwException(new EntityNotFoundException("expected")));
       }
     });
 
@@ -168,7 +168,7 @@ public void testGetDiskStoreDescriptionThrowsDiskStoreNotFoundException() {
 
     try {
       describeCommand.getDiskStoreDescription(memberId, diskStoreName);
-    } catch (DiskStoreNotFoundException expected) {
+    } catch (EntityNotFoundException expected) {
       assertEquals("expected", expected.getMessage());
       throw expected;
     }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommandTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommandTest.java
index 9c5d030a95..03a05a7fb9 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommandTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommandTest.java
@@ -14,7 +14,10 @@
  */
 package org.apache.geode.management.internal.cli.commands;
 
-import static org.apache.geode.management.internal.cli.commands.ExportLogsCommand.*;
+import static org.apache.geode.management.internal.cli.commands.ExportLogsCommand.GIGABYTE;
+import static org.apache.geode.management.internal.cli.commands.ExportLogsCommand.KILOBYTE;
+import static org.apache.geode.management.internal.cli.commands.ExportLogsCommand.MEGABYTE;
+import static org.apache.geode.management.internal.cli.commands.ExportLogsCommand.TERABYTE;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.mockito.Matchers.eq;
@@ -179,7 +182,7 @@ public void testTotalEstimateSizeExceedsLocatorAvailableDisk() throws Exception
     testResults2.addResult(member2, 60 * MEGABYTE);
 
     doReturn(mockCache).when(spyCmd).getCache();
-    doReturn(testMembers).when(spyCmd).getMembers(null, null);
+    doReturn(testMembers).when(spyCmd).getMembersIncludingLocators(null, null);
     doReturn(testResults1).when(spyCmd)
         .estimateLogSize(Matchers.any(SizeExportLogsFunction.Args.class), eq(member1));
     doReturn(testResults2).when(spyCmd)
@@ -220,7 +223,7 @@ public void testTotalEstimateSizeExceedsUserSpecifiedValue() throws Exception {
     testResults2.addResult(member2, 60 * MEGABYTE);
 
     doReturn(mockCache).when(spyCmd).getCache();
-    doReturn(testMembers).when(spyCmd).getMembers(null, null);
+    doReturn(testMembers).when(spyCmd).getMembersIncludingLocators(null, null);
     doReturn(testResults1).when(spyCmd)
         .estimateLogSize(Matchers.any(SizeExportLogsFunction.Args.class), eq(member1));
     doReturn(testResults2).when(spyCmd)
@@ -261,7 +264,7 @@ public void estimateLogSizeExceedsServerDisk() throws Exception {
     testResults1.addResult(member1, new ManagementException(sb.toString()));
 
     doReturn(mockCache).when(spyCmd).getCache();
-    doReturn(testMembers).when(spyCmd).getMembers(null, null);
+    doReturn(testMembers).when(spyCmd).getMembersIncludingLocators(null, null);
     doReturn(testResults1).when(spyCmd)
         .estimateLogSize(Matchers.any(SizeExportLogsFunction.Args.class), eq(member1));
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GfshCommandJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GfshCommandJUnitTest.java
index 27c41427cc..a2ee67e503 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GfshCommandJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GfshCommandJUnitTest.java
@@ -14,441 +14,87 @@
  */
 package org.apache.geode.management.internal.cli.commands;
 
-import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_BIND_ADDRESS;
-import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_PORT;
-import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;
-import static org.apache.geode.distributed.ConfigurationProperties.LOG_FILE;
-import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;
-import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;
-import static org.apache.geode.distributed.ConfigurationProperties.NAME;
-import static org.apache.geode.distributed.ConfigurationProperties.START_DEV_REST_API;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
 
-import java.io.File;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Properties;
+import java.util.Collections;
 
-import org.jmock.Expectations;
-import org.jmock.Mockery;
-import org.jmock.lib.concurrent.Synchroniser;
-import org.jmock.lib.legacy.ClassImposteriser;
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
-import org.apache.geode.cache.execute.Function;
-import org.apache.geode.cache.execute.FunctionService;
-import org.apache.geode.distributed.DistributedMember;
-import org.apache.geode.distributed.internal.DistributionConfig;
-import org.apache.geode.internal.cache.InternalCache;
-import org.apache.geode.internal.lang.StringUtils;
-import org.apache.geode.management.cli.CliMetaData;
+import org.apache.geode.distributed.internal.ClusterConfigurationService;
+import org.apache.geode.management.cli.Result;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
+import org.apache.geode.management.internal.cli.result.ResultBuilder;
+import org.apache.geode.management.internal.cli.shell.Gfsh;
 import org.apache.geode.test.junit.categories.UnitTest;
 
-/**
- * The GfshCommandJUnitTest class is a test suite of test cases testing the contract and
- * functionality of the GfshCommand class for implementing GemFire shell (Gfsh) commands.
- *
- * @see GfshCommand
- * @see org.jmock.Expectations
- * @see org.jmock.Mockery
- * @see org.jmock.lib.legacy.ClassImposteriser
- * @see org.junit.Assert
- * @see org.junit.Test
- * @since GemFire 7.0
- */
 @Category(UnitTest.class)
 public class GfshCommandJUnitTest {
 
-  private Mockery mockContext;
-
-  private static <T extends Function> T register(T function) {
-    if (FunctionService.isRegistered(function.getId())) {
-      function = (T) FunctionService.getFunction(function.getId());
-    } else {
-      FunctionService.registerFunction(function);
-    }
-
-    return function;
-  }
-
-  private static class DefaultGfshCommand implements GfshCommand {
-  }
-
-  private DefaultGfshCommand defaultGfshCommand;
+  private GfshCommand command;
+  private Gfsh gfsh;
+  private ClusterConfigurationService clusterConfigurationService;
 
   @Before
-  public void setup() {
-    mockContext = new Mockery();
-    mockContext.setImposteriser(ClassImposteriser.INSTANCE);
-    mockContext.setThreadingPolicy(new Synchroniser());
-
-    defaultGfshCommand = new DefaultGfshCommand();
-  }
-
-  @After
-  public void tearDown() {
-    mockContext.assertIsSatisfied();
-    mockContext = null;
-  }
-
-  private GfshCommand createAbstractCommandsSupport(final InternalCache cache) {
-    return new TestCommands(cache);
-  }
-
-  private DistributedMember createMockMember(final String memberId, final String memberName) {
-    final DistributedMember mockMember =
-        mockContext.mock(DistributedMember.class, "DistributedMember " + memberId);
-
-    mockContext.checking(new Expectations() {
-      {
-        allowing(mockMember).getName();
-        will(returnValue(memberName));
-        allowing(mockMember).getId();
-        will(returnValue(memberId));
-      }
-    });
-
-    return mockMember;
-  }
-
-  @Test
-  public void testConvertDefaultValue() {
-    assertNull(defaultGfshCommand.convertDefaultValue(null, StringUtils.EMPTY));
-    assertEquals(StringUtils.EMPTY,
-        defaultGfshCommand.convertDefaultValue(StringUtils.EMPTY, "test"));
-    assertEquals(StringUtils.SPACE,
-        defaultGfshCommand.convertDefaultValue(StringUtils.SPACE, "testing"));
-    assertEquals("tested",
-        defaultGfshCommand.convertDefaultValue(CliMetaData.ANNOTATION_DEFAULT_VALUE, "tested"));
+  public void before() throws Exception {
+    command = spy(GfshCommand.class);
+    gfsh = mock(Gfsh.class);
+    clusterConfigurationService = mock(ClusterConfigurationService.class);
   }
 
   @Test
-  public void testRegister() {
-    try {
-      final Function mockFunction = mockContext.mock(Function.class, "Function");
-
-      mockContext.checking(new Expectations() {
-        {
-          exactly(3).of(mockFunction).getId();
-          will(returnValue("testRegister"));
-          oneOf(mockFunction).isHA();
-          will(returnValue(true));
-          oneOf(mockFunction).hasResult();
-          will(returnValue(true));
-        }
-      });
+  public void isConnectedAndReady() throws Exception {
+    when(command.getGfsh()).thenReturn(null);
+    assertThat(command.isConnectedAndReady()).isFalse();
 
-      final GfshCommand commands =
-          createAbstractCommandsSupport(mockContext.mock(InternalCache.class));
+    when(command.getGfsh()).thenReturn(gfsh);
+    when(gfsh.isConnectedAndReady()).thenReturn(false);
+    assertThat(command.isConnectedAndReady()).isFalse();
 
-      assertFalse(FunctionService.isRegistered("testRegister"));
-      assertSame(mockFunction, register(mockFunction));
-      assertTrue(FunctionService.isRegistered("testRegister"));
-    } finally {
-      FunctionService.unregisterFunction("testRegister");
-    }
+    when(command.getGfsh()).thenReturn(gfsh);
+    when(gfsh.isConnectedAndReady()).thenReturn(true);
+    assertThat(command.isConnectedAndReady()).isTrue();
   }
 
   @Test
-  public void testRegisteredAlready() {
-    try {
-      final Function registeredFunction = mockContext.mock(Function.class, "Registered Function");
-      final Function unregisteredFunction =
-          mockContext.mock(Function.class, "Unregistered Function");
-
-      mockContext.checking(new Expectations() {
-        {
-          exactly(2).of(registeredFunction).getId();
-          will(returnValue("testRegisteredAlready"));
-          oneOf(registeredFunction).isHA();
-          will(returnValue(false));
-          exactly(2).of(unregisteredFunction).getId();
-          will(returnValue("testRegisteredAlready"));
-        }
-      });
-
-      final GfshCommand commands =
-          createAbstractCommandsSupport(mockContext.mock(InternalCache.class));
-
-      FunctionService.registerFunction(registeredFunction);
+  public void persistClusterConfiguration() throws Exception {
+    when(command.getSharedConfiguration()).thenReturn(null);
+    Result result = ResultBuilder.createInfoResult("info");
+    Runnable runnable = mock(Runnable.class);
 
-      assertTrue(FunctionService.isRegistered("testRegisteredAlready"));
-      assertSame(registeredFunction, register(unregisteredFunction));
-      assertTrue(FunctionService.isRegistered("testRegisteredAlready"));
-    } finally {
-      FunctionService.unregisterFunction("testRegisteredAlready");
-    }
-  }
+    command.persistClusterConfiguration(result, runnable);
+    assertThat(result.failedToPersist()).isTrue();
 
-  @Test
-  public void testToStringOnBoolean() {
-    assertEquals("false", defaultGfshCommand.toString(null, null, null));
-    assertEquals("true", defaultGfshCommand.toString(true, null, null));
-    assertEquals("true", defaultGfshCommand.toString(Boolean.TRUE, null, null));
-    assertEquals("false", defaultGfshCommand.toString(false, null, null));
-    assertEquals("false", defaultGfshCommand.toString(Boolean.FALSE, null, null));
-    assertEquals("false", defaultGfshCommand.toString(true, "false", "true"));
-    assertEquals("true", defaultGfshCommand.toString(false, "false", "true"));
-    assertEquals("Yes", defaultGfshCommand.toString(true, "Yes", "No"));
-    assertEquals("Yes", defaultGfshCommand.toString(false, "No", "Yes"));
-    assertEquals("TRUE", defaultGfshCommand.toString(Boolean.TRUE, "TRUE", "FALSE"));
-    assertEquals("FALSE", defaultGfshCommand.toString(Boolean.FALSE, "TRUE", "FALSE"));
+    when(command.getSharedConfiguration()).thenReturn(clusterConfigurationService);
+    command.persistClusterConfiguration(result, runnable);
+    assertThat(result.failedToPersist()).isFalse();
   }
 
   @Test
-  public void testToStringOnThrowable() {
-    assertEquals("test", defaultGfshCommand.toString(new Throwable("test"), false));
+  public void getMember() throws Exception {
+    doReturn(null).when(command).findMember("test");
+    assertThatThrownBy(() -> command.getMember("test")).isInstanceOf(EntityNotFoundException.class);
   }
 
   @Test
-  public void testToStringOnThrowablePrintingStackTrace() {
-    final StringWriter writer = new StringWriter();
-    final Throwable t = new Throwable("test");
-
-    t.printStackTrace(new PrintWriter(writer));
-
-    assertEquals(writer.toString(), defaultGfshCommand.toString(t, true));
-  }
-
-  private static class TestCommands implements GfshCommand {
-
-    private final InternalCache cache;
-
-    protected TestCommands(final InternalCache cache) {
-      assert cache != null : "The InternalCache cannot be null!";
-      this.cache = cache;
-    }
-
-    @Override
-    public InternalCache getCache() {
-      return this.cache;
-    }
-  }
-
-  @Test
-  public void testAddGemFirePropertyFileToCommandLine() {
-    List<String> commandLine = new ArrayList<>();
-    assertTrue(commandLine.isEmpty());
-
-    StartMemberUtils.addGemFirePropertyFile(commandLine, null);
-    assertTrue(commandLine.isEmpty());
-
-    File file = new File("/path/to/gemfire.properties");
-    StartMemberUtils.addGemFirePropertyFile(commandLine, file);
-    assertFalse(commandLine.isEmpty());
-    assertTrue(commandLine.contains("-DgemfirePropertyFile=" + file.getAbsolutePath()));
+  public void getMembers() throws Exception {
+    String[] members = {"member"};
+    doReturn(Collections.emptySet()).when(command).findMembers(members, null);
+    assertThatThrownBy(() -> command.getMembers(members, null))
+        .isInstanceOf(EntityNotFoundException.class);
   }
 
   @Test
-  public void testAddGemFireSystemPropertiesToCommandLine() {
-    final List<String> commandLine = new ArrayList<>();
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addGemFireSystemProperties(commandLine, new Properties());
-    assertTrue(commandLine.isEmpty());
-
-    final Properties gemfireProperties = new Properties();
-    gemfireProperties.setProperty(LOCATORS, "localhost[11235]");
-    gemfireProperties.setProperty(LOG_LEVEL, "config");
-    gemfireProperties.setProperty(LOG_FILE, org.apache.commons.lang.StringUtils.EMPTY);
-    gemfireProperties.setProperty(MCAST_PORT, "0");
-    gemfireProperties.setProperty(NAME, "machine");
-    StartMemberUtils.addGemFireSystemProperties(commandLine, gemfireProperties);
-
-    assertFalse(commandLine.isEmpty());
-    assertEquals(4, commandLine.size());
-
-    for (final String propertyName : gemfireProperties.stringPropertyNames()) {
-      final String propertyValue = gemfireProperties.getProperty(propertyName);
-      if (org.apache.commons.lang.StringUtils.isBlank(propertyValue)) {
-        for (final String systemProperty : commandLine) {
-          assertFalse(systemProperty.startsWith(
-              "-D" + DistributionConfig.GEMFIRE_PREFIX + "".concat(propertyName).concat("=")));
-        }
-      } else {
-        assertTrue(commandLine.contains("-D" + DistributionConfig.GEMFIRE_PREFIX
-            + "".concat(propertyName).concat("=").concat(propertyValue)));
-      }
-    }
-  }
-
-  @Test
-  public void testAddGemFireSystemPropertiesToCommandLineWithRestAPI() {
-    final List<String> commandLine = new ArrayList<>();
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addGemFireSystemProperties(commandLine, new Properties());
-    assertTrue(commandLine.isEmpty());
-    final Properties gemfireProperties = new Properties();
-    gemfireProperties.setProperty(LOCATORS, "localhost[11235]");
-    gemfireProperties.setProperty(LOG_LEVEL, "config");
-    gemfireProperties.setProperty(LOG_FILE, StringUtils.EMPTY);
-    gemfireProperties.setProperty(MCAST_PORT, "0");
-    gemfireProperties.setProperty(NAME, "machine");
-    gemfireProperties.setProperty(START_DEV_REST_API, "true");
-    gemfireProperties.setProperty(HTTP_SERVICE_PORT, "8080");
-    gemfireProperties.setProperty(HTTP_SERVICE_BIND_ADDRESS, "localhost");
-
-    StartMemberUtils.addGemFireSystemProperties(commandLine, gemfireProperties);
-
-    assertFalse(commandLine.isEmpty());
-    assertEquals(7, commandLine.size());
-
-    for (final String propertyName : gemfireProperties.stringPropertyNames()) {
-      final String propertyValue = gemfireProperties.getProperty(propertyName);
-      if (StringUtils.isBlank(propertyValue)) {
-        for (final String systemProperty : commandLine) {
-          assertFalse(systemProperty.startsWith(
-              "-D" + DistributionConfig.GEMFIRE_PREFIX + "".concat(propertyName).concat("=")));
-        }
-      } else {
-        assertTrue(commandLine.contains("-D" + DistributionConfig.GEMFIRE_PREFIX
-            + "".concat(propertyName).concat("=").concat(propertyValue)));
-      }
-    }
-  }
-
-  @Test
-  public void testAddInitialHeapToCommandLine() {
-    final List<String> commandLine = new ArrayList<>();
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addInitialHeap(commandLine, null);
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addInitialHeap(commandLine, org.apache.commons.lang.StringUtils.EMPTY);
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addInitialHeap(commandLine, " ");
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addInitialHeap(commandLine, "512M");
-    assertFalse(commandLine.isEmpty());
-    assertEquals("-Xms512M", commandLine.get(0));
-  }
-
-  @Test
-  public void testAddJvmArgumentsAndOptionsToCommandLine() {
-    final List<String> commandLine = new ArrayList<>();
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addJvmArgumentsAndOptions(commandLine, null);
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addJvmArgumentsAndOptions(commandLine, new String[] {});
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addJvmArgumentsAndOptions(commandLine,
-        new String[] {"-DmyProp=myVal", "-d64", "-server", "-Xprof"});
-    assertFalse(commandLine.isEmpty());
-    assertEquals(4, commandLine.size());
-    assertEquals("-DmyProp=myVal", commandLine.get(0));
-    assertEquals("-d64", commandLine.get(1));
-    assertEquals("-server", commandLine.get(2));
-    assertEquals("-Xprof", commandLine.get(3));
-  }
-
-  @Test
-  public void testAddMaxHeapToCommandLine() {
-    final List<String> commandLine = new ArrayList<>();
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addMaxHeap(commandLine, null);
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addMaxHeap(commandLine, org.apache.commons.lang.StringUtils.EMPTY);
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addMaxHeap(commandLine, "  ");
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addMaxHeap(commandLine, "1024M");
-    assertFalse(commandLine.isEmpty());
-    assertEquals(3, commandLine.size());
-    assertEquals("-Xmx1024M", commandLine.get(0));
-    assertEquals("-XX:+UseConcMarkSweepGC", commandLine.get(1));
-    assertEquals(
-        "-XX:CMSInitiatingOccupancyFraction=" + StartMemberUtils.CMS_INITIAL_OCCUPANCY_FRACTION,
-        commandLine.get(2));
-  }
-
-  @Test(expected = AssertionError.class)
-  public void testReadPidWithNull() {
-    try {
-      StartMemberUtils.readPid(null);
-    } catch (AssertionError expected) {
-      assertEquals("The file from which to read the process ID (pid) cannot be null!",
-          expected.getMessage());
-      throw expected;
-    }
-  }
-
-  @Test
-  public void testReadPidWithNonExistingFile() {
-    assertEquals(StartMemberUtils.INVALID_PID,
-        StartMemberUtils.readPid(new File("/path/to/non_existing/pid.file")));
-  }
-
-  @Test
-  public void testGetSystemClasspath() {
-    assertEquals(System.getProperty("java.class.path"), StartMemberUtils.getSystemClasspath());
-  }
-
-  @Test
-  public void testToClasspath() {
-    final boolean EXCLUDE_SYSTEM_CLASSPATH = false;
-    final boolean INCLUDE_SYSTEM_CLASSPATH = true;
-    String[] jarFilePathnames =
-        {"/path/to/user/libs/A.jar", "/path/to/user/libs/B.jar", "/path/to/user/libs/C.jar"};
-    String[] userClasspaths = {"/path/to/classes:/path/to/libs/1.jar:/path/to/libs/2.jar",
-        "/path/to/ext/libs/1.jar:/path/to/ext/classes:/path/to/ext/lib/10.jar"};
-    String expectedClasspath = StartMemberUtils.GEODE_JAR_PATHNAME.concat(File.pathSeparator)
-        .concat(toClasspath(userClasspaths)).concat(File.pathSeparator)
-        .concat(toClasspath(jarFilePathnames));
-    assertEquals(expectedClasspath,
-        StartMemberUtils.toClasspath(EXCLUDE_SYSTEM_CLASSPATH, jarFilePathnames, userClasspaths));
-    expectedClasspath = StartMemberUtils.GEODE_JAR_PATHNAME.concat(File.pathSeparator)
-        .concat(toClasspath(userClasspaths)).concat(File.pathSeparator)
-        .concat(System.getProperty("java.class.path")).concat(File.pathSeparator)
-        .concat(toClasspath(jarFilePathnames));
-    assertEquals(expectedClasspath,
-        StartMemberUtils.toClasspath(INCLUDE_SYSTEM_CLASSPATH, jarFilePathnames, userClasspaths));
-    expectedClasspath = StartMemberUtils.GEODE_JAR_PATHNAME.concat(File.pathSeparator)
-        .concat(System.getProperty("java.class.path"));
-    assertEquals(expectedClasspath,
-        StartMemberUtils.toClasspath(INCLUDE_SYSTEM_CLASSPATH, null, (String[]) null));
-    assertEquals(StartMemberUtils.GEODE_JAR_PATHNAME,
-        StartMemberUtils.toClasspath(EXCLUDE_SYSTEM_CLASSPATH, null, (String[]) null));
-    assertEquals(StartMemberUtils.GEODE_JAR_PATHNAME,
-        StartMemberUtils.toClasspath(EXCLUDE_SYSTEM_CLASSPATH, new String[0], ""));
-  }
-
-  @Test
-  public void testToClassPathOrder() {
-    String userClasspathOne = "/path/to/user/lib/a.jar:/path/to/user/classes";
-    String userClasspathTwo =
-        "/path/to/user/lib/x.jar:/path/to/user/lib/y.jar:/path/to/user/lib/z.jar";
-
-    String expectedClasspath = StartMemberUtils.getGemFireJarPath().concat(File.pathSeparator)
-        .concat(userClasspathOne).concat(File.pathSeparator).concat(userClasspathTwo)
-        .concat(File.pathSeparator).concat(System.getProperty("java.class.path"))
-        .concat(File.pathSeparator).concat(StartMemberUtils.CORE_DEPENDENCIES_JAR_PATHNAME)
-        .concat(File.pathSeparator).concat(StartMemberUtils.CORE_DEPENDENCIES_JAR_PATHNAME);
-
-    String actualClasspath =
-        StartMemberUtils.toClasspath(true,
-            new String[] {StartMemberUtils.CORE_DEPENDENCIES_JAR_PATHNAME,
-                StartMemberUtils.CORE_DEPENDENCIES_JAR_PATHNAME},
-            userClasspathOne, userClasspathTwo);
-
-    assertEquals(expectedClasspath, actualClasspath);
-  }
-
-  private String toClasspath(final String... jarFilePathnames) {
-    String classpath = org.apache.commons.lang.StringUtils.EMPTY;
-    if (jarFilePathnames != null) {
-      for (final String jarFilePathname : jarFilePathnames) {
-        classpath +=
-            (classpath.isEmpty() ? org.apache.commons.lang.StringUtils.EMPTY : File.pathSeparator);
-        classpath += jarFilePathname;
-      }
-    }
-    return classpath;
+  public void getMembersIncludingLocators() throws Exception {
+    String[] members = {"member"};
+    doReturn(Collections.emptySet()).when(command).findMembersIncludingLocators(members, null);
+    assertThatThrownBy(() -> command.getMembersIncludingLocators(members, null))
+        .isInstanceOf(EntityNotFoundException.class);
   }
 }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeDiskStoreCommandsDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeDiskStoreCommandsDUnitTest.java
index bbd0b6cb76..0e9468cc3b 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeDiskStoreCommandsDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeDiskStoreCommandsDUnitTest.java
@@ -20,6 +20,7 @@
 import static org.apache.geode.test.dunit.Host.getHost;
 import static org.apache.geode.test.dunit.LogWriterUtils.getDUnitLogLevel;
 import static org.apache.geode.test.dunit.LogWriterUtils.getLogWriter;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.io.Serializable;
 import java.util.Properties;
@@ -100,9 +101,8 @@ public void testDescribeDiskStoreWithInvalidDiskStoreName() {
 
     assertNotNull(commandResult);
     assertEquals(Result.Status.ERROR, commandResult.getStatus());
-    assertEquals(
-        "A disk store with name (badDiskStoreName) was not found on member (producerServer).",
-        toString(commandResult));
+    assertThat(toString(commandResult)).contains(
+        "A disk store with name (badDiskStoreName) was not found on member (producerServer).");
   }
 
   private static String toString(final Result result) {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/DescribeDiskStoreFunctionJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/DescribeDiskStoreFunctionJUnitTest.java
index 23398389e3..cd65dbbf56 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/DescribeDiskStoreFunctionJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/DescribeDiskStoreFunctionJUnitTest.java
@@ -14,8 +14,12 @@
  */
 package org.apache.geode.management.internal.cli.functions;
 
-import static org.assertj.core.api.Assertions.*;
-import static org.junit.Assert.*;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 
 import java.io.File;
 import java.util.Arrays;
@@ -55,7 +59,7 @@
 import org.apache.geode.internal.logging.LogService;
 import org.apache.geode.internal.util.CollectionUtils;
 import org.apache.geode.management.internal.cli.domain.DiskStoreDetails;
-import org.apache.geode.management.internal.cli.util.DiskStoreNotFoundException;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
 import org.apache.geode.test.dunit.IgnoredException;
 import org.apache.geode.test.junit.categories.UnitTest;
 
@@ -610,7 +614,7 @@ public void testExecuteOnMemberHavingANonGemFireCache() throws Throwable {
   }
 
   @Test
-  public void testExecuteThrowingDiskStoreNotFoundException() throws Exception {
+  public void testExecuteThrowingEntityNotFoundException() throws Exception {
     final String diskStoreName = "testDiskStore";
     final String memberId = "mockMemberId";
     final String memberName = "mockMemberName";
@@ -649,7 +653,7 @@ public void testExecuteThrowingDiskStoreNotFoundException() throws Exception {
     String expected = String.format("A disk store with name (%1$s) was not found on member (%2$s).",
         diskStoreName, memberName);
     assertThatThrownBy(() -> testResultSender.getResults())
-        .isInstanceOf(DiskStoreNotFoundException.class).hasMessage(expected);
+        .isInstanceOf(EntityNotFoundException.class).hasMessage(expected);
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/RegionDestroyFunctionTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/RegionDestroyFunctionTest.java
new file mode 100644
index 0000000000..60885099b2
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/RegionDestroyFunctionTest.java
@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.functions;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+import org.mockito.ArgumentCaptor;
+
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.execute.FunctionContext;
+import org.apache.geode.cache.execute.ResultSender;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.test.junit.categories.UnitTest;
+
+
+@Category(UnitTest.class)
+public class RegionDestroyFunctionTest {
+
+  private RegionDestroyFunction function;
+  private FunctionContext context;
+  private InternalCache cache;
+  private ResultSender resultSender;
+  private ArgumentCaptor<CliFunctionResult> resultCaptor;
+
+  @Before
+  public void before() {
+    function = spy(RegionDestroyFunction.class);
+    context = mock(FunctionContext.class);
+    cache = mock(InternalCache.class);
+    resultSender = mock(ResultSender.class);
+    when(context.getCache()).thenReturn(cache);
+    when(context.getResultSender()).thenReturn(resultSender);
+    when(context.getArguments()).thenReturn("testRegion");
+    resultCaptor = ArgumentCaptor.forClass(CliFunctionResult.class);
+  }
+
+  @Test
+  public void functionContextIsWrong() throws Exception {
+    function.execute(context);
+    verify(resultSender).lastResult(resultCaptor.capture());
+    CliFunctionResult result = resultCaptor.getValue();
+
+    assertThat(result.isSuccessful()).isFalse();
+    assertThat(result.getMessage()).contains("Function Id mismatch or arguments is not available");
+  }
+
+  @Test
+  public void regionAlreadyDestroyed() throws Exception {
+    when(context.getFunctionId()).thenReturn(RegionDestroyFunction.class.getName());
+    when(cache.getRegion(any())).thenReturn(null);
+    function.execute(context);
+
+    verify(resultSender).lastResult(resultCaptor.capture());
+    CliFunctionResult result = resultCaptor.getValue();
+
+    assertThat(result.isSuccessful()).isTrue();
+    assertThat(result.getMessage()).contains("SUCCESS");
+  }
+
+  @Test
+  public void illegalStateExceptionWillNotThrowExceptionToCommand() throws Exception {
+    when(context.getFunctionId()).thenReturn(RegionDestroyFunction.class.getName());
+    Region region = mock(Region.class);
+    when(cache.getRegion(any())).thenReturn(region);
+    doThrow(new IllegalStateException("message")).when(region).destroyRegion();
+
+    function.execute(context);
+    verify(resultSender).lastResult(resultCaptor.capture());
+    CliFunctionResult result = resultCaptor.getValue();
+    assertThat(result.isSuccessful()).isFalse();
+    // will not populate the exception in the result, but only preserve the message
+    assertThat(result.getThrowable()).isNull();
+    assertThat(result.getMessage()).isEqualTo("message");
+  }
+}
diff --git a/geode-core/src/test/resources/org/apache/geode/codeAnalysis/sanctionedSerializables.txt b/geode-core/src/test/resources/org/apache/geode/codeAnalysis/sanctionedSerializables.txt
index 37a4224286..d23a3d8690 100755
--- a/geode-core/src/test/resources/org/apache/geode/codeAnalysis/sanctionedSerializables.txt
+++ b/geode-core/src/test/resources/org/apache/geode/codeAnalysis/sanctionedSerializables.txt
@@ -563,14 +563,13 @@ org/apache/geode/management/internal/cli/result/TableBuilderHelper$TooManyColumn
 org/apache/geode/management/internal/cli/shell/JMXConnectionException,true,3872374016604940917,exceptionType:int
 org/apache/geode/management/internal/cli/shell/JMXInvocationException,true,-4265451314790394366
 org/apache/geode/management/internal/cli/shell/jline/ANSIHandler$ANSIStyle,false
-org/apache/geode/management/internal/cli/util/DiskStoreNotFoundException,true,-5184836041554948093
+org/apache/geode/management/internal/cli/util/EntityNotFoundException,true,-5184836041554948093
 org/apache/geode/management/internal/cli/util/EvictionAttributesInfo,true,1,evictionAction:java/lang/String,evictionAlgorithm:java/lang/String,evictionMaxValue:int
 org/apache/geode/management/internal/cli/util/ExportLogsCacheWriter,false,currentFile:java/nio/file/Path,currentOutputStream:java/io/BufferedOutputStream,isEmpty:boolean
 org/apache/geode/management/internal/cli/util/FixedPartitionAttributesInfo,false,isPrimary:boolean,numBuckets:int,partitionName:java/lang/String
 org/apache/geode/management/internal/cli/util/JConsoleNotFoundException,true,-1485615321440327206
 org/apache/geode/management/internal/cli/util/LogFilter$LineFilterResult,false
 org/apache/geode/management/internal/cli/util/MemberInformation,true,1,cacheXmlFilePath:java/lang/String,cpuUsage:java/lang/String,groups:java/lang/String,heapUsage:java/lang/String,host:java/lang/String,id:java/lang/String,initHeapSize:java/lang/String,locatorBindAddress:java/lang/String,locatorPort:int,locators:java/lang/String,logFilePath:java/lang/String,maxHeapSize:java/lang/String,name:java/lang/String,processId:java/lang/String,serverBindAddress:java/lang/String,statArchiveFilePath:java/lang/String,workingDirPath:java/lang/String
-org/apache/geode/management/internal/cli/util/MemberNotFoundException,true,5686788909239181174
 org/apache/geode/management/internal/cli/util/VisualVmNotFoundException,true,-8491645604829510102
 org/apache/geode/management/internal/configuration/domain/SharedConfigurationStatus,false
 org/apache/geode/management/internal/configuration/functions/GetRegionNamesFunction,false
diff --git a/geode-lucene/src/main/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommands.java b/geode-lucene/src/main/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommands.java
index 971293b27a..926b2d0e92 100755
--- a/geode-lucene/src/main/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommands.java
+++ b/geode-lucene/src/main/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommands.java
@@ -29,10 +29,8 @@
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.cache.execute.Execution;
 import org.apache.geode.cache.execute.Function;
-import org.apache.geode.cache.execute.FunctionInvocationTargetException;
 import org.apache.geode.cache.execute.ResultCollector;
 import org.apache.geode.cache.lucene.internal.cli.functions.LuceneCreateIndexFunction;
 import org.apache.geode.cache.lucene.internal.cli.functions.LuceneDescribeIndexFunction;
@@ -48,6 +46,7 @@
 import org.apache.geode.management.cli.Result;
 import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.commands.GfshCommand;
+import org.apache.geode.management.internal.cli.exceptions.UserErrorException;
 import org.apache.geode.management.internal.cli.functions.CliFunctionResult;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.result.CommandResult;
@@ -56,7 +55,6 @@
 import org.apache.geode.management.internal.cli.result.TabularResultData;
 import org.apache.geode.management.internal.cli.shell.Gfsh;
 import org.apache.geode.management.internal.configuration.domain.XmlEntity;
-import org.apache.geode.security.GemFireSecurityException;
 import org.apache.geode.security.ResourcePermission.Operation;
 import org.apache.geode.security.ResourcePermission.Resource;
 
@@ -88,21 +86,7 @@ public Result listIndex(@CliOption(key = LuceneCliStrings.LUCENE_LIST_INDEX__STA
       help = LuceneCliStrings.LUCENE_LIST_INDEX__STATS__HELP) final boolean stats) {
 
     getSecurityService().authorize(Resource.CLUSTER, Operation.READ, LucenePermission.TARGET);
-
-    try {
-      return toTabularResult(getIndexListing(), stats);
-    } catch (FunctionInvocationTargetException ignore) {
-      return ResultBuilder.createGemFireErrorResult(CliStrings.format(
-          CliStrings.COULD_NOT_EXECUTE_COMMAND_TRY_AGAIN, LuceneCliStrings.LUCENE_LIST_INDEX));
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      getCache().getLogger().info(t);
-      return ResultBuilder.createGemFireErrorResult(String
-          .format(LuceneCliStrings.LUCENE_LIST_INDEX__ERROR_MESSAGE, toString(t, isDebugging())));
-    }
+    return toTabularResult(getIndexListing(), stats);
   }
 
   @SuppressWarnings("unchecked")
@@ -230,27 +214,12 @@ public Result describeIndex(
 
       @CliOption(key = LuceneCliStrings.LUCENE__REGION_PATH, mandatory = true,
           optionContext = ConverterHint.REGION_PATH,
-          help = LuceneCliStrings.LUCENE_DESCRIBE_INDEX__REGION_HELP) final String regionPath) {
+          help = LuceneCliStrings.LUCENE_DESCRIBE_INDEX__REGION_HELP) final String regionPath)
+      throws Exception {
 
     getSecurityService().authorize(Resource.CLUSTER, Operation.READ, LucenePermission.TARGET);
-
-    try {
-      LuceneIndexInfo indexInfo = new LuceneIndexInfo(indexName, regionPath);
-      return toTabularResult(getIndexDetails(indexInfo), true);
-    } catch (FunctionInvocationTargetException ignore) {
-      return ResultBuilder.createGemFireErrorResult(CliStrings.format(
-          CliStrings.COULD_NOT_EXECUTE_COMMAND_TRY_AGAIN, LuceneCliStrings.LUCENE_DESCRIBE_INDEX));
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (IllegalArgumentException e) {
-      return ResultBuilder.createInfoResult(e.getMessage());
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      getCache().getLogger().info(t);
-      return ResultBuilder.createGemFireErrorResult(String.format(
-          LuceneCliStrings.LUCENE_DESCRIBE_INDEX__ERROR_MESSAGE, toString(t, isDebugging())));
-    }
+    LuceneIndexInfo indexInfo = new LuceneIndexInfo(indexName, regionPath);
+    return toTabularResult(getIndexDetails(indexInfo), true);
   }
 
   @SuppressWarnings("unchecked")
@@ -288,32 +257,15 @@ public Result searchIndex(@CliOption(key = LuceneCliStrings.LUCENE__INDEX_NAME,
 
       @CliOption(key = LuceneCliStrings.LUCENE_SEARCH_INDEX__KEYSONLY,
           unspecifiedDefaultValue = "false",
-          help = LuceneCliStrings.LUCENE_SEARCH_INDEX__KEYSONLY__HELP) boolean keysOnly) {
-
+          help = LuceneCliStrings.LUCENE_SEARCH_INDEX__KEYSONLY__HELP) boolean keysOnly)
+      throws Exception {
     getSecurityService().authorize(Resource.DATA, Operation.READ, regionPath);
+    LuceneQueryInfo queryInfo =
+        new LuceneQueryInfo(indexName, regionPath, queryString, defaultField, limit, keysOnly);
+    int pageSize = Integer.MAX_VALUE;
+    searchResults = getSearchResults(queryInfo);
+    return displayResults(pageSize, keysOnly);
 
-    try {
-      LuceneQueryInfo queryInfo =
-          new LuceneQueryInfo(indexName, regionPath, queryString, defaultField, limit, keysOnly);
-      int pageSize = Integer.MAX_VALUE;
-      searchResults = getSearchResults(queryInfo);
-      return displayResults(pageSize, keysOnly);
-    } catch (FunctionInvocationTargetException ignore) {
-      return ResultBuilder.createGemFireErrorResult(CliStrings.format(
-          CliStrings.COULD_NOT_EXECUTE_COMMAND_TRY_AGAIN, LuceneCliStrings.LUCENE_SEARCH_INDEX));
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (IllegalArgumentException e) {
-      return ResultBuilder.createInfoResult(e.getMessage());
-    } catch (GemFireSecurityException e) {
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      getCache().getLogger().info(t);
-      return ResultBuilder.createGemFireErrorResult(String
-          .format(LuceneCliStrings.LUCENE_SEARCH_INDEX__ERROR_MESSAGE, toString(t, isDebugging())));
-    }
   }
 
   @CliCommand(value = LuceneCliStrings.LUCENE_DESTROY_INDEX,
@@ -526,7 +478,7 @@ private Result getResults(int fromIndex, int toIndex, boolean keysonly) throws E
           data.accumulate("score", searchResults.get(i).getScore());
         }
       } else {
-        throw new Exception(searchResults.get(i).getExceptionMessage());
+        throw new UserErrorException(searchResults.get(i).getExceptionMessage());
       }
     }
     return ResultBuilder.buildResult(data);
@@ -548,7 +500,7 @@ private Result getResults(int fromIndex, int toIndex, boolean keysonly) throws E
     Set<DistributedMember> targetMembers = CliUtil.getRegionAssociatedMembers(
         functionArguments.getRegionPath(), getCache(), returnAllMembers);
     if (targetMembers.isEmpty()) {
-      throw new IllegalArgumentException(CliStrings.format(
+      throw new UserErrorException(CliStrings.format(
           LuceneCliStrings.LUCENE_DESTROY_INDEX__MSG__COULDNOT_FIND_MEMBERS_FOR_REGION_0,
           new Object[] {functionArguments.getRegionPath()}));
     }
diff --git a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsDUnitTest.java b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsDUnitTest.java
index 2aa38041fe..afed83a4a0 100755
--- a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsDUnitTest.java
+++ b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsDUnitTest.java
@@ -416,7 +416,7 @@ public void describeIndexWithoutRegionShouldReturnErrorMessage() throws Exceptio
     CommandStringBuilder csb = new CommandStringBuilder(LuceneCliStrings.LUCENE_DESCRIBE_INDEX);
     csb.addOption(LuceneCliStrings.LUCENE__INDEX_NAME, "notAnIndex");
     csb.addOption(LuceneCliStrings.LUCENE__REGION_PATH, REGION_NAME);
-    gfsh.executeAndAssertThat(csb.toString()).statusIsSuccess().containsOutput(REGION_NAME);
+    gfsh.executeAndAssertThat(csb.toString()).statusIsError().containsOutput(REGION_NAME);
   }
 
   @Test
@@ -554,7 +554,7 @@ public void searchOnIndexWithoutRegionShouldReturnError() throws Exception {
     csb.addOption(LuceneCliStrings.LUCENE_SEARCH_INDEX__QUERY_STRING, "EFG");
     csb.addOption(LuceneCliStrings.LUCENE_SEARCH_INDEX__DEFAULT_FIELD, "field2");
 
-    gfsh.executeAndAssertThat(csb.toString()).statusIsSuccess()
+    gfsh.executeAndAssertThat(csb.toString()).statusIsError()
         .containsOutput(getRegionNotFoundErrorMessage("/region"));
   }
 


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao opened a new pull request #1045: GEODE-3539: cleanup GfshCommand and refactor tests
URL: https://github.com/apache/geode/pull/1045
 
 
   
   * remove more try catch blocks in commands
   * make GfshCommand a pure wrapper around CliUtil for easy mocking
   * Generalize MemberNotFoundException and DiskStoreNotFoundException into EntityNotFoundException
   
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit e67456dbce7d2781ad40824cb9e20b67bf7c4074 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e67456d ]

GEODE-3539: cleanup GfshCommand and refactor tests

* remove more try catch blocks in commands
* make GfshCommand a pure wrapper around CliUtil for easy mocking
* unify EntityNotFoundException


jinmeiliao closed pull request #1045: GEODE-3539: cleanup GfshCommand and refactor tests
URL: https://github.com/apache/geode/pull/1045
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandIntegrationTest.java b/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandIntegrationTest.java
index 6fa05c7b33..f8cd315f1f 100644
--- a/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandIntegrationTest.java
+++ b/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommandIntegrationTest.java
@@ -29,7 +29,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
-import org.junit.rules.TemporaryFolder;
+import org.junit.rules.ExpectedException;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Mockito;
 
@@ -46,7 +46,7 @@
   public GfshParserRule commandRule = new GfshParserRule();
 
   @Rule
-  public TemporaryFolder temporaryFolder = new TemporaryFolder();
+  public ExpectedException thrown = ExpectedException.none();
 
   private StartLocatorCommand spy;
 
@@ -58,6 +58,7 @@ public void before() throws Exception {
 
   @Test
   public void startLocatorWorksWithNoOptions() throws Exception {
+    thrown.expect(NullPointerException.class);
     commandRule.executeCommandWithInstance(spy, "start locator");
 
     ArgumentCaptor<Properties> gemfirePropertiesCaptor = ArgumentCaptor.forClass(Properties.class);
@@ -74,6 +75,7 @@ public void startLocatorRespectsJmxManagerHostnameForClients() throws Exception
     String startLocatorCommand = new CommandStringBuilder("start locator")
         .addOption(JMX_MANAGER_HOSTNAME_FOR_CLIENTS, FAKE_HOSTNAME).toString();
 
+    thrown.expect(NullPointerException.class);
     commandRule.executeCommandWithInstance(spy, startLocatorCommand);
 
     ArgumentCaptor<Properties> gemfirePropertiesCaptor = ArgumentCaptor.forClass(Properties.class);
diff --git a/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartServerCommandIntegrationTest.java b/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartServerCommandIntegrationTest.java
index 2a8807e4ab..92f874993a 100644
--- a/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartServerCommandIntegrationTest.java
+++ b/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/StartServerCommandIntegrationTest.java
@@ -29,7 +29,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
-import org.junit.rules.TemporaryFolder;
+import org.junit.rules.ExpectedException;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Mockito;
 
@@ -46,7 +46,7 @@
   public GfshParserRule commandRule = new GfshParserRule();
 
   @Rule
-  public TemporaryFolder temporaryFolder = new TemporaryFolder();
+  public ExpectedException thrown = ExpectedException.none();
 
   private StartServerCommand spy;
 
@@ -58,6 +58,7 @@ public void before() throws Exception {
 
   @Test
   public void startServerWorksWithNoOptions() throws Exception {
+    thrown.expect(NullPointerException.class);
     commandRule.executeCommandWithInstance(spy, "start server");
 
     ArgumentCaptor<Properties> gemfirePropertiesCaptor = ArgumentCaptor.forClass(Properties.class);
@@ -74,6 +75,7 @@ public void startServerRespectsJmxManagerHostnameForClients() throws Exception {
     String startServerCommand = new CommandStringBuilder("start server")
         .addOption(JMX_MANAGER_HOSTNAME_FOR_CLIENTS, FAKE_HOSTNAME).toString();
 
+    thrown.expect(NullPointerException.class);
     commandRule.executeCommandWithInstance(spy, startServerCommand);
 
     ArgumentCaptor<Properties> gemfirePropertiesCaptor = ArgumentCaptor.forClass(Properties.class);
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommand.java
index f56e591a70..cdb7d2780b 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommand.java
@@ -21,8 +21,6 @@
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
-import org.apache.geode.cache.execute.FunctionInvocationTargetException;
 import org.apache.geode.cache.execute.ResultCollector;
 import org.apache.geode.distributed.DistributedMember;
 import org.apache.geode.internal.lang.ClassUtils;
@@ -30,13 +28,12 @@
 import org.apache.geode.management.cli.ConverterHint;
 import org.apache.geode.management.cli.Result;
 import org.apache.geode.management.internal.cli.domain.DiskStoreDetails;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
 import org.apache.geode.management.internal.cli.functions.DescribeDiskStoreFunction;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.result.CompositeResultData;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
 import org.apache.geode.management.internal.cli.result.TabularResultData;
-import org.apache.geode.management.internal.cli.util.DiskStoreNotFoundException;
-import org.apache.geode.management.internal.cli.util.MemberNotFoundException;
 import org.apache.geode.management.internal.security.ResourceOperation;
 import org.apache.geode.security.ResourcePermission;
 
@@ -52,22 +49,9 @@ public Result describeDiskStore(
       @CliOption(key = CliStrings.DESCRIBE_DISK_STORE__NAME, mandatory = true,
           optionContext = ConverterHint.DISKSTORE,
           help = CliStrings.DESCRIBE_DISK_STORE__NAME__HELP) final String diskStoreName) {
-    try {
-      return toCompositeResult(getDiskStoreDescription(memberName, diskStoreName));
-    } catch (DiskStoreNotFoundException | MemberNotFoundException e) {
-      return ResultBuilder.createShellClientErrorResult(e.getMessage());
-    } catch (FunctionInvocationTargetException ignore) {
-      return ResultBuilder.createGemFireErrorResult(CliStrings
-          .format(CliStrings.COULD_NOT_EXECUTE_COMMAND_TRY_AGAIN, CliStrings.DESCRIBE_DISK_STORE));
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      return ResultBuilder
-          .createGemFireErrorResult(String.format(CliStrings.DESCRIBE_DISK_STORE__ERROR_MESSAGE,
-              memberName, diskStoreName, toString(t, isDebugging())));
-    }
+
+    return toCompositeResult(getDiskStoreDescription(memberName, diskStoreName));
+
   }
 
   DiskStoreDetails getDiskStoreDescription(final String memberName, final String diskStoreName) {
@@ -81,8 +65,8 @@ DiskStoreDetails getDiskStoreDescription(final String memberName, final String d
 
     if (result instanceof DiskStoreDetails) { // disk store details in hand...
       return (DiskStoreDetails) result;
-    } else if (result instanceof DiskStoreNotFoundException) { // bad disk store name...
-      throw (DiskStoreNotFoundException) result;
+    } else if (result instanceof EntityNotFoundException) { // bad disk store name...
+      throw (EntityNotFoundException) result;
     } else { // unknown and unexpected return type...
       final Throwable cause = (result instanceof Throwable ? (Throwable) result : null);
 
@@ -117,9 +101,8 @@ private Result toCompositeResult(final DiskStoreDetails diskStoreDetails) {
     diskStoreSection.addData("Member ID", diskStoreDetails.getMemberId());
     diskStoreSection.addData("Member Name", diskStoreDetails.getMemberName());
     diskStoreSection.addData("Allow Force Compaction",
-        toString(diskStoreDetails.isAllowForceCompaction(), "Yes", "No"));
-    diskStoreSection.addData("Auto Compaction",
-        toString(diskStoreDetails.isAutoCompact(), "Yes", "No"));
+        diskStoreDetails.isAllowForceCompaction() ? "Yes" : "No");
+    diskStoreSection.addData("Auto Compaction", diskStoreDetails.isAutoCompact() ? "Yes" : "No");
     diskStoreSection.addData("Compaction Threshold", diskStoreDetails.getCompactionThreshold());
     diskStoreSection.addData("Max Oplog Size", diskStoreDetails.getMaxOplogSize());
     diskStoreSection.addData("Queue Size", diskStoreDetails.getQueueSize());
@@ -130,7 +113,7 @@ private Result toCompositeResult(final DiskStoreDetails diskStoreDetails) {
     diskStoreSection.addData("Disk Usage Critical Percentage",
         diskStoreDetails.getDiskUsageCriticalPercentage());
     diskStoreSection.addData("PDX Serialization Meta-Data Stored",
-        toString(diskStoreDetails.isPdxSerializationMetaDataStored(), "Yes", "No"));
+        diskStoreDetails.isPdxSerializationMetaDataStored() ? "Yes" : "No");
 
     final TabularResultData diskDirTable = diskStoreData.addSection().addTable();
 
@@ -144,9 +127,8 @@ private Result toCompositeResult(final DiskStoreDetails diskStoreDetails) {
     for (DiskStoreDetails.RegionDetails regionDetails : diskStoreDetails.iterateRegions()) {
       regionTable.accumulate("Region Path", regionDetails.getFullPath());
       regionTable.accumulate("Region Name", regionDetails.getName());
-      regionTable.accumulate("Persistent", toString(regionDetails.isPersistent(), "Yes", "No"));
-      regionTable.accumulate("Overflow To Disk",
-          toString(regionDetails.isOverflowToDisk(), "Yes", "No"));
+      regionTable.accumulate("Persistent", regionDetails.isPersistent() ? "Yes" : "No");
+      regionTable.accumulate("Overflow To Disk", regionDetails.isOverflowToDisk() ? "Yes" : "No");
     }
 
     final TabularResultData cacheServerTable = diskStoreData.addSection().addTable();
@@ -162,7 +144,7 @@ private Result toCompositeResult(final DiskStoreDetails diskStoreDetails) {
 
     for (DiskStoreDetails.GatewayDetails gatewayDetails : diskStoreDetails.iterateGateways()) {
       gatewayTable.accumulate("Gateway ID", gatewayDetails.getId());
-      gatewayTable.accumulate("Persistent", toString(gatewayDetails.isPersistent(), "Yes", "No"));
+      gatewayTable.accumulate("Persistent", gatewayDetails.isPersistent() ? "Yes" : "No");
     }
 
     final TabularResultData asyncEventQueueTable = diskStoreData.addSection().addTable();
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommand.java
index 821eb64c3b..13947ec469 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommand.java
@@ -26,8 +26,6 @@
 import org.apache.geode.management.cli.CliMetaData;
 import org.apache.geode.management.cli.ConverterHint;
 import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.cli.LogWrapper;
 import org.apache.geode.management.internal.cli.functions.CliFunctionResult;
 import org.apache.geode.management.internal.cli.functions.RegionDestroyFunction;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
@@ -45,10 +43,10 @@ public Result destroyRegion(
       @CliOption(key = CliStrings.DESTROY_REGION__REGION, optionContext = ConverterHint.REGION_PATH,
           mandatory = true, help = CliStrings.DESTROY_REGION__REGION__HELP) String regionPath,
       @CliOption(key = CliStrings.IFEXISTS, help = CliStrings.IFEXISTS_HELP,
-          specifiedDefaultValue = "true", unspecifiedDefaultValue = "false") boolean ifExists) {
+          specifiedDefaultValue = "true", unspecifiedDefaultValue = "false") boolean ifExists)
+      throws Throwable {
 
     // regionPath should already be converted to have "/" in front of it.
-    Result result;
     AtomicReference<XmlEntity> xmlEntity = new AtomicReference<>();
 
     Set<DistributedMember> regionMembersList = findMembersForRegion(getCache(), regionPath);
@@ -63,45 +61,40 @@ public Result destroyRegion(
       }
     }
 
-    CliFunctionResult destroyRegionResult;
-
     ResultCollector<?, ?> resultCollector =
-        CliUtil.executeFunction(RegionDestroyFunction.INSTANCE, regionPath, regionMembersList);
+        executeFunction(RegionDestroyFunction.INSTANCE, regionPath, regionMembersList);
     List<CliFunctionResult> resultsList = (List<CliFunctionResult>) resultCollector.getResult();
-    String message =
-        CliStrings.format(CliStrings.DESTROY_REGION__MSG__REGION_0_1_DESTROYED, regionPath, "");
 
-    // Only if there is an error is this set to false
-    boolean isRegionDestroyed = true;
-    for (CliFunctionResult aResultsList : resultsList) {
-      destroyRegionResult = aResultsList;
-      if (destroyRegionResult.isSuccessful()) {
-        xmlEntity.set(destroyRegionResult.getXmlEntity());
-      } else if (destroyRegionResult.getThrowable() != null) {
-        Throwable t = destroyRegionResult.getThrowable();
-        LogWrapper.getInstance().info(t.getMessage(), t);
-        message = CliStrings.format(
-            CliStrings.DESTROY_REGION__MSG__ERROR_OCCURRED_WHILE_DESTROYING_0_REASON_1, regionPath,
-            t.getMessage());
-        isRegionDestroyed = false;
+    // destroy is called on each member, if any error happens in any one of the member, we should
+    // deem the destroy not successful.
+    String errorMessage = null;
+    for (CliFunctionResult functionResult : resultsList) {
+      if (functionResult.isSuccessful()) {
+        xmlEntity.set(functionResult.getXmlEntity());
       } else {
-        message = CliStrings.format(
-            CliStrings.DESTROY_REGION__MSG__UNKNOWN_RESULT_WHILE_DESTROYING_REGION_0_REASON_1,
-            regionPath, destroyRegionResult.getMessage());
-        isRegionDestroyed = false;
+        if (functionResult.getThrowable() != null) {
+          throw functionResult.getThrowable();
+        }
+        if (functionResult.getMessage() != null) {
+          errorMessage = functionResult.getMessage();
+        } else {
+          errorMessage = "Destroy failed on one member";
+        }
+        // if any error occurred, break out without looking further
+        break;
       }
     }
-    if (isRegionDestroyed) {
-      result = ResultBuilder.createInfoResult(message);
-    } else {
-      result = ResultBuilder.createUserErrorResult(message);
+
+    if (errorMessage != null) {
+      return ResultBuilder.createGemFireErrorResult(errorMessage);
     }
 
+    Result result =
+        ResultBuilder.createInfoResult(String.format("\"%s\" destroyed successfully.", regionPath));
     if (xmlEntity.get() != null) {
       persistClusterConfiguration(result,
           () -> getSharedConfiguration().deleteXmlEntity(xmlEntity.get(), null));
     }
-
     return result;
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommand.java
index 20cbeac9d6..90b6fc66d0 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommand.java
@@ -39,7 +39,6 @@
 import org.apache.geode.management.cli.CliMetaData;
 import org.apache.geode.management.cli.ConverterHint;
 import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.functions.ExportLogsFunction;
 import org.apache.geode.management.internal.cli.functions.SizeExportLogsFunction;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
@@ -97,17 +96,14 @@ public Result exportLogs(
       @CliOption(key = CliStrings.EXPORT_LOGS__FILESIZELIMIT,
           unspecifiedDefaultValue = CliStrings.EXPORT_LOGS__FILESIZELIMIT__UNSPECIFIED_DEFAULT,
           specifiedDefaultValue = CliStrings.EXPORT_LOGS__FILESIZELIMIT__SPECIFIED_DEFAULT,
-          help = CliStrings.EXPORT_LOGS__FILESIZELIMIT__HELP) String fileSizeLimit) {
+          help = CliStrings.EXPORT_LOGS__FILESIZELIMIT__HELP) String fileSizeLimit)
+      throws Exception {
 
     long totalEstimatedExportSize = 0;
     Result result;
     InternalCache cache = getCache();
     try {
-      Set<DistributedMember> targetMembers = getMembers(groups, memberIds);
-
-      if (targetMembers.isEmpty()) {
-        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
-      }
+      Set<DistributedMember> targetMembers = getMembersIncludingLocators(groups, memberIds);
 
       long userSpecifiedLimit = parseFileSizeLimit(fileSizeLimit);
       if (userSpecifiedLimit > 0) {
@@ -201,9 +197,6 @@ public Result exportLogs(
       FileUtils.deleteDirectory(tempDir.toFile());
 
       result = new CommandResult(exportedLogsZipFile);
-    } catch (Exception ex) {
-      logger.error(ex.getMessage(), ex);
-      result = ResultBuilder.createGemFireErrorResult(ex.getMessage());
     } finally {
       ExportLogsFunction.destroyExportLogsRegion(cache);
     }
@@ -216,13 +209,6 @@ public Result exportLogs(
   /**
    * Wrapper to enable stubbing of static method call for unit testing
    */
-  Set<DistributedMember> getMembers(String[] groups, String[] memberIds) {
-    return CliUtil.findMembersIncludingLocators(groups, memberIds);
-  }
-
-  /**
-   * Wrapper to enable stubbing of static method call for unit testing
-   */
   ResultCollector estimateLogSize(SizeExportLogsFunction.Args args, DistributedMember member) {
     return executeFunction(new SizeExportLogsFunction(), args, member);
   }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java
index 449b42a4e1..904001f34e 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java
@@ -14,12 +14,9 @@
  */
 package org.apache.geode.management.internal.cli.commands;
 
-import java.io.PrintWriter;
-import java.io.StringWriter;
 import java.util.Collections;
 import java.util.Set;
 
-import org.apache.commons.lang.StringUtils;
 import org.springframework.shell.core.CommandMarker;
 
 import org.apache.geode.cache.CacheFactory;
@@ -32,47 +29,22 @@
 import org.apache.geode.distributed.internal.InternalLocator;
 import org.apache.geode.internal.cache.InternalCache;
 import org.apache.geode.internal.security.SecurityService;
-import org.apache.geode.management.cli.CliMetaData;
 import org.apache.geode.management.cli.Result;
 import org.apache.geode.management.internal.cli.CliUtil;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.shell.Gfsh;
-import org.apache.geode.management.internal.cli.util.MemberNotFoundException;
 
 /**
  * Encapsulates common functionality for implementing command classes for the Geode shell (gfsh).
+ * this provides wrapper around the static methods in CliUtils for easy mock of the commands
  *
- * @see org.apache.geode.cache.Cache
- * @see org.apache.geode.cache.execute.FunctionService
- * @see org.apache.geode.distributed.DistributedMember
- * @see org.apache.geode.management.internal.cli.shell.Gfsh
- * @see org.springframework.shell.core.CommandMarker
+ * this class should not have much implementation of its own other then those tested in
+ * GfshCommandJUnitTest
  */
 @SuppressWarnings("unused")
 public interface GfshCommand extends CommandMarker {
 
-  default String convertDefaultValue(final String from, final String to) {
-    return CliMetaData.ANNOTATION_DEFAULT_VALUE.equals(from) ? to : from;
-  }
-
-  default String toString(final Boolean condition, final String trueValue,
-      final String falseValue) {
-    return Boolean.TRUE.equals(condition) ? StringUtils.defaultIfBlank(trueValue, "true")
-        : StringUtils.defaultIfBlank(falseValue, "false");
-  }
-
-  default String toString(final Throwable t, final boolean printStackTrace) {
-    String message = t.getMessage();
-
-    if (printStackTrace) {
-      StringWriter writer = new StringWriter();
-      t.printStackTrace(new PrintWriter(writer));
-      message = writer.toString();
-    }
-
-    return message;
-  }
-
   default boolean isConnectedAndReady() {
     return getGfsh() != null && getGfsh().isConnectedAndReady();
   }
@@ -103,7 +75,6 @@ default boolean isLogging() {
     return getGfsh() != null;
   }
 
-
   default InternalCache getCache() {
     return (InternalCache) CacheFactory.getAnyInstance();
   }
@@ -120,16 +91,23 @@ default Gfsh getGfsh() {
    * this either returns a non-null member or throw an exception if member is not found.
    */
   default DistributedMember getMember(final String memberName) {
-    DistributedMember member = CliUtil.getDistributedMemberByNameOrId(memberName);
+    DistributedMember member = findMember(memberName);
 
     if (member == null) {
-      throw new MemberNotFoundException(
+      throw new EntityNotFoundException(
           CliStrings.format(CliStrings.MEMBER_NOT_FOUND_ERROR_MESSAGE, memberName));
     }
     return member;
   }
 
   /**
+   * this will return the member found or null if no member with that name
+   */
+  default DistributedMember findMember(final String memberName) {
+    return CliUtil.getDistributedMemberByNameOrId(memberName);
+  }
+
+  /**
    * Gets all members in the GemFire distributed system/cache, including locators
    */
   default Set<DistributedMember> getAllMembers(final InternalCache cache) {
@@ -147,10 +125,42 @@ default Execution getMembersFunctionExecutor(final Set<DistributedMember> member
     return FunctionService.onMembers(members);
   }
 
+  /**
+   * if no members matches these names, an empty set would return
+   */
   default Set<DistributedMember> findMembers(String[] groups, String[] members) {
     return CliUtil.findMembers(groups, members);
   }
 
+  /**
+   * if no members matches these names, a UserErrorException will be thrown
+   */
+  default Set<DistributedMember> getMembers(String[] groups, String[] members) {
+    Set<DistributedMember> matchingMembers = findMembers(groups, members);
+    if (matchingMembers.size() == 0) {
+      throw new EntityNotFoundException(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    }
+    return matchingMembers;
+  }
+
+  /**
+   * if no members matches these names, an empty set would return
+   */
+  default Set<DistributedMember> findMembersIncludingLocators(String[] groups, String[] members) {
+    return CliUtil.findMembersIncludingLocators(groups, members);
+  }
+
+  /**
+   * if no members matches these names, a UserErrorException will be thrown
+   */
+  default Set<DistributedMember> getMembersIncludingLocators(String[] groups, String[] members) {
+    Set<DistributedMember> matchingMembers = findMembersIncludingLocators(groups, members);
+    if (matchingMembers.size() == 0) {
+      throw new EntityNotFoundException(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    }
+    return matchingMembers;
+  }
+
   default Set<DistributedMember> findMembersForRegion(InternalCache cache, String regionPath) {
     return CliUtil.getRegionAssociatedMembers(regionPath, cache, true);
   }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListDiskStoresCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListDiskStoresCommand.java
index 5444c4d8e3..e65d4fb57d 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListDiskStoresCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListDiskStoresCommand.java
@@ -22,9 +22,7 @@
 
 import org.springframework.shell.core.annotation.CliCommand;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.cache.execute.Execution;
-import org.apache.geode.cache.execute.FunctionInvocationTargetException;
 import org.apache.geode.cache.execute.ResultCollector;
 import org.apache.geode.distributed.DistributedMember;
 import org.apache.geode.internal.cache.execute.AbstractExecution;
@@ -45,25 +43,12 @@
   @ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,
       operation = ResourcePermission.Operation.READ)
   public Result listDiskStores() {
-    try {
-      Set<DistributedMember> dataMembers = DiskStoreCommandsUtils.getNormalMembers(getCache());
+    Set<DistributedMember> dataMembers = DiskStoreCommandsUtils.getNormalMembers(getCache());
 
-      if (dataMembers.isEmpty()) {
-        return ResultBuilder.createInfoResult(CliStrings.NO_CACHING_MEMBERS_FOUND_MESSAGE);
-      }
-
-      return toTabularResult(getDiskStoreListing(dataMembers));
-    } catch (FunctionInvocationTargetException ignore) {
-      return ResultBuilder.createGemFireErrorResult(CliStrings
-          .format(CliStrings.COULD_NOT_EXECUTE_COMMAND_TRY_AGAIN, CliStrings.LIST_DISK_STORE));
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      return ResultBuilder.createGemFireErrorResult(
-          String.format(CliStrings.LIST_DISK_STORE__ERROR_MESSAGE, toString(t, isDebugging())));
+    if (dataMembers.isEmpty()) {
+      return ResultBuilder.createInfoResult(CliStrings.NO_CACHING_MEMBERS_FOUND_MESSAGE);
     }
+    return toTabularResult(getDiskStoreListing(dataMembers));
   }
 
   @SuppressWarnings("unchecked")
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListIndexCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListIndexCommand.java
index c5010debd2..663d1858f4 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListIndexCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListIndexCommand.java
@@ -23,9 +23,7 @@
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.cache.execute.Execution;
-import org.apache.geode.cache.execute.FunctionInvocationTargetException;
 import org.apache.geode.cache.execute.ResultCollector;
 import org.apache.geode.internal.cache.execute.AbstractExecution;
 import org.apache.geode.internal.lang.StringUtils;
@@ -48,20 +46,8 @@
   public Result listIndex(@CliOption(key = CliStrings.LIST_INDEX__STATS,
       specifiedDefaultValue = "true", unspecifiedDefaultValue = "false",
       help = CliStrings.LIST_INDEX__STATS__HELP) final boolean showStats) {
-    try {
-      return toTabularResult(getIndexListing(), showStats);
-    } catch (FunctionInvocationTargetException ignore) {
-      return ResultBuilder.createGemFireErrorResult(
-          CliStrings.format(CliStrings.COULD_NOT_EXECUTE_COMMAND_TRY_AGAIN, CliStrings.LIST_INDEX));
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      getCache().getLogger().error(t);
-      return ResultBuilder.createGemFireErrorResult(
-          String.format(CliStrings.LIST_INDEX__ERROR_MESSAGE, toString(t, isDebugging())));
-    }
+
+    return toTabularResult(getIndexListing(), showStats);
   }
 
   private Result toTabularResult(final List<IndexDetails> indexDetailsList,
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommand.java
index 6020eca61f..1e6f5da046 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartLocatorCommand.java
@@ -28,13 +28,11 @@
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.distributed.AbstractLauncher;
 import org.apache.geode.distributed.ConfigurationProperties;
 import org.apache.geode.distributed.LocatorLauncher;
 import org.apache.geode.distributed.ServerLauncher;
 import org.apache.geode.internal.OSProcess;
-import org.apache.geode.internal.i18n.LocalizedStrings;
 import org.apache.geode.internal.lang.StringUtils;
 import org.apache.geode.internal.lang.SystemUtils;
 import org.apache.geode.internal.process.ProcessStreamReader;
@@ -119,219 +117,193 @@ public Result startLocator(
       @CliOption(key = CliStrings.START_LOCATOR__HTTP_SERVICE_PORT,
           help = CliStrings.START_LOCATOR__HTTP_SERVICE_PORT__HELP) final Integer httpServicePort,
       @CliOption(key = CliStrings.START_LOCATOR__HTTP_SERVICE_BIND_ADDRESS,
-          help = CliStrings.START_LOCATOR__HTTP_SERVICE_BIND_ADDRESS__HELP) final String httpServiceBindAddress) {
-    try {
-      if (StringUtils.isBlank(memberName)) {
-        // when the user doesn't give us a name, we make one up!
-        memberName = StartMemberUtils.getNameGenerator().generate('-');
-      }
+          help = CliStrings.START_LOCATOR__HTTP_SERVICE_BIND_ADDRESS__HELP) final String httpServiceBindAddress)
+      throws Exception {
+    if (StringUtils.isBlank(memberName)) {
+      // when the user doesn't give us a name, we make one up!
+      memberName = StartMemberUtils.getNameGenerator().generate('-');
+    }
 
-      workingDirectory = StartMemberUtils.resolveWorkingDir(workingDirectory, memberName);
+    workingDirectory = StartMemberUtils.resolveWorkingDir(workingDirectory, memberName);
 
-      if (gemfirePropertiesFile != null && !gemfirePropertiesFile.exists()) {
-        return ResultBuilder.createUserErrorResult(
-            CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, StringUtils.EMPTY,
-                gemfirePropertiesFile.getAbsolutePath()));
-      }
+    if (gemfirePropertiesFile != null && !gemfirePropertiesFile.exists()) {
+      return ResultBuilder.createUserErrorResult(
+          CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, StringUtils.EMPTY,
+              gemfirePropertiesFile.getAbsolutePath()));
+    }
 
-      if (gemfireSecurityPropertiesFile != null && !gemfireSecurityPropertiesFile.exists()) {
-        return ResultBuilder.createUserErrorResult(
-            CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, "Security ",
-                gemfireSecurityPropertiesFile.getAbsolutePath()));
-      }
+    if (gemfireSecurityPropertiesFile != null && !gemfireSecurityPropertiesFile.exists()) {
+      return ResultBuilder.createUserErrorResult(
+          CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, "Security ",
+              gemfireSecurityPropertiesFile.getAbsolutePath()));
+    }
 
-      File locatorPidFile = new File(workingDirectory, ProcessType.LOCATOR.getPidFileName());
-
-      final int oldPid = StartMemberUtils.readPid(locatorPidFile);
-
-      Properties gemfireProperties = new Properties();
-
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.GROUPS,
-          group);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOCATORS,
-          locators);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOG_LEVEL,
-          logLevel);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.MCAST_ADDRESS, mcastBindAddress);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.MCAST_PORT,
-          mcastPort);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.ENABLE_CLUSTER_CONFIGURATION, enableSharedConfiguration);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.LOAD_CLUSTER_CONFIGURATION_FROM_DIR,
-          loadSharedConfigurationFromDirectory);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.CLUSTER_CONFIGURATION_DIR, clusterConfigDir);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.HTTP_SERVICE_PORT, httpServicePort);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.HTTP_SERVICE_BIND_ADDRESS, httpServiceBindAddress);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.JMX_MANAGER_HOSTNAME_FOR_CLIENTS, jmxManagerHostnameForClients);
-
-      // read the OSProcess enable redirect system property here
-      // TODO: replace with new GFSH argument
-      final boolean redirectOutput =
-          Boolean.getBoolean(OSProcess.ENABLE_OUTPUT_REDIRECTION_PROPERTY);
-      LocatorLauncher.Builder locatorLauncherBuilder =
-          new LocatorLauncher.Builder().setBindAddress(bindAddress).setForce(force).setPort(port)
-              .setRedirectOutput(redirectOutput).setWorkingDirectory(workingDirectory);
-      if (hostnameForClients != null) {
-        locatorLauncherBuilder.setHostnameForClients(hostnameForClients);
-      }
-      if (memberName != null) {
-        locatorLauncherBuilder.setMemberName(memberName);
+    File locatorPidFile = new File(workingDirectory, ProcessType.LOCATOR.getPidFileName());
+
+    final int oldPid = StartMemberUtils.readPid(locatorPidFile);
+
+    Properties gemfireProperties = new Properties();
+
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.GROUPS, group);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOCATORS,
+        locators);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOG_LEVEL,
+        logLevel);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.MCAST_ADDRESS,
+        mcastBindAddress);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.MCAST_PORT,
+        mcastPort);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.ENABLE_CLUSTER_CONFIGURATION, enableSharedConfiguration);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.LOAD_CLUSTER_CONFIGURATION_FROM_DIR,
+        loadSharedConfigurationFromDirectory);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.CLUSTER_CONFIGURATION_DIR, clusterConfigDir);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.HTTP_SERVICE_PORT, httpServicePort);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.HTTP_SERVICE_BIND_ADDRESS, httpServiceBindAddress);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.JMX_MANAGER_HOSTNAME_FOR_CLIENTS, jmxManagerHostnameForClients);
+
+    // read the OSProcess enable redirect system property here
+    // TODO: replace with new GFSH argument
+    final boolean redirectOutput = Boolean.getBoolean(OSProcess.ENABLE_OUTPUT_REDIRECTION_PROPERTY);
+    LocatorLauncher.Builder locatorLauncherBuilder =
+        new LocatorLauncher.Builder().setBindAddress(bindAddress).setForce(force).setPort(port)
+            .setRedirectOutput(redirectOutput).setWorkingDirectory(workingDirectory);
+    if (hostnameForClients != null) {
+      locatorLauncherBuilder.setHostnameForClients(hostnameForClients);
+    }
+    if (memberName != null) {
+      locatorLauncherBuilder.setMemberName(memberName);
+    }
+    LocatorLauncher locatorLauncher = locatorLauncherBuilder.build();
+
+    String[] locatorCommandLine = createStartLocatorCommandLine(locatorLauncher,
+        gemfirePropertiesFile, gemfireSecurityPropertiesFile, gemfireProperties, classpath,
+        includeSystemClasspath, jvmArgsOpts, initialHeap, maxHeap);
+
+    final Process locatorProcess = new ProcessBuilder(locatorCommandLine)
+        .directory(new File(locatorLauncher.getWorkingDirectory())).start();
+
+    locatorProcess.getInputStream().close();
+    locatorProcess.getOutputStream().close();
+
+    // fix TRAC bug #51967 by using NON_BLOCKING on Windows
+    final ProcessStreamReader.ReadingMode readingMode = SystemUtils.isWindows()
+        ? ProcessStreamReader.ReadingMode.NON_BLOCKING : ProcessStreamReader.ReadingMode.BLOCKING;
+
+    final StringBuffer message = new StringBuffer(); // need thread-safe StringBuffer
+    ProcessStreamReader.InputListener inputListener = line -> {
+      message.append(line);
+      if (readingMode == ProcessStreamReader.ReadingMode.BLOCKING) {
+        message.append(StringUtils.LINE_SEPARATOR);
       }
-      LocatorLauncher locatorLauncher = locatorLauncherBuilder.build();
+    };
 
-      String[] locatorCommandLine = createStartLocatorCommandLine(locatorLauncher,
-          gemfirePropertiesFile, gemfireSecurityPropertiesFile, gemfireProperties, classpath,
-          includeSystemClasspath, jvmArgsOpts, initialHeap, maxHeap);
+    ProcessStreamReader stderrReader = new ProcessStreamReader.Builder(locatorProcess)
+        .inputStream(locatorProcess.getErrorStream()).inputListener(inputListener)
+        .readingMode(readingMode).continueReadingMillis(2 * 1000).build().start();
 
-      final Process locatorProcess = new ProcessBuilder(locatorCommandLine)
-          .directory(new File(locatorLauncher.getWorkingDirectory())).start();
+    LocatorLauncher.LocatorState locatorState;
 
-      locatorProcess.getInputStream().close();
-      locatorProcess.getOutputStream().close();
+    String previousLocatorStatusMessage = null;
 
-      // fix TRAC bug #51967 by using NON_BLOCKING on Windows
-      final ProcessStreamReader.ReadingMode readingMode = SystemUtils.isWindows()
-          ? ProcessStreamReader.ReadingMode.NON_BLOCKING : ProcessStreamReader.ReadingMode.BLOCKING;
+    LauncherSignalListener locatorSignalListener = new LauncherSignalListener();
 
-      final StringBuffer message = new StringBuffer(); // need thread-safe StringBuffer
-      ProcessStreamReader.InputListener inputListener = line -> {
-        message.append(line);
-        if (readingMode == ProcessStreamReader.ReadingMode.BLOCKING) {
-          message.append(StringUtils.LINE_SEPARATOR);
-        }
-      };
+    final boolean registeredLocatorSignalListener =
+        getGfsh().getSignalHandler().registerListener(locatorSignalListener);
 
-      ProcessStreamReader stderrReader = new ProcessStreamReader.Builder(locatorProcess)
-          .inputStream(locatorProcess.getErrorStream()).inputListener(inputListener)
-          .readingMode(readingMode).continueReadingMillis(2 * 1000).build().start();
+    try {
+      getGfsh().logInfo(String.format(CliStrings.START_LOCATOR__RUN_MESSAGE, IOUtils
+          .tryGetCanonicalPathElseGetAbsolutePath(new File(locatorLauncher.getWorkingDirectory()))),
+          null);
 
-      LocatorLauncher.LocatorState locatorState;
+      do {
+        if (locatorProcess.isAlive()) {
+          Gfsh.print(".");
 
-      String previousLocatorStatusMessage = null;
+          synchronized (this) {
+            TimeUnit.MILLISECONDS.timedWait(this, 500);
+          }
 
-      LauncherSignalListener locatorSignalListener = new LauncherSignalListener();
+          locatorState = LocatorLauncher.LocatorState.fromDirectory(workingDirectory, memberName);
 
-      final boolean registeredLocatorSignalListener =
-          getGfsh().getSignalHandler().registerListener(locatorSignalListener);
+          String currentLocatorStatusMessage = locatorState.getStatusMessage();
 
-      try {
-        getGfsh().logInfo(String.format(CliStrings.START_LOCATOR__RUN_MESSAGE,
-            IOUtils.tryGetCanonicalPathElseGetAbsolutePath(
-                new File(locatorLauncher.getWorkingDirectory()))),
-            null);
-
-        do {
-          if (locatorProcess.isAlive()) {
-            Gfsh.print(".");
-
-            synchronized (this) {
-              TimeUnit.MILLISECONDS.timedWait(this, 500);
-            }
-
-            locatorState = LocatorLauncher.LocatorState.fromDirectory(workingDirectory, memberName);
-
-            String currentLocatorStatusMessage = locatorState.getStatusMessage();
-
-            if (locatorState.isStartingOrNotResponding()
-                && !(StringUtils.isBlank(currentLocatorStatusMessage)
-                    || currentLocatorStatusMessage.equalsIgnoreCase(previousLocatorStatusMessage)
-                    || currentLocatorStatusMessage.trim().toLowerCase().equals("null"))) {
-              Gfsh.println();
-              Gfsh.println(currentLocatorStatusMessage);
-              previousLocatorStatusMessage = currentLocatorStatusMessage;
-            }
-          } else {
-            final int exitValue = locatorProcess.exitValue();
-
-            return ResultBuilder.createShellClientErrorResult(
-                String.format(CliStrings.START_LOCATOR__PROCESS_TERMINATED_ABNORMALLY_ERROR_MESSAGE,
-                    exitValue, locatorLauncher.getWorkingDirectory(), message.toString()));
+          if (locatorState.isStartingOrNotResponding()
+              && !(StringUtils.isBlank(currentLocatorStatusMessage)
+                  || currentLocatorStatusMessage.equalsIgnoreCase(previousLocatorStatusMessage)
+                  || currentLocatorStatusMessage.trim().toLowerCase().equals("null"))) {
+            Gfsh.println();
+            Gfsh.println(currentLocatorStatusMessage);
+            previousLocatorStatusMessage = currentLocatorStatusMessage;
           }
-        } while (!(registeredLocatorSignalListener && locatorSignalListener.isSignaled())
-            && locatorState.isStartingOrNotResponding());
-      } finally {
-        // stop will close
-        stderrReader.stopAsync(StartMemberUtils.PROCESS_STREAM_READER_ASYNC_STOP_TIMEOUT_MILLIS);
-
-        // ErrorStream
-        getGfsh().getSignalHandler().unregisterListener(locatorSignalListener);
-      }
+        } else {
+          final int exitValue = locatorProcess.exitValue();
 
-      Gfsh.println();
+          return ResultBuilder.createShellClientErrorResult(
+              String.format(CliStrings.START_LOCATOR__PROCESS_TERMINATED_ABNORMALLY_ERROR_MESSAGE,
+                  exitValue, locatorLauncher.getWorkingDirectory(), message.toString()));
+        }
+      } while (!(registeredLocatorSignalListener && locatorSignalListener.isSignaled())
+          && locatorState.isStartingOrNotResponding());
+    } finally {
+      // stop will close
+      stderrReader.stopAsync(StartMemberUtils.PROCESS_STREAM_READER_ASYNC_STOP_TIMEOUT_MILLIS);
 
-      final boolean asyncStart =
-          (registeredLocatorSignalListener && locatorSignalListener.isSignaled()
-              && ServerLauncher.ServerState.isStartingNotRespondingOrNull(locatorState));
+      // ErrorStream
+      getGfsh().getSignalHandler().unregisterListener(locatorSignalListener);
+    }
 
-      InfoResultData infoResultData = ResultBuilder.createInfoResultData();
+    Gfsh.println();
 
-      if (asyncStart) {
-        infoResultData.addLine(
-            String.format(CliStrings.ASYNC_PROCESS_LAUNCH_MESSAGE, CliStrings.LOCATOR_TERM_NAME));
-        return ResultBuilder.buildResult(infoResultData);
-      }
+    final boolean asyncStart =
+        (registeredLocatorSignalListener && locatorSignalListener.isSignaled()
+            && ServerLauncher.ServerState.isStartingNotRespondingOrNull(locatorState));
 
-      infoResultData.addLine(locatorState.toString());
-      String locatorHostName;
-      InetAddress bindAddr = locatorLauncher.getBindAddress();
-      if (bindAddr != null) {
-        locatorHostName = bindAddr.getCanonicalHostName();
-      } else {
-        locatorHostName = StringUtils.defaultIfBlank(locatorLauncher.getHostnameForClients(),
-            HostUtils.getLocalHost());
-      }
+    InfoResultData infoResultData = ResultBuilder.createInfoResultData();
+
+    if (asyncStart) {
+      infoResultData.addLine(
+          String.format(CliStrings.ASYNC_PROCESS_LAUNCH_MESSAGE, CliStrings.LOCATOR_TERM_NAME));
+      return ResultBuilder.buildResult(infoResultData);
+    }
 
-      int locatorPort = Integer.parseInt(locatorState.getPort());
+    infoResultData.addLine(locatorState.toString());
+    String locatorHostName;
+    InetAddress bindAddr = locatorLauncher.getBindAddress();
+    if (bindAddr != null) {
+      locatorHostName = bindAddr.getCanonicalHostName();
+    } else {
+      locatorHostName = StringUtils.defaultIfBlank(locatorLauncher.getHostnameForClients(),
+          HostUtils.getLocalHost());
+    }
 
+    int locatorPort = Integer.parseInt(locatorState.getPort());
 
-      ConnectCommand connectCommand = new ConnectCommand();
-      Properties configProperties = connectCommand.resolveSslProperties(getGfsh(), false,
-          gemfirePropertiesFile, gemfireSecurityPropertiesFile);
 
-      // AUTO-CONNECT
-      // If the connect succeeds add the connected message to the result,
-      // Else, ask the user to use the "connect" command to connect to the Locator.
-      if (shouldAutoConnect(connect)) {
-        doAutoConnect(locatorHostName, locatorPort, configProperties, infoResultData);
-      }
+    ConnectCommand connectCommand = new ConnectCommand();
+    Properties configProperties = connectCommand.resolveSslProperties(getGfsh(), false,
+        gemfirePropertiesFile, gemfireSecurityPropertiesFile);
 
-      // Report on the state of the Shared Configuration service if enabled...
-      if (enableSharedConfiguration) {
-        infoResultData.addLine(ClusterConfigurationStatusRetriever.fromLocator(locatorHostName,
-            locatorPort, configProperties));
-      }
+    // AUTO-CONNECT
+    // If the connect succeeds add the connected message to the result,
+    // Else, ask the user to use the "connect" command to connect to the Locator.
+    if (shouldAutoConnect(connect)) {
+      doAutoConnect(locatorHostName, locatorPort, configProperties, infoResultData);
+    }
 
-      return ResultBuilder.buildResult(infoResultData);
-    } catch (IllegalArgumentException e) {
-      String message = e.getMessage();
-      if (message != null && message.matches(
-          LocalizedStrings.Launcher_Builder_UNKNOWN_HOST_ERROR_MESSAGE.toLocalizedString(".+"))) {
-        message =
-            CliStrings.format(CliStrings.LAUNCHERLIFECYCLECOMMANDS__MSG__FAILED_TO_START_0_REASON_1,
-                CliStrings.LOCATOR_TERM_NAME, message);
-      }
-      return ResultBuilder.createUserErrorResult(message);
-    } catch (IllegalStateException e) {
-      return ResultBuilder.createUserErrorResult(e.getMessage());
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      String errorMessage = String.format(CliStrings.START_LOCATOR__GENERAL_ERROR_MESSAGE,
-          StringUtils.defaultIfBlank(workingDirectory, memberName),
-          HostUtils.getLocatorId(bindAddress, port), this.toString(t, getGfsh().getDebug()));
-      getGfsh().logToFile(errorMessage, t);
-      return ResultBuilder.createShellClientErrorResult(errorMessage);
-    } finally {
-      Gfsh.redirectInternalJavaLoggers();
+    // Report on the state of the Shared Configuration service if enabled...
+    if (enableSharedConfiguration) {
+      infoResultData.addLine(ClusterConfigurationStatusRetriever.fromLocator(locatorHostName,
+          locatorPort, configProperties));
     }
+
+    return ResultBuilder.buildResult(infoResultData);
+
   }
 
   // TODO should we connect implicitly when in non-interactive, headless mode (e.g. gfsh -e "start
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartServerCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartServerCommand.java
index 8080e3fa36..35227010be 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartServerCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/StartServerCommand.java
@@ -26,13 +26,11 @@
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.cache.server.CacheServer;
 import org.apache.geode.distributed.AbstractLauncher;
 import org.apache.geode.distributed.ConfigurationProperties;
 import org.apache.geode.distributed.ServerLauncher;
 import org.apache.geode.internal.OSProcess;
-import org.apache.geode.internal.i18n.LocalizedStrings;
 import org.apache.geode.internal.lang.StringUtils;
 import org.apache.geode.internal.lang.SystemUtils;
 import org.apache.geode.internal.process.ProcessStreamReader;
@@ -176,243 +174,221 @@ public Result startServer(
           help = CliStrings.START_SERVER__USERNAME__HELP) final String userName,
       @CliOption(key = CliStrings.START_SERVER__PASSWORD, unspecifiedDefaultValue = "",
           help = CliStrings.START_SERVER__PASSWORD__HELP) String passwordToUse)
+      throws Exception
   // NOTICE: keep the parameters in alphabetical order based on their CliStrings.START_SERVER_* text
   {
-    try {
-      if (StringUtils.isBlank(memberName)) {
-        // when the user doesn't give us a name, we make one up!
-        memberName = StartMemberUtils.getNameGenerator().generate('-');
-      }
 
-      // prompt for password is username is specified in the command
-      if (StringUtils.isNotBlank(userName)) {
-        if (StringUtils.isBlank(passwordToUse)) {
-          passwordToUse = getGfsh().readPassword(CliStrings.START_SERVER__PASSWORD + ": ");
-        }
-        if (StringUtils.isBlank(passwordToUse)) {
-          return ResultBuilder.createConnectionErrorResult(
-              CliStrings.START_SERVER__MSG__PASSWORD_MUST_BE_SPECIFIED);
-        }
+    if (StringUtils.isBlank(memberName)) {
+      // when the user doesn't give us a name, we make one up!
+      memberName = StartMemberUtils.getNameGenerator().generate('-');
+    }
+
+    // prompt for password is username is specified in the command
+    if (StringUtils.isNotBlank(userName)) {
+      if (StringUtils.isBlank(passwordToUse)) {
+        passwordToUse = getGfsh().readPassword(CliStrings.START_SERVER__PASSWORD + ": ");
+      }
+      if (StringUtils.isBlank(passwordToUse)) {
+        return ResultBuilder
+            .createConnectionErrorResult(CliStrings.START_SERVER__MSG__PASSWORD_MUST_BE_SPECIFIED);
       }
+    }
 
-      workingDirectory = StartMemberUtils.resolveWorkingDir(workingDirectory, memberName);
+    workingDirectory = StartMemberUtils.resolveWorkingDir(workingDirectory, memberName);
 
-      cacheXmlPathname = CliUtil.resolvePathname(cacheXmlPathname);
+    cacheXmlPathname = CliUtil.resolvePathname(cacheXmlPathname);
 
-      if (StringUtils.isNotBlank(cacheXmlPathname)
-          && !IOUtils.isExistingPathname(cacheXmlPathname)) {
-        return ResultBuilder.createUserErrorResult(
-            CliStrings.format(CliStrings.CACHE_XML_NOT_FOUND_MESSAGE, cacheXmlPathname));
-      }
+    if (StringUtils.isNotBlank(cacheXmlPathname) && !IOUtils.isExistingPathname(cacheXmlPathname)) {
+      return ResultBuilder.createUserErrorResult(
+          CliStrings.format(CliStrings.CACHE_XML_NOT_FOUND_MESSAGE, cacheXmlPathname));
+    }
 
-      if (gemfirePropertiesFile != null && !gemfirePropertiesFile.exists()) {
-        return ResultBuilder.createUserErrorResult(
-            CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, StringUtils.EMPTY,
-                gemfirePropertiesFile.getAbsolutePath()));
-      }
+    if (gemfirePropertiesFile != null && !gemfirePropertiesFile.exists()) {
+      return ResultBuilder.createUserErrorResult(
+          CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, StringUtils.EMPTY,
+              gemfirePropertiesFile.getAbsolutePath()));
+    }
 
-      if (gemfireSecurityPropertiesFile != null && !gemfireSecurityPropertiesFile.exists()) {
-        return ResultBuilder.createUserErrorResult(
-            CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, "Security ",
-                gemfireSecurityPropertiesFile.getAbsolutePath()));
-      }
+    if (gemfireSecurityPropertiesFile != null && !gemfireSecurityPropertiesFile.exists()) {
+      return ResultBuilder.createUserErrorResult(
+          CliStrings.format(CliStrings.GEODE_0_PROPERTIES_1_NOT_FOUND_MESSAGE, "Security ",
+              gemfireSecurityPropertiesFile.getAbsolutePath()));
+    }
 
-      File serverPidFile = new File(workingDirectory, ProcessType.SERVER.getPidFileName());
-
-      final int oldPid = StartMemberUtils.readPid(serverPidFile);
-
-      Properties gemfireProperties = new Properties();
-
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.BIND_ADDRESS,
-          bindAddress);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.CACHE_XML_FILE, cacheXmlPathname);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.ENABLE_TIME_STATISTICS, enableTimeStatistics);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.GROUPS,
-          group);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.JMX_MANAGER_HOSTNAME_FOR_CLIENTS, jmxManagerHostnameForClients);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOCATORS,
-          locators);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.LOCATOR_WAIT_TIME, locatorWaitTime);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOG_LEVEL,
-          logLevel);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.MCAST_ADDRESS, mcastBindAddress);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.MCAST_PORT,
-          mcastPort);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.MEMCACHED_PORT, memcachedPort);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.MEMCACHED_PROTOCOL, memcachedProtocol);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.MEMCACHED_BIND_ADDRESS, memcachedBindAddress);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.REDIS_PORT,
-          redisPort);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.REDIS_BIND_ADDRESS, redisBindAddress);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.REDIS_PASSWORD, redisPassword);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.STATISTIC_ARCHIVE_FILE, statisticsArchivePathname);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.USE_CLUSTER_CONFIGURATION, requestSharedConfiguration);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOCK_MEMORY,
-          lockMemory);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.OFF_HEAP_MEMORY_SIZE, offHeapMemorySize);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.START_DEV_REST_API, startRestApi);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.HTTP_SERVICE_PORT, httpServicePort);
-      StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
-          ConfigurationProperties.HTTP_SERVICE_BIND_ADDRESS, httpServiceBindAddress);
-      // if username is specified in the command line, it will overwrite what's set in the
-      // properties file
-      if (StringUtils.isNotBlank(userName)) {
-        gemfireProperties.setProperty(ResourceConstants.USER_NAME, userName);
-        gemfireProperties.setProperty(ResourceConstants.PASSWORD, passwordToUse);
-      }
+    File serverPidFile = new File(workingDirectory, ProcessType.SERVER.getPidFileName());
+
+    final int oldPid = StartMemberUtils.readPid(serverPidFile);
+
+    Properties gemfireProperties = new Properties();
+
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.BIND_ADDRESS,
+        bindAddress);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.CACHE_XML_FILE,
+        cacheXmlPathname);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.ENABLE_TIME_STATISTICS, enableTimeStatistics);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.GROUPS, group);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.JMX_MANAGER_HOSTNAME_FOR_CLIENTS, jmxManagerHostnameForClients);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOCATORS,
+        locators);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.LOCATOR_WAIT_TIME, locatorWaitTime);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOG_LEVEL,
+        logLevel);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.MCAST_ADDRESS,
+        mcastBindAddress);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.MCAST_PORT,
+        mcastPort);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.MEMCACHED_PORT,
+        memcachedPort);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.MEMCACHED_PROTOCOL, memcachedProtocol);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.MEMCACHED_BIND_ADDRESS, memcachedBindAddress);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.REDIS_PORT,
+        redisPort);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.REDIS_BIND_ADDRESS, redisBindAddress);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.REDIS_PASSWORD,
+        redisPassword);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.STATISTIC_ARCHIVE_FILE, statisticsArchivePathname);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.USE_CLUSTER_CONFIGURATION, requestSharedConfiguration);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties, ConfigurationProperties.LOCK_MEMORY,
+        lockMemory);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.OFF_HEAP_MEMORY_SIZE, offHeapMemorySize);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.START_DEV_REST_API, startRestApi);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.HTTP_SERVICE_PORT, httpServicePort);
+    StartMemberUtils.setPropertyIfNotNull(gemfireProperties,
+        ConfigurationProperties.HTTP_SERVICE_BIND_ADDRESS, httpServiceBindAddress);
+    // if username is specified in the command line, it will overwrite what's set in the
+    // properties file
+    if (StringUtils.isNotBlank(userName)) {
+      gemfireProperties.setProperty(ResourceConstants.USER_NAME, userName);
+      gemfireProperties.setProperty(ResourceConstants.PASSWORD, passwordToUse);
+    }
 
-      // read the OSProcess enable redirect system property here -- TODO: replace with new GFSH
-      // argument
-      final boolean redirectOutput =
-          Boolean.getBoolean(OSProcess.ENABLE_OUTPUT_REDIRECTION_PROPERTY);
-
-      ServerLauncher.Builder serverLauncherBuilder = new ServerLauncher.Builder()
-          .setAssignBuckets(assignBuckets).setDisableDefaultServer(disableDefaultServer)
-          .setForce(force).setRebalance(rebalance).setRedirectOutput(redirectOutput)
-          .setServerBindAddress(serverBindAddress).setServerPort(serverPort)
-          .setSpringXmlLocation(springXmlLocation).setWorkingDirectory(workingDirectory)
-          .setCriticalHeapPercentage(criticalHeapPercentage)
-          .setEvictionHeapPercentage(evictionHeapPercentage)
-          .setCriticalOffHeapPercentage(criticalOffHeapPercentage)
-          .setEvictionOffHeapPercentage(evictionOffHeapPercentage).setMaxConnections(maxConnections)
-          .setMaxMessageCount(maxMessageCount).setMaxThreads(maxThreads)
-          .setMessageTimeToLive(messageTimeToLive).setSocketBufferSize(socketBufferSize);
-      if (hostNameForClients != null) {
-        serverLauncherBuilder.setHostNameForClients(hostNameForClients);
-      }
-      if (memberName != null) {
-        serverLauncherBuilder.setMemberName(memberName);
-      }
-      ServerLauncher serverLauncher = serverLauncherBuilder.build();
+    // read the OSProcess enable redirect system property here -- TODO: replace with new GFSH
+    // argument
+    final boolean redirectOutput = Boolean.getBoolean(OSProcess.ENABLE_OUTPUT_REDIRECTION_PROPERTY);
+
+    ServerLauncher.Builder serverLauncherBuilder = new ServerLauncher.Builder()
+        .setAssignBuckets(assignBuckets).setDisableDefaultServer(disableDefaultServer)
+        .setForce(force).setRebalance(rebalance).setRedirectOutput(redirectOutput)
+        .setServerBindAddress(serverBindAddress).setServerPort(serverPort)
+        .setSpringXmlLocation(springXmlLocation).setWorkingDirectory(workingDirectory)
+        .setCriticalHeapPercentage(criticalHeapPercentage)
+        .setEvictionHeapPercentage(evictionHeapPercentage)
+        .setCriticalOffHeapPercentage(criticalOffHeapPercentage)
+        .setEvictionOffHeapPercentage(evictionOffHeapPercentage).setMaxConnections(maxConnections)
+        .setMaxMessageCount(maxMessageCount).setMaxThreads(maxThreads)
+        .setMessageTimeToLive(messageTimeToLive).setSocketBufferSize(socketBufferSize);
+    if (hostNameForClients != null) {
+      serverLauncherBuilder.setHostNameForClients(hostNameForClients);
+    }
+    if (memberName != null) {
+      serverLauncherBuilder.setMemberName(memberName);
+    }
+    ServerLauncher serverLauncher = serverLauncherBuilder.build();
 
-      String[] serverCommandLine = createStartServerCommandLine(serverLauncher,
-          gemfirePropertiesFile, gemfireSecurityPropertiesFile, gemfireProperties, classpath,
-          includeSystemClasspath, jvmArgsOpts, disableExitWhenOutOfMemory, initialHeap, maxHeap);
+    String[] serverCommandLine = createStartServerCommandLine(serverLauncher, gemfirePropertiesFile,
+        gemfireSecurityPropertiesFile, gemfireProperties, classpath, includeSystemClasspath,
+        jvmArgsOpts, disableExitWhenOutOfMemory, initialHeap, maxHeap);
 
-      if (getGfsh().getDebug()) {
-        getGfsh().logInfo(StringUtils.join(serverCommandLine, StringUtils.SPACE), null);
-      }
+    if (getGfsh().getDebug()) {
+      getGfsh().logInfo(StringUtils.join(serverCommandLine, StringUtils.SPACE), null);
+    }
 
-      Process serverProcess = new ProcessBuilder(serverCommandLine)
-          .directory(new File(serverLauncher.getWorkingDirectory())).start();
+    Process serverProcess = new ProcessBuilder(serverCommandLine)
+        .directory(new File(serverLauncher.getWorkingDirectory())).start();
 
-      serverProcess.getInputStream().close();
-      serverProcess.getOutputStream().close();
+    serverProcess.getInputStream().close();
+    serverProcess.getOutputStream().close();
 
-      // fix TRAC bug #51967 by using NON_BLOCKING on Windows
-      final ProcessStreamReader.ReadingMode readingMode = SystemUtils.isWindows()
-          ? ProcessStreamReader.ReadingMode.NON_BLOCKING : ProcessStreamReader.ReadingMode.BLOCKING;
+    // fix TRAC bug #51967 by using NON_BLOCKING on Windows
+    final ProcessStreamReader.ReadingMode readingMode = SystemUtils.isWindows()
+        ? ProcessStreamReader.ReadingMode.NON_BLOCKING : ProcessStreamReader.ReadingMode.BLOCKING;
 
-      final StringBuffer message = new StringBuffer(); // need thread-safe StringBuffer
-      ProcessStreamReader.InputListener inputListener = line -> {
-        message.append(line);
-        if (readingMode == ProcessStreamReader.ReadingMode.BLOCKING) {
-          message.append(StringUtils.LINE_SEPARATOR);
-        }
-      };
+    final StringBuffer message = new StringBuffer(); // need thread-safe StringBuffer
+    ProcessStreamReader.InputListener inputListener = line -> {
+      message.append(line);
+      if (readingMode == ProcessStreamReader.ReadingMode.BLOCKING) {
+        message.append(StringUtils.LINE_SEPARATOR);
+      }
+    };
 
-      ProcessStreamReader stderrReader = new ProcessStreamReader.Builder(serverProcess)
-          .inputStream(serverProcess.getErrorStream()).inputListener(inputListener)
-          .readingMode(readingMode).continueReadingMillis(2 * 1000).build().start();
+    ProcessStreamReader stderrReader = new ProcessStreamReader.Builder(serverProcess)
+        .inputStream(serverProcess.getErrorStream()).inputListener(inputListener)
+        .readingMode(readingMode).continueReadingMillis(2 * 1000).build().start();
 
-      ServerLauncher.ServerState serverState;
+    ServerLauncher.ServerState serverState;
 
-      String previousServerStatusMessage = null;
+    String previousServerStatusMessage = null;
 
-      LauncherSignalListener serverSignalListener = new LauncherSignalListener();
+    LauncherSignalListener serverSignalListener = new LauncherSignalListener();
 
-      final boolean registeredServerSignalListener =
-          getGfsh().getSignalHandler().registerListener(serverSignalListener);
+    final boolean registeredServerSignalListener =
+        getGfsh().getSignalHandler().registerListener(serverSignalListener);
 
-      try {
-        getGfsh().logInfo(String.format(CliStrings.START_SERVER__RUN_MESSAGE,
-            IOUtils.tryGetCanonicalPathElseGetAbsolutePath(
-                new File(serverLauncher.getWorkingDirectory()))),
-            null);
+    try {
+      getGfsh().logInfo(String.format(CliStrings.START_SERVER__RUN_MESSAGE, IOUtils
+          .tryGetCanonicalPathElseGetAbsolutePath(new File(serverLauncher.getWorkingDirectory()))),
+          null);
 
-        serverState = ServerLauncher.ServerState.fromDirectory(workingDirectory, memberName);
-        do {
-          if (serverProcess.isAlive()) {
-            Gfsh.print(".");
+      serverState = ServerLauncher.ServerState.fromDirectory(workingDirectory, memberName);
+      do {
+        if (serverProcess.isAlive()) {
+          Gfsh.print(".");
 
-            synchronized (this) {
-              TimeUnit.MILLISECONDS.timedWait(this, 500);
-            }
+          synchronized (this) {
+            TimeUnit.MILLISECONDS.timedWait(this, 500);
+          }
 
-            serverState = ServerLauncher.ServerState.fromDirectory(workingDirectory, memberName);
+          serverState = ServerLauncher.ServerState.fromDirectory(workingDirectory, memberName);
 
-            String currentServerStatusMessage = serverState.getStatusMessage();
+          String currentServerStatusMessage = serverState.getStatusMessage();
 
-            if (serverState.isStartingOrNotResponding()
-                && !(StringUtils.isBlank(currentServerStatusMessage)
-                    || currentServerStatusMessage.equalsIgnoreCase(previousServerStatusMessage)
-                    || currentServerStatusMessage.trim().toLowerCase().equals("null"))) {
-              Gfsh.println();
-              Gfsh.println(currentServerStatusMessage);
-              previousServerStatusMessage = currentServerStatusMessage;
-            }
-          } else {
-            final int exitValue = serverProcess.exitValue();
+          if (serverState.isStartingOrNotResponding()
+              && !(StringUtils.isBlank(currentServerStatusMessage)
+                  || currentServerStatusMessage.equalsIgnoreCase(previousServerStatusMessage)
+                  || currentServerStatusMessage.trim().toLowerCase().equals("null"))) {
+            Gfsh.println();
+            Gfsh.println(currentServerStatusMessage);
+            previousServerStatusMessage = currentServerStatusMessage;
+          }
+        } else {
+          final int exitValue = serverProcess.exitValue();
 
-            return ResultBuilder.createShellClientErrorResult(
-                String.format(CliStrings.START_SERVER__PROCESS_TERMINATED_ABNORMALLY_ERROR_MESSAGE,
-                    exitValue, serverLauncher.getWorkingDirectory(), message.toString()));
+          return ResultBuilder.createShellClientErrorResult(
+              String.format(CliStrings.START_SERVER__PROCESS_TERMINATED_ABNORMALLY_ERROR_MESSAGE,
+                  exitValue, serverLauncher.getWorkingDirectory(), message.toString()));
 
-          }
-        } while (!(registeredServerSignalListener && serverSignalListener.isSignaled())
-            && serverState.isStartingOrNotResponding());
-      } finally {
-        stderrReader.stopAsync(StartMemberUtils.PROCESS_STREAM_READER_ASYNC_STOP_TIMEOUT_MILLIS); // stop
-                                                                                                  // will
-                                                                                                  // close
-        // ErrorStream
-        getGfsh().getSignalHandler().unregisterListener(serverSignalListener);
-      }
+        }
+      } while (!(registeredServerSignalListener && serverSignalListener.isSignaled())
+          && serverState.isStartingOrNotResponding());
+    } finally {
+      stderrReader.stopAsync(StartMemberUtils.PROCESS_STREAM_READER_ASYNC_STOP_TIMEOUT_MILLIS); // stop
+                                                                                                // will
+                                                                                                // close
+      // ErrorStream
+      getGfsh().getSignalHandler().unregisterListener(serverSignalListener);
+    }
 
-      Gfsh.println();
+    Gfsh.println();
 
-      final boolean asyncStart =
-          ServerLauncher.ServerState.isStartingNotRespondingOrNull(serverState);
+    final boolean asyncStart =
+        ServerLauncher.ServerState.isStartingNotRespondingOrNull(serverState);
 
-      if (asyncStart) { // async start
-        Gfsh.print(String.format(CliStrings.ASYNC_PROCESS_LAUNCH_MESSAGE, SERVER_TERM_NAME));
-        return ResultBuilder.createInfoResult("");
-      } else {
-        return ResultBuilder.createInfoResult(serverState.toString());
-      }
-    } catch (IllegalArgumentException e) {
-      String message = e.getMessage();
-      if (message != null && message.matches(
-          LocalizedStrings.Launcher_Builder_UNKNOWN_HOST_ERROR_MESSAGE.toLocalizedString(".+"))) {
-        message =
-            CliStrings.format(CliStrings.LAUNCHERLIFECYCLECOMMANDS__MSG__FAILED_TO_START_0_REASON_1,
-                SERVER_TERM_NAME, message);
-      }
-      return ResultBuilder.createUserErrorResult(message);
-    } catch (IllegalStateException e) {
-      return ResultBuilder.createUserErrorResult(e.getMessage());
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      return ResultBuilder.createShellClientErrorResult(String.format(
-          CliStrings.START_SERVER__GENERAL_ERROR_MESSAGE, this.toString(t, getGfsh().getDebug())));
+    if (asyncStart) { // async start
+      Gfsh.print(String.format(CliStrings.ASYNC_PROCESS_LAUNCH_MESSAGE, SERVER_TERM_NAME));
+      return ResultBuilder.createInfoResult("");
+    } else {
+      return ResultBuilder.createInfoResult(serverState.toString());
     }
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartJConsoleCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartJConsoleCommand.java
index 1bcbbae893..0e27bfdb0b 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartJConsoleCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartJConsoleCommand.java
@@ -108,7 +108,7 @@ public Result startJConsole(
     } catch (Throwable t) {
       SystemFailure.checkFailure();
       return ResultBuilder.createShellClientErrorResult(
-          String.format(CliStrings.START_JCONSOLE__CATCH_ALL_ERROR_MESSAGE, toString(t, false)));
+          String.format(CliStrings.START_JCONSOLE__CATCH_ALL_ERROR_MESSAGE, t.getMessage()));
     }
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartJVisualVMCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartJVisualVMCommand.java
index 699a4825f3..48a711f020 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartJVisualVMCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartJVisualVMCommand.java
@@ -72,7 +72,7 @@ public Result startJVisualVM(
     } catch (Throwable t) {
       SystemFailure.checkFailure();
       return ResultBuilder.createShellClientErrorResult(
-          String.format(CliStrings.START_JVISUALVM__ERROR_MESSAGE, toString(t, false)));
+          String.format(CliStrings.START_JVISUALVM__ERROR_MESSAGE, t.getMessage()));
     }
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartPulseCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartPulseCommand.java
index fbf32d88fa..f07a90fb4e 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartPulseCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartPulseCommand.java
@@ -81,7 +81,7 @@ public Result startPulse(@CliOption(key = CliStrings.START_PULSE__URL,
     } catch (Throwable t) {
       SystemFailure.checkFailure();
       return ResultBuilder.createShellClientErrorResult(
-          String.format(CliStrings.START_PULSE__ERROR, toString(t, false)));
+          String.format(CliStrings.START_PULSE__ERROR, t.getMessage()));
     }
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartVsdCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartVsdCommand.java
index 7719611779..36b56147cb 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartVsdCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StartVsdCommand.java
@@ -85,7 +85,7 @@ public Result startVsd(@CliOption(key = CliStrings.START_VSD__FILE,
     } catch (Throwable t) {
       SystemFailure.checkFailure();
       return ResultBuilder.createShellClientErrorResult(
-          String.format(CliStrings.START_VSD__ERROR_MESSAGE, toString(t, false)));
+          String.format(CliStrings.START_VSD__ERROR_MESSAGE, t.getMessage()));
     }
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StatusLocatorCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StatusLocatorCommand.java
index 06f835034c..fac8ad2a23 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StatusLocatorCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StatusLocatorCommand.java
@@ -16,18 +16,15 @@
 
 import static org.apache.geode.management.internal.cli.i18n.CliStrings.LOCATOR_TERM_NAME;
 import static org.apache.geode.management.internal.cli.shell.MXBeanProvider.getMemberMXBean;
-import static org.apache.geode.management.internal.cli.util.HostUtils.getLocatorId;
 
 import java.io.IOException;
 
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.distributed.AbstractLauncher;
 import org.apache.geode.distributed.LocatorLauncher;
 import org.apache.geode.internal.lang.StringUtils;
-import org.apache.geode.internal.lang.SystemUtils;
 import org.apache.geode.management.MemberMXBean;
 import org.apache.geode.management.cli.CliMetaData;
 import org.apache.geode.management.cli.ConverterHint;
@@ -53,49 +50,39 @@ public Result statusLocator(
       @CliOption(key = CliStrings.STATUS_LOCATOR__PID,
           help = CliStrings.STATUS_LOCATOR__PID__HELP) final Integer pid,
       @CliOption(key = CliStrings.STATUS_LOCATOR__DIR,
-          help = CliStrings.STATUS_LOCATOR__DIR__HELP) final String workingDirectory) {
-    try {
-      if (StringUtils.isNotBlank(member)) {
-        if (isConnectedAndReady()) {
-          final MemberMXBean locatorProxy = getMemberMXBean(member);
+          help = CliStrings.STATUS_LOCATOR__DIR__HELP) final String workingDirectory)
+      throws Exception {
 
-          if (locatorProxy != null) {
-            LocatorLauncher.LocatorState state =
-                LocatorLauncher.LocatorState.fromJson(locatorProxy.status());
-            return createStatusLocatorResult(state);
-          } else {
-            return ResultBuilder.createUserErrorResult(CliStrings.format(
-                CliStrings.STATUS_LOCATOR__NO_LOCATOR_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
-          }
+    if (StringUtils.isNotBlank(member)) {
+      if (isConnectedAndReady()) {
+        final MemberMXBean locatorProxy = getMemberMXBean(member);
+
+        if (locatorProxy != null) {
+          LocatorLauncher.LocatorState state =
+              LocatorLauncher.LocatorState.fromJson(locatorProxy.status());
+          return createStatusLocatorResult(state);
         } else {
           return ResultBuilder.createUserErrorResult(CliStrings.format(
-              CliStrings.STATUS_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, LOCATOR_TERM_NAME));
+              CliStrings.STATUS_LOCATOR__NO_LOCATOR_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
         }
       } else {
-        final LocatorLauncher locatorLauncher =
-            new LocatorLauncher.Builder().setCommand(LocatorLauncher.Command.STATUS)
-                .setBindAddress(locatorHost).setDebug(isDebugging()).setPid(pid)
-                .setPort(locatorPort).setWorkingDirectory(workingDirectory).build();
+        return ResultBuilder.createUserErrorResult(CliStrings.format(
+            CliStrings.STATUS_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, LOCATOR_TERM_NAME));
+      }
+    } else {
+      final LocatorLauncher locatorLauncher =
+          new LocatorLauncher.Builder().setCommand(LocatorLauncher.Command.STATUS)
+              .setBindAddress(locatorHost).setDebug(isDebugging()).setPid(pid).setPort(locatorPort)
+              .setWorkingDirectory(workingDirectory).build();
 
-        final LocatorLauncher.LocatorState status = locatorLauncher.status();
-        if (status.getStatus().equals(AbstractLauncher.Status.NOT_RESPONDING)
-            || status.getStatus().equals(AbstractLauncher.Status.STOPPED)) {
-          return ResultBuilder.createShellClientErrorResult(status.toString());
-        }
-        return createStatusLocatorResult(status);
+      final LocatorLauncher.LocatorState status = locatorLauncher.status();
+      if (status.getStatus().equals(AbstractLauncher.Status.NOT_RESPONDING)
+          || status.getStatus().equals(AbstractLauncher.Status.STOPPED)) {
+        return ResultBuilder.createShellClientErrorResult(status.toString());
       }
-    } catch (IllegalArgumentException | IllegalStateException e) {
-      return ResultBuilder.createUserErrorResult(e.getMessage());
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      return ResultBuilder.createShellClientErrorResult(String.format(
-          CliStrings.STATUS_LOCATOR__GENERAL_ERROR_MESSAGE, getLocatorId(locatorHost, locatorPort),
-          StringUtils.defaultIfBlank(workingDirectory, SystemUtils.CURRENT_DIRECTORY),
-          toString(t, getGfsh().getDebug())));
+      return createStatusLocatorResult(status);
     }
+
   }
 
   protected Result createStatusLocatorResult(final LocatorLauncher.LocatorState state)
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StatusServerCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StatusServerCommand.java
index 43374ab161..0a7fb8b7bf 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StatusServerCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StatusServerCommand.java
@@ -16,10 +16,11 @@
 
 import static org.apache.geode.management.internal.cli.shell.MXBeanProvider.getMemberMXBean;
 
+import java.io.IOException;
+
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.distributed.AbstractLauncher;
 import org.apache.geode.distributed.ServerLauncher;
 import org.apache.geode.internal.lang.StringUtils;
@@ -42,52 +43,41 @@ public Result statusServer(
       @CliOption(key = CliStrings.STATUS_SERVER__PID,
           help = CliStrings.STATUS_SERVER__PID__HELP) final Integer pid,
       @CliOption(key = CliStrings.STATUS_SERVER__DIR,
-          help = CliStrings.STATUS_SERVER__DIR__HELP) final String workingDirectory) {
-    try {
-      if (StringUtils.isNotBlank(member)) {
-        if (isConnectedAndReady()) {
-          final MemberMXBean serverProxy = getMemberMXBean(member);
+          help = CliStrings.STATUS_SERVER__DIR__HELP) final String workingDirectory)
+      throws IOException {
+
+    if (StringUtils.isNotBlank(member)) {
+      if (isConnectedAndReady()) {
+        final MemberMXBean serverProxy = getMemberMXBean(member);
 
-          if (serverProxy != null) {
-            return ResultBuilder.createInfoResult(
-                ServerLauncher.ServerState.fromJson(serverProxy.status()).toString());
-          } else {
-            return ResultBuilder.createUserErrorResult(CliStrings.format(
-                CliStrings.STATUS_SERVER__NO_SERVER_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
-          }
+        if (serverProxy != null) {
+          return ResultBuilder.createInfoResult(
+              ServerLauncher.ServerState.fromJson(serverProxy.status()).toString());
         } else {
           return ResultBuilder.createUserErrorResult(CliStrings
-              .format(CliStrings.STATUS_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, "Cache Server"));
+              .format(CliStrings.STATUS_SERVER__NO_SERVER_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
         }
       } else {
-        final ServerLauncher serverLauncher = new ServerLauncher.Builder()
-            .setCommand(ServerLauncher.Command.STATUS).setDebug(isDebugging())
-            // NOTE since we do not know whether the "CacheServer" was enabled or not on the GemFire
-            // server when it was started,
-            // set the disableDefaultServer property in the ServerLauncher.Builder to default status
-            // to the MemberMBean
-            // TODO fix this hack! (how, the 'start server' loop needs it)
-            .setDisableDefaultServer(true).setPid(pid).setWorkingDirectory(workingDirectory)
-            .build();
+        return ResultBuilder.createUserErrorResult(CliStrings
+            .format(CliStrings.STATUS_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, "Cache Server"));
+      }
+    } else {
+      final ServerLauncher serverLauncher = new ServerLauncher.Builder()
+          .setCommand(ServerLauncher.Command.STATUS).setDebug(isDebugging())
+          // NOTE since we do not know whether the "CacheServer" was enabled or not on the GemFire
+          // server when it was started,
+          // set the disableDefaultServer property in the ServerLauncher.Builder to default status
+          // to the MemberMBean
+          // TODO fix this hack! (how, the 'start server' loop needs it)
+          .setDisableDefaultServer(true).setPid(pid).setWorkingDirectory(workingDirectory).build();
 
-        final ServerLauncher.ServerState status = serverLauncher.status();
+      final ServerLauncher.ServerState status = serverLauncher.status();
 
-        if (status.getStatus().equals(AbstractLauncher.Status.NOT_RESPONDING)
-            || status.getStatus().equals(AbstractLauncher.Status.STOPPED)) {
-          return ResultBuilder.createGemFireErrorResult(status.toString());
-        }
-        return ResultBuilder.createInfoResult(status.toString());
+      if (status.getStatus().equals(AbstractLauncher.Status.NOT_RESPONDING)
+          || status.getStatus().equals(AbstractLauncher.Status.STOPPED)) {
+        return ResultBuilder.createGemFireErrorResult(status.toString());
       }
-    } catch (IllegalArgumentException | IllegalStateException e) {
-
-      return ResultBuilder.createUserErrorResult(e.getMessage());
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      return ResultBuilder.createShellClientErrorResult(String.format(
-          CliStrings.STATUS_SERVER__GENERAL_ERROR_MESSAGE, toString(t, getGfsh().getDebug())));
+      return ResultBuilder.createInfoResult(status.toString());
     }
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StopLocatorCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StopLocatorCommand.java
index ec3583c09a..e435b6e2e6 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StopLocatorCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StopLocatorCommand.java
@@ -22,7 +22,6 @@
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.distributed.AbstractLauncher;
 import org.apache.geode.distributed.LocatorLauncher;
 import org.apache.geode.internal.lang.StringUtils;
@@ -49,77 +48,65 @@ public Result stopLocator(
       @CliOption(key = CliStrings.STOP_LOCATOR__PID,
           help = CliStrings.STOP_LOCATOR__PID__HELP) final Integer pid,
       @CliOption(key = CliStrings.STOP_LOCATOR__DIR,
-          help = CliStrings.STOP_LOCATOR__DIR__HELP) final String workingDirectory) {
-    LocatorLauncher.LocatorState locatorState;
-
-    try {
-      if (StringUtils.isNotBlank(member)) {
-        if (isConnectedAndReady()) {
-          final MemberMXBean locatorProxy = getMemberMXBean(member);
+          help = CliStrings.STOP_LOCATOR__DIR__HELP) final String workingDirectory)
+      throws Exception {
 
-          if (locatorProxy != null) {
-            if (!locatorProxy.isLocator()) {
-              throw new IllegalStateException(
-                  CliStrings.format(CliStrings.STOP_LOCATOR__NOT_LOCATOR_ERROR_MESSAGE, member));
-            }
+    LocatorLauncher.LocatorState locatorState;
+    if (StringUtils.isNotBlank(member)) {
+      if (isConnectedAndReady()) {
+        final MemberMXBean locatorProxy = getMemberMXBean(member);
 
-            if (locatorProxy.isServer()) {
-              throw new IllegalStateException(CliStrings
-                  .format(CliStrings.STOP_LOCATOR__LOCATOR_IS_CACHE_SERVER_ERROR_MESSAGE, member));
-            }
+        if (locatorProxy != null) {
+          if (!locatorProxy.isLocator()) {
+            throw new IllegalStateException(
+                CliStrings.format(CliStrings.STOP_LOCATOR__NOT_LOCATOR_ERROR_MESSAGE, member));
+          }
 
-            locatorState = LocatorLauncher.LocatorState.fromJson(locatorProxy.status());
-            locatorProxy.shutDownMember();
-          } else {
-            return ResultBuilder.createUserErrorResult(CliStrings.format(
-                CliStrings.STOP_LOCATOR__NO_LOCATOR_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
+          if (locatorProxy.isServer()) {
+            throw new IllegalStateException(CliStrings
+                .format(CliStrings.STOP_LOCATOR__LOCATOR_IS_CACHE_SERVER_ERROR_MESSAGE, member));
           }
+
+          locatorState = LocatorLauncher.LocatorState.fromJson(locatorProxy.status());
+          locatorProxy.shutDownMember();
         } else {
-          return ResultBuilder.createUserErrorResult(CliStrings.format(
-              CliStrings.STOP_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, LOCATOR_TERM_NAME));
+          return ResultBuilder.createUserErrorResult(CliStrings
+              .format(CliStrings.STOP_LOCATOR__NO_LOCATOR_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
         }
       } else {
-        final LocatorLauncher locatorLauncher =
-            new LocatorLauncher.Builder().setCommand(LocatorLauncher.Command.STOP)
-                .setDebug(isDebugging()).setPid(pid).setWorkingDirectory(workingDirectory).build();
-
-        locatorState = locatorLauncher.status();
-        locatorLauncher.stop();
+        return ResultBuilder.createUserErrorResult(CliStrings
+            .format(CliStrings.STOP_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, LOCATOR_TERM_NAME));
       }
+    } else {
+      final LocatorLauncher locatorLauncher =
+          new LocatorLauncher.Builder().setCommand(LocatorLauncher.Command.STOP)
+              .setDebug(isDebugging()).setPid(pid).setWorkingDirectory(workingDirectory).build();
+
+      locatorState = locatorLauncher.status();
+      locatorLauncher.stop();
+    }
 
-      if (AbstractLauncher.Status.ONLINE.equals(locatorState.getStatus())) {
-        getGfsh().logInfo(
-            String.format(CliStrings.STOP_LOCATOR__STOPPING_LOCATOR_MESSAGE,
-                locatorState.getWorkingDirectory(), locatorState.getServiceLocation(),
-                locatorState.getMemberName(), locatorState.getPid(), locatorState.getLogFile()),
-            null);
+    if (AbstractLauncher.Status.ONLINE.equals(locatorState.getStatus())) {
+      getGfsh().logInfo(
+          String.format(CliStrings.STOP_LOCATOR__STOPPING_LOCATOR_MESSAGE,
+              locatorState.getWorkingDirectory(), locatorState.getServiceLocation(),
+              locatorState.getMemberName(), locatorState.getPid(), locatorState.getLogFile()),
+          null);
 
-        StopWatch stopWatch = new StopWatch(true);
-        while (locatorState.isVmWithProcessIdRunning()) {
-          Gfsh.print(".");
-          if (stopWatch.elapsedTimeMillis() > WAITING_FOR_STOP_TO_MAKE_PID_GO_AWAY_TIMEOUT_MILLIS) {
-            break;
-          }
-          synchronized (this) {
-            TimeUnit.MILLISECONDS.timedWait(this, 500);
-          }
+      StopWatch stopWatch = new StopWatch(true);
+      while (locatorState.isVmWithProcessIdRunning()) {
+        Gfsh.print(".");
+        if (stopWatch.elapsedTimeMillis() > WAITING_FOR_STOP_TO_MAKE_PID_GO_AWAY_TIMEOUT_MILLIS) {
+          break;
+        }
+        synchronized (this) {
+          TimeUnit.MILLISECONDS.timedWait(this, 500);
         }
-
-        return ResultBuilder.createInfoResult(StringUtils.EMPTY);
-      } else {
-        return ResultBuilder.createUserErrorResult(locatorState.toString());
       }
-    } catch (IllegalArgumentException | IllegalStateException e) {
-      return ResultBuilder.createUserErrorResult(e.getMessage());
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      return ResultBuilder.createShellClientErrorResult(String.format(
-          CliStrings.STOP_LOCATOR__GENERAL_ERROR_MESSAGE, toString(t, getGfsh().getDebug())));
-    } finally {
-      Gfsh.redirectInternalJavaLoggers();
+
+      return ResultBuilder.createInfoResult(StringUtils.EMPTY);
+    } else {
+      return ResultBuilder.createUserErrorResult(locatorState.toString());
     }
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StopServerCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StopServerCommand.java
index 526dcd8952..ba05073997 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StopServerCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/lifecycle/StopServerCommand.java
@@ -21,7 +21,6 @@
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.distributed.AbstractLauncher;
 import org.apache.geode.distributed.ServerLauncher;
 import org.apache.geode.internal.lang.StringUtils;
@@ -47,73 +46,61 @@ public Result stopServer(
       @CliOption(key = CliStrings.STOP_SERVER__PID,
           help = CliStrings.STOP_SERVER__PID__HELP) final Integer pid,
       @CliOption(key = CliStrings.STOP_SERVER__DIR,
-          help = CliStrings.STOP_SERVER__DIR__HELP) final String workingDirectory) {
+          help = CliStrings.STOP_SERVER__DIR__HELP) final String workingDirectory)
+      throws Exception {
     ServerLauncher.ServerState serverState;
 
-    try {
-      if (StringUtils.isNotBlank(member)) {
-        if (!isConnectedAndReady()) {
-          return ResultBuilder.createUserErrorResult(CliStrings
-              .format(CliStrings.STOP_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, "Cache Server"));
-        }
-
-        final MemberMXBean serverProxy = getMemberMXBean(member);
+    if (StringUtils.isNotBlank(member)) {
+      if (!isConnectedAndReady()) {
+        return ResultBuilder.createUserErrorResult(CliStrings
+            .format(CliStrings.STOP_SERVICE__GFSH_NOT_CONNECTED_ERROR_MESSAGE, "Cache Server"));
+      }
 
-        if (serverProxy != null) {
-          if (!serverProxy.isServer()) {
-            throw new IllegalStateException(CliStrings
-                .format(CliStrings.STOP_SERVER__MEMBER_IS_NOT_SERVER_ERROR_MESSAGE, member));
-          }
+      final MemberMXBean serverProxy = getMemberMXBean(member);
 
-          serverState = ServerLauncher.ServerState.fromJson(serverProxy.status());
-          serverProxy.shutDownMember();
-        } else {
-          return ResultBuilder.createUserErrorResult(CliStrings
-              .format(CliStrings.STOP_SERVER__NO_SERVER_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
+      if (serverProxy != null) {
+        if (!serverProxy.isServer()) {
+          throw new IllegalStateException(CliStrings
+              .format(CliStrings.STOP_SERVER__MEMBER_IS_NOT_SERVER_ERROR_MESSAGE, member));
         }
 
+        serverState = ServerLauncher.ServerState.fromJson(serverProxy.status());
+        serverProxy.shutDownMember();
       } else {
-        final ServerLauncher serverLauncher =
-            new ServerLauncher.Builder().setCommand(ServerLauncher.Command.STOP)
-                .setDebug(isDebugging()).setPid(pid).setWorkingDirectory(workingDirectory).build();
-
-        serverState = serverLauncher.status();
-        serverLauncher.stop();
+        return ResultBuilder.createUserErrorResult(CliStrings
+            .format(CliStrings.STOP_SERVER__NO_SERVER_FOUND_FOR_MEMBER_ERROR_MESSAGE, member));
       }
 
-      if (AbstractLauncher.Status.ONLINE.equals(serverState.getStatus())) {
-        getGfsh().logInfo(
-            String.format(CliStrings.STOP_SERVER__STOPPING_SERVER_MESSAGE,
-                serverState.getWorkingDirectory(), serverState.getServiceLocation(),
-                serverState.getMemberName(), serverState.getPid(), serverState.getLogFile()),
-            null);
-
-        StopWatch stopWatch = new StopWatch(true);
-        while (serverState.isVmWithProcessIdRunning()) {
-          Gfsh.print(".");
-          if (stopWatch.elapsedTimeMillis() > WAITING_FOR_STOP_TO_MAKE_PID_GO_AWAY_TIMEOUT_MILLIS) {
-            break;
-          }
-          synchronized (this) {
-            TimeUnit.MILLISECONDS.timedWait(this, 500);
-          }
-        }
+    } else {
+      final ServerLauncher serverLauncher =
+          new ServerLauncher.Builder().setCommand(ServerLauncher.Command.STOP)
+              .setDebug(isDebugging()).setPid(pid).setWorkingDirectory(workingDirectory).build();
 
-        return ResultBuilder.createInfoResult(StringUtils.EMPTY);
-      } else {
-        return ResultBuilder.createUserErrorResult(serverState.toString());
+      serverState = serverLauncher.status();
+      serverLauncher.stop();
+    }
+
+    if (AbstractLauncher.Status.ONLINE.equals(serverState.getStatus())) {
+      getGfsh().logInfo(
+          String.format(CliStrings.STOP_SERVER__STOPPING_SERVER_MESSAGE,
+              serverState.getWorkingDirectory(), serverState.getServiceLocation(),
+              serverState.getMemberName(), serverState.getPid(), serverState.getLogFile()),
+          null);
+
+      StopWatch stopWatch = new StopWatch(true);
+      while (serverState.isVmWithProcessIdRunning()) {
+        Gfsh.print(".");
+        if (stopWatch.elapsedTimeMillis() > WAITING_FOR_STOP_TO_MAKE_PID_GO_AWAY_TIMEOUT_MILLIS) {
+          break;
+        }
+        synchronized (this) {
+          TimeUnit.MILLISECONDS.timedWait(this, 500);
+        }
       }
-    } catch (IllegalArgumentException | IllegalStateException e) {
-      return ResultBuilder.createUserErrorResult(e.getMessage());
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      return ResultBuilder.createShellClientErrorResult(String.format(
-          CliStrings.STOP_SERVER__GENERAL_ERROR_MESSAGE, toString(t, getGfsh().getDebug())));
-    } finally {
-      Gfsh.redirectInternalJavaLoggers();
+
+      return ResultBuilder.createInfoResult(StringUtils.EMPTY);
+    } else {
+      return ResultBuilder.createUserErrorResult(serverState.toString());
     }
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/CreateSubregionException.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/EntityNotFoundException.java
similarity index 63%
rename from geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/CreateSubregionException.java
rename to geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/EntityNotFoundException.java
index 9aaf247741..3f4f173fd6 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/CreateSubregionException.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/EntityNotFoundException.java
@@ -12,27 +12,35 @@
  * or implied. See the License for the specific language governing permissions and limitations under
  * the License.
  */
+
 package org.apache.geode.management.internal.cli.exceptions;
 
-/**
- * Indicates inability to create a Subregion of a region.
- *
- * @since GemFire 8.0
- */
-// TODO - Abhishek - Include in GemFire Exception Enhancements
-public class CreateSubregionException extends RuntimeException {
+import org.apache.geode.GemFireException;
 
-  private static final long serialVersionUID = 4387344870743824916L;
+public class EntityNotFoundException extends GemFireException {
 
-  public CreateSubregionException(String message, Throwable cause) {
-    super(message, cause);
+  private boolean statusOK;
+
+  public EntityNotFoundException() {}
+
+  public EntityNotFoundException(String message) {
+    super(message);
   }
 
-  public CreateSubregionException(String message) {
+  public EntityNotFoundException(String message, boolean statusOK) {
     super(message);
+    this.statusOK = statusOK;
   }
 
-  public CreateSubregionException(Throwable cause) {
+  public EntityNotFoundException(Throwable cause) {
     super(cause);
   }
+
+  public EntityNotFoundException(String message, Throwable cause) {
+    super(message, cause);
+  }
+
+  public boolean isStatusOK() {
+    return statusOK;
+  }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/IndexNotFoundException.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/IndexNotFoundException.java
deleted file mode 100644
index 402285bddf..0000000000
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/exceptions/IndexNotFoundException.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-package org.apache.geode.management.internal.cli.exceptions;
-
-import org.apache.geode.management.internal.cli.i18n.CliStrings;
-
-public class IndexNotFoundException extends Exception {
-
-  private static final long serialVersionUID = 1L;
-  final String indexName;
-  final String message;
-
-  public IndexNotFoundException(final String indexName) {
-    this.indexName = indexName;
-    this.message = CliStrings.format("Index \" {0} \" not found", indexName);
-  }
-
-  public String getMessage() {
-    return this.message;
-  }
-}
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/DescribeDiskStoreFunction.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/DescribeDiskStoreFunction.java
index 1bbc3b52fb..f8668c074e 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/DescribeDiskStoreFunction.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/DescribeDiskStoreFunction.java
@@ -40,7 +40,7 @@
 import org.apache.geode.internal.logging.LogService;
 import org.apache.geode.internal.util.ArrayUtils;
 import org.apache.geode.management.internal.cli.domain.DiskStoreDetails;
-import org.apache.geode.management.internal.cli.util.DiskStoreNotFoundException;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
 
 /**
  * The DescribeDiskStoreFunction class is an implementation of a GemFire Function used to collect
@@ -120,7 +120,7 @@ public void execute(final FunctionContext context) {
           context.getResultSender().lastResult(diskStoreDetails);
         } else {
           context.getResultSender()
-              .sendException(new DiskStoreNotFoundException(
+              .sendException(new EntityNotFoundException(
                   String.format("A disk store with name (%1$s) was not found on member (%2$s).",
                       diskStoreName, memberName)));
         }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/RegionCreateFunction.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/RegionCreateFunction.java
index e524c2de50..55344d4e74 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/RegionCreateFunction.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/RegionCreateFunction.java
@@ -44,7 +44,6 @@
 import org.apache.geode.internal.logging.LogService;
 import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.commands.RegionCommandsUtils;
-import org.apache.geode.management.internal.cli.exceptions.CreateSubregionException;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.util.RegionPath;
 import org.apache.geode.management.internal.configuration.domain.XmlEntity;
@@ -105,7 +104,7 @@ public void execute(FunctionContext context) {
                 new Object[] {String.valueOf(RegionCommandsUtils.PERSISTENT_OVERFLOW_SHORTCUTS)});
       }
       resultSender.lastResult(handleException(memberNameOrId, exceptionMsg, null/* do not log */));
-    } catch (IllegalArgumentException | CreateSubregionException e) {
+    } catch (IllegalArgumentException e) {
       resultSender.lastResult(handleException(memberNameOrId, e.getMessage(), e));
     } catch (RegionExistsException e) {
       String exceptionMsg =
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/RegionDestroyFunction.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/RegionDestroyFunction.java
index d7cf09152b..1aae3383a4 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/RegionDestroyFunction.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/RegionDestroyFunction.java
@@ -20,7 +20,6 @@
 import org.apache.geode.cache.execute.FunctionContext;
 import org.apache.geode.internal.InternalEntity;
 import org.apache.geode.internal.cache.xmlcache.CacheXml;
-import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.configuration.domain.XmlEntity;
 
 /**
@@ -44,29 +43,35 @@ public void execute(FunctionContext context) {
     String regionPath = null;
     try {
       String functionId = context.getFunctionId();
-      if (getId().equals(functionId)) {
-        Object arguments = context.getArguments();
-        if (arguments != null) {
-          regionPath = (String) arguments;
-          Cache cache = context.getCache();
-          Region<?, ?> region = cache.getRegion(regionPath);
-          region.destroyRegion();
-          String regionName =
-              regionPath.startsWith(Region.SEPARATOR) ? regionPath.substring(1) : regionPath;
-          XmlEntity xmlEntity = new XmlEntity(CacheXml.REGION, "name", regionName);
-          context.getResultSender().lastResult(new CliFunctionResult("", xmlEntity, regionPath));
-        }
+      Object arguments = context.getArguments();
+
+      if (!getId().equals(functionId) || arguments == null) {
+        context.getResultSender().lastResult(new CliFunctionResult("", false,
+            "Function Id mismatch or arguments is not available."));
+        return;
+      }
+
+      regionPath = (String) arguments;
+      Cache cache = context.getCache();
+      Region<?, ?> region = cache.getRegion(regionPath);
+      // if the region is a distributed region, and is already destroyed by another member
+      if (region == null) {
+        context.getResultSender().lastResult(new CliFunctionResult("", true, "SUCCESS"));
+        return;
       }
-      context.getResultSender().lastResult(new CliFunctionResult("", false, "FAILURE"));
-    } catch (IllegalStateException e) {
-      context.getResultSender().lastResult(new CliFunctionResult("", e, null));
+
+      region.destroyRegion();
+      String regionName =
+          regionPath.startsWith(Region.SEPARATOR) ? regionPath.substring(1) : regionPath;
+      XmlEntity xmlEntity = new XmlEntity(CacheXml.REGION, "name", regionName);
+      context.getResultSender().lastResult(new CliFunctionResult("", xmlEntity, regionPath));
+
+    } catch (IllegalStateException ex) {
+      // user is trying to destroy something that can't destroyed.
+      context.getResultSender().lastResult(new CliFunctionResult("", false, ex.getMessage()));
     } catch (Exception ex) {
       context.getResultSender()
-          .lastResult(new CliFunctionResult("",
-              new RuntimeException(CliStrings.format(
-                  CliStrings.DESTROY_REGION__MSG__ERROR_WHILE_DESTROYING_REGION_0_REASON_1,
-                  new Object[] {regionPath, ex.getMessage()})),
-              null));
+          .lastResult(new CliFunctionResult("", ex, "failed to destroy " + regionPath));
     }
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/CommandExecutor.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/CommandExecutor.java
index c664a58c95..d4f52187b8 100755
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/CommandExecutor.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/CommandExecutor.java
@@ -18,7 +18,9 @@
 import org.springframework.shell.event.ParseResult;
 import org.springframework.util.ReflectionUtils;
 
+import org.apache.geode.SystemFailure;
 import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
 import org.apache.geode.management.internal.cli.exceptions.UserErrorException;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
 import org.apache.geode.security.NotAuthorizedException;
@@ -40,16 +42,45 @@ public Object execute(ParseResult parseResult) {
         return ResultBuilder.createGemFireErrorResult("Command returned null: " + parseResult);
       }
       return result;
-    } catch (NotAuthorizedException e) {
+    }
+
+    // for Authorization Exception, we need to throw them for higher level code to catch
+    catch (NotAuthorizedException e) {
       logger.error("Not authorized to execute \"" + parseResult + "\".", e);
       throw e;
-    } catch (UserErrorException e) {
+    }
+
+    // for these exceptions, needs to create a UserErrorResult (still reported as error by gfsh)
+    // no need to log since this is a user error
+    catch (UserErrorException | IllegalStateException | IllegalArgumentException e) {
       return ResultBuilder.createUserErrorResult(e.getMessage());
-    } catch (Exception e) {
+    }
+
+    // if entity not found, depending on the thrower's intention, report either as success or error
+    // no need to log since this is a user error
+    catch (EntityNotFoundException e) {
+      if (e.isStatusOK()) {
+        return ResultBuilder.createInfoResult("Skipping: " + e.getMessage());
+      } else {
+        return ResultBuilder.createUserErrorResult(e.getMessage());
+      }
+    }
+
+    // all other exceptions, log it and build an error result.
+    catch (Exception e) {
       logger.error("Could not execute \"" + parseResult + "\".", e);
       return ResultBuilder.createGemFireErrorResult(
           "Error while processing command <" + parseResult + "> Reason : " + e.getMessage());
     }
+
+    // for errors more lower-level than Exception, just throw them.
+    catch (VirtualMachineError e) {
+      SystemFailure.initiateFailure(e);
+      throw e;
+    } catch (Throwable t) {
+      SystemFailure.checkFailure();
+      throw t;
+    }
   }
 
   protected Object invokeCommand(ParseResult parseResult) {
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/util/DiskStoreNotFoundException.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/util/DiskStoreNotFoundException.java
deleted file mode 100644
index 1887f8842a..0000000000
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/util/DiskStoreNotFoundException.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.apache.geode.management.internal.cli.util;
-
-import org.apache.geode.GemFireException;
-
-/**
- * The DiskStoreNotFoundException is a GemFireException class indicating that a disk store by name
- * could not be found on a member specified by name!
- * </p>
- *
- * @see org.apache.geode.GemFireException
- * @since GemFire 7.0
- */
-// TODO this GemFireException should be moved to a more appropriate package!
-@SuppressWarnings("unused")
-public class DiskStoreNotFoundException extends GemFireException {
-  private static final long serialVersionUID = -5184836041554948093L;
-
-  public DiskStoreNotFoundException() {}
-
-  public DiskStoreNotFoundException(final String message) {
-    super(message);
-  }
-
-  public DiskStoreNotFoundException(final Throwable cause) {
-    super(cause);
-  }
-
-  public DiskStoreNotFoundException(final String message, final Throwable cause) {
-    super(message, cause);
-  }
-
-}
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/util/MemberNotFoundException.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/util/MemberNotFoundException.java
deleted file mode 100644
index 4a2ec4b9a2..0000000000
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/util/MemberNotFoundException.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package org.apache.geode.management.internal.cli.util;
-
-import org.apache.geode.management.internal.cli.exceptions.UserErrorException;
-
-/**
- * The MemberNotFoundException is a GemFirException indicating that a member by name could not be
- * found in the GemFire distributed system.
- * </p>
- *
- * @see org.apache.geode.GemFireException
- * @since GemFire 7.0
- */
-// TODO this GemFireException should be moved to a more appropriate package!
-@SuppressWarnings("unused")
-public class MemberNotFoundException extends UserErrorException {
-  private static final long serialVersionUID = 5686788909239181174L;
-
-  public MemberNotFoundException() {}
-
-  public MemberNotFoundException(final String message) {
-    super(message);
-  }
-
-  public MemberNotFoundException(final Throwable cause) {
-    super(cause);
-  }
-
-  public MemberNotFoundException(final String message, final Throwable cause) {
-    super(message, cause);
-  }
-
-}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java
index c5c3ee0e32..cf85a8a39b 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java
@@ -19,7 +19,6 @@
 
 import java.io.IOException;
 
-import org.junit.After;
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.ClassRule;
@@ -63,15 +62,6 @@ public void before() throws Exception {
     gfsh.connectAndVerify(locator);
   }
 
-  @After
-  public void after() throws Exception {
-    // destroy regions
-    gfsh.execute("destroy region --name=/Customer --if-exists");
-    gfsh.execute("destroy region --name=/Order --if-exists");
-    gfsh.execute("destroy region --name=/Customer_2 --if-exists");
-    gfsh.execute("destroy region --name=/Customer_3 --if-exists");
-  }
-
   @Test
   public void testDestroyDistributedRegion() {
     MemberVM.invokeInEveryMember(() -> {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandTest.java
index b519c8d423..0970d1a373 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandTest.java
@@ -16,21 +16,32 @@
 package org.apache.geode.management.internal.cli.commands;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
+import java.util.ArrayList;
 import java.util.Collections;
+import java.util.List;
+import java.util.Set;
 
 import org.junit.Before;
 import org.junit.ClassRule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
+import org.apache.geode.cache.execute.ResultCollector;
+import org.apache.geode.distributed.DistributedMember;
 import org.apache.geode.internal.cache.InternalCache;
 import org.apache.geode.management.cli.Result;
+import org.apache.geode.management.internal.cli.functions.CliFunctionResult;
 import org.apache.geode.management.internal.cli.result.CommandResult;
+import org.apache.geode.management.internal.configuration.domain.XmlEntity;
 import org.apache.geode.test.junit.categories.UnitTest;
 import org.apache.geode.test.junit.rules.GfshParserRule;
 
@@ -42,11 +53,22 @@
 
   private DestroyRegionCommand command;
   private CommandResult result;
+  private CliFunctionResult result1, result2;
 
   @Before
   public void before() throws Exception {
     command = spy(DestroyRegionCommand.class);
     doReturn(mock(InternalCache.class)).when(command).getCache();
+
+    ResultCollector collector = mock(ResultCollector.class);
+    doReturn(collector).when(command).executeFunction(any(), any(), any(Set.class));
+
+    List<CliFunctionResult> functionResults = new ArrayList<>();
+    doReturn(functionResults).when(collector).getResult();
+    result1 = mock(CliFunctionResult.class);
+    result2 = mock(CliFunctionResult.class);
+    functionResults.add(result1);
+    functionResults.add(result2);
   }
 
   @Test
@@ -73,4 +95,45 @@ public void whenNoRegionIsFoundOnAnyMembers() throws Exception {
     result = parser.executeCommandWithInstance(command, "destroy region --name=test --if-exists");
     assertThat(result.getStatus()).isEqualTo(Result.Status.OK);
   }
+
+  @Test
+  public void multipleResultReturnedWithOneError() throws Exception {
+    // mock this to pass the member search call
+    doReturn(Collections.singleton(DistributedMember.class)).when(command)
+        .findMembersForRegion(any(), any());
+    when(result1.isSuccessful()).thenReturn(true);
+    when(result1.getMessage()).thenReturn("result1 message");
+    when(result1.getXmlEntity()).thenReturn(mock(XmlEntity.class));
+
+    when(result2.isSuccessful()).thenReturn(false);
+    when(result2.getMessage()).thenReturn("result2 message");
+
+    result = parser.executeCommandWithInstance(command, "destroy region --name=test");
+    assertThat(result.getStatus()).isEqualTo(Result.Status.ERROR);
+    assertThat(result.getContent().toString()).contains("result2 message");
+
+
+    // verify that xmlEntiry returned by the result1 is not saved to Cluster config
+    verify(command, never()).persistClusterConfiguration(any(), any());
+  }
+
+  @Test
+  public void multipleResultReturnedWithOneException() throws Exception {
+    // mock this to pass the member search call
+    doReturn(Collections.singleton(DistributedMember.class)).when(command)
+        .findMembersForRegion(any(), any());
+    when(result1.isSuccessful()).thenReturn(true);
+    when(result1.getMessage()).thenReturn("result1 message");
+    when(result1.getXmlEntity()).thenReturn(mock(XmlEntity.class));
+
+    when(result2.isSuccessful()).thenReturn(false);
+    when(result2.getThrowable()).thenReturn(new IllegalArgumentException("something happened"));
+
+    assertThatThrownBy(
+        () -> parser.executeCommandWithInstance(command, "destroy region --name=test"))
+            .isInstanceOf(IllegalArgumentException.class);
+
+    // verify that xmlEntiry returned by the result1 is not saved to Cluster config
+    verify(command, never()).persistClusterConfiguration(any(), any());
+  }
 }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsJUnitTest.java
index f5eb7800f3..eb15d05320 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsJUnitTest.java
@@ -43,10 +43,10 @@
 import org.apache.geode.internal.cache.execute.AbstractExecution;
 import org.apache.geode.internal.util.CollectionUtils;
 import org.apache.geode.management.internal.cli.domain.DiskStoreDetails;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
 import org.apache.geode.management.internal.cli.functions.DescribeDiskStoreFunction;
 import org.apache.geode.management.internal.cli.functions.ListDiskStoresFunction;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
-import org.apache.geode.management.internal.cli.util.DiskStoreNotFoundException;
 import org.apache.geode.test.junit.categories.UnitTest;
 
 /**
@@ -142,8 +142,8 @@ public void testGetDiskStoreDescription() {
     assertEquals(expectedDiskStoredDetails, actualDiskStoreDetails);
   }
 
-  @Test(expected = DiskStoreNotFoundException.class)
-  public void testGetDiskStoreDescriptionThrowsDiskStoreNotFoundException() {
+  @Test(expected = EntityNotFoundException.class)
+  public void testGetDiskStoreDescriptionThrowsEntityNotFoundException() {
     final String diskStoreName = "mockDiskStore";
     final String memberId = "mockMember";
 
@@ -159,7 +159,7 @@ public void testGetDiskStoreDescriptionThrowsDiskStoreNotFoundException() {
         oneOf(mockFunctionExecutor).setArguments(with(equal(diskStoreName)));
         will(returnValue(mockFunctionExecutor));
         oneOf(mockFunctionExecutor).execute(with(aNonNull(DescribeDiskStoreFunction.class)));
-        will(throwException(new DiskStoreNotFoundException("expected")));
+        will(throwException(new EntityNotFoundException("expected")));
       }
     });
 
@@ -168,7 +168,7 @@ public void testGetDiskStoreDescriptionThrowsDiskStoreNotFoundException() {
 
     try {
       describeCommand.getDiskStoreDescription(memberId, diskStoreName);
-    } catch (DiskStoreNotFoundException expected) {
+    } catch (EntityNotFoundException expected) {
       assertEquals("expected", expected.getMessage());
       throw expected;
     }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommandTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommandTest.java
index 9c5d030a95..03a05a7fb9 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommandTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsCommandTest.java
@@ -14,7 +14,10 @@
  */
 package org.apache.geode.management.internal.cli.commands;
 
-import static org.apache.geode.management.internal.cli.commands.ExportLogsCommand.*;
+import static org.apache.geode.management.internal.cli.commands.ExportLogsCommand.GIGABYTE;
+import static org.apache.geode.management.internal.cli.commands.ExportLogsCommand.KILOBYTE;
+import static org.apache.geode.management.internal.cli.commands.ExportLogsCommand.MEGABYTE;
+import static org.apache.geode.management.internal.cli.commands.ExportLogsCommand.TERABYTE;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.mockito.Matchers.eq;
@@ -179,7 +182,7 @@ public void testTotalEstimateSizeExceedsLocatorAvailableDisk() throws Exception
     testResults2.addResult(member2, 60 * MEGABYTE);
 
     doReturn(mockCache).when(spyCmd).getCache();
-    doReturn(testMembers).when(spyCmd).getMembers(null, null);
+    doReturn(testMembers).when(spyCmd).getMembersIncludingLocators(null, null);
     doReturn(testResults1).when(spyCmd)
         .estimateLogSize(Matchers.any(SizeExportLogsFunction.Args.class), eq(member1));
     doReturn(testResults2).when(spyCmd)
@@ -220,7 +223,7 @@ public void testTotalEstimateSizeExceedsUserSpecifiedValue() throws Exception {
     testResults2.addResult(member2, 60 * MEGABYTE);
 
     doReturn(mockCache).when(spyCmd).getCache();
-    doReturn(testMembers).when(spyCmd).getMembers(null, null);
+    doReturn(testMembers).when(spyCmd).getMembersIncludingLocators(null, null);
     doReturn(testResults1).when(spyCmd)
         .estimateLogSize(Matchers.any(SizeExportLogsFunction.Args.class), eq(member1));
     doReturn(testResults2).when(spyCmd)
@@ -261,7 +264,7 @@ public void estimateLogSizeExceedsServerDisk() throws Exception {
     testResults1.addResult(member1, new ManagementException(sb.toString()));
 
     doReturn(mockCache).when(spyCmd).getCache();
-    doReturn(testMembers).when(spyCmd).getMembers(null, null);
+    doReturn(testMembers).when(spyCmd).getMembersIncludingLocators(null, null);
     doReturn(testResults1).when(spyCmd)
         .estimateLogSize(Matchers.any(SizeExportLogsFunction.Args.class), eq(member1));
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GfshCommandJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GfshCommandJUnitTest.java
index 27c41427cc..a2ee67e503 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GfshCommandJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GfshCommandJUnitTest.java
@@ -14,441 +14,87 @@
  */
 package org.apache.geode.management.internal.cli.commands;
 
-import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_BIND_ADDRESS;
-import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_PORT;
-import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;
-import static org.apache.geode.distributed.ConfigurationProperties.LOG_FILE;
-import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;
-import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;
-import static org.apache.geode.distributed.ConfigurationProperties.NAME;
-import static org.apache.geode.distributed.ConfigurationProperties.START_DEV_REST_API;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
 
-import java.io.File;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Properties;
+import java.util.Collections;
 
-import org.jmock.Expectations;
-import org.jmock.Mockery;
-import org.jmock.lib.concurrent.Synchroniser;
-import org.jmock.lib.legacy.ClassImposteriser;
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
-import org.apache.geode.cache.execute.Function;
-import org.apache.geode.cache.execute.FunctionService;
-import org.apache.geode.distributed.DistributedMember;
-import org.apache.geode.distributed.internal.DistributionConfig;
-import org.apache.geode.internal.cache.InternalCache;
-import org.apache.geode.internal.lang.StringUtils;
-import org.apache.geode.management.cli.CliMetaData;
+import org.apache.geode.distributed.internal.ClusterConfigurationService;
+import org.apache.geode.management.cli.Result;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
+import org.apache.geode.management.internal.cli.result.ResultBuilder;
+import org.apache.geode.management.internal.cli.shell.Gfsh;
 import org.apache.geode.test.junit.categories.UnitTest;
 
-/**
- * The GfshCommandJUnitTest class is a test suite of test cases testing the contract and
- * functionality of the GfshCommand class for implementing GemFire shell (Gfsh) commands.
- *
- * @see GfshCommand
- * @see org.jmock.Expectations
- * @see org.jmock.Mockery
- * @see org.jmock.lib.legacy.ClassImposteriser
- * @see org.junit.Assert
- * @see org.junit.Test
- * @since GemFire 7.0
- */
 @Category(UnitTest.class)
 public class GfshCommandJUnitTest {
 
-  private Mockery mockContext;
-
-  private static <T extends Function> T register(T function) {
-    if (FunctionService.isRegistered(function.getId())) {
-      function = (T) FunctionService.getFunction(function.getId());
-    } else {
-      FunctionService.registerFunction(function);
-    }
-
-    return function;
-  }
-
-  private static class DefaultGfshCommand implements GfshCommand {
-  }
-
-  private DefaultGfshCommand defaultGfshCommand;
+  private GfshCommand command;
+  private Gfsh gfsh;
+  private ClusterConfigurationService clusterConfigurationService;
 
   @Before
-  public void setup() {
-    mockContext = new Mockery();
-    mockContext.setImposteriser(ClassImposteriser.INSTANCE);
-    mockContext.setThreadingPolicy(new Synchroniser());
-
-    defaultGfshCommand = new DefaultGfshCommand();
-  }
-
-  @After
-  public void tearDown() {
-    mockContext.assertIsSatisfied();
-    mockContext = null;
-  }
-
-  private GfshCommand createAbstractCommandsSupport(final InternalCache cache) {
-    return new TestCommands(cache);
-  }
-
-  private DistributedMember createMockMember(final String memberId, final String memberName) {
-    final DistributedMember mockMember =
-        mockContext.mock(DistributedMember.class, "DistributedMember " + memberId);
-
-    mockContext.checking(new Expectations() {
-      {
-        allowing(mockMember).getName();
-        will(returnValue(memberName));
-        allowing(mockMember).getId();
-        will(returnValue(memberId));
-      }
-    });
-
-    return mockMember;
-  }
-
-  @Test
-  public void testConvertDefaultValue() {
-    assertNull(defaultGfshCommand.convertDefaultValue(null, StringUtils.EMPTY));
-    assertEquals(StringUtils.EMPTY,
-        defaultGfshCommand.convertDefaultValue(StringUtils.EMPTY, "test"));
-    assertEquals(StringUtils.SPACE,
-        defaultGfshCommand.convertDefaultValue(StringUtils.SPACE, "testing"));
-    assertEquals("tested",
-        defaultGfshCommand.convertDefaultValue(CliMetaData.ANNOTATION_DEFAULT_VALUE, "tested"));
+  public void before() throws Exception {
+    command = spy(GfshCommand.class);
+    gfsh = mock(Gfsh.class);
+    clusterConfigurationService = mock(ClusterConfigurationService.class);
   }
 
   @Test
-  public void testRegister() {
-    try {
-      final Function mockFunction = mockContext.mock(Function.class, "Function");
-
-      mockContext.checking(new Expectations() {
-        {
-          exactly(3).of(mockFunction).getId();
-          will(returnValue("testRegister"));
-          oneOf(mockFunction).isHA();
-          will(returnValue(true));
-          oneOf(mockFunction).hasResult();
-          will(returnValue(true));
-        }
-      });
+  public void isConnectedAndReady() throws Exception {
+    when(command.getGfsh()).thenReturn(null);
+    assertThat(command.isConnectedAndReady()).isFalse();
 
-      final GfshCommand commands =
-          createAbstractCommandsSupport(mockContext.mock(InternalCache.class));
+    when(command.getGfsh()).thenReturn(gfsh);
+    when(gfsh.isConnectedAndReady()).thenReturn(false);
+    assertThat(command.isConnectedAndReady()).isFalse();
 
-      assertFalse(FunctionService.isRegistered("testRegister"));
-      assertSame(mockFunction, register(mockFunction));
-      assertTrue(FunctionService.isRegistered("testRegister"));
-    } finally {
-      FunctionService.unregisterFunction("testRegister");
-    }
+    when(command.getGfsh()).thenReturn(gfsh);
+    when(gfsh.isConnectedAndReady()).thenReturn(true);
+    assertThat(command.isConnectedAndReady()).isTrue();
   }
 
   @Test
-  public void testRegisteredAlready() {
-    try {
-      final Function registeredFunction = mockContext.mock(Function.class, "Registered Function");
-      final Function unregisteredFunction =
-          mockContext.mock(Function.class, "Unregistered Function");
-
-      mockContext.checking(new Expectations() {
-        {
-          exactly(2).of(registeredFunction).getId();
-          will(returnValue("testRegisteredAlready"));
-          oneOf(registeredFunction).isHA();
-          will(returnValue(false));
-          exactly(2).of(unregisteredFunction).getId();
-          will(returnValue("testRegisteredAlready"));
-        }
-      });
-
-      final GfshCommand commands =
-          createAbstractCommandsSupport(mockContext.mock(InternalCache.class));
-
-      FunctionService.registerFunction(registeredFunction);
+  public void persistClusterConfiguration() throws Exception {
+    when(command.getSharedConfiguration()).thenReturn(null);
+    Result result = ResultBuilder.createInfoResult("info");
+    Runnable runnable = mock(Runnable.class);
 
-      assertTrue(FunctionService.isRegistered("testRegisteredAlready"));
-      assertSame(registeredFunction, register(unregisteredFunction));
-      assertTrue(FunctionService.isRegistered("testRegisteredAlready"));
-    } finally {
-      FunctionService.unregisterFunction("testRegisteredAlready");
-    }
-  }
+    command.persistClusterConfiguration(result, runnable);
+    assertThat(result.failedToPersist()).isTrue();
 
-  @Test
-  public void testToStringOnBoolean() {
-    assertEquals("false", defaultGfshCommand.toString(null, null, null));
-    assertEquals("true", defaultGfshCommand.toString(true, null, null));
-    assertEquals("true", defaultGfshCommand.toString(Boolean.TRUE, null, null));
-    assertEquals("false", defaultGfshCommand.toString(false, null, null));
-    assertEquals("false", defaultGfshCommand.toString(Boolean.FALSE, null, null));
-    assertEquals("false", defaultGfshCommand.toString(true, "false", "true"));
-    assertEquals("true", defaultGfshCommand.toString(false, "false", "true"));
-    assertEquals("Yes", defaultGfshCommand.toString(true, "Yes", "No"));
-    assertEquals("Yes", defaultGfshCommand.toString(false, "No", "Yes"));
-    assertEquals("TRUE", defaultGfshCommand.toString(Boolean.TRUE, "TRUE", "FALSE"));
-    assertEquals("FALSE", defaultGfshCommand.toString(Boolean.FALSE, "TRUE", "FALSE"));
+    when(command.getSharedConfiguration()).thenReturn(clusterConfigurationService);
+    command.persistClusterConfiguration(result, runnable);
+    assertThat(result.failedToPersist()).isFalse();
   }
 
   @Test
-  public void testToStringOnThrowable() {
-    assertEquals("test", defaultGfshCommand.toString(new Throwable("test"), false));
+  public void getMember() throws Exception {
+    doReturn(null).when(command).findMember("test");
+    assertThatThrownBy(() -> command.getMember("test")).isInstanceOf(EntityNotFoundException.class);
   }
 
   @Test
-  public void testToStringOnThrowablePrintingStackTrace() {
-    final StringWriter writer = new StringWriter();
-    final Throwable t = new Throwable("test");
-
-    t.printStackTrace(new PrintWriter(writer));
-
-    assertEquals(writer.toString(), defaultGfshCommand.toString(t, true));
-  }
-
-  private static class TestCommands implements GfshCommand {
-
-    private final InternalCache cache;
-
-    protected TestCommands(final InternalCache cache) {
-      assert cache != null : "The InternalCache cannot be null!";
-      this.cache = cache;
-    }
-
-    @Override
-    public InternalCache getCache() {
-      return this.cache;
-    }
-  }
-
-  @Test
-  public void testAddGemFirePropertyFileToCommandLine() {
-    List<String> commandLine = new ArrayList<>();
-    assertTrue(commandLine.isEmpty());
-
-    StartMemberUtils.addGemFirePropertyFile(commandLine, null);
-    assertTrue(commandLine.isEmpty());
-
-    File file = new File("/path/to/gemfire.properties");
-    StartMemberUtils.addGemFirePropertyFile(commandLine, file);
-    assertFalse(commandLine.isEmpty());
-    assertTrue(commandLine.contains("-DgemfirePropertyFile=" + file.getAbsolutePath()));
+  public void getMembers() throws Exception {
+    String[] members = {"member"};
+    doReturn(Collections.emptySet()).when(command).findMembers(members, null);
+    assertThatThrownBy(() -> command.getMembers(members, null))
+        .isInstanceOf(EntityNotFoundException.class);
   }
 
   @Test
-  public void testAddGemFireSystemPropertiesToCommandLine() {
-    final List<String> commandLine = new ArrayList<>();
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addGemFireSystemProperties(commandLine, new Properties());
-    assertTrue(commandLine.isEmpty());
-
-    final Properties gemfireProperties = new Properties();
-    gemfireProperties.setProperty(LOCATORS, "localhost[11235]");
-    gemfireProperties.setProperty(LOG_LEVEL, "config");
-    gemfireProperties.setProperty(LOG_FILE, org.apache.commons.lang.StringUtils.EMPTY);
-    gemfireProperties.setProperty(MCAST_PORT, "0");
-    gemfireProperties.setProperty(NAME, "machine");
-    StartMemberUtils.addGemFireSystemProperties(commandLine, gemfireProperties);
-
-    assertFalse(commandLine.isEmpty());
-    assertEquals(4, commandLine.size());
-
-    for (final String propertyName : gemfireProperties.stringPropertyNames()) {
-      final String propertyValue = gemfireProperties.getProperty(propertyName);
-      if (org.apache.commons.lang.StringUtils.isBlank(propertyValue)) {
-        for (final String systemProperty : commandLine) {
-          assertFalse(systemProperty.startsWith(
-              "-D" + DistributionConfig.GEMFIRE_PREFIX + "".concat(propertyName).concat("=")));
-        }
-      } else {
-        assertTrue(commandLine.contains("-D" + DistributionConfig.GEMFIRE_PREFIX
-            + "".concat(propertyName).concat("=").concat(propertyValue)));
-      }
-    }
-  }
-
-  @Test
-  public void testAddGemFireSystemPropertiesToCommandLineWithRestAPI() {
-    final List<String> commandLine = new ArrayList<>();
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addGemFireSystemProperties(commandLine, new Properties());
-    assertTrue(commandLine.isEmpty());
-    final Properties gemfireProperties = new Properties();
-    gemfireProperties.setProperty(LOCATORS, "localhost[11235]");
-    gemfireProperties.setProperty(LOG_LEVEL, "config");
-    gemfireProperties.setProperty(LOG_FILE, StringUtils.EMPTY);
-    gemfireProperties.setProperty(MCAST_PORT, "0");
-    gemfireProperties.setProperty(NAME, "machine");
-    gemfireProperties.setProperty(START_DEV_REST_API, "true");
-    gemfireProperties.setProperty(HTTP_SERVICE_PORT, "8080");
-    gemfireProperties.setProperty(HTTP_SERVICE_BIND_ADDRESS, "localhost");
-
-    StartMemberUtils.addGemFireSystemProperties(commandLine, gemfireProperties);
-
-    assertFalse(commandLine.isEmpty());
-    assertEquals(7, commandLine.size());
-
-    for (final String propertyName : gemfireProperties.stringPropertyNames()) {
-      final String propertyValue = gemfireProperties.getProperty(propertyName);
-      if (StringUtils.isBlank(propertyValue)) {
-        for (final String systemProperty : commandLine) {
-          assertFalse(systemProperty.startsWith(
-              "-D" + DistributionConfig.GEMFIRE_PREFIX + "".concat(propertyName).concat("=")));
-        }
-      } else {
-        assertTrue(commandLine.contains("-D" + DistributionConfig.GEMFIRE_PREFIX
-            + "".concat(propertyName).concat("=").concat(propertyValue)));
-      }
-    }
-  }
-
-  @Test
-  public void testAddInitialHeapToCommandLine() {
-    final List<String> commandLine = new ArrayList<>();
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addInitialHeap(commandLine, null);
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addInitialHeap(commandLine, org.apache.commons.lang.StringUtils.EMPTY);
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addInitialHeap(commandLine, " ");
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addInitialHeap(commandLine, "512M");
-    assertFalse(commandLine.isEmpty());
-    assertEquals("-Xms512M", commandLine.get(0));
-  }
-
-  @Test
-  public void testAddJvmArgumentsAndOptionsToCommandLine() {
-    final List<String> commandLine = new ArrayList<>();
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addJvmArgumentsAndOptions(commandLine, null);
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addJvmArgumentsAndOptions(commandLine, new String[] {});
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addJvmArgumentsAndOptions(commandLine,
-        new String[] {"-DmyProp=myVal", "-d64", "-server", "-Xprof"});
-    assertFalse(commandLine.isEmpty());
-    assertEquals(4, commandLine.size());
-    assertEquals("-DmyProp=myVal", commandLine.get(0));
-    assertEquals("-d64", commandLine.get(1));
-    assertEquals("-server", commandLine.get(2));
-    assertEquals("-Xprof", commandLine.get(3));
-  }
-
-  @Test
-  public void testAddMaxHeapToCommandLine() {
-    final List<String> commandLine = new ArrayList<>();
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addMaxHeap(commandLine, null);
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addMaxHeap(commandLine, org.apache.commons.lang.StringUtils.EMPTY);
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addMaxHeap(commandLine, "  ");
-    assertTrue(commandLine.isEmpty());
-    StartMemberUtils.addMaxHeap(commandLine, "1024M");
-    assertFalse(commandLine.isEmpty());
-    assertEquals(3, commandLine.size());
-    assertEquals("-Xmx1024M", commandLine.get(0));
-    assertEquals("-XX:+UseConcMarkSweepGC", commandLine.get(1));
-    assertEquals(
-        "-XX:CMSInitiatingOccupancyFraction=" + StartMemberUtils.CMS_INITIAL_OCCUPANCY_FRACTION,
-        commandLine.get(2));
-  }
-
-  @Test(expected = AssertionError.class)
-  public void testReadPidWithNull() {
-    try {
-      StartMemberUtils.readPid(null);
-    } catch (AssertionError expected) {
-      assertEquals("The file from which to read the process ID (pid) cannot be null!",
-          expected.getMessage());
-      throw expected;
-    }
-  }
-
-  @Test
-  public void testReadPidWithNonExistingFile() {
-    assertEquals(StartMemberUtils.INVALID_PID,
-        StartMemberUtils.readPid(new File("/path/to/non_existing/pid.file")));
-  }
-
-  @Test
-  public void testGetSystemClasspath() {
-    assertEquals(System.getProperty("java.class.path"), StartMemberUtils.getSystemClasspath());
-  }
-
-  @Test
-  public void testToClasspath() {
-    final boolean EXCLUDE_SYSTEM_CLASSPATH = false;
-    final boolean INCLUDE_SYSTEM_CLASSPATH = true;
-    String[] jarFilePathnames =
-        {"/path/to/user/libs/A.jar", "/path/to/user/libs/B.jar", "/path/to/user/libs/C.jar"};
-    String[] userClasspaths = {"/path/to/classes:/path/to/libs/1.jar:/path/to/libs/2.jar",
-        "/path/to/ext/libs/1.jar:/path/to/ext/classes:/path/to/ext/lib/10.jar"};
-    String expectedClasspath = StartMemberUtils.GEODE_JAR_PATHNAME.concat(File.pathSeparator)
-        .concat(toClasspath(userClasspaths)).concat(File.pathSeparator)
-        .concat(toClasspath(jarFilePathnames));
-    assertEquals(expectedClasspath,
-        StartMemberUtils.toClasspath(EXCLUDE_SYSTEM_CLASSPATH, jarFilePathnames, userClasspaths));
-    expectedClasspath = StartMemberUtils.GEODE_JAR_PATHNAME.concat(File.pathSeparator)
-        .concat(toClasspath(userClasspaths)).concat(File.pathSeparator)
-        .concat(System.getProperty("java.class.path")).concat(File.pathSeparator)
-        .concat(toClasspath(jarFilePathnames));
-    assertEquals(expectedClasspath,
-        StartMemberUtils.toClasspath(INCLUDE_SYSTEM_CLASSPATH, jarFilePathnames, userClasspaths));
-    expectedClasspath = StartMemberUtils.GEODE_JAR_PATHNAME.concat(File.pathSeparator)
-        .concat(System.getProperty("java.class.path"));
-    assertEquals(expectedClasspath,
-        StartMemberUtils.toClasspath(INCLUDE_SYSTEM_CLASSPATH, null, (String[]) null));
-    assertEquals(StartMemberUtils.GEODE_JAR_PATHNAME,
-        StartMemberUtils.toClasspath(EXCLUDE_SYSTEM_CLASSPATH, null, (String[]) null));
-    assertEquals(StartMemberUtils.GEODE_JAR_PATHNAME,
-        StartMemberUtils.toClasspath(EXCLUDE_SYSTEM_CLASSPATH, new String[0], ""));
-  }
-
-  @Test
-  public void testToClassPathOrder() {
-    String userClasspathOne = "/path/to/user/lib/a.jar:/path/to/user/classes";
-    String userClasspathTwo =
-        "/path/to/user/lib/x.jar:/path/to/user/lib/y.jar:/path/to/user/lib/z.jar";
-
-    String expectedClasspath = StartMemberUtils.getGemFireJarPath().concat(File.pathSeparator)
-        .concat(userClasspathOne).concat(File.pathSeparator).concat(userClasspathTwo)
-        .concat(File.pathSeparator).concat(System.getProperty("java.class.path"))
-        .concat(File.pathSeparator).concat(StartMemberUtils.CORE_DEPENDENCIES_JAR_PATHNAME)
-        .concat(File.pathSeparator).concat(StartMemberUtils.CORE_DEPENDENCIES_JAR_PATHNAME);
-
-    String actualClasspath =
-        StartMemberUtils.toClasspath(true,
-            new String[] {StartMemberUtils.CORE_DEPENDENCIES_JAR_PATHNAME,
-                StartMemberUtils.CORE_DEPENDENCIES_JAR_PATHNAME},
-            userClasspathOne, userClasspathTwo);
-
-    assertEquals(expectedClasspath, actualClasspath);
-  }
-
-  private String toClasspath(final String... jarFilePathnames) {
-    String classpath = org.apache.commons.lang.StringUtils.EMPTY;
-    if (jarFilePathnames != null) {
-      for (final String jarFilePathname : jarFilePathnames) {
-        classpath +=
-            (classpath.isEmpty() ? org.apache.commons.lang.StringUtils.EMPTY : File.pathSeparator);
-        classpath += jarFilePathname;
-      }
-    }
-    return classpath;
+  public void getMembersIncludingLocators() throws Exception {
+    String[] members = {"member"};
+    doReturn(Collections.emptySet()).when(command).findMembersIncludingLocators(members, null);
+    assertThatThrownBy(() -> command.getMembersIncludingLocators(members, null))
+        .isInstanceOf(EntityNotFoundException.class);
   }
 }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeDiskStoreCommandsDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeDiskStoreCommandsDUnitTest.java
index bbd0b6cb76..0e9468cc3b 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeDiskStoreCommandsDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeDiskStoreCommandsDUnitTest.java
@@ -20,6 +20,7 @@
 import static org.apache.geode.test.dunit.Host.getHost;
 import static org.apache.geode.test.dunit.LogWriterUtils.getDUnitLogLevel;
 import static org.apache.geode.test.dunit.LogWriterUtils.getLogWriter;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import java.io.Serializable;
 import java.util.Properties;
@@ -100,9 +101,8 @@ public void testDescribeDiskStoreWithInvalidDiskStoreName() {
 
     assertNotNull(commandResult);
     assertEquals(Result.Status.ERROR, commandResult.getStatus());
-    assertEquals(
-        "A disk store with name (badDiskStoreName) was not found on member (producerServer).",
-        toString(commandResult));
+    assertThat(toString(commandResult)).contains(
+        "A disk store with name (badDiskStoreName) was not found on member (producerServer).");
   }
 
   private static String toString(final Result result) {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/DescribeDiskStoreFunctionJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/DescribeDiskStoreFunctionJUnitTest.java
index 23398389e3..cd65dbbf56 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/DescribeDiskStoreFunctionJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/DescribeDiskStoreFunctionJUnitTest.java
@@ -14,8 +14,12 @@
  */
 package org.apache.geode.management.internal.cli.functions;
 
-import static org.assertj.core.api.Assertions.*;
-import static org.junit.Assert.*;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 
 import java.io.File;
 import java.util.Arrays;
@@ -55,7 +59,7 @@
 import org.apache.geode.internal.logging.LogService;
 import org.apache.geode.internal.util.CollectionUtils;
 import org.apache.geode.management.internal.cli.domain.DiskStoreDetails;
-import org.apache.geode.management.internal.cli.util.DiskStoreNotFoundException;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
 import org.apache.geode.test.dunit.IgnoredException;
 import org.apache.geode.test.junit.categories.UnitTest;
 
@@ -610,7 +614,7 @@ public void testExecuteOnMemberHavingANonGemFireCache() throws Throwable {
   }
 
   @Test
-  public void testExecuteThrowingDiskStoreNotFoundException() throws Exception {
+  public void testExecuteThrowingEntityNotFoundException() throws Exception {
     final String diskStoreName = "testDiskStore";
     final String memberId = "mockMemberId";
     final String memberName = "mockMemberName";
@@ -649,7 +653,7 @@ public void testExecuteThrowingDiskStoreNotFoundException() throws Exception {
     String expected = String.format("A disk store with name (%1$s) was not found on member (%2$s).",
         diskStoreName, memberName);
     assertThatThrownBy(() -> testResultSender.getResults())
-        .isInstanceOf(DiskStoreNotFoundException.class).hasMessage(expected);
+        .isInstanceOf(EntityNotFoundException.class).hasMessage(expected);
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/RegionDestroyFunctionTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/RegionDestroyFunctionTest.java
new file mode 100644
index 0000000000..60885099b2
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/RegionDestroyFunctionTest.java
@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.functions;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+import org.mockito.ArgumentCaptor;
+
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.execute.FunctionContext;
+import org.apache.geode.cache.execute.ResultSender;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.test.junit.categories.UnitTest;
+
+
+@Category(UnitTest.class)
+public class RegionDestroyFunctionTest {
+
+  private RegionDestroyFunction function;
+  private FunctionContext context;
+  private InternalCache cache;
+  private ResultSender resultSender;
+  private ArgumentCaptor<CliFunctionResult> resultCaptor;
+
+  @Before
+  public void before() {
+    function = spy(RegionDestroyFunction.class);
+    context = mock(FunctionContext.class);
+    cache = mock(InternalCache.class);
+    resultSender = mock(ResultSender.class);
+    when(context.getCache()).thenReturn(cache);
+    when(context.getResultSender()).thenReturn(resultSender);
+    when(context.getArguments()).thenReturn("testRegion");
+    resultCaptor = ArgumentCaptor.forClass(CliFunctionResult.class);
+  }
+
+  @Test
+  public void functionContextIsWrong() throws Exception {
+    function.execute(context);
+    verify(resultSender).lastResult(resultCaptor.capture());
+    CliFunctionResult result = resultCaptor.getValue();
+
+    assertThat(result.isSuccessful()).isFalse();
+    assertThat(result.getMessage()).contains("Function Id mismatch or arguments is not available");
+  }
+
+  @Test
+  public void regionAlreadyDestroyed() throws Exception {
+    when(context.getFunctionId()).thenReturn(RegionDestroyFunction.class.getName());
+    when(cache.getRegion(any())).thenReturn(null);
+    function.execute(context);
+
+    verify(resultSender).lastResult(resultCaptor.capture());
+    CliFunctionResult result = resultCaptor.getValue();
+
+    assertThat(result.isSuccessful()).isTrue();
+    assertThat(result.getMessage()).contains("SUCCESS");
+  }
+
+  @Test
+  public void illegalStateExceptionWillNotThrowExceptionToCommand() throws Exception {
+    when(context.getFunctionId()).thenReturn(RegionDestroyFunction.class.getName());
+    Region region = mock(Region.class);
+    when(cache.getRegion(any())).thenReturn(region);
+    doThrow(new IllegalStateException("message")).when(region).destroyRegion();
+
+    function.execute(context);
+    verify(resultSender).lastResult(resultCaptor.capture());
+    CliFunctionResult result = resultCaptor.getValue();
+    assertThat(result.isSuccessful()).isFalse();
+    // will not populate the exception in the result, but only preserve the message
+    assertThat(result.getThrowable()).isNull();
+    assertThat(result.getMessage()).isEqualTo("message");
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/remote/CommandExecutorTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/remote/CommandExecutorTest.java
index 3020bc2b23..4f51f25008 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/remote/CommandExecutorTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/remote/CommandExecutorTest.java
@@ -17,7 +17,11 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -25,6 +29,8 @@
 import org.springframework.shell.event.ParseResult;
 
 import org.apache.geode.management.cli.Result;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
+import org.apache.geode.management.internal.cli.exceptions.UserErrorException;
 import org.apache.geode.management.internal.cli.result.CommandResult;
 import org.apache.geode.security.NotAuthorizedException;
 import org.apache.geode.test.junit.categories.UnitTest;
@@ -39,7 +45,7 @@
   public void before() {
     parseResult = mock(ParseResult.class);
     result = mock(Result.class);
-    executor = new CommandExecutor();
+    executor = spy(CommandExecutor.class);
   }
 
 
@@ -52,46 +58,77 @@ public void executeWhenGivenDummyParseResult() throws Exception {
 
   @Test
   public void returnsResultAsExpected() throws Exception {
-    executor = new CommandExecutor() {
-      protected Object invokeCommand(ParseResult parseResult) {
-        return result;
-      }
-    };
+    doReturn(result).when(executor).invokeCommand(any());
     Object thisResult = executor.execute(parseResult);
     assertThat(thisResult).isSameAs(result);
   }
 
   @Test
   public void testNullResult() throws Exception {
-    executor = new CommandExecutor() {
-      protected Object invokeCommand(ParseResult parseResult) {
-        return null;
-      }
-    };
+    doReturn(null).when(executor).invokeCommand(any());
     Object thisResult = executor.execute(parseResult);
     assertThat(thisResult.toString()).contains("Command returned null");
   }
 
   @Test
   public void anyRuntimeExceptionGetsCaught() throws Exception {
-    executor = new CommandExecutor() {
-      protected Object invokeCommand(ParseResult parseResult) {
-        throw new RuntimeException("my message here");
-      }
-    };
+    ;
+    doThrow(new RuntimeException("my message here")).when(executor).invokeCommand(any());
     Object thisResult = executor.execute(parseResult);
+    assertThat(((CommandResult) thisResult).getStatus()).isEqualTo(Result.Status.ERROR);
     assertThat(thisResult.toString()).contains("my message here");
   }
 
   @Test
   public void notAuthorizedExceptionGetsThrown() throws Exception {
-    executor = new CommandExecutor() {
-      protected Object invokeCommand(ParseResult parseResult) {
-        throw new NotAuthorizedException("Not Authorized");
-      }
-    };
+    doThrow(new NotAuthorizedException("Not Authorized")).when(executor).invokeCommand(any());
     assertThatThrownBy(() -> executor.execute(parseResult))
         .isInstanceOf(NotAuthorizedException.class);
+  }
+
+  @Test
+  public void anyIllegalArgumentExceptionGetsCaught() throws Exception {
+    ;
+    doThrow(new IllegalArgumentException("my message here")).when(executor).invokeCommand(any());
+    Object thisResult = executor.execute(parseResult);
+    assertThat(((CommandResult) thisResult).getStatus()).isEqualTo(Result.Status.ERROR);
+    assertThat(thisResult.toString()).contains("my message here");
+  }
 
+  @Test
+  public void anyIllegalStateExceptionGetsCaught() throws Exception {
+    ;
+    doThrow(new IllegalStateException("my message here")).when(executor).invokeCommand(any());
+    Object thisResult = executor.execute(parseResult);
+    assertThat(((CommandResult) thisResult).getStatus()).isEqualTo(Result.Status.ERROR);
+    assertThat(thisResult.toString()).contains("my message here");
+  }
+
+  @Test
+  public void anyUserErrorExceptionGetsCaught() throws Exception {
+    ;
+    doThrow(new UserErrorException("my message here")).when(executor).invokeCommand(any());
+    Object thisResult = executor.execute(parseResult);
+    assertThat(((CommandResult) thisResult).getStatus()).isEqualTo(Result.Status.ERROR);
+    assertThat(thisResult.toString()).contains("my message here");
+  }
+
+  @Test
+  public void anyEntityNotFoundException_statusOK() throws Exception {
+    ;
+    doThrow(new EntityNotFoundException("my message here", true)).when(executor)
+        .invokeCommand(any());
+    Object thisResult = executor.execute(parseResult);
+    assertThat(((CommandResult) thisResult).getStatus()).isEqualTo(Result.Status.OK);
+    assertThat(thisResult.toString()).contains("Skipping: my message here");
+  }
+
+  @Test
+  public void anyEntityNotFoundException_statusERROR() throws Exception {
+    ;
+    doThrow(new EntityNotFoundException("my message here")).when(executor).invokeCommand(any());
+    Object thisResult = executor.execute(parseResult);
+    assertThat(((CommandResult) thisResult).getStatus()).isEqualTo(Result.Status.ERROR);
+    assertThat(thisResult.toString()).contains("my message here");
   }
 }
diff --git a/geode-core/src/test/resources/org/apache/geode/codeAnalysis/sanctionedSerializables.txt b/geode-core/src/test/resources/org/apache/geode/codeAnalysis/sanctionedSerializables.txt
index 37a4224286..f6b4302cdb 100755
--- a/geode-core/src/test/resources/org/apache/geode/codeAnalysis/sanctionedSerializables.txt
+++ b/geode-core/src/test/resources/org/apache/geode/codeAnalysis/sanctionedSerializables.txt
@@ -490,8 +490,7 @@ org/apache/geode/management/internal/cli/domain/RegionDescriptionPerMember,true,
 org/apache/geode/management/internal/cli/domain/RegionInformation,true,1,dataPolicy:org/apache/geode/cache/DataPolicy,isRoot:boolean,name:java/lang/String,parentRegion:java/lang/String,path:java/lang/String,scope:org/apache/geode/cache/Scope,subRegionInformationSet:java/util/Set
 org/apache/geode/management/internal/cli/domain/StackTracesPerMember,true,1,memberNameOrId:java/lang/String,stackTraces:byte[]
 org/apache/geode/management/internal/cli/domain/SubscriptionQueueSizeResult,true,1,subscriptionQueueSize:long
-org/apache/geode/management/internal/cli/exceptions/CliException,true,-7603040667204839200
-org/apache/geode/management/internal/cli/exceptions/CreateSubregionException,true,4387344870743824916
+org/apache/geode/management/internal/cli/exceptions/EntityNotFoundException,false,statusOK:boolean
 org/apache/geode/management/internal/cli/exceptions/IndexNotFoundException,true,1,indexName:java/lang/String,message:java/lang/String
 org/apache/geode/management/internal/cli/functions/AlterRuntimeConfigFunction,true,1
 org/apache/geode/management/internal/cli/functions/AsyncEventQueueFunctionArgs,true,-6524494645663740872,asyncEventQueueId:java/lang/String,batchSize:int,batchTimeInterval:int,diskStoreName:java/lang/String,diskSynchronous:boolean,dispatcherThreads:int,enableBatchConflation:boolean,forwardExpirationDestroy:boolean,gatewayEventFilters:java/lang/String[],gatewaySubstitutionFilter:java/lang/String,isParallel:boolean,listenerClassName:java/lang/String,listenerProperties:java/util/Properties,maxQueueMemory:int,orderPolicy:java/lang/String,persistent:boolean
@@ -563,14 +562,12 @@ org/apache/geode/management/internal/cli/result/TableBuilderHelper$TooManyColumn
 org/apache/geode/management/internal/cli/shell/JMXConnectionException,true,3872374016604940917,exceptionType:int
 org/apache/geode/management/internal/cli/shell/JMXInvocationException,true,-4265451314790394366
 org/apache/geode/management/internal/cli/shell/jline/ANSIHandler$ANSIStyle,false
-org/apache/geode/management/internal/cli/util/DiskStoreNotFoundException,true,-5184836041554948093
 org/apache/geode/management/internal/cli/util/EvictionAttributesInfo,true,1,evictionAction:java/lang/String,evictionAlgorithm:java/lang/String,evictionMaxValue:int
 org/apache/geode/management/internal/cli/util/ExportLogsCacheWriter,false,currentFile:java/nio/file/Path,currentOutputStream:java/io/BufferedOutputStream,isEmpty:boolean
 org/apache/geode/management/internal/cli/util/FixedPartitionAttributesInfo,false,isPrimary:boolean,numBuckets:int,partitionName:java/lang/String
 org/apache/geode/management/internal/cli/util/JConsoleNotFoundException,true,-1485615321440327206
 org/apache/geode/management/internal/cli/util/LogFilter$LineFilterResult,false
 org/apache/geode/management/internal/cli/util/MemberInformation,true,1,cacheXmlFilePath:java/lang/String,cpuUsage:java/lang/String,groups:java/lang/String,heapUsage:java/lang/String,host:java/lang/String,id:java/lang/String,initHeapSize:java/lang/String,locatorBindAddress:java/lang/String,locatorPort:int,locators:java/lang/String,logFilePath:java/lang/String,maxHeapSize:java/lang/String,name:java/lang/String,processId:java/lang/String,serverBindAddress:java/lang/String,statArchiveFilePath:java/lang/String,workingDirPath:java/lang/String
-org/apache/geode/management/internal/cli/util/MemberNotFoundException,true,5686788909239181174
 org/apache/geode/management/internal/cli/util/VisualVmNotFoundException,true,-8491645604829510102
 org/apache/geode/management/internal/configuration/domain/SharedConfigurationStatus,false
 org/apache/geode/management/internal/configuration/functions/GetRegionNamesFunction,false
diff --git a/geode-lucene/src/main/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommands.java b/geode-lucene/src/main/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommands.java
index 971293b27a..926b2d0e92 100755
--- a/geode-lucene/src/main/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommands.java
+++ b/geode-lucene/src/main/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommands.java
@@ -29,10 +29,8 @@
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.cache.execute.Execution;
 import org.apache.geode.cache.execute.Function;
-import org.apache.geode.cache.execute.FunctionInvocationTargetException;
 import org.apache.geode.cache.execute.ResultCollector;
 import org.apache.geode.cache.lucene.internal.cli.functions.LuceneCreateIndexFunction;
 import org.apache.geode.cache.lucene.internal.cli.functions.LuceneDescribeIndexFunction;
@@ -48,6 +46,7 @@
 import org.apache.geode.management.cli.Result;
 import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.commands.GfshCommand;
+import org.apache.geode.management.internal.cli.exceptions.UserErrorException;
 import org.apache.geode.management.internal.cli.functions.CliFunctionResult;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.result.CommandResult;
@@ -56,7 +55,6 @@
 import org.apache.geode.management.internal.cli.result.TabularResultData;
 import org.apache.geode.management.internal.cli.shell.Gfsh;
 import org.apache.geode.management.internal.configuration.domain.XmlEntity;
-import org.apache.geode.security.GemFireSecurityException;
 import org.apache.geode.security.ResourcePermission.Operation;
 import org.apache.geode.security.ResourcePermission.Resource;
 
@@ -88,21 +86,7 @@ public Result listIndex(@CliOption(key = LuceneCliStrings.LUCENE_LIST_INDEX__STA
       help = LuceneCliStrings.LUCENE_LIST_INDEX__STATS__HELP) final boolean stats) {
 
     getSecurityService().authorize(Resource.CLUSTER, Operation.READ, LucenePermission.TARGET);
-
-    try {
-      return toTabularResult(getIndexListing(), stats);
-    } catch (FunctionInvocationTargetException ignore) {
-      return ResultBuilder.createGemFireErrorResult(CliStrings.format(
-          CliStrings.COULD_NOT_EXECUTE_COMMAND_TRY_AGAIN, LuceneCliStrings.LUCENE_LIST_INDEX));
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      getCache().getLogger().info(t);
-      return ResultBuilder.createGemFireErrorResult(String
-          .format(LuceneCliStrings.LUCENE_LIST_INDEX__ERROR_MESSAGE, toString(t, isDebugging())));
-    }
+    return toTabularResult(getIndexListing(), stats);
   }
 
   @SuppressWarnings("unchecked")
@@ -230,27 +214,12 @@ public Result describeIndex(
 
       @CliOption(key = LuceneCliStrings.LUCENE__REGION_PATH, mandatory = true,
           optionContext = ConverterHint.REGION_PATH,
-          help = LuceneCliStrings.LUCENE_DESCRIBE_INDEX__REGION_HELP) final String regionPath) {
+          help = LuceneCliStrings.LUCENE_DESCRIBE_INDEX__REGION_HELP) final String regionPath)
+      throws Exception {
 
     getSecurityService().authorize(Resource.CLUSTER, Operation.READ, LucenePermission.TARGET);
-
-    try {
-      LuceneIndexInfo indexInfo = new LuceneIndexInfo(indexName, regionPath);
-      return toTabularResult(getIndexDetails(indexInfo), true);
-    } catch (FunctionInvocationTargetException ignore) {
-      return ResultBuilder.createGemFireErrorResult(CliStrings.format(
-          CliStrings.COULD_NOT_EXECUTE_COMMAND_TRY_AGAIN, LuceneCliStrings.LUCENE_DESCRIBE_INDEX));
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (IllegalArgumentException e) {
-      return ResultBuilder.createInfoResult(e.getMessage());
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      getCache().getLogger().info(t);
-      return ResultBuilder.createGemFireErrorResult(String.format(
-          LuceneCliStrings.LUCENE_DESCRIBE_INDEX__ERROR_MESSAGE, toString(t, isDebugging())));
-    }
+    LuceneIndexInfo indexInfo = new LuceneIndexInfo(indexName, regionPath);
+    return toTabularResult(getIndexDetails(indexInfo), true);
   }
 
   @SuppressWarnings("unchecked")
@@ -288,32 +257,15 @@ public Result searchIndex(@CliOption(key = LuceneCliStrings.LUCENE__INDEX_NAME,
 
       @CliOption(key = LuceneCliStrings.LUCENE_SEARCH_INDEX__KEYSONLY,
           unspecifiedDefaultValue = "false",
-          help = LuceneCliStrings.LUCENE_SEARCH_INDEX__KEYSONLY__HELP) boolean keysOnly) {
-
+          help = LuceneCliStrings.LUCENE_SEARCH_INDEX__KEYSONLY__HELP) boolean keysOnly)
+      throws Exception {
     getSecurityService().authorize(Resource.DATA, Operation.READ, regionPath);
+    LuceneQueryInfo queryInfo =
+        new LuceneQueryInfo(indexName, regionPath, queryString, defaultField, limit, keysOnly);
+    int pageSize = Integer.MAX_VALUE;
+    searchResults = getSearchResults(queryInfo);
+    return displayResults(pageSize, keysOnly);
 
-    try {
-      LuceneQueryInfo queryInfo =
-          new LuceneQueryInfo(indexName, regionPath, queryString, defaultField, limit, keysOnly);
-      int pageSize = Integer.MAX_VALUE;
-      searchResults = getSearchResults(queryInfo);
-      return displayResults(pageSize, keysOnly);
-    } catch (FunctionInvocationTargetException ignore) {
-      return ResultBuilder.createGemFireErrorResult(CliStrings.format(
-          CliStrings.COULD_NOT_EXECUTE_COMMAND_TRY_AGAIN, LuceneCliStrings.LUCENE_SEARCH_INDEX));
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (IllegalArgumentException e) {
-      return ResultBuilder.createInfoResult(e.getMessage());
-    } catch (GemFireSecurityException e) {
-      throw e;
-    } catch (Throwable t) {
-      SystemFailure.checkFailure();
-      getCache().getLogger().info(t);
-      return ResultBuilder.createGemFireErrorResult(String
-          .format(LuceneCliStrings.LUCENE_SEARCH_INDEX__ERROR_MESSAGE, toString(t, isDebugging())));
-    }
   }
 
   @CliCommand(value = LuceneCliStrings.LUCENE_DESTROY_INDEX,
@@ -526,7 +478,7 @@ private Result getResults(int fromIndex, int toIndex, boolean keysonly) throws E
           data.accumulate("score", searchResults.get(i).getScore());
         }
       } else {
-        throw new Exception(searchResults.get(i).getExceptionMessage());
+        throw new UserErrorException(searchResults.get(i).getExceptionMessage());
       }
     }
     return ResultBuilder.buildResult(data);
@@ -548,7 +500,7 @@ private Result getResults(int fromIndex, int toIndex, boolean keysonly) throws E
     Set<DistributedMember> targetMembers = CliUtil.getRegionAssociatedMembers(
         functionArguments.getRegionPath(), getCache(), returnAllMembers);
     if (targetMembers.isEmpty()) {
-      throw new IllegalArgumentException(CliStrings.format(
+      throw new UserErrorException(CliStrings.format(
           LuceneCliStrings.LUCENE_DESTROY_INDEX__MSG__COULDNOT_FIND_MEMBERS_FOR_REGION_0,
           new Object[] {functionArguments.getRegionPath()}));
     }
diff --git a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsDUnitTest.java b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsDUnitTest.java
index 2aa38041fe..afed83a4a0 100755
--- a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsDUnitTest.java
+++ b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsDUnitTest.java
@@ -416,7 +416,7 @@ public void describeIndexWithoutRegionShouldReturnErrorMessage() throws Exceptio
     CommandStringBuilder csb = new CommandStringBuilder(LuceneCliStrings.LUCENE_DESCRIBE_INDEX);
     csb.addOption(LuceneCliStrings.LUCENE__INDEX_NAME, "notAnIndex");
     csb.addOption(LuceneCliStrings.LUCENE__REGION_PATH, REGION_NAME);
-    gfsh.executeAndAssertThat(csb.toString()).statusIsSuccess().containsOutput(REGION_NAME);
+    gfsh.executeAndAssertThat(csb.toString()).statusIsError().containsOutput(REGION_NAME);
   }
 
   @Test
@@ -554,7 +554,7 @@ public void searchOnIndexWithoutRegionShouldReturnError() throws Exception {
     csb.addOption(LuceneCliStrings.LUCENE_SEARCH_INDEX__QUERY_STRING, "EFG");
     csb.addOption(LuceneCliStrings.LUCENE_SEARCH_INDEX__DEFAULT_FIELD, "field2");
 
-    gfsh.executeAndAssertThat(csb.toString()).statusIsSuccess()
+    gfsh.executeAndAssertThat(csb.toString()).statusIsError()
         .containsOutput(getRegionNotFoundErrorMessage("/region"));
   }
 


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao opened a new pull request #1051: GEODE-3539: rename GfshShellConnectionRule to GfshCommandRule
URL: https://github.com/apache/geode/pull/1051
 
 
   rename only

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied opened a new pull request #1052: GEODE-3539: Add missing test coverage for 'list regions' and 'describe region' commands
URL: https://github.com/apache/geode/pull/1052
 
 
   * Mutually exclusive options --group and --member checked in interceptor instead of failing server-side
   * Command logic flattened to stream.
   * Testing of 'list region' and 'describe region' separated into distinct DUnit and Integration tests
   * Removed @Flaky annotation from 'describe region' DUnit test.
   
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao closed pull request #1051: GEODE-3539: rename GfshShellConnectionRule to GfshCommandRule
URL: https://github.com/apache/geode/pull/1051
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-assembly/src/test/java/org/apache/geode/session/tests/TomcatClientServerTest.java b/geode-assembly/src/test/java/org/apache/geode/session/tests/TomcatClientServerTest.java
index 4d7688a0ea..cb94e7474a 100644
--- a/geode-assembly/src/test/java/org/apache/geode/session/tests/TomcatClientServerTest.java
+++ b/geode-assembly/src/test/java/org/apache/geode/session/tests/TomcatClientServerTest.java
@@ -25,7 +25,7 @@
 import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
 import org.apache.geode.test.dunit.DUnitEnv;
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 /**
  * Setup class for Tomcat Client Server tests
@@ -39,7 +39,7 @@
   public transient TemporaryFolder temporaryFolder = new TemporaryFolder();
 
   @Rule
-  public transient GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public transient GfshCommandRule gfsh = new GfshCommandRule();
 
   @Rule
   public transient LocatorServerStartupRule locatorStartup = new LocatorServerStartupRule();
diff --git a/geode-assembly/src/test/java/org/apache/geode/session/tests/TomcatSessionBackwardsCompatibilityTest.java b/geode-assembly/src/test/java/org/apache/geode/session/tests/TomcatSessionBackwardsCompatibilityTest.java
index e38a374e27..aae71e450e 100644
--- a/geode-assembly/src/test/java/org/apache/geode/session/tests/TomcatSessionBackwardsCompatibilityTest.java
+++ b/geode-assembly/src/test/java/org/apache/geode/session/tests/TomcatSessionBackwardsCompatibilityTest.java
@@ -38,7 +38,7 @@
 import org.apache.geode.test.dunit.standalone.VersionManager;
 import org.apache.geode.test.junit.categories.BackwardCompatibilityTest;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.runners.CategoryWithParameterizedRunnerFactory;
 
 /**
@@ -61,7 +61,7 @@
   }
 
   @Rule
-  public transient GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public transient GfshCommandRule gfsh = new GfshCommandRule();
 
   @Rule
   public TemporaryFolder tempFolder = new TemporaryFolder();
diff --git a/geode-core/src/test/java/org/apache/geode/internal/cache/extension/ExtensionClusterConfigurationDUnitTest.java b/geode-core/src/test/java/org/apache/geode/internal/cache/extension/ExtensionClusterConfigurationDUnitTest.java
index 8fb5feb420..8cfd6246cd 100644
--- a/geode-core/src/test/java/org/apache/geode/internal/cache/extension/ExtensionClusterConfigurationDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/internal/cache/extension/ExtensionClusterConfigurationDUnitTest.java
@@ -38,7 +38,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category({DistributedTest.class})
 @SuppressWarnings("serial")
@@ -48,7 +48,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private static final String REPLICATE_REGION = "ReplicateRegion1";
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilDUnitTest.java
index ebcd7fed10..f1050d8423 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilDUnitTest.java
@@ -35,7 +35,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class CliUtilDUnitTest {
@@ -44,7 +44,7 @@
   public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @ClassRule
-  public static GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public static GfshCommandRule gfsh = new GfshCommandRule();
 
   private static MemberVM locator;
   private static Set<DistributedMember> members;
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/NetstatDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/NetstatDUnitTest.java
index 9649ab5644..571d2b5efe 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/NetstatDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/NetstatDUnitTest.java
@@ -28,7 +28,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class NetstatDUnitTest {
@@ -36,7 +36,7 @@
   public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @ClassRule
-  public static GfshShellConnectionRule gfshConnector = new GfshShellConnectionRule();
+  public static GfshCommandRule gfshConnector = new GfshCommandRule();
 
   private static int[] ports = AvailablePortHelper.getRandomAvailableTCPPorts(3);
 
@@ -75,40 +75,40 @@ public static void beforeClass() throws Exception {
 
   @Test
   public void testConnectToLocator() throws Exception {
-    gfshConnector.connect(ports[0], GfshShellConnectionRule.PortType.locator);
+    gfshConnector.connect(ports[0], GfshCommandRule.PortType.locator);
     gfshConnector.executeAndAssertThat(netStatCommand).statusIsSuccess();
   }
 
   @Test
   public void testConnectToJmxManagerOne() throws Exception {
-    gfshConnector.connect(ports[1], GfshShellConnectionRule.PortType.jmxManager);
+    gfshConnector.connect(ports[1], GfshCommandRule.PortType.jmxManager);
     gfshConnector.executeAndAssertThat(netStatCommand).statusIsSuccess();
   }
 
   @Test
   public void testConnectToJmxManagerTwo() throws Exception {
-    gfshConnector.connect(ports[2], GfshShellConnectionRule.PortType.jmxManager);
+    gfshConnector.connect(ports[2], GfshCommandRule.PortType.jmxManager);
     gfshConnector.executeAndAssertThat(netStatCommand).statusIsSuccess();
   }
 
   @Ignore("GEODE-2488")
   @Test
   public void testConnectToLocatorWithLargeCommandResponse() throws Exception {
-    gfshConnector.connect(ports[0], GfshShellConnectionRule.PortType.locator);
+    gfshConnector.connect(ports[0], GfshCommandRule.PortType.locator);
     gfshConnector.executeAndAssertThat(netStatLsofCommand).statusIsSuccess();
   }
 
   @Ignore("GEODE-2488")
   @Test
   public void testConnectToJmxManagerOneWithLargeCommandResponse() throws Exception {
-    gfshConnector.connect(ports[1], GfshShellConnectionRule.PortType.jmxManager);
+    gfshConnector.connect(ports[1], GfshCommandRule.PortType.jmxManager);
     gfshConnector.executeAndAssertThat(netStatLsofCommand).statusIsSuccess();
   }
 
   @Ignore("GEODE-2488")
   @Test
   public void testConnectToJmxManagerTwoWithLargeCommandResponse() throws Exception {
-    gfshConnector.connect(ports[2], GfshShellConnectionRule.PortType.jmxManager);
+    gfshConnector.connect(ports[2], GfshCommandRule.PortType.jmxManager);
     gfshConnector.executeAndAssertThat(netStatLsofCommand).statusIsSuccess();
   }
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandIntegrationTest.java
index 44aa4e1814..5ab4faf98d 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterRegionCommandIntegrationTest.java
@@ -22,7 +22,7 @@
 
 import org.apache.geode.cache.RegionShortcut;
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.ServerStarterRule;
 
 @Category(IntegrationTest.class)
@@ -32,11 +32,11 @@
       new ServerStarterRule().withJMXManager().withRegion(RegionShortcut.REPLICATE, "REPLICATED");
 
   @ClassRule
-  public static GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public static GfshCommandRule gfsh = new GfshCommandRule();
 
   @BeforeClass
   public static void before() throws Exception {
-    gfsh.connectAndVerify(server.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+    gfsh.connectAndVerify(server.getJmxPort(), GfshCommandRule.PortType.jmxManager);
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ChangeLogLevelCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ChangeLogLevelCommandDUnitTest.java
index d417995c2e..3fd908cee7 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ChangeLogLevelCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ChangeLogLevelCommandDUnitTest.java
@@ -16,8 +16,8 @@
 
 import static org.apache.geode.distributed.ConfigurationProperties.GROUPS;
 import static org.apache.geode.distributed.ConfigurationProperties.NAME;
-import static org.apache.geode.test.junit.rules.GfshShellConnectionRule.PortType.http;
-import static org.apache.geode.test.junit.rules.GfshShellConnectionRule.PortType.jmxManager;
+import static org.apache.geode.test.junit.rules.GfshCommandRule.PortType.http;
+import static org.apache.geode.test.junit.rules.GfshCommandRule.PortType.jmxManager;
 
 import java.util.Properties;
 
@@ -31,7 +31,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 
 @Category(DistributedTest.class)
@@ -48,7 +48,7 @@
   public static LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @ClassRule
-  public static GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public static GfshCommandRule gfsh = new GfshCommandRule();
 
 
   @Parameterized.Parameter
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ConcurrentDeployDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ConcurrentDeployDUnitTest.java
index f4e6635d6d..3449c21335 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ConcurrentDeployDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ConcurrentDeployDUnitTest.java
@@ -27,7 +27,7 @@
 import org.apache.geode.test.dunit.VM;
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.JarFileRule;
 import org.apache.geode.test.junit.rules.LocatorStarterRule;
 
@@ -44,7 +44,7 @@
   public JarFileRule jar1Rule = new JarFileRule("classOne", "jar1.jar", true);
 
   // This is a reference used to refer to connections in VM 2 and VM 3
-  private static GfshShellConnectionRule gfsh;
+  private static GfshCommandRule gfsh;
 
   private VM gfsh1, gfsh2, gfsh3;
 
@@ -79,8 +79,8 @@ public void after() {
   }
 
   public static void connectToLocator(int locatorPort) throws Exception {
-    gfsh = new GfshShellConnectionRule();
-    gfsh.connectAndVerify(locatorPort, GfshShellConnectionRule.PortType.locator);
+    gfsh = new GfshCommandRule();
+    gfsh.connectAndVerify(locatorPort, GfshCommandRule.PortType.locator);
   }
 
   public static void loopThroughDeployAndUndeploys(File jar1) throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommandDUnitTest.java
index 7b8a5e8286..b9f6513dcf 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommandDUnitTest.java
@@ -36,7 +36,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.serializable.SerializableTestName;
 
 @Category(DistributedTest.class)
@@ -49,7 +49,7 @@
   public LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Rule
   public TestName testName = new SerializableTestName();
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommandIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommandIntegrationTest.java
index ce580a5b17..28dffab734 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommandIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateRegionCommandIntegrationTest.java
@@ -36,7 +36,7 @@
 import org.apache.geode.cache.RegionShortcut;
 import org.apache.geode.cache.util.CacheListenerAdapter;
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.ServerStarterRule;
 
 @Category(IntegrationTest.class)
@@ -55,11 +55,11 @@
       new ServerStarterRule().withJMXManager().withRegion(RegionShortcut.REPLICATE, "REPLICATED");
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Before
   public void before() throws Exception {
-    gfsh.connectAndVerify(server.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+    gfsh.connectAndVerify(server.getJmxPort(), GfshCommandRule.PortType.jmxManager);
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandFunctionRegistrationDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandFunctionRegistrationDUnitTest.java
index c2a03bfd01..a043ff257a 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandFunctionRegistrationDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandFunctionRegistrationDUnitTest.java
@@ -37,7 +37,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;
 
 @Category(DistributedTest.class)
@@ -52,7 +52,7 @@
   public LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @Rule
-  public transient GfshShellConnectionRule gfshConnector = new GfshShellConnectionRule();
+  public transient GfshCommandRule gfshConnector = new GfshCommandRule();
 
   @Before
   public void setup() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandRedeployDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandRedeployDUnitTest.java
index ed8de9e32c..4b91ce50c4 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandRedeployDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandRedeployDUnitTest.java
@@ -43,7 +43,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;
 
 @Category(DistributedTest.class)
@@ -73,7 +73,7 @@
   public LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @Rule
-  public transient GfshShellConnectionRule gfshConnector = new GfshShellConnectionRule();
+  public transient GfshCommandRule gfshConnector = new GfshCommandRule();
 
   @Before
   public void setup() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployWithGroupsDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployWithGroupsDUnitTest.java
index 34402a52f9..145bbe4ee9 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployWithGroupsDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployWithGroupsDUnitTest.java
@@ -32,7 +32,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;
 
 /**
@@ -73,7 +73,7 @@
   public LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @Rule
-  public transient GfshShellConnectionRule gfshConnector = new GfshShellConnectionRule();
+  public transient GfshCommandRule gfshConnector = new GfshCommandRule();
 
   @Before
   public void setup() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandIntegrationTest.java
index cdbdf2d4b8..e76a26bb0c 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandIntegrationTest.java
@@ -21,8 +21,8 @@
 
 import org.apache.geode.cache.RegionShortcut;
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule.PortType;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
 import org.apache.geode.test.junit.rules.ServerStarterRule;
 
 @Category(IntegrationTest.class)
@@ -38,8 +38,7 @@
       .withName("server").withRegion(RegionShortcut.PARTITION, "region").withAutoStart();
 
   @Rule
-  public GfshShellConnectionRule gfsh =
-      new GfshShellConnectionRule(server::getJmxPort, PortType.jmxManager);
+  public GfshCommandRule gfsh = new GfshCommandRule(server::getJmxPort, PortType.jmxManager);
 
   @Test
   public void describeConfig() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeMembersCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeMembersCommandDUnitTest.java
index 9db128e001..65b3b8c6d2 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeMembersCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeMembersCommandDUnitTest.java
@@ -25,7 +25,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class DescribeMembersCommandDUnitTest {
@@ -34,7 +34,7 @@
   private static MemberVM locator;
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @BeforeClass
   public static void setup() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyIndexCommandsDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyIndexCommandsDUnitTest.java
index 0959804fa7..9902ca724b 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyIndexCommandsDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyIndexCommandsDUnitTest.java
@@ -30,7 +30,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class DestroyIndexCommandsDUnitTest {
@@ -47,7 +47,7 @@
   public LocatorServerStartupRule rule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Before
   public void before() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java
index cf85a8a39b..51e2102b08 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyRegionCommandDUnitTest.java
@@ -37,7 +37,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class DestroyRegionCommandDUnitTest {
@@ -45,7 +45,7 @@
   public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private static MemberVM locator, server1, server2, server3;
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommandSecurityTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommandSecurityTest.java
index 5247daece5..4ab8b2e78b 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommandSecurityTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommandSecurityTest.java
@@ -44,7 +44,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class ExecuteFunctionCommandSecurityTest implements Serializable {
@@ -53,7 +53,7 @@
   public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private static MemberVM locator, server1, server2;
 
@@ -87,8 +87,8 @@ public static void beforeClass() throws Exception {
 
   @Test
   public void dataReaderCanExecuteReadFunction() throws Exception {
-    gfsh.secureConnectAndVerify(locator.getPort(), GfshShellConnectionRule.PortType.locator,
-        "dataRead", "dataRead");
+    gfsh.secureConnectAndVerify(locator.getPort(), GfshCommandRule.PortType.locator, "dataRead",
+        "dataRead");
     gfsh.executeAndAssertThat("execute function --id=" + new ReadFunction().getId())
         .statusIsSuccess();
     assertThat(gfsh.getGfshOutput()).contains(ReadFunction.SUCCESS_OUTPUT);
@@ -96,8 +96,8 @@ public void dataReaderCanExecuteReadFunction() throws Exception {
 
   @Test
   public void dataReaderCanNotExecuteWriteFunction() throws Exception {
-    gfsh.secureConnectAndVerify(locator.getPort(), GfshShellConnectionRule.PortType.locator,
-        "dataRead", "dataRead");
+    gfsh.secureConnectAndVerify(locator.getPort(), GfshCommandRule.PortType.locator, "dataRead",
+        "dataRead");
     gfsh.executeAndAssertThat("execute function --id=" + new WriteFunction().getId())
         .containsOutput("dataRead not authorized for DATA:WRITE")
         .doesNotContainOutput(WriteFunction.SUCCESS_OUTPUT);
@@ -105,8 +105,8 @@ public void dataReaderCanNotExecuteWriteFunction() throws Exception {
 
   @Test
   public void dataWriterCanExecuteWriteFunction() throws Exception {
-    gfsh.secureConnectAndVerify(locator.getPort(), GfshShellConnectionRule.PortType.locator,
-        "dataWrite", "dataWrite");
+    gfsh.secureConnectAndVerify(locator.getPort(), GfshCommandRule.PortType.locator, "dataWrite",
+        "dataWrite");
     gfsh.executeAndAssertThat("execute function --id=" + new WriteFunction().getId())
         .statusIsSuccess();
     assertThat(gfsh.getGfshOutput()).contains(WriteFunction.SUCCESS_OUTPUT);
@@ -114,8 +114,8 @@ public void dataWriterCanExecuteWriteFunction() throws Exception {
 
   @Test
   public void dataWriterCanNotExecuteReadFunction() throws Exception {
-    gfsh.secureConnectAndVerify(locator.getPort(), GfshShellConnectionRule.PortType.locator,
-        "dataWrite", "dataWrite");
+    gfsh.secureConnectAndVerify(locator.getPort(), GfshCommandRule.PortType.locator, "dataWrite",
+        "dataWrite");
     gfsh.executeCommand("execute function --id=" + new ReadFunction().getId());
     assertThat(gfsh.getGfshOutput()).contains("dataWrite not authorized for DATA:READ");
     assertThat(gfsh.getGfshOutput()).doesNotContain(ReadFunction.SUCCESS_OUTPUT);
@@ -123,8 +123,8 @@ public void dataWriterCanNotExecuteReadFunction() throws Exception {
 
   @Test
   public void readOnlyUserOnReplicatedRegion() throws Exception {
-    gfsh.secureConnectAndVerify(locator.getPort(), GfshShellConnectionRule.PortType.locator,
-        "dataRead", "dataRead");
+    gfsh.secureConnectAndVerify(locator.getPort(), GfshCommandRule.PortType.locator, "dataRead",
+        "dataRead");
     gfsh.executeAndAssertThat(
         "execute function --id=" + new ReadFunction().getId() + " --region=" + REPLICATED_REGION)
         .statusIsSuccess().containsOutput(ReadFunction.SUCCESS_OUTPUT);
@@ -137,8 +137,8 @@ public void readOnlyUserOnReplicatedRegion() throws Exception {
 
   @Test
   public void readOnlyUserOnPartitionedRegion() throws Exception {
-    gfsh.secureConnectAndVerify(locator.getPort(), GfshShellConnectionRule.PortType.locator,
-        "dataRead", "dataRead");
+    gfsh.secureConnectAndVerify(locator.getPort(), GfshCommandRule.PortType.locator, "dataRead",
+        "dataRead");
     gfsh.executeAndAssertThat(
         "execute function --id=" + new ReadFunction().getId() + " --region=" + PARTITIONED_REGION)
         .statusIsSuccess().containsOutput(ReadFunction.SUCCESS_OUTPUT);
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportDataIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportDataIntegrationTest.java
index cefc685092..fda9f6f1aa 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportDataIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportDataIntegrationTest.java
@@ -35,7 +35,7 @@
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.ServerStarterRule;
 
 @Category(IntegrationTest.class)
@@ -50,7 +50,7 @@
       .withRegion(RegionShortcut.PARTITION, TEST_REGION_NAME).withEmbeddedLocator();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Rule
   public TemporaryFolder tempDir = new TemporaryFolder();
@@ -61,8 +61,7 @@
 
   @Before
   public void setup() throws Exception {
-    gfsh.connectAndVerify(server.getEmbeddedLocatorPort(),
-        GfshShellConnectionRule.PortType.locator);
+    gfsh.connectAndVerify(server.getEmbeddedLocatorPort(), GfshCommandRule.PortType.locator);
     region = server.getCache().getRegion(TEST_REGION_NAME);
     loadRegion("value");
     Path basePath = tempDir.getRoot().toPath();
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsDUnitTest.java
index 43adca6593..c23393fef8 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsDUnitTest.java
@@ -57,7 +57,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.Member;
 
 @Category(DistributedTest.class)
@@ -69,7 +69,7 @@
       new LocatorServerStartupRule().withTempWorkingDir().withLogFile();
 
   @Rule
-  public GfshShellConnectionRule gfshConnector = new GfshShellConnectionRule();
+  public GfshCommandRule gfshConnector = new GfshCommandRule();
 
   private MemberVM locator;
   private MemberVM server1;
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsIntegrationTest.java
index c798ee0b85..f992f9a452 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsIntegrationTest.java
@@ -28,7 +28,7 @@
 import org.junit.experimental.categories.Category;
 
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.LocatorStarterRule;
 
 @Category(IntegrationTest.class)
@@ -38,7 +38,7 @@
       new LocatorStarterRule().withWorkingDir().withLogFile().withAutoStart();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Before
   public void connect() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsOnServerManagerDUnit.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsOnServerManagerDUnit.java
index f1e3bbd6e2..c7696a5e24 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsOnServerManagerDUnit.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsOnServerManagerDUnit.java
@@ -30,7 +30,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 
 @Category(DistributedTest.class)
@@ -41,12 +41,12 @@
       new LocatorServerStartupRule().withTempWorkingDir().withLogFile();
 
   @Rule
-  public GfshShellConnectionRule gfshConnector = new GfshShellConnectionRule();
+  public GfshCommandRule gfshConnector = new GfshCommandRule();
 
   @Test
   public void testExportWithOneServer() throws Exception {
     MemberVM server0 = lsRule.startServerAsJmxManager(0);
-    gfshConnector.connect(server0.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+    gfshConnector.connect(server0.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     gfshConnector.executeAndAssertThat("export logs").statusIsSuccess();
 
     String message = gfshConnector.getGfshOutput();
@@ -64,8 +64,7 @@ public void testExportWithOneServer() throws Exception {
   public void testExportWithPeerLocator() throws Exception {
     MemberVM server0 = lsRule.startServerAsEmbededLocator(0);
     lsRule.startServerVM(1, server0.getEmbeddedLocatorPort());
-    gfshConnector.connect(server0.getEmbeddedLocatorPort(),
-        GfshShellConnectionRule.PortType.locator);
+    gfshConnector.connect(server0.getEmbeddedLocatorPort(), GfshCommandRule.PortType.locator);
     gfshConnector.executeAndAssertThat("export logs").statusIsSuccess();
 
     String message = gfshConnector.getGfshOutput();
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsStatsDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsStatsDUnitTest.java
index d7e60953b8..009053be64 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsStatsDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsStatsDUnitTest.java
@@ -48,7 +48,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class ExportLogsStatsDUnitTest {
@@ -57,7 +57,7 @@
       new LocatorServerStartupRule().withTempWorkingDir().withLogFile();
 
   @ClassRule
-  public static GfshShellConnectionRule connector = new GfshShellConnectionRule();
+  public static GfshCommandRule connector = new GfshCommandRule();
 
   protected static int jmxPort, httpPort;
   protected static Set<String> expectedZipEntries = new HashSet<>();
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsWithMemberGroupDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsWithMemberGroupDUnitTest.java
index ad5ea931fd..b4ae33484d 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsWithMemberGroupDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsWithMemberGroupDUnitTest.java
@@ -41,7 +41,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class ExportLogsWithMemberGroupDUnitTest {
@@ -50,7 +50,7 @@
       new LocatorServerStartupRule().withTempWorkingDir().withLogFile();
 
   @ClassRule
-  public static GfshShellConnectionRule connector = new GfshShellConnectionRule();
+  public static GfshCommandRule connector = new GfshCommandRule();
 
   protected static int jmxPort, httpPort;
   protected static Set<String> expectedZipEntries = new HashSet<>();
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/FunctionCommandsDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/FunctionCommandsDUnitTest.java
index cc5227f975..ab67cd30f6 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/FunctionCommandsDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/FunctionCommandsDUnitTest.java
@@ -40,7 +40,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class FunctionCommandsDUnitTest {
@@ -54,7 +54,7 @@
   public LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Before
   public void before() throws Exception {
@@ -116,7 +116,7 @@ private void registerFunction(Function function, MemberVM... vms) {
   }
 
   public void connectGfsh(MemberVM vm) throws Exception {
-    gfsh.connectAndVerify(vm.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+    gfsh.connectAndVerify(vm.getJmxPort(), GfshCommandRule.PortType.jmxManager);
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GcCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GcCommandDUnitTest.java
index a3e2937a1a..bf00b73f90 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GcCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GcCommandDUnitTest.java
@@ -17,8 +17,8 @@
 import static org.apache.geode.distributed.ConfigurationProperties.GROUPS;
 import static org.apache.geode.distributed.ConfigurationProperties.LOG_FILE;
 import static org.apache.geode.distributed.ConfigurationProperties.NAME;
-import static org.apache.geode.test.junit.rules.GfshShellConnectionRule.PortType.http;
-import static org.apache.geode.test.junit.rules.GfshShellConnectionRule.PortType.jmxManager;
+import static org.apache.geode.test.junit.rules.GfshCommandRule.PortType.http;
+import static org.apache.geode.test.junit.rules.GfshCommandRule.PortType.jmxManager;
 import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.Properties;
@@ -35,7 +35,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 
 @Category(DistributedTest.class)
@@ -61,7 +61,7 @@
   public static LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @ClassRule
-  public static GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public static GfshCommandRule gfsh = new GfshCommandRule();
 
   @BeforeClass
   public static void setup() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GetCommandIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GetCommandIntegrationTest.java
index 226edc3b99..d8406132f1 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GetCommandIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GetCommandIntegrationTest.java
@@ -37,7 +37,7 @@
 import org.apache.geode.cache.RegionFactory;
 import org.apache.geode.cache.RegionShortcut;
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.ServerStarterRule;
 
 
@@ -47,8 +47,8 @@
   private static ServerStarterRule server =
       new ServerStarterRule().withJMXManager().withAutoStart();
 
-  private static GfshShellConnectionRule gfsh =
-      new GfshShellConnectionRule(server::getJmxPort, GfshShellConnectionRule.PortType.jmxManager);
+  private static GfshCommandRule gfsh =
+      new GfshCommandRule(server::getJmxPort, GfshCommandRule.PortType.jmxManager);
 
   @ClassRule
   public static RuleChain chain = RuleChain.outerRule(server).around(gfsh);
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GfshCommandIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GfshCommandIntegrationTest.java
index 3436cde0d2..2902daa037 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GfshCommandIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/GfshCommandIntegrationTest.java
@@ -15,15 +15,13 @@
 
 package org.apache.geode.management.internal.cli.commands;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 import org.junit.ClassRule;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.LocatorStarterRule;
 
 @Category(IntegrationTest.class)
@@ -32,7 +30,7 @@
   public static LocatorStarterRule locator = new LocatorStarterRule().withAutoStart();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Test
   public void invalidCommandWhenNotConnected() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ImportDataIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ImportDataIntegrationTest.java
index d599a6d0f8..7f774dd373 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ImportDataIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ImportDataIntegrationTest.java
@@ -36,7 +36,7 @@
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.ServerStarterRule;
 
 @Category(IntegrationTest.class)
@@ -51,7 +51,7 @@
       .withRegion(RegionShortcut.PARTITION, TEST_REGION_NAME).withEmbeddedLocator();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Rule
   public TemporaryFolder tempDir = new TemporaryFolder();
@@ -62,8 +62,7 @@
 
   @Before
   public void setup() throws Exception {
-    gfsh.connectAndVerify(server.getEmbeddedLocatorPort(),
-        GfshShellConnectionRule.PortType.locator);
+    gfsh.connectAndVerify(server.getEmbeddedLocatorPort(), GfshCommandRule.PortType.locator);
     region = server.getCache().getRegion(TEST_REGION_NAME);
     loadRegion("value");
     Path basePath = tempDir.getRoot().toPath();
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/IndexCommandsIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/IndexCommandsIntegrationTest.java
index 0da359527d..85a379208b 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/IndexCommandsIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/IndexCommandsIntegrationTest.java
@@ -39,7 +39,7 @@
 import org.apache.geode.management.internal.cli.result.CommandResult;
 import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.Server;
 import org.apache.geode.test.junit.rules.ServerStarterRule;
 
@@ -66,7 +66,7 @@ public static void beforeClass() throws Exception {
   }
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Before
   public void before() throws Exception {
@@ -86,7 +86,7 @@ public void after() throws Exception {
   }
 
   public void connect(Server server) throws Exception {
-    gfsh.connectAndVerify(server.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+    gfsh.connectAndVerify(server.getJmxPort(), GfshCommandRule.PortType.jmxManager);
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/IndexCommandsShareConfigurationDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/IndexCommandsShareConfigurationDUnitTest.java
index 54d03ae7b8..61eae9cee7 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/IndexCommandsShareConfigurationDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/IndexCommandsShareConfigurationDUnitTest.java
@@ -51,13 +51,13 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class IndexCommandsShareConfigurationDUnitTest {
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Rule
   public LocatorServerStartupRule startupRule = new LocatorServerStartupRule();
@@ -86,7 +86,7 @@ public void before() throws Exception {
 
     locator = startupRule.startLocatorVM(0, locatorProps);
 
-    gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+    gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
 
     Properties props = new Properties();
     props.setProperty(GROUPS, groupName);
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeRegionDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeRegionDUnitTest.java
index c56124c045..f85816e645 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeRegionDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeRegionDUnitTest.java
@@ -56,7 +56,7 @@
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
 import org.apache.geode.test.junit.categories.FlakyTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class ListAndDescribeRegionDUnitTest implements Serializable {
@@ -73,7 +73,7 @@
   public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @ClassRule
-  public static GfshShellConnectionRule gfshShellConnectionRule = new GfshShellConnectionRule();
+  public static GfshCommandRule gfshCommandRule = new GfshCommandRule();
 
   @BeforeClass
   public static void setupSystem() throws Exception {
@@ -127,13 +127,13 @@ public static void setupSystem() throws Exception {
       createRegionsWithSubRegions();
     });
 
-    gfshShellConnectionRule.connectAndVerify(locator);
+    gfshCommandRule.connectAndVerify(locator);
   }
 
   @Test
   public void listAllRegions() throws Exception {
     String listRegions = new CommandStringBuilder(LIST_REGION).toString();
-    gfshShellConnectionRule.executeAndAssertThat(listRegions).statusIsSuccess().containsOutput(PR1,
+    gfshCommandRule.executeAndAssertThat(listRegions).statusIsSuccess().containsOutput(PR1,
         LOCALREGIONONMANAGER, REGION1, REGION2, REGION3);
   }
 
@@ -141,7 +141,7 @@ public void listAllRegions() throws Exception {
   public void listRegionsOnManager() throws Exception {
     String listRegions =
         new CommandStringBuilder(LIST_REGION).addOption(MEMBER, "Manager").toString();
-    gfshShellConnectionRule.executeAndAssertThat(listRegions).statusIsSuccess().containsOutput(PR1,
+    gfshCommandRule.executeAndAssertThat(listRegions).statusIsSuccess().containsOutput(PR1,
         LOCALREGIONONMANAGER);
   }
 
@@ -149,39 +149,39 @@ public void listRegionsOnManager() throws Exception {
   public void listRegionsOnServer() throws Exception {
     CommandStringBuilder csb = new CommandStringBuilder(LIST_REGION);
     csb.addOption(MEMBER, "Server");
-    gfshShellConnectionRule.executeAndAssertThat(csb.toString()).statusIsSuccess()
-        .containsOutput(PR1, REGION1, REGION2, REGION3, SUBREGION1A);
+    gfshCommandRule.executeAndAssertThat(csb.toString()).statusIsSuccess().containsOutput(PR1,
+        REGION1, REGION2, REGION3, SUBREGION1A);
   }
 
   @Test
   public void listRegionsInGroup1() throws Exception {
     CommandStringBuilder csb = new CommandStringBuilder(LIST_REGION);
     csb.addOption(GROUP, "G1");
-    gfshShellConnectionRule.executeAndAssertThat(csb.toString()).statusIsSuccess()
-        .containsOutput(PR1, LOCALREGIONONMANAGER);
+    gfshCommandRule.executeAndAssertThat(csb.toString()).statusIsSuccess().containsOutput(PR1,
+        LOCALREGIONONMANAGER);
   }
 
   @Test
   public void listRegionsInGroup2() throws Exception {
     CommandStringBuilder csb = new CommandStringBuilder(LIST_REGION);
     csb.addOption(GROUP, "G2");
-    gfshShellConnectionRule.executeAndAssertThat(csb.toString()).statusIsSuccess()
-        .containsOutput(PR1, REGION1, REGION2, REGION3, SUBREGION1A);
+    gfshCommandRule.executeAndAssertThat(csb.toString()).statusIsSuccess().containsOutput(PR1,
+        REGION1, REGION2, REGION3, SUBREGION1A);
   }
 
   @Test
   public void describeRegionsOnManager() throws Exception {
     CommandStringBuilder csb = new CommandStringBuilder(DESCRIBE_REGION);
     csb.addOption(DESCRIBE_REGION__NAME, PR1);
-    gfshShellConnectionRule.executeAndAssertThat(csb.toString()).statusIsSuccess()
-        .containsOutput(PR1, "Server");
+    gfshCommandRule.executeAndAssertThat(csb.toString()).statusIsSuccess().containsOutput(PR1,
+        "Server");
   }
 
   @Test
   public void describeRegionsOnServer() throws Exception {
     CommandStringBuilder csb = new CommandStringBuilder(DESCRIBE_REGION);
     csb.addOption(DESCRIBE_REGION__NAME, LOCALREGIONONMANAGER);
-    gfshShellConnectionRule.executeAndAssertThat(csb.toString()).statusIsSuccess()
+    gfshCommandRule.executeAndAssertThat(csb.toString()).statusIsSuccess()
         .containsOutput(LOCALREGIONONMANAGER, "Manager");
   }
 
@@ -204,7 +204,7 @@ public void describeRegionWithCompressionCodec() throws Exception {
     CommandStringBuilder csb = new CommandStringBuilder(DESCRIBE_REGION);
     csb.addOption(DESCRIBE_REGION__NAME, regionName);
     String commandString = csb.toString();
-    gfshShellConnectionRule.executeAndAssertThat(csb.toString()).statusIsSuccess().containsOutput(
+    gfshCommandRule.executeAndAssertThat(csb.toString()).statusIsSuccess().containsOutput(
         regionName, RegionAttributesNames.COMPRESSOR,
         RegionEntryContext.DEFAULT_COMPRESSION_PROVIDER);
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListIndexCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListIndexCommandDUnitTest.java
index 8857625df5..5522cf0f13 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListIndexCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListIndexCommandDUnitTest.java
@@ -29,7 +29,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class ListIndexCommandDUnitTest {
@@ -44,7 +44,7 @@
   public LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Before
   public void before() throws Exception {
@@ -65,7 +65,7 @@ public void before() throws Exception {
   }
 
   public void connectGfsh(MemberVM vm) throws Exception {
-    gfsh.connectAndVerify(vm.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+    gfsh.connectAndVerify(vm.getJmxPort(), GfshCommandRule.PortType.jmxManager);
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListMembersCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListMembersCommandDUnitTest.java
index 9dbbc3098c..05b83c96ab 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListMembersCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListMembersCommandDUnitTest.java
@@ -29,7 +29,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class ListMembersCommandDUnitTest {
@@ -38,7 +38,7 @@
   private static MemberVM locator;
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @BeforeClass
   public static void setup() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/LocateEntryDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/LocateEntryDUnitTest.java
index 573fc63c2e..2528dbf6a4 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/LocateEntryDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/LocateEntryDUnitTest.java
@@ -25,7 +25,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 
 @Category(DistributedTest.class)
@@ -34,7 +34,7 @@
   public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @ClassRule
-  public static GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public static GfshCommandRule gfsh = new GfshCommandRule();
 
   private static MemberVM locator, server1, server2;
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/PutCommandIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/PutCommandIntegrationTest.java
index 8ec785a61f..e164d10d5c 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/PutCommandIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/PutCommandIntegrationTest.java
@@ -31,7 +31,7 @@
 import org.apache.geode.management.internal.cli.dto.Value;
 import org.apache.geode.management.internal.cli.dto.Value2;
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.ServerStarterRule;
 
 
@@ -41,8 +41,8 @@
   private static ServerStarterRule server =
       new ServerStarterRule().withJMXManager().withRegion(RegionShortcut.REPLICATE, "testRegion");
 
-  private static GfshShellConnectionRule gfsh =
-      new GfshShellConnectionRule(server::getJmxPort, GfshShellConnectionRule.PortType.jmxManager);
+  private static GfshCommandRule gfsh =
+      new GfshCommandRule(server::getJmxPort, GfshCommandRule.PortType.jmxManager);
 
   @ClassRule
   public static RuleChain chain = RuleChain.outerRule(server).around(gfsh);
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/QueryCommandTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/QueryCommandTest.java
index bafd47f733..afc1dbc9ba 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/QueryCommandTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/QueryCommandTest.java
@@ -21,7 +21,6 @@
 import java.nio.charset.StandardCharsets;
 import java.util.Arrays;
 import java.util.List;
-import java.util.regex.Pattern;
 
 import com.google.common.io.Files;
 import org.apache.commons.io.FileUtils;
@@ -40,7 +39,7 @@
 import org.apache.geode.cache.RegionShortcut;
 import org.apache.geode.management.internal.cli.shell.Gfsh;
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.ServerStarterRule;
 
 @Category(IntegrationTest.class)
@@ -62,7 +61,7 @@
           .withRegion(RegionShortcut.REPLICATE, "complexRegion");
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Rule
   public TemporaryFolder temporaryFolder = new TemporaryFolder();
@@ -84,9 +83,9 @@ public static void populateRegions() {
   @Before
   public void connect() throws Exception {
     if (useHttp) {
-      gfsh.connectAndVerify(server.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(server.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(server.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(server.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
   }
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/RemoveCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/RemoveCommandDUnitTest.java
index 5a0bb17e62..4051dc1d49 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/RemoveCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/RemoveCommandDUnitTest.java
@@ -39,7 +39,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class RemoveCommandDUnitTest implements Serializable {
@@ -51,7 +51,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public transient GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public transient GfshCommandRule gfsh = new GfshCommandRule();
 
   private transient MemberVM locator;
   private transient MemberVM server1;
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/RemoveCommandJsonDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/RemoveCommandJsonDUnitTest.java
index 4137820729..bc1c80a810 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/RemoveCommandJsonDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/RemoveCommandJsonDUnitTest.java
@@ -40,7 +40,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class RemoveCommandJsonDUnitTest implements Serializable {
@@ -50,7 +50,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public transient GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public transient GfshCommandRule gfsh = new GfshCommandRule();
 
   private transient MemberVM locator;
   private transient MemberVM server1;
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowDeadlockDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowDeadlockDUnitTest.java
index 885370ba47..6d27f7b288 100755
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowDeadlockDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowDeadlockDUnitTest.java
@@ -40,7 +40,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 /**
  * Distributed tests for show deadlock command in {@link ShowDeadlockCommand}.
@@ -65,7 +65,7 @@
   public TemporaryFolder temporaryFolder = new TemporaryFolder();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Before
   public void setup() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowLogCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowLogCommandDUnitTest.java
index 233fb71ef1..19ecff1f64 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowLogCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowLogCommandDUnitTest.java
@@ -18,8 +18,8 @@
 import static org.apache.geode.distributed.ConfigurationProperties.LOG_FILE;
 import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;
 import static org.apache.geode.distributed.ConfigurationProperties.NAME;
-import static org.apache.geode.test.junit.rules.GfshShellConnectionRule.PortType.http;
-import static org.apache.geode.test.junit.rules.GfshShellConnectionRule.PortType.jmxManager;
+import static org.apache.geode.test.junit.rules.GfshCommandRule.PortType.http;
+import static org.apache.geode.test.junit.rules.GfshCommandRule.PortType.jmxManager;
 import static org.assertj.core.api.Assertions.assertThat;
 
 import java.io.Serializable;
@@ -44,7 +44,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 @RunWith(Parameterized.class)
@@ -65,7 +65,7 @@
   public static LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @ClassRule
-  public static GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public static GfshCommandRule gfsh = new GfshCommandRule();
 
   @Parameterized.Parameter
   public static boolean useHttp;
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowMetricsDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowMetricsDUnitTest.java
index 1a34a3e69a..151d39694d 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowMetricsDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowMetricsDUnitTest.java
@@ -41,7 +41,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class ShowMetricsDUnitTest {
@@ -52,7 +52,7 @@
   public LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Rule
   public TemporaryFolder tempFolder = new TemporaryFolder();
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowMissingDiskStoresDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowMissingDiskStoresDUnitTest.java
index f0f4a690ae..9245100e3a 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowMissingDiskStoresDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowMissingDiskStoresDUnitTest.java
@@ -37,7 +37,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class ShowMissingDiskStoresDUnitTest {
@@ -55,7 +55,7 @@
   public LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfshConnector = new GfshShellConnectionRule();
+  public GfshCommandRule gfshConnector = new GfshCommandRule();
 
   @Before
   public void before() throws Exception {
@@ -126,7 +126,7 @@ private AsyncInvocation restartServerAsync(MemberVM member) throws Exception {
     return restart;
   }
 
-  private void checkAsyncResults(AsyncInvocation ai, GfshShellConnectionRule gfsh, int secsToWait)
+  private void checkAsyncResults(AsyncInvocation ai, GfshCommandRule gfsh, int secsToWait)
       throws Exception {
     try {
       Awaitility.await().atLeast(secsToWait, TimeUnit.SECONDS).until(() -> ai.isDone());
@@ -142,7 +142,7 @@ private void checkAsyncResults(AsyncInvocation ai, GfshShellConnectionRule gfsh,
     System.out.println(result);
   }
 
-  private void putUsingGfsh(GfshShellConnectionRule gfsh, String regionName, int key, String val)
+  private void putUsingGfsh(GfshCommandRule gfsh, String regionName, int key, String val)
       throws Exception {
     CommandStringBuilder csb = new CommandStringBuilder(CliStrings.PUT)
         .addOption(CliStrings.PUT__KEY, Integer.toString(key)).addOption(CliStrings.PUT__VALUE, val)
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShutdownCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShutdownCommandDUnitTest.java
index 84e280334d..e108867bd3 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShutdownCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShutdownCommandDUnitTest.java
@@ -17,8 +17,8 @@
 import static org.apache.geode.distributed.ConfigurationProperties.GROUPS;
 import static org.apache.geode.distributed.ConfigurationProperties.LOG_FILE;
 import static org.apache.geode.distributed.ConfigurationProperties.NAME;
-import static org.apache.geode.test.junit.rules.GfshShellConnectionRule.PortType.http;
-import static org.apache.geode.test.junit.rules.GfshShellConnectionRule.PortType.jmxManager;
+import static org.apache.geode.test.junit.rules.GfshCommandRule.PortType.http;
+import static org.apache.geode.test.junit.rules.GfshCommandRule.PortType.jmxManager;
 import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.Properties;
@@ -40,7 +40,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 
 @Category(DistributedTest.class)
@@ -70,7 +70,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
 
   @Before
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/VersionCommandJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/VersionCommandJUnitTest.java
index 6a23b1c342..68841235e0 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/VersionCommandJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/VersionCommandJUnitTest.java
@@ -35,7 +35,7 @@
 
 import org.apache.geode.internal.GemFireVersion;
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.LocatorStarterRule;
 
 @Category(IntegrationTest.class)
@@ -49,7 +49,7 @@
   public static LocatorStarterRule locator = new LocatorStarterRule().withAutoStart();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Test
   @Parameters({"version", "version --full=false"})
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/lifecycle/GfshStatusCommandsIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/lifecycle/GfshStatusCommandsIntegrationTest.java
index 83f58e75fd..ddfa7c0e80 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/lifecycle/GfshStatusCommandsIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/lifecycle/GfshStatusCommandsIntegrationTest.java
@@ -27,7 +27,7 @@
 
 import org.apache.geode.management.internal.cli.result.CommandResult;
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.LocatorStarterRule;
 
 @Category(IntegrationTest.class)
@@ -39,7 +39,7 @@
       new LocatorStarterRule().withJMXManager().withName(LOCATOR_NAME).withAutoStart();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Rule
   public TemporaryFolder temporaryFolder = new TemporaryFolder();
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/shell/GfshMultilineCommandTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/shell/GfshMultilineCommandTest.java
index 80bfe62b08..95fcb15949 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/shell/GfshMultilineCommandTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/shell/GfshMultilineCommandTest.java
@@ -25,7 +25,7 @@
 
 import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.ServerStarterRule;
 
 
@@ -37,11 +37,11 @@
 
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Test
   public void testMultiLineCommand() throws Exception {
-    gfsh.connectAndVerify(server.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+    gfsh.connectAndVerify(server.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     // Execute a command
     CommandStringBuilder csb = new CommandStringBuilder(LIST_MEMBER);
     csb.addOption(GROUP, "nogroup");
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigDeployJarDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigDeployJarDUnitTest.java
index 6d8da39ac0..0d12a18949 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigDeployJarDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigDeployJarDUnitTest.java
@@ -26,7 +26,7 @@
 
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class ClusterConfigDeployJarDUnitTest extends ClusterConfigTestBase {
@@ -36,7 +36,7 @@
   private String group2Jar;
 
   @Rule
-  public GfshShellConnectionRule gfshConnector = new GfshShellConnectionRule();
+  public GfshCommandRule gfshConnector = new GfshCommandRule();
 
   @Before
   public void before() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigDistributionDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigDistributionDUnitTest.java
index 99d40e1fa1..1c0890bad9 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigDistributionDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigDistributionDUnitTest.java
@@ -40,7 +40,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;
 
 @Category(DistributedTest.class)
@@ -60,7 +60,7 @@
   @Rule
   public LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
   @Rule
-  public GfshShellConnectionRule gfshConnector = new GfshShellConnectionRule();
+  public GfshCommandRule gfshConnector = new GfshCommandRule();
 
   @Before
   public void before() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigImportDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigImportDUnitTest.java
index b70c71bc57..fe170e9a37 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigImportDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigImportDUnitTest.java
@@ -40,7 +40,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class ClusterConfigImportDUnitTest extends ClusterConfigTestBase {
@@ -50,7 +50,7 @@
   private MemberVM locatorVM;
 
   @Rule
-  public GfshShellConnectionRule gfshConnector = new GfshShellConnectionRule();
+  public GfshCommandRule gfshConnector = new GfshCommandRule();
 
   @Before
   public void before() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigWithSecurityDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigWithSecurityDUnitTest.java
index 2c763621ae..030e4effca 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigWithSecurityDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigWithSecurityDUnitTest.java
@@ -40,7 +40,7 @@
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
 import org.apache.geode.test.junit.categories.SecurityTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;
 
 @Category({DistributedTest.class, SecurityTest.class})
@@ -57,7 +57,7 @@
   public LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule connector = new GfshShellConnectionRule();
+  public GfshCommandRule connector = new GfshCommandRule();
 
   @Before
   public void before() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ImportClusterConfigDistributedTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ImportClusterConfigDistributedTest.java
index c214246667..46d1f7a83e 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ImportClusterConfigDistributedTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ImportClusterConfigDistributedTest.java
@@ -33,7 +33,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class ImportClusterConfigDistributedTest {
@@ -50,7 +50,7 @@
   public LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Before
   public void exportClusterConfig() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ImportOldClusterConfigDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ImportOldClusterConfigDUnitTest.java
index 8ef523d4aa..396a40a969 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ImportOldClusterConfigDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ImportOldClusterConfigDUnitTest.java
@@ -33,7 +33,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class ImportOldClusterConfigDUnitTest {
@@ -41,7 +41,7 @@
   public LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Rule
   public TemporaryFolder tempFolder = new TemporaryFolder();
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/security/GfshCommandsPostProcessorTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/security/GfshCommandsPostProcessorTest.java
index f09a2e4842..ba32771990 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/security/GfshCommandsPostProcessorTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/security/GfshCommandsPostProcessorTest.java
@@ -16,7 +16,6 @@
 
 import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_MANAGER;
 import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_POST_PROCESSOR;
-import static org.assertj.core.api.Assertions.assertThat;
 
 import org.junit.BeforeClass;
 import org.junit.ClassRule;
@@ -30,7 +29,7 @@
 import org.apache.geode.test.junit.categories.IntegrationTest;
 import org.apache.geode.test.junit.categories.SecurityTest;
 import org.apache.geode.test.junit.rules.ConnectionConfiguration;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.ServerStarterRule;
 
 @Category({IntegrationTest.class, SecurityTest.class})
@@ -42,8 +41,8 @@
       .withProperty(SECURITY_MANAGER, SimpleTestSecurityManager.class.getName()).withAutoStart();
 
   @Rule
-  public GfshShellConnectionRule gfshConnection = new GfshShellConnectionRule(
-      serverStarter::getJmxPort, GfshShellConnectionRule.PortType.jmxManager);
+  public GfshCommandRule gfshConnection =
+      new GfshCommandRule(serverStarter::getJmxPort, GfshCommandRule.PortType.jmxManager);
 
   @BeforeClass
   public static void beforeClass() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/security/GfshCommandsSecurityTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/security/GfshCommandsSecurityTest.java
index 9e3478cb2d..a2980b71ea 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/security/GfshCommandsSecurityTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/security/GfshCommandsSecurityTest.java
@@ -35,7 +35,7 @@
 import org.apache.geode.test.junit.categories.IntegrationTest;
 import org.apache.geode.test.junit.categories.SecurityTest;
 import org.apache.geode.test.junit.rules.ConnectionConfiguration;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.ServerStarterRule;
 
 @Category({IntegrationTest.class, SecurityTest.class})
@@ -46,8 +46,8 @@
           .withRegion(RegionShortcut.REPLICATE_PERSISTENT, "persistentRegion");
 
   @Rule
-  public GfshShellConnectionRule gfshConnection = new GfshShellConnectionRule(
-      serverStarter::getJmxPort, GfshShellConnectionRule.PortType.jmxManager);
+  public GfshCommandRule gfshConnection =
+      new GfshCommandRule(serverStarter::getJmxPort, GfshCommandRule.PortType.jmxManager);
 
   @BeforeClass
   public static void beforeClass() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/security/MultiUserDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/security/MultiUserDUnitTest.java
index c33da974e5..749d58a374 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/security/MultiUserDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/security/MultiUserDUnitTest.java
@@ -43,8 +43,8 @@
 import org.apache.geode.test.junit.categories.DistributedTest;
 import org.apache.geode.test.junit.categories.FlakyTest;
 import org.apache.geode.test.junit.categories.SecurityTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule.PortType;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
 import org.apache.geode.test.junit.rules.Member;
 
 @Category({DistributedTest.class, SecurityTest.class})
@@ -73,7 +73,7 @@ public void testMultiUser() throws IOException, JSONException, InterruptedExcept
     // test is done.
     VM vm1 = lsRule.getVM(1);
     AsyncInvocation vm1Invoke = vm1.invokeAsync("run as data-reader", () -> {
-      GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+      GfshCommandRule gfsh = new GfshCommandRule();
       gfsh.secureConnectAndVerify(jmxPort, PortType.jmxManager, "dataRead", "dataRead");
 
       Awaitility.waitAtMost(5, TimeUnit.MILLISECONDS);
@@ -84,7 +84,7 @@ public void testMultiUser() throws IOException, JSONException, InterruptedExcept
     // set up vm_2 as a gfsh vm, and then connect as "stranger" and try to execute the commands and
     // assert errors comes back are NotAuthorized
     AsyncInvocation vm2Invoke = vm2.invokeAsync("run as guest", () -> {
-      GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+      GfshCommandRule gfsh = new GfshCommandRule();
       gfsh.secureConnectAndVerify(jmxPort, PortType.jmxManager, "guest", "guest");
 
       List<TestCommand> allCommands = TestCommand.getOnlineCommands();
@@ -119,7 +119,7 @@ public void testMultiUser() throws IOException, JSONException, InterruptedExcept
     // set up vm_3 as another gfsh vm, and then connect as "super-user" and try to execute the
     // commands and assert we don't get a NotAuthorized Exception
     AsyncInvocation vm3Invoke = vm3.invokeAsync("run as superUser", () -> {
-      GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+      GfshCommandRule gfsh = new GfshCommandRule();
       gfsh.secureConnectAndVerify(jmxPort, PortType.jmxManager, "data,cluster", "data,cluster");
 
       List<TestCommand> allCommands = TestCommand.getOnlineCommands();
diff --git a/geode-core/src/test/java/org/apache/geode/security/PDXGfshPostProcessorOnRemoteServerTest.java b/geode-core/src/test/java/org/apache/geode/security/PDXGfshPostProcessorOnRemoteServerTest.java
index b747d73012..7cea40c207 100644
--- a/geode-core/src/test/java/org/apache/geode/security/PDXGfshPostProcessorOnRemoteServerTest.java
+++ b/geode-core/src/test/java/org/apache/geode/security/PDXGfshPostProcessorOnRemoteServerTest.java
@@ -39,7 +39,7 @@
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
 import org.apache.geode.test.junit.categories.SecurityTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category({DistributedTest.class, SecurityTest.class})
 public class PDXGfshPostProcessorOnRemoteServerTest {
@@ -50,7 +50,7 @@
   public LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Test
   public void testGfshCommand() throws Exception {
@@ -96,7 +96,7 @@ public void testGfshCommand() throws Exception {
           });
     });
 
-    gfsh.connectAndVerify(locatorVM.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager,
+    gfsh.connectAndVerify(locatorVM.getJmxPort(), GfshCommandRule.PortType.jmxManager,
         CliStrings.CONNECT__USERNAME, "dataUser", CliStrings.CONNECT__PASSWORD, "1234567");
 
     // get command
diff --git a/geode-core/src/test/java/org/apache/geode/security/PDXPostProcessorDUnitTest.java b/geode-core/src/test/java/org/apache/geode/security/PDXPostProcessorDUnitTest.java
index 1e051d7f35..15ae43d40a 100644
--- a/geode-core/src/test/java/org/apache/geode/security/PDXPostProcessorDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/security/PDXPostProcessorDUnitTest.java
@@ -49,7 +49,7 @@
 import org.apache.geode.test.dunit.internal.JUnit4DistributedTestCase;
 import org.apache.geode.test.junit.categories.DistributedTest;
 import org.apache.geode.test.junit.categories.SecurityTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.ServerStarterRule;
 import org.apache.geode.test.junit.runners.CategoryWithParameterizedRunnerFactory;
 
@@ -211,9 +211,9 @@ public void testGfshCommand() {
     });
 
     this.client1.invoke(() -> {
-      GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
-      gfsh.secureConnectAndVerify(this.server.getJmxPort(),
-          GfshShellConnectionRule.PortType.jmxManager, "dataUser", "1234567");
+      GfshCommandRule gfsh = new GfshCommandRule();
+      gfsh.secureConnectAndVerify(this.server.getJmxPort(), GfshCommandRule.PortType.jmxManager,
+          "dataUser", "1234567");
 
       // get command
       gfsh.executeAndAssertThat("get --key=key1 --region=AuthRegion").statusIsSuccess();
diff --git a/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshShellConnectionRule.java b/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshCommandRule.java
similarity index 96%
rename from geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshShellConnectionRule.java
rename to geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshCommandRule.java
index 1b09cb9c09..358368488a 100644
--- a/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshShellConnectionRule.java
+++ b/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshCommandRule.java
@@ -52,7 +52,7 @@
  * you can use this as Rule:
  *
  * <pre>
- * {@literal @}Rule GfshShellConnectionRule rule = new GfshShellConnectionRule();
+ * {@literal @}Rule GfshCommandRule rule = new GfshCommandRule();
  * </pre>
  *
  * then after you connect to a locator, you don't have to call disconnect() or close() at all, since
@@ -62,13 +62,13 @@
  * Or as a ClassRule:
  *
  * <pre>
- * {@literal @}ClassRule GfshShellConnectionRule rule = new GfshShellConnectionRule();
+ * {@literal @}ClassRule GfshCommandRule rule = new GfshCommandRule();
  * </pre>
  *
  * When using as a ClassRule, if you call connect in a test, you will need to call disconnect after
  * the test as well. See NetstatDUnitTest for example.
  */
-public class GfshShellConnectionRule extends DescribedExternalResource {
+public class GfshCommandRule extends DescribedExternalResource {
 
   private Supplier<Integer> portSupplier;
   private PortType portType = PortType.jmxManager;
@@ -78,7 +78,7 @@
   private TemporaryFolder temporaryFolder = new TemporaryFolder();
   private File workingDir;
 
-  public GfshShellConnectionRule() {
+  public GfshCommandRule() {
     try {
       temporaryFolder.create();
     } catch (IOException e) {
@@ -86,7 +86,7 @@ public GfshShellConnectionRule() {
     }
   }
 
-  public GfshShellConnectionRule(Supplier<Integer> portSupplier, PortType portType) {
+  public GfshCommandRule(Supplier<Integer> portSupplier, PortType portType) {
     this();
     this.portType = portType;
     this.portSupplier = portSupplier;
diff --git a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/LuceneCommandsSecurityDUnitTest.java b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/LuceneCommandsSecurityDUnitTest.java
index 8de5ea1d9f..0606b10de7 100644
--- a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/LuceneCommandsSecurityDUnitTest.java
+++ b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/LuceneCommandsSecurityDUnitTest.java
@@ -44,7 +44,7 @@
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
 import org.apache.geode.test.junit.categories.SecurityTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category({DistributedTest.class, SecurityTest.class})
 @RunWith(JUnitParamsRunner.class)
@@ -54,7 +54,7 @@
   public LocatorServerStartupRule locatorServer = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfshShell = new GfshShellConnectionRule();
+  public GfshCommandRule gfshShell = new GfshCommandRule();
 
   private MemberVM locator;
 
@@ -84,8 +84,8 @@ public void before() throws Exception {
   @Parameters(method = "getCreateIndexUserNameAndExpectedResponses")
   public void verifyCreateIndexPermissions(UserNameAndExpectedResponse user) throws Exception {
     // Connect gfsh
-    this.gfshShell.secureConnectAndVerify(this.locator.getPort(),
-        GfshShellConnectionRule.PortType.locator, user.getUserName(), user.getUserName());
+    this.gfshShell.secureConnectAndVerify(this.locator.getPort(), GfshCommandRule.PortType.locator,
+        user.getUserName(), user.getUserName());
 
     // Attempt to create lucene index
     CommandResult result = this.gfshShell.executeCommand(getCreateIndexCommand());
@@ -108,8 +108,8 @@ public void verifySearchIndexPermissions(UserNameAndExpectedResponse user) throw
     createIndexAndRegion();
 
     // Connect gfsh
-    this.gfshShell.secureConnectAndVerify(this.locator.getPort(),
-        GfshShellConnectionRule.PortType.locator, user.getUserName(), user.getUserName());
+    this.gfshShell.secureConnectAndVerify(this.locator.getPort(), GfshCommandRule.PortType.locator,
+        user.getUserName(), user.getUserName());
 
     // Attempt to search lucene index
     CommandResult result = this.gfshShell.executeCommand(getSearchIndexCommand());
@@ -132,8 +132,8 @@ public void verifyListIndexesPermissions(UserNameAndExpectedResponse user) throw
     createIndexAndRegion();
 
     // Connect gfsh
-    this.gfshShell.secureConnectAndVerify(this.locator.getPort(),
-        GfshShellConnectionRule.PortType.locator, user.getUserName(), user.getUserName());
+    this.gfshShell.secureConnectAndVerify(this.locator.getPort(), GfshCommandRule.PortType.locator,
+        user.getUserName(), user.getUserName());
 
     // Attempt to search lucene index
     CommandResult result = this.gfshShell.executeCommand(getListIndexesCommand());
@@ -156,8 +156,8 @@ public void verifyDescribeIndexPermissions(UserNameAndExpectedResponse user) thr
     createIndexAndRegion();
 
     // Connect gfsh
-    this.gfshShell.secureConnectAndVerify(this.locator.getPort(),
-        GfshShellConnectionRule.PortType.locator, user.getUserName(), user.getUserName());
+    this.gfshShell.secureConnectAndVerify(this.locator.getPort(), GfshCommandRule.PortType.locator,
+        user.getUserName(), user.getUserName());
 
     // Attempt to search lucene index
     CommandResult result = this.gfshShell.executeCommand(getDescribeIndexCommand());
@@ -181,8 +181,8 @@ public void verifyDestroyIndexPermissions(UserNameAndExpectedResponse user) thro
     createIndexAndRegion();
 
     // Connect gfsh
-    this.gfshShell.secureConnectAndVerify(this.locator.getPort(),
-        GfshShellConnectionRule.PortType.locator, user.getUserName(), user.getUserName());
+    this.gfshShell.secureConnectAndVerify(this.locator.getPort(), GfshCommandRule.PortType.locator,
+        user.getUserName(), user.getUserName());
 
     // Attempt to search lucene index
     CommandResult result = this.gfshShell.executeCommand(getDestroyIndexCommand());
@@ -193,8 +193,8 @@ public void verifyDestroyIndexPermissions(UserNameAndExpectedResponse user) thro
 
   private void createIndexAndRegion() throws Exception {
     // Connect gfsh to locator with permissions necessary to create an index and region
-    this.gfshShell.secureConnectAndVerify(this.locator.getPort(),
-        GfshShellConnectionRule.PortType.locator, "cluster,data", "cluster,data");
+    this.gfshShell.secureConnectAndVerify(this.locator.getPort(), GfshCommandRule.PortType.locator,
+        "cluster,data", "cluster,data");
 
     // Create lucene index
     this.gfshShell.executeAndAssertThat(getCreateIndexCommand()).statusIsSuccess();
diff --git a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsDUnitTest.java b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsDUnitTest.java
index 4f2f61fdc6..64c9ec050a 100755
--- a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsDUnitTest.java
+++ b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/cli/LuceneIndexCommandsDUnitTest.java
@@ -61,7 +61,7 @@
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.assertions.CommandResultAssert;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.serializable.SerializableTestName;
 
 @Category(DistributedTest.class)
@@ -70,7 +70,7 @@
 public class LuceneIndexCommandsDUnitTest implements Serializable {
 
   @Rule
-  public transient GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public transient GfshCommandRule gfsh = new GfshCommandRule();
 
   @Rule
   public LocatorServerStartupRule startupRule = new LocatorServerStartupRule();
@@ -88,7 +88,7 @@ public void before() throws Exception {
   }
 
   public void connect(MemberVM serverVM) throws Exception {
-    gfsh.connectAndVerify(serverVM.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+    gfsh.connectAndVerify(serverVM.getJmxPort(), GfshCommandRule.PortType.jmxManager);
   }
 
   @Test
diff --git a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/configuration/LuceneClusterConfigurationDUnitTest.java b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/configuration/LuceneClusterConfigurationDUnitTest.java
index 0c0f8ff94a..e7189e4465 100755
--- a/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/configuration/LuceneClusterConfigurationDUnitTest.java
+++ b/geode-lucene/src/test/java/org/apache/geode/cache/lucene/internal/configuration/LuceneClusterConfigurationDUnitTest.java
@@ -48,7 +48,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 
 @Category(DistributedTest.class)
@@ -58,7 +58,7 @@
   public LocatorServerStartupRule ls = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfshConnector = new GfshShellConnectionRule();
+  public GfshCommandRule gfshConnector = new GfshCommandRule();
 
   private MemberVM locator = null;
 
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/CreateAndDestroyGatewaySenderCommandsDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/CreateAndDestroyGatewaySenderCommandsDUnitTest.java
index 0594dd35d7..613b620ebe 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/CreateAndDestroyGatewaySenderCommandsDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/CreateAndDestroyGatewaySenderCommandsDUnitTest.java
@@ -46,7 +46,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class CreateAndDestroyGatewaySenderCommandsDUnitTest {
@@ -55,7 +55,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private MemberVM locatorSite1;
   private MemberVM locatorSite2;
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/CreateGatewayReceiverCommandDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/CreateGatewayReceiverCommandDUnitTest.java
index 287f9ea7a5..d8d7fdeb8e 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/CreateGatewayReceiverCommandDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/CreateGatewayReceiverCommandDUnitTest.java
@@ -49,7 +49,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 /**
  * DUnit tests for 'create gateway-receiver' command.
@@ -63,7 +63,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private MemberVM locatorSite1;
   private MemberVM locatorSite2;
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/CreateGatewaySenderCommandDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/CreateGatewaySenderCommandDUnitTest.java
index 21a89e59c0..61b78911fb 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/CreateGatewaySenderCommandDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/CreateGatewaySenderCommandDUnitTest.java
@@ -40,7 +40,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class CreateGatewaySenderCommandDUnitTest {
@@ -49,7 +49,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private MemberVM locatorSite1;
   private MemberVM locatorSite2;
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/DestroyGatewaySenderCommandDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/DestroyGatewaySenderCommandDUnitTest.java
index 5166bc7ddc..61f9163977 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/DestroyGatewaySenderCommandDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/DestroyGatewaySenderCommandDUnitTest.java
@@ -38,7 +38,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class DestroyGatewaySenderCommandDUnitTest {
@@ -47,7 +47,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private MemberVM locatorSite1;
   private MemberVM locatorSite2;
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/PauseGatewaySenderCommandDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/PauseGatewaySenderCommandDUnitTest.java
index 1b2e3f8ec1..fa1bf34d0a 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/PauseGatewaySenderCommandDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/PauseGatewaySenderCommandDUnitTest.java
@@ -44,7 +44,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class PauseGatewaySenderCommandDUnitTest {
@@ -53,7 +53,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private MemberVM locatorSite1;
   private MemberVM locatorSite2;
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/ResumeGatewaySenderCommandDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/ResumeGatewaySenderCommandDUnitTest.java
index a85604e263..df19f7306f 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/ResumeGatewaySenderCommandDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/ResumeGatewaySenderCommandDUnitTest.java
@@ -46,7 +46,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class ResumeGatewaySenderCommandDUnitTest {
@@ -55,7 +55,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private MemberVM locatorSite1;
   private MemberVM locatorSite2;
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StartGatewayReceiverCommandDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StartGatewayReceiverCommandDUnitTest.java
index 17b8106496..f7e2aa3da7 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StartGatewayReceiverCommandDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StartGatewayReceiverCommandDUnitTest.java
@@ -43,7 +43,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class StartGatewayReceiverCommandDUnitTest {
@@ -52,7 +52,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private MemberVM locatorSite1;
   private MemberVM locatorSite2;
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StartGatewaySenderCommandDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StartGatewaySenderCommandDUnitTest.java
index 2a41db35e4..a1fa23a3b9 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StartGatewaySenderCommandDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StartGatewaySenderCommandDUnitTest.java
@@ -44,7 +44,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class StartGatewaySenderCommandDUnitTest {
@@ -53,7 +53,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private MemberVM locatorSite1;
   private MemberVM locatorSite2;
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StatusGatewayReceiverCommandDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StatusGatewayReceiverCommandDUnitTest.java
index c863fe2b6b..760405a559 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StatusGatewayReceiverCommandDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StatusGatewayReceiverCommandDUnitTest.java
@@ -44,7 +44,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class StatusGatewayReceiverCommandDUnitTest {
@@ -53,7 +53,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private MemberVM locatorSite1;
   private MemberVM locatorSite2;
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StatusGatewaySenderCommandDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StatusGatewaySenderCommandDUnitTest.java
index d727040016..da9aab71d8 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StatusGatewaySenderCommandDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StatusGatewaySenderCommandDUnitTest.java
@@ -44,7 +44,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class StatusGatewaySenderCommandDUnitTest {
@@ -53,7 +53,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private MemberVM locatorSite1;
   private MemberVM locatorSite2;
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StopGatewayReceiverCommandDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StopGatewayReceiverCommandDUnitTest.java
index f3cd6768bf..ed6b016a46 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StopGatewayReceiverCommandDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StopGatewayReceiverCommandDUnitTest.java
@@ -44,7 +44,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class StopGatewayReceiverCommandDUnitTest {
@@ -53,7 +53,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private MemberVM locatorSite1;
   private MemberVM locatorSite2;
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StopGatewaySenderCommandDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StopGatewaySenderCommandDUnitTest.java
index 01bbddad3c..1b2174a976 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StopGatewaySenderCommandDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/StopGatewaySenderCommandDUnitTest.java
@@ -45,7 +45,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class StopGatewaySenderCommandDUnitTest {
@@ -54,7 +54,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private MemberVM locatorSite1;
   private MemberVM locatorSite2;
diff --git a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/WanCommandListDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/WanCommandListDUnitTest.java
index 39c6393997..3ab3cf8b85 100644
--- a/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/WanCommandListDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/internal/cache/wan/wancommand/WanCommandListDUnitTest.java
@@ -41,7 +41,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class WanCommandListDUnitTest {
@@ -52,7 +52,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private MemberVM locatorSite1;
   private MemberVM locatorSite2;
diff --git a/geode-wan/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigurationIndexWithFromClauseDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigurationIndexWithFromClauseDUnitTest.java
index 6c4c0c497a..894668d5c5 100644
--- a/geode-wan/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigurationIndexWithFromClauseDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigurationIndexWithFromClauseDUnitTest.java
@@ -31,7 +31,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 @RunWith(JUnitParamsRunner.class)
@@ -51,7 +51,7 @@
   public LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfshShellConnectionRule = new GfshShellConnectionRule();
+  public GfshCommandRule gfshCommandRule = new GfshCommandRule();
 
   private MemberVM locator = null;
 
@@ -65,12 +65,12 @@ public void before() throws Exception {
   public void indexCreatedWithEntrySetInFromClauseMustPersist(RegionShortcut regionShortcut)
       throws Exception {
     MemberVM vm1 = lsRule.startServerVM(1, locator.getPort());
-    gfshShellConnectionRule.connectAndVerify(locator);
+    gfshCommandRule.connectAndVerify(locator);
     createRegionUsingGfsh(REGION_NAME, regionShortcut, null);
     createIndexUsingGfsh("\"" + REGION_NAME + ".entrySet() z\"", "z.key", INDEX_NAME);
     String serverName = vm1.getName();
     CommandStringBuilder csb = new CommandStringBuilder(CliStrings.LIST_MEMBER);
-    gfshShellConnectionRule.executeAndAssertThat(csb.toString()).statusIsSuccess();
+    gfshCommandRule.executeAndAssertThat(csb.toString()).statusIsSuccess();
     lsRule.stopVM(1);
     lsRule.startServerVM(1, locator.getPort());
     verifyIndexRecreated(INDEX_NAME);
@@ -78,8 +78,8 @@ public void indexCreatedWithEntrySetInFromClauseMustPersist(RegionShortcut regio
 
   private void verifyIndexRecreated(String indexName) throws Exception {
     CommandStringBuilder csb = new CommandStringBuilder(CliStrings.LIST_INDEX);
-    gfshShellConnectionRule.executeAndAssertThat(csb.toString()).statusIsSuccess();
-    String resultAsString = gfshShellConnectionRule.getGfshOutput();
+    gfshCommandRule.executeAndAssertThat(csb.toString()).statusIsSuccess();
+    String resultAsString = gfshCommandRule.getGfshOutput();
     assertTrue(resultAsString.contains(indexName));
   }
 
@@ -89,7 +89,7 @@ private void createIndexUsingGfsh(String regionName, String expression, String i
     csb.addOption(CliStrings.CREATE_INDEX__EXPRESSION, expression);
     csb.addOption(CliStrings.CREATE_INDEX__REGION, regionName);
     csb.addOption(CliStrings.CREATE_INDEX__NAME, indexName);
-    gfshShellConnectionRule.executeAndAssertThat(csb.toString()).statusIsSuccess();
+    gfshCommandRule.executeAndAssertThat(csb.toString()).statusIsSuccess();
   }
 
   private void createRegionUsingGfsh(String regionName, RegionShortcut regionShortCut, String group)
@@ -98,6 +98,6 @@ private void createRegionUsingGfsh(String regionName, RegionShortcut regionShort
     csb.addOption(CliStrings.CREATE_REGION__REGION, regionName);
     csb.addOption(CliStrings.CREATE_REGION__REGIONSHORTCUT, regionShortCut.name());
     csb.addOptionWithValueCheck(CliStrings.GROUP, group);
-    gfshShellConnectionRule.executeAndAssertThat(csb.toString()).statusIsSuccess();
+    gfshCommandRule.executeAndAssertThat(csb.toString()).statusIsSuccess();
   }
 }
diff --git a/geode-wan/src/test/java/org/apache/geode/management/internal/configuration/WANClusterConfigurationDUnitTest.java b/geode-wan/src/test/java/org/apache/geode/management/internal/configuration/WANClusterConfigurationDUnitTest.java
index e42573d60f..63cc2128d4 100644
--- a/geode-wan/src/test/java/org/apache/geode/management/internal/configuration/WANClusterConfigurationDUnitTest.java
+++ b/geode-wan/src/test/java/org/apache/geode/management/internal/configuration/WANClusterConfigurationDUnitTest.java
@@ -34,7 +34,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category({DistributedTest.class})
 @SuppressWarnings("serial")
@@ -44,7 +44,7 @@
   public LocatorServerStartupRule locatorServerStartupRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private static final String REPLICATE_REGION = "ReplicateRegion1";
 
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/AlterRuntimeCommandDUnitTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/AlterRuntimeCommandDUnitTest.java
index c748b94e40..081ed72752 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/AlterRuntimeCommandDUnitTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/AlterRuntimeCommandDUnitTest.java
@@ -41,7 +41,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 @RunWith(JUnitParamsRunner.class)
@@ -51,7 +51,7 @@
       new LocatorServerStartupRule().withTempWorkingDir().withLogFile();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Rule
   public TemporaryFolder temporaryFolder = new TemporaryFolder();
@@ -83,9 +83,9 @@ public void testAlterRuntimeConfig(final boolean connectOverHttp) throws Excepti
     MemberVM server0 = startupRule.startServerAsJmxManager(0, props);
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(server0.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(server0.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(server0.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(server0.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_RUNTIME_CONFIG);
@@ -137,9 +137,9 @@ public void alterLogDiskSpaceLimitWithFileSizeLimitNotSet_OK(final boolean conne
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_RUNTIME_CONFIG);
@@ -173,9 +173,9 @@ public void alterLogDiskSpaceLimitWithFileSizeLimitSet_OK(final boolean connectO
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     CommandStringBuilder csbSetFileSizeLimit =
@@ -221,9 +221,9 @@ public void alterLogDiskSpaceLimitOnMember_OK(final boolean connectOverHttp) thr
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_RUNTIME_CONFIG);
@@ -264,9 +264,9 @@ public void alterLogDiskSpaceLimitOnGroup_OK(final boolean connectOverHttp) thro
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     final int TEST_LIMIT = 10;
@@ -314,9 +314,9 @@ public void alterLogFileSizeLimit_changesConfigOnAllServers(final boolean connec
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_RUNTIME_CONFIG);
@@ -352,9 +352,9 @@ public void alterLogFileSizeLimitNegative_errorCanNotSet(final boolean connectOv
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_RUNTIME_CONFIG);
@@ -382,9 +382,9 @@ public void alterLogFileSizeLimitTooBig_errorCanNotSet(final boolean connectOver
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_RUNTIME_CONFIG);
@@ -423,9 +423,9 @@ public void alterStatArchiveFile_updatesAllServerConfigs(final boolean connectOv
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     final String TEST_NAME = "statisticsArchive";
@@ -460,9 +460,9 @@ public void alterStatArchiveFileWithMember_updatesSelectedServerConfigs(
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     final String TEST_NAME = "statisticsArchive";
@@ -505,9 +505,9 @@ public void alterStatArchiveFileWithGroup_updatesSelectedServerConfigs(
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     final String TEST_NAME = "statisticsArchive";
@@ -549,9 +549,9 @@ public void alterStatSampleRate_updatesAllServerConfigs(final boolean connectOve
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_RUNTIME_CONFIG);
@@ -585,9 +585,9 @@ public void alterStatSampleRateWithMember_updatesSelectedServerConfigs(
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     final int TEST_RATE = 2000;
@@ -631,9 +631,9 @@ public void alterStatSampleRateWithGroup_updatesSelectedServerConfigs(
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     final int TEST_RATE = 2500;
@@ -678,9 +678,9 @@ public void alterStatisticSampleRateRangeIsEnforced(final boolean connectOverHtt
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_RUNTIME_CONFIG);
@@ -713,9 +713,9 @@ public void alterArchiveDiskSpaceLimit_updatesAllServerConfigs(final boolean con
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     final int TEST_LIMIT = 10;
@@ -752,9 +752,9 @@ public void alterArchiveDiskSpaceLimitWithMember_updatesSelectedServerConfigs(
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     final int TEST_LIMIT = 10;
@@ -799,9 +799,9 @@ public void alterArchiveDiskSpaceLimitWithGroup_updatesSelectedServerConfigs(
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     final int TEST_LIMIT = 25;
@@ -847,9 +847,9 @@ public void alterArchiveDiskSpaceLimitRangeIsEnforced(final boolean connectOverH
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_RUNTIME_CONFIG);
@@ -895,9 +895,9 @@ public void alterArchiveFileSizeLimit_updatesAllServerConfigs(final boolean conn
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     final int TEST_LIMIT = 10;
@@ -934,9 +934,9 @@ public void alterArchiveFileSizeLimitWithMember_updatesSelectedServerConfigs(
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     final int TEST_LIMIT = 10;
@@ -981,9 +981,9 @@ public void alterArchiveFileSizeLimitWithGroup_updatesSelectedServerConfigs(
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     final int TEST_LIMIT = 25;
@@ -1029,9 +1029,9 @@ public void alterArchiveFileSizeLimitRangeIsEnforced(final boolean connectOverHt
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_RUNTIME_CONFIG);
@@ -1064,9 +1064,9 @@ public void alterDisableStatisticSampling(final boolean connectOverHttp) throws
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_RUNTIME_CONFIG);
@@ -1105,9 +1105,9 @@ public void alterGroupWithoutOptions_needsRelevantParameter(final boolean connec
     MemberVM server2 = startupRule.startServerVM(2, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     server2.invoke(() -> {
@@ -1151,9 +1151,9 @@ public void alterMemberWithoutOptions_needsRelevantParameter(final boolean conne
     MemberVM server1 = startupRule.startServerVM(1, props, locator.getPort());
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_RUNTIME_CONFIG);
@@ -1182,9 +1182,9 @@ public void testAlterUpdatesSharedConfig(final boolean connectOverHttp) throws E
     MemberVM locator = startupRule.startLocatorVM(0);
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     Properties props = new Properties();
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ClusterConfigurationDUnitTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ClusterConfigurationDUnitTest.java
index f5ddf6229b..eda609aad8 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ClusterConfigurationDUnitTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ClusterConfigurationDUnitTest.java
@@ -36,7 +36,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 @RunWith(Parameterized.class)
@@ -45,7 +45,7 @@
   public LocatorServerStartupRule startupRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Rule
   public TemporaryFolder temporaryFolder = new TemporaryFolder();
@@ -63,7 +63,7 @@
   public void testStartServerAndExecuteCommands() throws Exception {
     MemberVM locator = startupRule.startLocatorVM(0);
     if (connectOverHttp) {
-      gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
       gfsh.connectAndVerify(locator);
     }
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpTest.java
index 80c60e6d02..69321241c1 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpTest.java
@@ -30,7 +30,7 @@
 import org.apache.geode.management.internal.cli.result.CommandResult;
 import org.apache.geode.test.compiler.ClassBuilder;
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.ServerStarterRule;
 
 @Category(IntegrationTest.class)
@@ -41,14 +41,14 @@
       new ServerStarterRule().withWorkingDir().withLogFile().withJMXManager().withAutoStart();
 
   @Rule
-  public GfshShellConnectionRule gfshRule = new GfshShellConnectionRule();
+  public GfshCommandRule gfshRule = new GfshCommandRule();
 
   @Rule
   public TemporaryFolder temporaryFolder = new TemporaryFolder();
 
   @Before
   public void before() throws Exception {
-    gfshRule.connectAndVerify(server.getHttpPort(), GfshShellConnectionRule.PortType.http);
+    gfshRule.connectAndVerify(server.getHttpPort(), GfshCommandRule.PortType.http);
   }
 
   @Test
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ConnectCommandIntegrationTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ConnectCommandIntegrationTest.java
index 1c7cdcb776..23015ce98f 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ConnectCommandIntegrationTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ConnectCommandIntegrationTest.java
@@ -21,7 +21,7 @@
 import org.junit.experimental.categories.Category;
 
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.LocatorStarterRule;
 
 @Category(IntegrationTest.class)
@@ -31,7 +31,7 @@
   public static LocatorStarterRule locator = new LocatorStarterRule().withAutoStart();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Test
   public void connectToLocator() throws Exception {
@@ -40,11 +40,11 @@ public void connectToLocator() throws Exception {
 
   @Test
   public void connectOverJmx() throws Exception {
-    gfsh.connectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+    gfsh.connectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
   }
 
   @Test
   public void connectOverHttp() throws Exception {
-    gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+    gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
   }
 }
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ConnectCommandWithSSLTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ConnectCommandWithSSLTest.java
index 0c1744b3bc..74c2b89624 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ConnectCommandWithSSLTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ConnectCommandWithSSLTest.java
@@ -70,7 +70,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class ConnectCommandWithSSLTest {
@@ -169,22 +169,22 @@ public void before() throws Exception {
   }
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Test
   public void connectWithNoSSL() throws Exception {
-    gfsh.connect(locator.getPort(), GfshShellConnectionRule.PortType.locator);
+    gfsh.connect(locator.getPort(), GfshCommandRule.PortType.locator);
     assertThat(gfsh.isConnected()).isFalse();
     // should fail at connecting to locator stage
     assertThat(gfsh.getGfshOutput()).doesNotContain("Connecting to Manager at");
     assertThat(gfsh.getGfshOutput())
         .contains("trying to connect a non-SSL-enabled client to an SSL-enabled locator");
 
-    gfsh.connect(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+    gfsh.connect(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     assertThat(gfsh.isConnected()).isFalse();
     assertThat(gfsh.getGfshOutput()).contains("non-JRMP server at remote endpoint");
 
-    gfsh.connect(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+    gfsh.connect(locator.getHttpPort(), GfshCommandRule.PortType.http);
     assertThat(gfsh.isConnected()).isFalse();
     assertThat(gfsh.getGfshOutput()).contains("Unexpected end of file from server");
   }
@@ -193,18 +193,18 @@ public void connectWithNoSSL() throws Exception {
   public void connectWithSSL() throws Exception {
     sslProperties.store(out, null);
 
-    gfsh.connect(locator.getPort(), GfshShellConnectionRule.PortType.locator,
-        "security-properties-file", sslConfigFile.getAbsolutePath());
+    gfsh.connect(locator.getPort(), GfshCommandRule.PortType.locator, "security-properties-file",
+        sslConfigFile.getAbsolutePath());
     assertThat(gfsh.isConnected()).isTrue();
     gfsh.disconnect();
 
-    gfsh.connect(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager,
+    gfsh.connect(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager,
         "security-properties-file", sslConfigFile.getAbsolutePath());
     assertThat(gfsh.isConnected()).isTrue();
     gfsh.disconnect();
 
-    gfsh.connect(locator.getHttpPort(), GfshShellConnectionRule.PortType.http,
-        "security-properties-file", sslConfigFile.getAbsolutePath(), "skip-ssl-validation", "true");
+    gfsh.connect(locator.getHttpPort(), GfshCommandRule.PortType.http, "security-properties-file",
+        sslConfigFile.getAbsolutePath(), "skip-ssl-validation", "true");
     assertThat(gfsh.isConnected()).isTrue();
   }
 
@@ -212,22 +212,22 @@ public void connectWithSSL() throws Exception {
   public void connectWithJmxSSL() throws Exception {
     jmxSslProperties.store(out, null);
     // can't connect locator
-    gfsh.connect(locator.getPort(), GfshShellConnectionRule.PortType.locator,
-        "security-properties-file", sslConfigFile.getAbsolutePath());
+    gfsh.connect(locator.getPort(), GfshCommandRule.PortType.locator, "security-properties-file",
+        sslConfigFile.getAbsolutePath());
     assertThat(gfsh.isConnected()).isFalse();
     assertThat(gfsh.getGfshOutput()).doesNotContain("Connecting to Manager at");
     assertThat(gfsh.getGfshOutput())
         .contains("trying to connect a non-SSL-enabled client to an SSL-enabled locator");
 
     // can connect to jmx
-    gfsh.connect(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager,
+    gfsh.connect(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager,
         "security-properties-file", sslConfigFile.getAbsolutePath());
     assertThat(gfsh.isConnected()).isTrue();
     gfsh.disconnect();
 
     // cannot connect to http
-    gfsh.connect(locator.getHttpPort(), GfshShellConnectionRule.PortType.http,
-        "security-properties-file", sslConfigFile.getAbsolutePath());
+    gfsh.connect(locator.getHttpPort(), GfshCommandRule.PortType.http, "security-properties-file",
+        sslConfigFile.getAbsolutePath());
     assertThat(gfsh.isConnected()).isFalse();
   }
 
@@ -241,20 +241,20 @@ public void connectWithJmxSSL() throws Exception {
   public void connectWithClusterSSL() throws Exception {
     clusterSslProperties.store(out, null);
     // can connect to locator and jmx
-    gfsh.connect(locator.getPort(), GfshShellConnectionRule.PortType.locator,
-        "security-properties-file", sslConfigFile.getAbsolutePath());
+    gfsh.connect(locator.getPort(), GfshCommandRule.PortType.locator, "security-properties-file",
+        sslConfigFile.getAbsolutePath());
     assertThat(gfsh.isConnected()).isTrue();
     gfsh.disconnect();
 
     // can connect to jmx
-    gfsh.connect(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager,
+    gfsh.connect(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager,
         "security-properties-file", sslConfigFile.getAbsolutePath());
     assertThat(gfsh.isConnected()).isTrue();
     gfsh.disconnect();
 
     // can connect to http
-    gfsh.connect(locator.getHttpPort(), GfshShellConnectionRule.PortType.http,
-        "security-properties-file", sslConfigFile.getAbsolutePath(), "skip-ssl-validation", "true");
+    gfsh.connect(locator.getHttpPort(), GfshCommandRule.PortType.http, "security-properties-file",
+        sslConfigFile.getAbsolutePath(), "skip-ssl-validation", "true");
     assertThat(gfsh.isConnected()).isTrue();
   }
 
@@ -262,18 +262,18 @@ public void connectWithClusterSSL() throws Exception {
   public void connectWithHttpSSL() throws Exception {
     httpSslProperties.store(out, null);
     // can connect to locator and jmx
-    gfsh.connect(locator.getPort(), GfshShellConnectionRule.PortType.locator,
-        "security-properties-file", sslConfigFile.getAbsolutePath());
+    gfsh.connect(locator.getPort(), GfshCommandRule.PortType.locator, "security-properties-file",
+        sslConfigFile.getAbsolutePath());
     assertThat(gfsh.isConnected()).isFalse();
 
     // cannot connect to jmx
-    gfsh.connect(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager,
+    gfsh.connect(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager,
         "security-properties-file", sslConfigFile.getAbsolutePath());
     assertThat(gfsh.isConnected()).isFalse();
 
     // can connect to http
-    gfsh.connect(locator.getHttpPort(), GfshShellConnectionRule.PortType.http,
-        "security-properties-file", sslConfigFile.getAbsolutePath(), "skip-ssl-validation", "true");
+    gfsh.connect(locator.getHttpPort(), GfshCommandRule.PortType.http, "security-properties-file",
+        sslConfigFile.getAbsolutePath(), "skip-ssl-validation", "true");
     assertThat(gfsh.isConnected()).isTrue();
   }
 
@@ -281,18 +281,18 @@ public void connectWithHttpSSL() throws Exception {
   public void connectWithHttpSSLAndSkipSSLValidation() throws Exception {
     httpSslPropertiesSkipValidation.store(out, null);
     // cannot connect to locator and jmx
-    gfsh.connect(locator.getPort(), GfshShellConnectionRule.PortType.locator,
-        "security-properties-file", sslConfigFile.getAbsolutePath());
+    gfsh.connect(locator.getPort(), GfshCommandRule.PortType.locator, "security-properties-file",
+        sslConfigFile.getAbsolutePath());
     assertThat(gfsh.isConnected()).isFalse();
 
     // cannot connect to jmx
-    gfsh.connect(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager,
+    gfsh.connect(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager,
         "security-properties-file", sslConfigFile.getAbsolutePath());
     assertThat(gfsh.isConnected()).isFalse();
 
     // can connect to http
-    gfsh.connect(locator.getHttpPort(), GfshShellConnectionRule.PortType.http,
-        "security-properties-file", sslConfigFile.getAbsolutePath(), "skip-ssl-validation", "true");
+    gfsh.connect(locator.getHttpPort(), GfshCommandRule.PortType.http, "security-properties-file",
+        sslConfigFile.getAbsolutePath(), "skip-ssl-validation", "true");
     assertThat(gfsh.isConnected()).isTrue();
   }
 
@@ -304,8 +304,8 @@ public void connectWithClusterAndJmxSSL() throws Exception {
     combined.store(out, null);
 
     // can connect to both locator and jmx
-    gfsh.connect(locator.getPort(), GfshShellConnectionRule.PortType.locator,
-        "security-properties-file", sslConfigFile.getAbsolutePath());
+    gfsh.connect(locator.getPort(), GfshCommandRule.PortType.locator, "security-properties-file",
+        sslConfigFile.getAbsolutePath());
     assertThat(gfsh.isConnected()).isTrue();
   }
 
@@ -315,13 +315,13 @@ public void connectWithSSLAndThenWithNoSSL() throws Exception {
     sslProperties.store(out, null);
 
     // can connect to both locator and jmx
-    gfsh.connect(locator.getPort(), GfshShellConnectionRule.PortType.locator,
-        "security-properties-file", sslConfigFile.getAbsolutePath());
+    gfsh.connect(locator.getPort(), GfshCommandRule.PortType.locator, "security-properties-file",
+        sslConfigFile.getAbsolutePath());
     assertThat(gfsh.isConnected()).isTrue();
     gfsh.disconnect();
 
     // reconnect again with no SSL should fail
-    gfsh.connect(locator.getPort(), GfshShellConnectionRule.PortType.locator);
+    gfsh.connect(locator.getPort(), GfshCommandRule.PortType.locator);
     assertThat(gfsh.isConnected()).isFalse();
     // it should fail at connecting to locator, not connecting to manager
     assertThat(gfsh.getGfshOutput()).doesNotContain("Connecting to Manager at");
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ConnectCommandWithSecurityTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ConnectCommandWithSecurityTest.java
index b0128a40bf..628ef1d865 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ConnectCommandWithSecurityTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ConnectCommandWithSecurityTest.java
@@ -22,7 +22,7 @@
 
 import org.apache.geode.security.SimpleTestSecurityManager;
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.LocatorStarterRule;
 
 @Category(IntegrationTest.class)
@@ -33,26 +33,26 @@
       new LocatorStarterRule().withSecurityManager(SimpleTestSecurityManager.class).withAutoStart();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Test
   public void connectToLocator() throws Exception {
-    gfsh.secureConnectAndVerify(locator.getPort(), GfshShellConnectionRule.PortType.locator,
-        "clusterRead", "clusterRead");
+    gfsh.secureConnectAndVerify(locator.getPort(), GfshCommandRule.PortType.locator, "clusterRead",
+        "clusterRead");
     gfsh.executeAndAssertThat("list members").statusIsSuccess();
   }
 
   @Test
   public void connectOverJmx() throws Exception {
-    gfsh.secureConnectAndVerify(locator.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager,
+    gfsh.secureConnectAndVerify(locator.getJmxPort(), GfshCommandRule.PortType.jmxManager,
         "clusterRead", "clusterRead");
     gfsh.executeAndAssertThat("list members").statusIsSuccess();
   }
 
   @Test
   public void connectOverHttp() throws Exception {
-    gfsh.secureConnectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http,
-        "clusterRead", "clusterRead");
+    gfsh.secureConnectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http, "clusterRead",
+        "clusterRead");
     gfsh.executeAndAssertThat("list members").statusIsSuccess();
   }
 }
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandDUnitTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandDUnitTest.java
index 370670b39e..a3d24cee25 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandDUnitTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConfigCommandDUnitTest.java
@@ -36,7 +36,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 @RunWith(JUnitParamsRunner.class)
@@ -46,7 +46,7 @@
       new LocatorServerStartupRule().withTempWorkingDir().withLogFile();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Rule
   public TemporaryFolder temporaryFolder = new TemporaryFolder();
@@ -61,9 +61,9 @@ public void testDescribeConfig(final boolean connectOverHttp) throws Exception {
     MemberVM server0 = startupRule.startServerAsJmxManager(0, localProps);
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(server0.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(server0.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(server0.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(server0.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     server0.invoke(() -> {
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommandWithSecurityDUnitTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommandWithSecurityDUnitTest.java
index 3b9084231a..87f3b34a05 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommandWithSecurityDUnitTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ExecuteFunctionCommandWithSecurityDUnitTest.java
@@ -17,8 +17,8 @@
 
 import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_MANAGER;
 import static org.apache.geode.management.internal.security.TestFunctions.ReadFunction;
-import static org.apache.geode.test.junit.rules.GfshShellConnectionRule.PortType.http;
-import static org.apache.geode.test.junit.rules.GfshShellConnectionRule.PortType.jmxManager;
+import static org.apache.geode.test.junit.rules.GfshCommandRule.PortType.http;
+import static org.apache.geode.test.junit.rules.GfshCommandRule.PortType.jmxManager;
 import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.Properties;
@@ -36,7 +36,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class ExecuteFunctionCommandWithSecurityDUnitTest {
@@ -44,7 +44,7 @@
   public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   private static MemberVM locator;
 
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ExportConfigCommandDUnitTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ExportConfigCommandDUnitTest.java
index a8504de19f..1ab1fba314 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ExportConfigCommandDUnitTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ExportConfigCommandDUnitTest.java
@@ -35,7 +35,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 @RunWith(JUnitParamsRunner.class)
@@ -45,7 +45,7 @@
       new LocatorServerStartupRule().withTempWorkingDir().withLogFile();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Rule
   public TemporaryFolder temporaryFolder = new TemporaryFolder();
@@ -59,9 +59,9 @@ public void testExportConfig(final boolean connectOverHttp) throws Exception {
     MemberVM server0 = startupRule.startServerAsEmbededLocator(0, props);
 
     if (connectOverHttp) {
-      gfsh.connectAndVerify(server0.getHttpPort(), GfshShellConnectionRule.PortType.http);
+      gfsh.connectAndVerify(server0.getHttpPort(), GfshCommandRule.PortType.http);
     } else {
-      gfsh.connectAndVerify(server0.getJmxPort(), GfshShellConnectionRule.PortType.jmxManager);
+      gfsh.connectAndVerify(server0.getJmxPort(), GfshCommandRule.PortType.jmxManager);
     }
 
     // start server1 and server2 in group2
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsOverHttpIntegrationTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsOverHttpIntegrationTest.java
index 68527e265d..63ad379059 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsOverHttpIntegrationTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsOverHttpIntegrationTest.java
@@ -20,14 +20,14 @@
 import org.junit.experimental.categories.Category;
 
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(IntegrationTest.class)
 public class ExportLogsOverHttpIntegrationTest extends ExportLogsIntegrationTest {
 
   @Override
   public void connect() throws Exception {
-    gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+    gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
   }
 
   public File getWorkingDirectory() throws Exception {
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsStatsOverHttpDUnitTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsStatsOverHttpDUnitTest.java
index 0775259cb9..99793c460c 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsStatsOverHttpDUnitTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsStatsOverHttpDUnitTest.java
@@ -30,7 +30,7 @@
 import org.junit.rules.TemporaryFolder;
 
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class ExportLogsStatsOverHttpDUnitTest extends ExportLogsStatsDUnitTest {
@@ -41,7 +41,7 @@
   @Override
   public void connectIfNeeded() throws Exception {
     if (!connector.isConnected())
-      connector.connect(httpPort, GfshShellConnectionRule.PortType.http);
+      connector.connect(httpPort, GfshCommandRule.PortType.http);
   }
 
   @Test
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/FunctionCommandsOverHttpDUnitTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/FunctionCommandsOverHttpDUnitTest.java
index d1aacbba78..55285d5ed4 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/FunctionCommandsOverHttpDUnitTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/FunctionCommandsOverHttpDUnitTest.java
@@ -19,12 +19,12 @@
 
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class FunctionCommandsOverHttpDUnitTest extends FunctionCommandsDUnitTest {
   @Override
   public void connectGfsh(MemberVM vm) throws Exception {
-    gfsh.connectAndVerify(vm.getHttpPort(), GfshShellConnectionRule.PortType.http);
+    gfsh.connectAndVerify(vm.getHttpPort(), GfshCommandRule.PortType.http);
   }
 }
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/IndexCommandOverHttpTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/IndexCommandOverHttpTest.java
index 64b27076ad..abe94802dc 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/IndexCommandOverHttpTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/IndexCommandOverHttpTest.java
@@ -18,13 +18,13 @@
 import org.junit.experimental.categories.Category;
 
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.Server;
 
 @Category(IntegrationTest.class)
 public class IndexCommandOverHttpTest extends IndexCommandsIntegrationTest {
   @Override
   public void connect(Server server) throws Exception {
-    gfsh.connectAndVerify(server.getHttpPort(), GfshShellConnectionRule.PortType.http);
+    gfsh.connectAndVerify(server.getHttpPort(), GfshCommandRule.PortType.http);
   }
 }
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ListIndexCommandOverHttpDUnitTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ListIndexCommandOverHttpDUnitTest.java
index 0c15a52bc9..64fae9af88 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ListIndexCommandOverHttpDUnitTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/ListIndexCommandOverHttpDUnitTest.java
@@ -19,12 +19,12 @@
 
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
 public class ListIndexCommandOverHttpDUnitTest extends ListIndexCommandDUnitTest {
   @Override
   public void connectGfsh(MemberVM vm) throws Exception {
-    gfsh.connectAndVerify(vm.getHttpPort(), GfshShellConnectionRule.PortType.http);
+    gfsh.connectAndVerify(vm.getHttpPort(), GfshCommandRule.PortType.http);
   }
 }
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/security/GfshCommandsOverHttpSecurityTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/security/GfshCommandsOverHttpSecurityTest.java
index 74e9277c2e..2b60a8f795 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/security/GfshCommandsOverHttpSecurityTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/security/GfshCommandsOverHttpSecurityTest.java
@@ -19,12 +19,11 @@
 
 import org.apache.geode.test.junit.categories.IntegrationTest;
 import org.apache.geode.test.junit.categories.SecurityTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category({IntegrationTest.class, SecurityTest.class})
 public class GfshCommandsOverHttpSecurityTest extends GfshCommandsSecurityTest {
   public GfshCommandsOverHttpSecurityTest() {
-    gfshConnection = new GfshShellConnectionRule(serverStarter::getHttpPort,
-        GfshShellConnectionRule.PortType.http);
+    gfshConnection = new GfshCommandRule(serverStarter::getHttpPort, GfshCommandRule.PortType.http);
   }
 }
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/security/LogNoPasswordTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/security/LogNoPasswordTest.java
index 97f2a96717..fa63d07bbc 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/security/LogNoPasswordTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/security/LogNoPasswordTest.java
@@ -33,7 +33,7 @@
 import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(IntegrationTest.class)
 public class LogNoPasswordTest {
@@ -43,7 +43,7 @@
   public LocatorServerStartupRule lsRule = new LocatorServerStartupRule().withLogFile();
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Test
   public void testPasswordInLogs() throws Exception {
@@ -51,7 +51,7 @@ public void testPasswordInLogs() throws Exception {
     properties.setProperty(LOG_LEVEL, "debug");
     properties.setProperty(SECURITY_MANAGER, MySecurityManager.class.getName());
     MemberVM locator = lsRule.startLocatorVM(0, properties);
-    gfsh.secureConnectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http, "any",
+    gfsh.secureConnectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http, "any",
         PASSWORD);
     gfsh.executeAndAssertThat("list members").statusIsSuccess();
 
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/web/shell/HttpOperationInvokerMBeanOperationTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/web/shell/HttpOperationInvokerMBeanOperationTest.java
index ab11dddfad..71f92f3ab3 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/web/shell/HttpOperationInvokerMBeanOperationTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/web/shell/HttpOperationInvokerMBeanOperationTest.java
@@ -34,7 +34,7 @@
 import org.apache.geode.management.DistributedSystemMXBean;
 import org.apache.geode.management.internal.ManagementConstants;
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.LocatorStarterRule;
 
 @Category(IntegrationTest.class)
@@ -46,11 +46,11 @@
   private HttpOperationInvoker invoker;
 
   @Rule
-  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public GfshCommandRule gfsh = new GfshCommandRule();
 
   @Before
   public void before() throws Exception {
-    gfsh.connectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http);
+    gfsh.connectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http);
     invoker = (HttpOperationInvoker) gfsh.getGfsh().getOperationInvoker();
   }
 
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/web/shell/HttpOperationInvokerSecurityTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/web/shell/HttpOperationInvokerSecurityTest.java
index 1a352ed9a6..fef7bbe8ad 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/web/shell/HttpOperationInvokerSecurityTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/web/shell/HttpOperationInvokerSecurityTest.java
@@ -37,7 +37,7 @@
 import org.apache.geode.security.NotAuthorizedException;
 import org.apache.geode.security.SimpleTestSecurityManager;
 import org.apache.geode.test.junit.categories.IntegrationTest;
-import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
 import org.apache.geode.test.junit.rules.LocatorStarterRule;
 
 @Category(IntegrationTest.class)
@@ -48,15 +48,15 @@
       new LocatorStarterRule().withSecurityManager(SimpleTestSecurityManager.class).withAutoStart();
 
   @ClassRule
-  public static GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+  public static GfshCommandRule gfsh = new GfshCommandRule();
 
   private static HttpOperationInvoker invoker;
   private static CommandRequest request;
 
   @Test
   public void performBeanOperationsHasAuthorizationCheck() throws Exception {
-    gfsh.secureConnectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http,
-        "test", "test");
+    gfsh.secureConnectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http, "test",
+        "test");
     invoker = (HttpOperationInvoker) gfsh.getGfsh().getOperationInvoker();
 
     Integer distributedSystemId =
@@ -84,8 +84,8 @@ public void performBeanOperationsHasAuthorizationCheck() throws Exception {
 
   @Test
   public void processCommandHasAuthorizationCheck() throws Exception {
-    gfsh.secureConnectAndVerify(locator.getHttpPort(), GfshShellConnectionRule.PortType.http,
-        "test", "test");
+    gfsh.secureConnectAndVerify(locator.getHttpPort(), GfshCommandRule.PortType.http, "test",
+        "test");
 
     invoker = (HttpOperationInvoker) gfsh.getGfsh().getOperationInvoker();
 


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 576bf716cbe75cff49e492bf800d84f525321b38 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=576bf71 ]

GEODE-3539: rename GfshShellConnectionRule to GfshCommandRule (#1051)



jdeppe-pivotal commented on a change in pull request #1052: GEODE-3539: Add missing test coverage for 'list regions' and 'describe region' commands
URL: https://github.com/apache/geode/pull/1052#discussion_r150873828
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListRegionDUnitTest.java
 ##########
 @@ -0,0 +1,199 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.apache.geode.distributed.ConfigurationProperties.ENABLE_TIME_STATISTICS;
+import static org.apache.geode.distributed.ConfigurationProperties.GROUPS;
+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;
+import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;
+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;
+import static org.apache.geode.distributed.ConfigurationProperties.NAME;
+import static org.apache.geode.distributed.ConfigurationProperties.STATISTIC_SAMPLING_ENABLED;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.GROUP;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.LIST_REGION;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.MEMBER;
+
+import java.util.Properties;
+
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.CacheFactory;
+import org.apache.geode.cache.EvictionAction;
+import org.apache.geode.cache.EvictionAttributes;
+import org.apache.geode.cache.FixedPartitionAttributes;
+import org.apache.geode.cache.PartitionAttributes;
+import org.apache.geode.cache.PartitionAttributesFactory;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
+import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
+import org.apache.geode.test.junit.categories.DistributedTest;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+
+@Category(DistributedTest.class)
+public class ListRegionDUnitTest {
+  private static final String REGION1 = "region1";
+  private static final String REGION2 = "region2";
+  private static final String REGION3 = "region3";
+  private static final String SUBREGION1A = "subregion1A";
+  private static final String SUBREGION1B = "subregion1B";
+  private static final String SUBREGION1C = "subregion1C";
+  private static final String PR1 = "PR1";
+  private static final String LOCALREGIONONMANAGER = "LocalRegionOnManager";
+
+  @ClassRule
+  public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
+
+  @ClassRule
+  public static GfshShellConnectionRule gfshShellConnectionRule = new GfshShellConnectionRule();
+
+  @BeforeClass
+  public static void setupSystem() throws Exception {
 
 Review comment:
   There's a ton of setup in here that doesn't seem to be relevant to what is actually being tested. Can this be trimmed down to the minimum to get the tests to pass?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jdeppe-pivotal commented on a change in pull request #1052: GEODE-3539: Add missing test coverage for 'list regions' and 'describe region' commands
URL: https://github.com/apache/geode/pull/1052#discussion_r150873388
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListRegionDUnitTest.java
 ##########
 @@ -0,0 +1,199 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.apache.geode.distributed.ConfigurationProperties.ENABLE_TIME_STATISTICS;
+import static org.apache.geode.distributed.ConfigurationProperties.GROUPS;
+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;
+import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;
+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;
+import static org.apache.geode.distributed.ConfigurationProperties.NAME;
+import static org.apache.geode.distributed.ConfigurationProperties.STATISTIC_SAMPLING_ENABLED;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.GROUP;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.LIST_REGION;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.MEMBER;
+
+import java.util.Properties;
+
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.CacheFactory;
+import org.apache.geode.cache.EvictionAction;
+import org.apache.geode.cache.EvictionAttributes;
+import org.apache.geode.cache.FixedPartitionAttributes;
+import org.apache.geode.cache.PartitionAttributes;
+import org.apache.geode.cache.PartitionAttributesFactory;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
+import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
+import org.apache.geode.test.junit.categories.DistributedTest;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+
+@Category(DistributedTest.class)
+public class ListRegionDUnitTest {
+  private static final String REGION1 = "region1";
+  private static final String REGION2 = "region2";
+  private static final String REGION3 = "region3";
+  private static final String SUBREGION1A = "subregion1A";
+  private static final String SUBREGION1B = "subregion1B";
+  private static final String SUBREGION1C = "subregion1C";
+  private static final String PR1 = "PR1";
+  private static final String LOCALREGIONONMANAGER = "LocalRegionOnManager";
+
+  @ClassRule
+  public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
+
+  @ClassRule
+  public static GfshShellConnectionRule gfshShellConnectionRule = new GfshShellConnectionRule();
+
+  @BeforeClass
+  public static void setupSystem() throws Exception {
+    final Properties locatorProps = createProperties("Locator", "G3");
+    MemberVM locator = lsRule.startLocatorVM(0, locatorProps);
+
+    final Properties managerProps = createProperties("Manager", "G1");
+    managerProps.setProperty(LOCATORS, "localhost[" + locator.getPort() + "]");
+    MemberVM manager = lsRule.startServerVM(1, managerProps, locator.getPort());
 
 Review comment:
   This isn't really a manager, is it?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on a change in pull request #1052: GEODE-3539: Add missing test coverage for 'list regions' and 'describe region' commands
URL: https://github.com/apache/geode/pull/1052#discussion_r150885659
 
 

 ##########
 File path: geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListRegionCommand.java
 ##########
 @@ -110,4 +108,17 @@ public Result listRegion(
     }
     return result;
   }
+
+  public static class ListRegionInterceptor extends AbstractCliAroundInterceptor {
 
 Review comment:
   the call of getMember or findMember inside the command will throw an exception if both are set, so we don't really need to do the check here. I admit that this brings the validation to the client side, but it's a bit of a redundant code. I think we can afford to make that check on the server side if it makes the code a little cleaner.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on a change in pull request #1052: GEODE-3539: Add missing test coverage for 'list regions' and 'describe region' commands
URL: https://github.com/apache/geode/pull/1052#discussion_r150887072
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeRegionIntegrationTest.java
 ##########
 @@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule.PortType;
+import org.apache.geode.test.junit.rules.ServerStarterRule;
+
+@Category(IntegrationTest.class)
+public class DescribeRegionIntegrationTest {
+  private static String MEMBER_NAME = "test-server";
+  private static String REGION_NAME = "test-region";
+  private static String GROUP_NAME = "test-group";
+
+  @ClassRule
+  public static ServerStarterRule server = new ServerStarterRule()
+      .withRegion(RegionShortcut.REPLICATE, REGION_NAME).withName(MEMBER_NAME)
+      .withProperty("groups", GROUP_NAME).withJMXManager().withEmbeddedLocator().withAutoStart();
+
+  @Rule
+  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+
+  @Test
+  public void commandFailsWhenNotConnected() throws Exception {
+    gfsh.executeAndAssertThat("describe region").statusIsError()
+        .containsOutput("was found but is not currently available");
+  }
+
+  @Test
+  public void commandFailsWithoutNameOption() throws Exception {
 
 Review comment:
   just a minor point: invalid command that failed parser takes a long time to run in the dunit/integration test. Better put them in a unit test and uses GfshParserRule to test them.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pdxrunner opened a new pull request #1057: GEODE-3539: Correct typo in javadoc annotation
URL: https://github.com/apache/geode/pull/1057
 
 
   This cleans up a build warning.
   
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [X] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [X] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [X] Is your initial contribution a single, squashed commit?
   
   - [X] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 576bf716cbe75cff49e492bf800d84f525321b38 in geode's branch refs/heads/feature/GEODE-3940 from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=576bf71 ]

GEODE-3539: rename GfshShellConnectionRule to GfshCommandRule (#1051)



pdxrunner closed pull request #1057: GEODE-3539: Correct typo in javadoc annotation
URL: https://github.com/apache/geode/pull/1057
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java
index 7e4ae044df..02eb8b81a6 100755
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java
@@ -597,7 +597,7 @@ public static boolean contains(Object[] array, Object object) {
    *
    * @param regions
    * @param cache
-   * @param returnAll: if true, returns all matching members, otherwise, returns only one.
+   * @param returnAll if true, returns all matching members, otherwise, returns only one.
    */
   public static Set<DistributedMember> getQueryRegionsAssociatedMembers(Set<String> regions,
       final InternalCache cache, boolean returnAll) {


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 740ce79f025478d8773f3b14c60755621d10c551 in geode's branch refs/heads/develop from [~khowe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=740ce79 ]

GEODE-3539: Correct typo in javadoc annotation (#1057)



PurelyApplied commented on a change in pull request #1052: GEODE-3539: Add missing test coverage for 'list regions' and 'describe region' commands
URL: https://github.com/apache/geode/pull/1052#discussion_r151210741
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeRegionIntegrationTest.java
 ##########
 @@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule.PortType;
+import org.apache.geode.test.junit.rules.ServerStarterRule;
+
+@Category(IntegrationTest.class)
+public class DescribeRegionIntegrationTest {
+  private static String MEMBER_NAME = "test-server";
+  private static String REGION_NAME = "test-region";
+  private static String GROUP_NAME = "test-group";
+
+  @ClassRule
+  public static ServerStarterRule server = new ServerStarterRule()
+      .withRegion(RegionShortcut.REPLICATE, REGION_NAME).withName(MEMBER_NAME)
+      .withProperty("groups", GROUP_NAME).withJMXManager().withEmbeddedLocator().withAutoStart();
+
+  @Rule
+  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+
+  @Test
+  public void commandFailsWhenNotConnected() throws Exception {
+    gfsh.executeAndAssertThat("describe region").statusIsError()
+        .containsOutput("was found but is not currently available");
+  }
+
+  @Test
+  public void commandFailsWithoutNameOption() throws Exception {
 
 Review comment:
   Would that be preferable to just lowering the timeout on `HeadlessGfsh` for commands that should be executed quickly?  I see that the timeout is otherwise only set at instantiation of the `HeadlessGfsh` instance.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied commented on a change in pull request #1052: GEODE-3539: Add missing test coverage for 'list regions' and 'describe region' commands
URL: https://github.com/apache/geode/pull/1052#discussion_r151212588
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListRegionDUnitTest.java
 ##########
 @@ -0,0 +1,199 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.apache.geode.distributed.ConfigurationProperties.ENABLE_TIME_STATISTICS;
+import static org.apache.geode.distributed.ConfigurationProperties.GROUPS;
+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;
+import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;
+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;
+import static org.apache.geode.distributed.ConfigurationProperties.NAME;
+import static org.apache.geode.distributed.ConfigurationProperties.STATISTIC_SAMPLING_ENABLED;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.GROUP;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.LIST_REGION;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.MEMBER;
+
+import java.util.Properties;
+
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.CacheFactory;
+import org.apache.geode.cache.EvictionAction;
+import org.apache.geode.cache.EvictionAttributes;
+import org.apache.geode.cache.FixedPartitionAttributes;
+import org.apache.geode.cache.PartitionAttributes;
+import org.apache.geode.cache.PartitionAttributesFactory;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
+import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
+import org.apache.geode.test.junit.categories.DistributedTest;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+
+@Category(DistributedTest.class)
+public class ListRegionDUnitTest {
+  private static final String REGION1 = "region1";
+  private static final String REGION2 = "region2";
+  private static final String REGION3 = "region3";
+  private static final String SUBREGION1A = "subregion1A";
+  private static final String SUBREGION1B = "subregion1B";
+  private static final String SUBREGION1C = "subregion1C";
+  private static final String PR1 = "PR1";
+  private static final String LOCALREGIONONMANAGER = "LocalRegionOnManager";
+
+  @ClassRule
+  public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
+
+  @ClassRule
+  public static GfshShellConnectionRule gfshShellConnectionRule = new GfshShellConnectionRule();
+
+  @BeforeClass
+  public static void setupSystem() throws Exception {
 
 Review comment:
   Good catch.  I pulled this from a test that was testing both `list regions` and `describe region` and didn't look closely enough at it.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on a change in pull request #1052: GEODE-3539: Add missing test coverage for 'list regions' and 'describe region' commands
URL: https://github.com/apache/geode/pull/1052#discussion_r151238253
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeRegionIntegrationTest.java
 ##########
 @@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule;
+import org.apache.geode.test.junit.rules.GfshShellConnectionRule.PortType;
+import org.apache.geode.test.junit.rules.ServerStarterRule;
+
+@Category(IntegrationTest.class)
+public class DescribeRegionIntegrationTest {
+  private static String MEMBER_NAME = "test-server";
+  private static String REGION_NAME = "test-region";
+  private static String GROUP_NAME = "test-group";
+
+  @ClassRule
+  public static ServerStarterRule server = new ServerStarterRule()
+      .withRegion(RegionShortcut.REPLICATE, REGION_NAME).withName(MEMBER_NAME)
+      .withProperty("groups", GROUP_NAME).withJMXManager().withEmbeddedLocator().withAutoStart();
+
+  @Rule
+  public GfshShellConnectionRule gfsh = new GfshShellConnectionRule();
+
+  @Test
+  public void commandFailsWhenNotConnected() throws Exception {
+    gfsh.executeAndAssertThat("describe region").statusIsError()
+        .containsOutput("was found but is not currently available");
+  }
+
+  @Test
+  public void commandFailsWithoutNameOption() throws Exception {
 
 Review comment:
   yeah, that would be a good solution too.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied commented on a change in pull request #1052: GEODE-3539: Add missing test coverage for 'list regions' and 'describe region' commands
URL: https://github.com/apache/geode/pull/1052#discussion_r151263537
 
 

 ##########
 File path: geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListRegionCommand.java
 ##########
 @@ -110,4 +108,17 @@ public Result listRegion(
     }
     return result;
   }
+
+  public static class ListRegionInterceptor extends AbstractCliAroundInterceptor {
 
 Review comment:
   I think cleaner is better, too, but throwing inside the command server-side feels a little too close to the "exception as program flow" antipattern.  Exceptions should be exceptional, right?
   
   There's also the issue that such an exception then gets wrapped a couple of times, to result in the output
   ```
   Could not process command due to error. Error occurred while fetching list of regions. : Please provide either "member" or "group" option.
   ```
   This could be improved by a better message in the root exception, but still would have two confusing layers of output for something that is ultimately a User error, not a server-error.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied opened a new pull request #1065: GEODE-3539: Add missing test coverage to 'list disk-stores' and …
URL: https://github.com/apache/geode/pull/1065
 
 
   'describe disk-store' commands
   
   * Refactor cumbersome DUnit test to individual IntegrationTests
   * Added setTimeout to GfshCommandRule / HeadlessGfsh for quicker failure in bad parameter tests.
   
   ---
   
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on a change in pull request #1052: GEODE-3539: Add missing test coverage for 'list regions' and 'describe region' commands
URL: https://github.com/apache/geode/pull/1052#discussion_r151294390
 
 

 ##########
 File path: geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListRegionCommand.java
 ##########
 @@ -110,4 +108,17 @@ public Result listRegion(
     }
     return result;
   }
+
+  public static class ListRegionInterceptor extends AbstractCliAroundInterceptor {
 
 Review comment:
   You probably did not rebase to the current develop, I just made a change in CommandExecutor to process UserErrorException differently than general exception. That would probably ease your concern. 
   
   The getMemberXXX call would have to throw an exception anyway to catch the cases where some commands do not do that validation in their interceptors. 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on a change in pull request #1052: GEODE-3539: Add missing test coverage for 'list regions' and 'describe region' commands
URL: https://github.com/apache/geode/pull/1052#discussion_r151294390
 
 

 ##########
 File path: geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListRegionCommand.java
 ##########
 @@ -110,4 +108,17 @@ public Result listRegion(
     }
     return result;
   }
+
+  public static class ListRegionInterceptor extends AbstractCliAroundInterceptor {
 
 Review comment:
   You probably did not rebase to the current develop, I just made a change in CommandExecutor to process UserErrorException differently than general exception. That would probably ease your concern. 
   
   The getMemberXXX call would have to throw an exception anyway to catch the cases where some commands do not do that validation in their interceptors.  So that pair of throw/catch needs to exist anyway. But it's your call whether you add an interceptor to handle it for this command or not.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on a change in pull request #1052: GEODE-3539: Add missing test coverage for 'list regions' and 'describe region' commands
URL: https://github.com/apache/geode/pull/1052#discussion_r151294390
 
 

 ##########
 File path: geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListRegionCommand.java
 ##########
 @@ -110,4 +108,17 @@ public Result listRegion(
     }
     return result;
   }
+
+  public static class ListRegionInterceptor extends AbstractCliAroundInterceptor {
 
 Review comment:
   You probably did not rebase to the current develop, I just made a change in CommandExecutor to process UserErrorException differently than general exception. That would probably ease your concern. 
   
   The getMemberXXX call would have to throw an exception anyway to catch the cases where some commands do not do that validation in their interceptors.  So that pair of throw/catch needs to exist anyway. But it's your call whether you add an interceptor to handle it for this command or not.
   
   You are right Exceptions should be exceptional. We are trying to move the commands away from using getXXX calls (which throws an exception when not found) and uses findXXX which would either return null or empty list, and your code would handle what to return when nothing is found. But that's for another ticket.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on a change in pull request #1065: GEODE-3539: Add missing test coverage to 'list disk-stores' and …
URL: https://github.com/apache/geode/pull/1065#discussion_r151484942
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommandIntegrationTest.java
 ##########
 @@ -0,0 +1,112 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
+import org.apache.geode.test.junit.rules.ServerStarterRule;
+
+@Category(IntegrationTest.class)
+public class DescribeDiskStoreCommandIntegrationTest {
+  private static final String REGION_NAME = "test-region";
+  private static final String MEMBER_NAME = "testServer";
+  private static final String DISK_STORE_NAME = "testDiskStore";
+
+  private static final List<String> expectedData = Arrays.asList("Disk Store ID", "Disk Store Name",
+      "Member ID", "Member Name", "Allow Force Compaction", "Auto Compaction",
+      "Compaction Threshold", "Max Oplog Size", "Queue Size", "Time Interval", "Write Buffer Size",
+      "Disk Usage Warning Percentage", "Disk Usage Critical Percentage ",
+      "PDX Serialization Meta-Data Stored", "Disk Directory", "Size");
+
+  @ClassRule
+  public static ServerStarterRule server =
+      new ServerStarterRule().withRegion(RegionShortcut.REPLICATE, REGION_NAME)
+          .withName(MEMBER_NAME).withJMXManager().withEmbeddedLocator().withAutoStart();
+
+  @BeforeClass
+  public static void beforeClass() {
+    server.getCache().createDiskStoreFactory().create(DISK_STORE_NAME);
+  }
+
+  @Rule
+  public GfshCommandRule gfsh = new GfshCommandRule();
+
+  @Before
+  public void setTimeout() {
+    gfsh.setTimeout(1);
+  }
+
+  @Test
+  public void commandFailsWithoutOptions() throws Exception {
+    String cmd = "describe disk-store";
+    gfsh.connectAndVerify(server.getEmbeddedLocatorPort(), PortType.locator);
 
 Review comment:
   you can put your connectAndVerify in the beforeClass() method

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied opened a new pull request #1070: GEODE-3539: Add test coverage to 'alter disk-store'.
URL: https://github.com/apache/geode/pull/1070
 
 
   * Remove flaky testing from DiskStoreCommandsDUnitTest, converted to AlterDiskStoreDUnitTest
   * Added AlterDiskStoreIntegrationTest for testing of option conflict
   
   ---
   
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied commented on issue #1065: GEODE-3539: Add missing test coverage to 'list disk-stores' and …
URL: https://github.com/apache/geode/pull/1065#issuecomment-345398498
 
 
   Rebased and updated per requests, precheckin running.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied commented on issue #1052: GEODE-3539: Add missing test coverage for 'list regions' and 'describe region' commands
URL: https://github.com/apache/geode/pull/1052#issuecomment-345399727
 
 
   Rebased and updated per requests, precheckin running.
   
   Changes to `GfshCommandRule` and `HeadlessGfsh` copied directly from PR #1065.  Verify that no strange conflict exists before rebasing / merging.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied closed pull request #1024: GEODE-3539: Restore test coverage for 'describe connection' command.
URL: https://github.com/apache/geode/pull/1024
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConnectionCommandJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConnectionCommandJUnitTest.java
new file mode 100644
index 0000000000..7db73af5c9
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeConnectionCommandJUnitTest.java
@@ -0,0 +1,65 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.management.internal.cli.commands;
+
+import org.apache.logging.log4j.Logger;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
+import org.apache.geode.test.junit.rules.LocatorStarterRule;
+
+/**
+ * The GfshCommandJUnitTest class is a test suite of test cases testing the contract and
+ * functionality of the GfshCommand class for implementing GemFire shell (Gfsh) commands.
+ *
+ * @see org.apache.geode.management.internal.cli.commands.GfshCommand
+ * @see org.jmock.Expectations
+ * @see org.jmock.Mockery
+ * @see org.jmock.lib.legacy.ClassImposteriser
+ * @see org.junit.Assert
+ * @see org.junit.Test
+ * @since GemFire 7.0
+ */
+
+@Category(IntegrationTest.class)
+public class DescribeConnectionCommandJUnitTest {
+  public static Logger logger = LogService.getLogger();
+
+  @ClassRule
+  public static LocatorStarterRule locator = new LocatorStarterRule().withAutoStart();
+
+  @Rule
+  public GfshCommandRule gfsh = new GfshCommandRule();
+
+  @Test
+  public void describeConnectionTest() throws Exception {
+    gfsh.connectAndVerify(locator.getJmxPort(), PortType.jmxManager);
+    gfsh.executeAndAssertThat("describe connection").tableHasColumnWithValuesContaining(
+        "Connection Endpoints", gfsh.getGfsh().getOperationInvoker().toString());
+  }
+
+  @Test
+  public void executeWhileNotConnected() throws Exception {
+    gfsh.executeAndAssertThat("describe connection")
+        .tableHasColumnWithValuesContaining("Connection Endpoints", "Not connected");
+  }
+
+}


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit cd0b65aa0d476037000b3f24da359e0111529fe4 in geode's branch refs/heads/develop from [~prhomberg]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=cd0b65a ]

GEODE-3539: Restore and correct test coverage for 'describe connection' command.



PurelyApplied commented on issue #1065: GEODE-3539: Add missing test coverage to 'list disk-stores' and …
URL: https://github.com/apache/geode/pull/1065#issuecomment-345766272
 
 
   Precheckin green but merge conflicts need resolution.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied closed pull request #1052: GEODE-3539: Add missing test coverage for 'list regions' and 'describe region' commands
URL: https://github.com/apache/geode/pull/1052
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListRegionCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListRegionCommand.java
index 1ca310cc6f..cd58449cc2 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListRegionCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ListRegionCommand.java
@@ -16,9 +16,12 @@
 package org.apache.geode.management.internal.cli.commands;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.LinkedHashSet;
+import java.util.Objects;
 import java.util.Set;
 import java.util.TreeSet;
+import java.util.stream.Collectors;
 
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
@@ -29,7 +32,9 @@
 import org.apache.geode.management.cli.CliMetaData;
 import org.apache.geode.management.cli.ConverterHint;
 import org.apache.geode.management.cli.Result;
+import org.apache.geode.management.internal.cli.AbstractCliAroundInterceptor;
 import org.apache.geode.management.internal.cli.CliUtil;
+import org.apache.geode.management.internal.cli.GfshParseResult;
 import org.apache.geode.management.internal.cli.domain.RegionInformation;
 import org.apache.geode.management.internal.cli.functions.GetRegionsFunction;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
@@ -67,19 +72,11 @@ public Result listRegion(
       ArrayList<?> resultList = (ArrayList<?>) rc.getResult();
 
       if (resultList != null) {
-
-        for (Object resultObj : resultList) {
-          if (resultObj != null) {
-            if (resultObj instanceof Object[]) {
-              Object[] resultObjectArray = (Object[]) resultObj;
-              for (Object regionInfo : resultObjectArray) {
-                if (regionInfo instanceof RegionInformation) {
-                  regionInfoSet.add((RegionInformation) regionInfo);
-                }
-              }
-            }
-          }
-        }
+        // Gather all RegionInformation into a flat set.
+        regionInfoSet.addAll(resultList.stream().filter(Objects::nonNull)
+            .filter(Object[].class::isInstance).map(Object[].class::cast).flatMap(Arrays::stream)
+            .filter(RegionInformation.class::isInstance).map(RegionInformation.class::cast)
+            .collect(Collectors.toSet()));
 
         Set<String> regionNames = new TreeSet<>();
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/HeadlessGfsh.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/HeadlessGfsh.java
index 340712ca4f..97f600b658 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/HeadlessGfsh.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/HeadlessGfsh.java
@@ -121,7 +121,7 @@ public void handleExecutionResult(Object result, String sysout) {
   }
 
   public Object getResult() throws InterruptedException {
-    // Dont wait for when some command calls gfsh.stop();
+    // Don't wait for when some command calls gfsh.stop();
     if (shell.stopCalledThroughAPI)
       return null;
     try {
@@ -146,6 +146,10 @@ public void clear() {
     outputString = null;
   }
 
+  public void setTimeout(long timeout) {
+    this.timeout = timeout;
+  }
+
   public void clearEvents() {
     queue.clear();
     outputString = null;
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeRegionDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeRegionDUnitTest.java
similarity index 78%
rename from geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeRegionDUnitTest.java
rename to geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeRegionDUnitTest.java
index f85816e645..8e223394cd 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeRegionDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeRegionDUnitTest.java
@@ -59,7 +59,7 @@
 import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 @Category(DistributedTest.class)
-public class ListAndDescribeRegionDUnitTest implements Serializable {
+public class DescribeRegionDUnitTest implements Serializable {
   private static final String REGION1 = "region1";
   private static final String REGION2 = "region2";
   private static final String REGION3 = "region3";
@@ -69,6 +69,15 @@
   private static final String PR1 = "PR1";
   private static final String LOCALREGIONONMANAGER = "LocalRegionOnManager";
 
+  private static final String LOCATOR_NAME = "Locator";
+  private static final String SERVER1_NAME = "Server-1";
+  private static final String SERVER2_NAME = "Server-2";
+  private static final String GROUP1_NAME = "G1";
+  private static final String GROUP2_NAME = "G2";
+  private static final String GROUP3_NAME = "G3";
+  private static final String PART1_NAME = "Par1";
+  private static final String PART2_NAME = "Par2";
+
   @ClassRule
   public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
@@ -77,14 +86,14 @@
 
   @BeforeClass
   public static void setupSystem() throws Exception {
-    final Properties locatorProps = createProperties("Locator", "G3");
+    final Properties locatorProps = createProperties(LOCATOR_NAME, GROUP3_NAME);
     MemberVM locator = lsRule.startLocatorVM(0, locatorProps);
 
-    final Properties managerProps = createProperties("Manager", "G1");
+    final Properties managerProps = createProperties(SERVER1_NAME, GROUP1_NAME);
     managerProps.setProperty(LOCATORS, "localhost[" + locator.getPort() + "]");
     MemberVM manager = lsRule.startServerVM(1, managerProps, locator.getPort());
 
-    final Properties serverProps = createProperties("Server", "G2");
+    final Properties serverProps = createProperties(SERVER2_NAME, GROUP2_NAME);
     MemberVM server = lsRule.startServerVM(2, serverProps, locator.getPort());
 
     manager.invoke(() -> {
@@ -97,7 +106,8 @@ public static void setupSystem() throws Exception {
       dataRegionFactory.setEvictionAttributes(ea);
       dataRegionFactory.setEnableAsyncConflation(true);
 
-      FixedPartitionAttributes fpa = FixedPartitionAttributes.createFixedPartition("Par1", true);
+      FixedPartitionAttributes fpa =
+          FixedPartitionAttributes.createFixedPartition(PART1_NAME, true);
       PartitionAttributes pa = new PartitionAttributesFactory().setLocalMaxMemory(100)
           .setRecoveryDelay(2).setTotalMaxMemory(200).setRedundantCopies(1)
           .addFixedPartitionAttributes(fpa).create();
@@ -117,7 +127,7 @@ public static void setupSystem() throws Exception {
       dataRegionFactory.setEvictionAttributes(ea);
       dataRegionFactory.setEnableAsyncConflation(true);
 
-      FixedPartitionAttributes fpa = FixedPartitionAttributes.createFixedPartition("Par2", 4);
+      FixedPartitionAttributes fpa = FixedPartitionAttributes.createFixedPartition(PART2_NAME, 4);
       PartitionAttributes pa = new PartitionAttributesFactory().setLocalMaxMemory(150)
           .setRecoveryDelay(4).setTotalMaxMemory(200).setRedundantCopies(1)
           .addFixedPartitionAttributes(fpa).create();
@@ -131,46 +141,7 @@ public static void setupSystem() throws Exception {
   }
 
   @Test
-  public void listAllRegions() throws Exception {
-    String listRegions = new CommandStringBuilder(LIST_REGION).toString();
-    gfshCommandRule.executeAndAssertThat(listRegions).statusIsSuccess().containsOutput(PR1,
-        LOCALREGIONONMANAGER, REGION1, REGION2, REGION3);
-  }
-
-  @Test
-  public void listRegionsOnManager() throws Exception {
-    String listRegions =
-        new CommandStringBuilder(LIST_REGION).addOption(MEMBER, "Manager").toString();
-    gfshCommandRule.executeAndAssertThat(listRegions).statusIsSuccess().containsOutput(PR1,
-        LOCALREGIONONMANAGER);
-  }
-
-  @Test
-  public void listRegionsOnServer() throws Exception {
-    CommandStringBuilder csb = new CommandStringBuilder(LIST_REGION);
-    csb.addOption(MEMBER, "Server");
-    gfshCommandRule.executeAndAssertThat(csb.toString()).statusIsSuccess().containsOutput(PR1,
-        REGION1, REGION2, REGION3, SUBREGION1A);
-  }
-
-  @Test
-  public void listRegionsInGroup1() throws Exception {
-    CommandStringBuilder csb = new CommandStringBuilder(LIST_REGION);
-    csb.addOption(GROUP, "G1");
-    gfshCommandRule.executeAndAssertThat(csb.toString()).statusIsSuccess().containsOutput(PR1,
-        LOCALREGIONONMANAGER);
-  }
-
-  @Test
-  public void listRegionsInGroup2() throws Exception {
-    CommandStringBuilder csb = new CommandStringBuilder(LIST_REGION);
-    csb.addOption(GROUP, "G2");
-    gfshCommandRule.executeAndAssertThat(csb.toString()).statusIsSuccess().containsOutput(PR1,
-        REGION1, REGION2, REGION3, SUBREGION1A);
-  }
-
-  @Test
-  public void describeRegionsOnManager() throws Exception {
+  public void describeRegionsOnServer2() throws Exception {
     CommandStringBuilder csb = new CommandStringBuilder(DESCRIBE_REGION);
     csb.addOption(DESCRIBE_REGION__NAME, PR1);
     gfshCommandRule.executeAndAssertThat(csb.toString()).statusIsSuccess().containsOutput(PR1,
@@ -178,35 +149,31 @@ public void describeRegionsOnManager() throws Exception {
   }
 
   @Test
-  public void describeRegionsOnServer() throws Exception {
+  public void describeRegionsOnServer1() throws Exception {
     CommandStringBuilder csb = new CommandStringBuilder(DESCRIBE_REGION);
     csb.addOption(DESCRIBE_REGION__NAME, LOCALREGIONONMANAGER);
     gfshCommandRule.executeAndAssertThat(csb.toString()).statusIsSuccess()
-        .containsOutput(LOCALREGIONONMANAGER, "Manager");
+        .containsOutput(LOCALREGIONONMANAGER, SERVER1_NAME);
   }
 
   /**
    * Asserts that a describe region command issued on a region with compression returns the correct
    * non default region attribute for compression and the correct codec value.
    */
-  @Category(FlakyTest.class) // GEODE-1033: HeadlesssGFSH, random port, Snappy dependency
   @Test
   public void describeRegionWithCompressionCodec() throws Exception {
     final String regionName = "compressedRegion";
     VM vm = Host.getHost(0).getVM(1);
 
     // Create compressed region
-    vm.invoke(() -> {
-      createCompressedRegion(regionName);
-    });
+    vm.invoke(() -> createCompressedRegion(regionName));
 
     // Test the describe command; look for compression
     CommandStringBuilder csb = new CommandStringBuilder(DESCRIBE_REGION);
     csb.addOption(DESCRIBE_REGION__NAME, regionName);
     String commandString = csb.toString();
-    gfshCommandRule.executeAndAssertThat(csb.toString()).statusIsSuccess().containsOutput(
-        regionName, RegionAttributesNames.COMPRESSOR,
-        RegionEntryContext.DEFAULT_COMPRESSION_PROVIDER);
+    gfshCommandRule.executeAndAssertThat(commandString).statusIsSuccess().containsOutput(regionName,
+        RegionAttributesNames.COMPRESSOR, RegionEntryContext.DEFAULT_COMPRESSION_PROVIDER);
 
     // Destroy compressed region
     vm.invoke(() -> {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeRegionIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeRegionIntegrationTest.java
new file mode 100644
index 0000000000..e0f990f0e1
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeRegionIntegrationTest.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
+import org.apache.geode.test.junit.rules.ServerStarterRule;
+
+@Category(IntegrationTest.class)
+public class DescribeRegionIntegrationTest {
+  private static String MEMBER_NAME = "test-server";
+  private static String REGION_NAME = "test-region";
+  private static String GROUP_NAME = "test-group";
+
+  @ClassRule
+  public static ServerStarterRule server = new ServerStarterRule()
+      .withRegion(RegionShortcut.REPLICATE, REGION_NAME).withName(MEMBER_NAME)
+      .withProperty("groups", GROUP_NAME).withJMXManager().withEmbeddedLocator().withAutoStart();
+
+  @Rule
+  public GfshCommandRule gfsh = new GfshCommandRule();
+
+  @Test
+  public void commandFailsWhenNotConnected() throws Exception {
+    gfsh.executeAndAssertThat("describe region").statusIsError()
+        .containsOutput("was found but is not currently available");
+  }
+
+  @Test
+  public void commandFailsWithoutNameOption() throws Exception {
+    String cmd = "describe region";
+    gfsh.connectAndVerify(server.getEmbeddedLocatorPort(), PortType.locator);
+    gfsh.executeAndAssertThat(cmd).statusIsError().containsOutput("You should specify option");
+  }
+
+  @Test
+  public void commandFailsWithBadNameOption() throws Exception {
+    String cmd = "describe region --name=invalid-region-name";
+    gfsh.connectAndVerify(server.getEmbeddedLocatorPort(), PortType.locator);
+    gfsh.executeAndAssertThat(cmd).statusIsError().containsOutput("invalid-region-name not found");
+  }
+
+  @Test
+  public void commandSucceedsWithGoodNameOption() throws Exception {
+    String cmd = "describe region --name=" + REGION_NAME;
+    gfsh.connectAndVerify(server.getEmbeddedLocatorPort(), PortType.locator);
+    gfsh.executeAndAssertThat(cmd).statusIsSuccess().containsOutput("Name", "Data Policy",
+        "Hosting Members");
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListRegionDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListRegionDUnitTest.java
new file mode 100644
index 0000000000..4c4a5289c3
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListRegionDUnitTest.java
@@ -0,0 +1,176 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.apache.geode.distributed.ConfigurationProperties.ENABLE_TIME_STATISTICS;
+import static org.apache.geode.distributed.ConfigurationProperties.GROUPS;
+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;
+import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;
+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;
+import static org.apache.geode.distributed.ConfigurationProperties.NAME;
+import static org.apache.geode.distributed.ConfigurationProperties.STATISTIC_SAMPLING_ENABLED;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.GROUP;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.LIST_REGION;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.MEMBER;
+
+import java.util.Properties;
+
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.CacheFactory;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
+import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
+import org.apache.geode.test.junit.categories.DistributedTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+
+@Category(DistributedTest.class)
+public class ListRegionDUnitTest {
+  private static final String REGION1 = "region1";
+  private static final String REGION2 = "region2";
+  private static final String REGION3 = "region3";
+  private static final String SUBREGION1A = "subregion1A";
+  private static final String SUBREGION1B = "subregion1B";
+  private static final String SUBREGION1C = "subregion1C";
+  private static final String PR1 = "PR1";
+  private static final String LOCALREGIONONSERVER1 = "LocalRegionOnServer1";
+
+  private static final String SERVER1_NAME = "Server-1";
+  private static final String SERVER2_NAME = "Server-2";
+  private static final String LOCATOR_NAME = "Locator";
+  private static final String GROUP1_NAME = "G1";
+  private static final String GROUP2_NAME = "G2";
+  private static final String GROUP3_NAME = "G3";
+
+  @ClassRule
+  public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
+
+  @ClassRule
+  public static GfshCommandRule gfshShellConnectionRule = new GfshCommandRule();
+
+  @BeforeClass
+  public static void setupSystem() throws Exception {
+    final Properties locatorProps = createProperties(LOCATOR_NAME, GROUP3_NAME);
+    MemberVM locator = lsRule.startLocatorVM(0, locatorProps);
+
+    final Properties server1Props = createProperties(SERVER1_NAME, GROUP1_NAME);
+    server1Props.setProperty(LOCATORS, "localhost[" + locator.getPort() + "]");
+    MemberVM server1 = lsRule.startServerVM(1, server1Props, locator.getPort());
+
+    final Properties server2Props = createProperties(SERVER2_NAME, GROUP2_NAME);
+    MemberVM server = lsRule.startServerVM(2, server2Props, locator.getPort());
+
+    server1.invoke(() -> {
+      final Cache cache = CacheFactory.getAnyInstance();
+      RegionFactory<String, Integer> dataRegionFactory =
+          cache.createRegionFactory(RegionShortcut.PARTITION);
+      dataRegionFactory.create(PR1);
+      createLocalRegion(LOCALREGIONONSERVER1);
+    });
+
+    server.invoke(() -> {
+      final Cache cache = CacheFactory.getAnyInstance();
+      RegionFactory<String, Integer> dataRegionFactory =
+          cache.createRegionFactory(RegionShortcut.PARTITION);
+      dataRegionFactory.create(PR1);
+      createRegionsWithSubRegions();
+    });
+
+    gfshShellConnectionRule.connectAndVerify(locator);
+  }
+
+  @Test
+  public void listAllRegions() throws Exception {
+    String listRegions = new CommandStringBuilder(LIST_REGION).toString();
+    gfshShellConnectionRule.executeAndAssertThat(listRegions).statusIsSuccess().containsOutput(PR1,
+        LOCALREGIONONSERVER1, REGION1, REGION2, REGION3);
+  }
+
+  @Test
+  public void listRegionsOnManager() throws Exception {
+    String listRegions =
+        new CommandStringBuilder(LIST_REGION).addOption(MEMBER, SERVER1_NAME).toString();
+    gfshShellConnectionRule.executeAndAssertThat(listRegions).statusIsSuccess().containsOutput(PR1,
+        LOCALREGIONONSERVER1);
+  }
+
+  @Test
+  public void listRegionsOnServer() throws Exception {
+    CommandStringBuilder csb = new CommandStringBuilder(LIST_REGION);
+    csb.addOption(MEMBER, SERVER2_NAME);
+    gfshShellConnectionRule.executeAndAssertThat(csb.toString()).statusIsSuccess()
+        .containsOutput(PR1, REGION1, REGION2, REGION3, SUBREGION1A);
+  }
+
+  @Test
+  public void listRegionsInGroup1() throws Exception {
+    CommandStringBuilder csb = new CommandStringBuilder(LIST_REGION);
+    csb.addOption(GROUP, GROUP1_NAME);
+    gfshShellConnectionRule.executeAndAssertThat(csb.toString()).statusIsSuccess()
+        .containsOutput(PR1, LOCALREGIONONSERVER1);
+  }
+
+  @Test
+  public void listRegionsInGroup2() throws Exception {
+    CommandStringBuilder csb = new CommandStringBuilder(LIST_REGION);
+    csb.addOption(GROUP, GROUP2_NAME);
+    gfshShellConnectionRule.executeAndAssertThat(csb.toString()).statusIsSuccess()
+        .containsOutput(PR1, REGION1, REGION2, REGION3, SUBREGION1A);
+  }
+
+
+  private static Properties createProperties(String name, String groups) {
+    Properties props = new Properties();
+    props.setProperty(MCAST_PORT, "0");
+    props.setProperty(LOG_LEVEL, "info");
+    props.setProperty(STATISTIC_SAMPLING_ENABLED, "true");
+    props.setProperty(ENABLE_TIME_STATISTICS, "true");
+    props.setProperty(NAME, name);
+    props.setProperty(GROUPS, groups);
+    return props;
+  }
+
+  private static void createLocalRegion(final String regionName) {
+    final Cache cache = CacheFactory.getAnyInstance();
+    // Create the data region
+    RegionFactory<String, Integer> dataRegionFactory =
+        cache.createRegionFactory(RegionShortcut.LOCAL);
+    dataRegionFactory.create(regionName);
+  }
+
+  private static void createRegionsWithSubRegions() {
+    final Cache cache = CacheFactory.getAnyInstance();
+
+    RegionFactory<String, Integer> dataRegionFactory =
+        cache.createRegionFactory(RegionShortcut.REPLICATE);
+    dataRegionFactory.setConcurrencyLevel(3);
+    Region<String, Integer> region1 = dataRegionFactory.create(REGION1);
+    region1.createSubregion(SUBREGION1C, region1.getAttributes());
+    Region<String, Integer> subregion2 =
+        region1.createSubregion(SUBREGION1A, region1.getAttributes());
+
+    subregion2.createSubregion(SUBREGION1B, subregion2.getAttributes());
+    dataRegionFactory.create(REGION2);
+    dataRegionFactory.create(REGION3);
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListRegionIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListRegionIntegrationTest.java
new file mode 100644
index 0000000000..673ebf020c
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListRegionIntegrationTest.java
@@ -0,0 +1,84 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import org.junit.Before;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
+import org.apache.geode.test.junit.rules.ServerStarterRule;
+
+@Category(IntegrationTest.class)
+public class ListRegionIntegrationTest {
+  private static String MEMBER_NAME = "test-server";
+  private static String REGION_NAME = "test-region";
+  private static String GROUP_NAME = "test-group";
+  private static String OUTPUT_HEADER = "List of regions";
+
+  @ClassRule
+  public static ServerStarterRule server = new ServerStarterRule()
+      .withRegion(RegionShortcut.REPLICATE, REGION_NAME).withName(MEMBER_NAME)
+      .withProperty("groups", GROUP_NAME).withJMXManager().withAutoStart();
+
+  @Rule
+  public GfshCommandRule gfsh = new GfshCommandRule(server::getJmxPort, PortType.jmxManager);
+
+  @Before
+  public void setup() {
+    gfsh.setTimeout(2);
+  }
+
+  @Test
+  public void commandFailsWhenNotConnected() throws Exception {
+    gfsh.disconnect();
+    gfsh.executeAndAssertThat("list regions").statusIsError()
+        .containsOutput("was found but is not currently available");
+  }
+
+  @Test
+  public void memberAndGroupAreMutuallyExclusive() throws Exception {
+    String cmd = "list regions --member=" + MEMBER_NAME + " --group=" + GROUP_NAME;
+    gfsh.executeAndAssertThat(cmd).statusIsError()
+        .containsOutput("Please provide either \"member\" or \"group\" option.");
+  }
+
+  @Test
+  public void commandWithNoOptionsSucceeds() throws Exception {
+    String cmd = "list regions";
+    gfsh.executeAndAssertThat(cmd).statusIsSuccess()
+        .tableHasColumnWithValuesContaining(OUTPUT_HEADER, REGION_NAME);
+  }
+
+  @Test
+  public void commandWithMemberSucceeds() throws Exception {
+    String cmd = "list regions --member=" + MEMBER_NAME;
+    gfsh.executeAndAssertThat(cmd).statusIsSuccess()
+        .tableHasColumnWithValuesContaining(OUTPUT_HEADER, REGION_NAME);
+  }
+
+  @Test
+  public void commandWithGroupSucceeds() throws Exception {
+    String cmd = "list regions --group=" + GROUP_NAME;
+    gfsh.executeAndAssertThat(cmd).statusIsSuccess()
+        .tableHasColumnWithValuesContaining(OUTPUT_HEADER, REGION_NAME);
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshCommandRule.java b/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshCommandRule.java
index 358368488a..752b68fe67 100644
--- a/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshCommandRule.java
+++ b/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshCommandRule.java
@@ -215,7 +215,7 @@ public Gfsh getGfsh() {
 
   public CommandResult executeCommand(String command) {
     gfsh.executeCommand(command);
-    CommandResult result = null;
+    CommandResult result;
     try {
       result = (CommandResult) gfsh.getResult();
     } catch (InterruptedException e) {
@@ -262,6 +262,10 @@ public File getWorkingDir() {
     return workingDir;
   }
 
+  public void setTimeout(long timeoutInSeconds) {
+    gfsh.setTimeout(timeoutInSeconds);
+  }
+
   public enum PortType {
     locator, jmxManager, http
   }


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 526bcfc073d5cdc448d072269717743292248402 in geode's branch refs/heads/develop from [~prhomberg]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=526bcfc ]

GEODE-3539: Add missing test coverage for 'list regions' and 'describe region' commands

* Command logic flattened to stream.
* Testing of 'list region' and 'describe region' separated into distinct DUnit and Integration tests.  'list region' DUnit simplified.
* Removed @Flaky annotation from 'describe region' DUnit test

jinmeiliao commented on a change in pull request #1070: GEODE-3539: Add test coverage to 'alter disk-store'.
URL: https://github.com/apache/geode/pull/1070#discussion_r152189334
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreDUnitTest.java
 ##########
 @@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.Serializable;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.DataPolicy;
+import org.apache.geode.cache.EvictionAction;
+import org.apache.geode.cache.EvictionAttributes;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.Scope;
+import org.apache.geode.management.internal.cli.i18n.CliStrings;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
+import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
+import org.apache.geode.test.junit.categories.DistributedTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
+
+@Category(DistributedTest.class)
+public class AlterDiskStoreDUnitTest implements Serializable {
+  private static final String regionName = "region1";
+  private static final String diskStoreName = "disk-store1";
+  private static final String diskDirName = "diskStoreDir";
+  private static final String aKey = "key1";
+
+  private static MemberVM locator;
+  private static MemberVM server1;
+
+  @Rule
+  public LocatorServerStartupRule startupRule = new LocatorServerStartupRule().withTempWorkingDir();
 
 Review comment:
   withTempWorkingDir will cause VM to bounce after tests, do we really need it to be in tempWorkignDir. A regular rule will have a workingDir setup as well.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on a change in pull request #1070: GEODE-3539: Add test coverage to 'alter disk-store'.
URL: https://github.com/apache/geode/pull/1070#discussion_r152188911
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreIntegrationTest.java
 ##########
 @@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import java.io.IOException;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.management.internal.cli.i18n.CliStrings;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
+import org.apache.geode.test.junit.rules.ServerStarterRule;
+
+@Category(IntegrationTest.class)
+public class AlterDiskStoreIntegrationTest {
+  private static final String regionName = "region1";
+  private static final String memberName = "server";
+  private static final String diskStoreName = "disk-store1";
+
+  @Rule
+  public ServerStarterRule server =
 
 Review comment:
   this is an offline command, we don't really need a running locator/server to test it.
   
   Use GfshParserRule to test this validation.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on a change in pull request #1070: GEODE-3539: Add test coverage to 'alter disk-store'.
URL: https://github.com/apache/geode/pull/1070#discussion_r152189222
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreDUnitTest.java
 ##########
 @@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.Serializable;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.DataPolicy;
+import org.apache.geode.cache.EvictionAction;
+import org.apache.geode.cache.EvictionAttributes;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.Scope;
+import org.apache.geode.management.internal.cli.i18n.CliStrings;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
+import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
+import org.apache.geode.test.junit.categories.DistributedTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
+
+@Category(DistributedTest.class)
+public class AlterDiskStoreDUnitTest implements Serializable {
 
 Review comment:
   does this needs to be serializable?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 3a63e609136de4196e4ae4d808358b8dfb8b3116 in geode's branch refs/heads/develop from [~jens.deppe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=3a63e60 ]

GEODE-2567: Update AnalyzeSerializables

- This also includes a change for GEODE-3539


PurelyApplied closed pull request #1065: GEODE-3539: Add missing test coverage to 'list disk-stores' and …
URL: https://github.com/apache/geode/pull/1065
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommandIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommandIntegrationTest.java
new file mode 100644
index 0000000000..3edc944ce2
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommandIntegrationTest.java
@@ -0,0 +1,108 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
+import org.apache.geode.test.junit.rules.ServerStarterRule;
+
+@Category(IntegrationTest.class)
+public class DescribeDiskStoreCommandIntegrationTest {
+  private static final String REGION_NAME = "test-region";
+  private static final String MEMBER_NAME = "testServer";
+  private static final String DISK_STORE_NAME = "testDiskStore";
+
+  private static final List<String> expectedData = Arrays.asList("Disk Store ID", "Disk Store Name",
+      "Member ID", "Member Name", "Allow Force Compaction", "Auto Compaction",
+      "Compaction Threshold", "Max Oplog Size", "Queue Size", "Time Interval", "Write Buffer Size",
+      "Disk Usage Warning Percentage", "Disk Usage Critical Percentage ",
+      "PDX Serialization Meta-Data Stored", "Disk Directory", "Size");
+
+  @ClassRule
+  public static ServerStarterRule server =
+      new ServerStarterRule().withRegion(RegionShortcut.REPLICATE, REGION_NAME)
+          .withName(MEMBER_NAME).withJMXManager().withAutoStart();
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    server.getCache().createDiskStoreFactory().create(DISK_STORE_NAME);
+    gfsh.connectAndVerify(server.getJmxPort(), PortType.jmxManager);
+
+  }
+
+  @ClassRule
+  public static GfshCommandRule gfsh = new GfshCommandRule();
+
+  @Before
+  public void setTimeout() {
+    gfsh.setTimeout(1);
+  }
+
+  @Test
+  public void commandFailsWithoutOptions() throws Exception {
+    String cmd = "describe disk-store";
+    gfsh.executeAndAssertThat(cmd).statusIsError().containsOutput("You should specify option (",
+        "--name", "--member", ") for this command");
+
+  }
+
+  @Test
+  public void commandFailsWithOnlyMember() throws Exception {
+    String cmd = "describe disk-store --member=" + MEMBER_NAME;
+    gfsh.executeAndAssertThat(cmd).statusIsError().containsOutput("You should specify option (",
+        "--name", ") for this command");
+  }
+
+  @Test
+  public void commandFailsWithOnlyName() throws Exception {
+    String cmd = "describe disk-store --name=" + DISK_STORE_NAME;
+    gfsh.executeAndAssertThat(cmd).statusIsError().containsOutput("You should specify option (",
+        "--member", ") for this command");
+  }
+
+  @Test
+  public void commandFailsWithBadMember() throws Exception {
+    String cmd = "describe disk-store --member=invalid-member-name --name=" + DISK_STORE_NAME;
+    gfsh.executeAndAssertThat(cmd).statusIsError().containsOutput("Member",
+        "could not be found.  Please verify the member name or ID and try again.");
+  }
+
+  @Test
+  public void commandFailsWithBadName() throws Exception {
+    String cmd = "describe disk-store --name=invalid-diskstore-name --member=" + MEMBER_NAME;
+    gfsh.executeAndAssertThat(cmd).statusIsError().containsOutput("A disk store with name",
+        "was not found on member");
+  }
+
+  @Test
+  public void commandSucceedsWithNameAndMember() throws Exception {
+    String cmd = "describe disk-store --name=" + DISK_STORE_NAME + " --member=" + MEMBER_NAME;
+    gfsh.executeAndAssertThat(cmd).statusIsSuccess()
+        .containsOutput(expectedData.toArray(new String[0]));
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeDiskStoreCommandsDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeDiskStoreCommandsDUnitTest.java
deleted file mode 100644
index 0e9468cc3b..0000000000
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAndDescribeDiskStoreCommandsDUnitTest.java
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-package org.apache.geode.management.internal.cli.commands;
-
-import static org.apache.geode.distributed.ConfigurationProperties.NAME;
-import static org.apache.geode.test.dunit.Assert.assertEquals;
-import static org.apache.geode.test.dunit.Assert.assertNotNull;
-import static org.apache.geode.test.dunit.Host.getHost;
-import static org.apache.geode.test.dunit.LogWriterUtils.getDUnitLogLevel;
-import static org.apache.geode.test.dunit.LogWriterUtils.getLogWriter;
-import static org.assertj.core.api.Assertions.assertThat;
-
-import java.io.Serializable;
-import java.util.Properties;
-
-import org.junit.Test;
-import org.junit.experimental.categories.Category;
-
-import org.apache.geode.cache.Cache;
-import org.apache.geode.cache.DataPolicy;
-import org.apache.geode.cache.DiskStore;
-import org.apache.geode.cache.DiskStoreFactory;
-import org.apache.geode.cache.RegionFactory;
-import org.apache.geode.cache.Scope;
-import org.apache.geode.distributed.ConfigurationProperties;
-import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.i18n.CliStrings;
-import org.apache.geode.test.dunit.SerializableRunnable;
-import org.apache.geode.test.dunit.SerializableRunnableIF;
-import org.apache.geode.test.dunit.VM;
-import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.categories.FlakyTest;
-
-/**
- * The ListAndDescribeDiskStoreCommandsDUnitTest class is a test suite of functional tests cases
- * testing the proper functioning of the 'list disk-store' and 'describe disk-store' commands.
- * </p>
- *
- * @see org.apache.geode.management.internal.cli.commands.CliCommandTestBase
- * @see ListDiskStoresCommand
- * @see org.apache.geode.management.internal.cli.commands.DescribeDiskStoreCommand
- *
- * @since GemFire 7.0
- */
-@Category({DistributedTest.class, FlakyTest.class}) // GEODE-3530
-@SuppressWarnings("serial")
-public class ListAndDescribeDiskStoreCommandsDUnitTest extends CliCommandTestBase {
-
-  @Override
-  public final void postSetUpCliCommandTestBase() throws Exception {
-    setUpJmxManagerOnVm0ThenConnect(null);
-    setupGemFire();
-  }
-
-  @Test
-  public void testListDiskStore() throws Exception {
-    final Result result = executeCommand(CliStrings.LIST_DISK_STORE);
-
-    assertNotNull(result);
-    getLogWriter().info(toString(result));
-    assertEquals(Result.Status.OK, result.getStatus());
-  }
-
-  @Test
-  public void testDescribeDiskStore() throws Exception {
-    final Result result = executeCommand(
-        CliStrings.DESCRIBE_DISK_STORE + " --member=producerServer --name=producerData");
-
-    assertNotNull(result);
-    getLogWriter().info(toString(result));
-    assertEquals(Result.Status.OK, result.getStatus());
-  }
-
-  @Test
-  public void testDescribeDiskStoreWithInvalidMemberName() throws Exception {
-    final Result commandResult = executeCommand(
-        CliStrings.DESCRIBE_DISK_STORE + " --member=badMemberName --name=producerData");
-
-    assertNotNull(commandResult);
-    assertEquals(Result.Status.ERROR, commandResult.getStatus());
-    assertEquals(CliStrings.format(CliStrings.MEMBER_NOT_FOUND_ERROR_MESSAGE, "badMemberName"),
-        toString(commandResult));
-  }
-
-  @Test
-  public void testDescribeDiskStoreWithInvalidDiskStoreName() {
-    final Result commandResult = executeCommand(
-        CliStrings.DESCRIBE_DISK_STORE + " --member=producerServer --name=badDiskStoreName");
-
-    assertNotNull(commandResult);
-    assertEquals(Result.Status.ERROR, commandResult.getStatus());
-    assertThat(toString(commandResult)).contains(
-        "A disk store with name (badDiskStoreName) was not found on member (producerServer).");
-  }
-
-  private static String toString(final Result result) {
-    assert result != null : "The Result object from the command execution cannot be null!";
-
-    final StringBuilder buffer = new StringBuilder(System.getProperty("line.separator"));
-
-    while (result.hasNextLine()) {
-      buffer.append(result.nextLine());
-      buffer.append(System.getProperty("line.separator"));
-    }
-
-    return buffer.toString().trim();
-  }
-
-  private Peer createPeer(final Properties distributedSystemConfiguration, final VM vm) {
-    return new Peer(distributedSystemConfiguration, vm);
-  }
-
-  private void setupGemFire() throws Exception {
-    final VM vm1 = getHost(0).getVM(1);
-    final VM vm2 = getHost(0).getVM(2);
-
-    final Peer peer1 = createPeer(createDistributedSystemProperties("consumerServer"), vm1);
-    final Peer peer2 = createPeer(createDistributedSystemProperties("producerServer"), vm2);
-
-    createPersistentRegion(peer1, "consumers", "consumerData");
-    createPersistentRegion(peer1, "observers", "observerData");
-    createPersistentRegion(peer2, "producer", "producerData");
-    createPersistentRegion(peer2, "producer-factory", "producerData");
-  }
-
-  private Properties createDistributedSystemProperties(final String gemfireName) {
-    final Properties distributedSystemProperties = new Properties();
-
-    distributedSystemProperties.setProperty(ConfigurationProperties.LOG_LEVEL, getDUnitLogLevel());
-    distributedSystemProperties.setProperty(NAME, gemfireName);
-
-    return distributedSystemProperties;
-  }
-
-  private void createPersistentRegion(final Peer peer, final String regionName,
-      final String diskStoreName) throws Exception {
-    peer.run(new SerializableRunnable("Creating Persistent Region for Member " + peer.getName()) {
-      @Override
-      public void run() {
-        getSystem(peer.getDistributedSystemConfiguration());
-
-        final Cache cache = getCache();
-
-        DiskStore diskStore = cache.findDiskStore(diskStoreName);
-
-        if (diskStore == null) {
-          final DiskStoreFactory diskStoreFactory = cache.createDiskStoreFactory();
-          diskStoreFactory.setDiskDirs(getDiskDirs());
-          diskStore = diskStoreFactory.create(diskStoreName);
-        }
-
-        final RegionFactory regionFactory = cache.createRegionFactory();
-
-        regionFactory.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);
-        regionFactory.setDiskStoreName(diskStore.getName());
-        regionFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
-        regionFactory.create(regionName);
-      }
-    });
-  }
-
-  private static class Peer implements Serializable {
-
-    private final Properties distributedSystemConfiguration;
-    private final VM vm;
-
-    protected Peer(final Properties distributedSystemConfiguration, final VM vm) {
-      assert distributedSystemConfiguration != null : "The GemFire distributed system configuration properties cannot be null!";
-      this.distributedSystemConfiguration = distributedSystemConfiguration;
-      this.vm = vm;
-    }
-
-    public Properties getDistributedSystemConfiguration() {
-      return distributedSystemConfiguration;
-    }
-
-    public String getName() {
-      return getDistributedSystemConfiguration().getProperty(NAME);
-    }
-
-    public VM getVm() {
-      return vm;
-    }
-
-    public void run(final SerializableRunnableIF runnable) throws Exception {
-      if (getVm() == null) {
-        runnable.run();
-      } else {
-        getVm().invoke(runnable);
-      }
-    }
-  }
-}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListDiskStoreCommandIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListDiskStoreCommandIntegrationTest.java
new file mode 100644
index 0000000000..25ac49cdbe
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListDiskStoreCommandIntegrationTest.java
@@ -0,0 +1,69 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import org.junit.Before;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.DiskStore;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
+import org.apache.geode.test.junit.rules.ServerStarterRule;
+
+@Category(IntegrationTest.class)
+public class ListDiskStoreCommandIntegrationTest {
+  private static final String REGION_NAME = "test-region";
+  private static final String MEMBER_NAME = "testServer";
+  private static final String DISK_STORE_NAME = "testDiskStore";
+
+  @ClassRule
+  public static ServerStarterRule server =
+      new ServerStarterRule().withRegion(RegionShortcut.REPLICATE, REGION_NAME)
+          .withName(MEMBER_NAME).withJMXManager().withAutoStart();
+
+  @Rule
+  public GfshCommandRule gfsh = new GfshCommandRule();
+
+  @Before
+  public void setTimeout() {
+    gfsh.setTimeout(1);
+  }
+
+  @Test
+  public void commandSucceedsWhenConnected() throws Exception {
+    Cache cache = server.getCache();
+    DiskStore ds = cache.createDiskStoreFactory().create(DISK_STORE_NAME);
+
+    gfsh.connectAndVerify(server.getJmxPort(), PortType.jmxManager);
+    gfsh.executeAndAssertThat("list disk-stores").statusIsSuccess()
+        .tableHasColumnWithValuesContaining("Member Name", MEMBER_NAME)
+        .tableHasColumnWithValuesContaining("Member Id", server.getCache().getMyId().getId())
+        .tableHasColumnWithValuesContaining("Disk Store Name", DISK_STORE_NAME)
+        .tableHasColumnWithValuesContaining("Disk Store ID", ds.getDiskStoreUUID().toString());
+  }
+
+  @Test
+  public void commandFailsWhenNotConnected() throws Exception {
+    gfsh.executeAndAssertThat("list disk-stores").statusIsError().containsOutput("Command",
+        "was found but is not currently available");
+  }
+}
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpDUnitTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpDUnitTest.java
index 4073b00a72..4844e3550a 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpDUnitTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpDUnitTest.java
@@ -29,8 +29,7 @@
  */
 @Category({DistributedTest.class, SecurityTest.class})
 @RunWith(SuiteRunner.class)
-@Suite.SuiteClasses({GemfireDataCommandsDUnitTest.class,
-    ListAndDescribeDiskStoreCommandsDUnitTest.class, QueueCommandsDUnitTest.class,
+@Suite.SuiteClasses({GemfireDataCommandsDUnitTest.class, QueueCommandsDUnitTest.class,
     ShellCommandsDUnitTest.class, ShowStackTraceDUnitTest.class})
 public class CommandOverHttpDUnitTest {
   @ClassRule


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit f3a021991d239dfc05357d6250d937a90d971f32 in geode's branch refs/heads/develop from [~prhomberg]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=f3a0219 ]

GEODE-3539: Add missing test coverage to 'list disk-stores' and 'describe disk-stores' commands

* Refactor cumbersome DUnit test to individual IntegrationTests

PurelyApplied commented on a change in pull request #1070: GEODE-3539: Add test coverage to 'alter disk-store'.
URL: https://github.com/apache/geode/pull/1070#discussion_r152685714
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreDUnitTest.java
 ##########
 @@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.Serializable;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.DataPolicy;
+import org.apache.geode.cache.EvictionAction;
+import org.apache.geode.cache.EvictionAttributes;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.Scope;
+import org.apache.geode.management.internal.cli.i18n.CliStrings;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
+import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
+import org.apache.geode.test.junit.categories.DistributedTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
+
+@Category(DistributedTest.class)
+public class AlterDiskStoreDUnitTest implements Serializable {
 
 Review comment:
   I was running into some RMIs during testing and had thought that was the culprit, looking at other DUnits.  But it looks like I was wrong on that front, or the root cause was massaged out.  Will remove. 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied commented on a change in pull request #1070: GEODE-3539: Add test coverage to 'alter disk-store'.
URL: https://github.com/apache/geode/pull/1070#discussion_r152691736
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreIntegrationTest.java
 ##########
 @@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import java.io.IOException;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.management.internal.cli.i18n.CliStrings;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
+import org.apache.geode.test.junit.rules.ServerStarterRule;
+
+@Category(IntegrationTest.class)
+public class AlterDiskStoreIntegrationTest {
+  private static final String regionName = "region1";
+  private static final String memberName = "server";
+  private static final String diskStoreName = "disk-store1";
+
+  @Rule
+  public ServerStarterRule server =
 
 Review comment:
   Can the GfshParserRule do that?  I thought that rule only determined if the string could find the function to call, not to test the mutual exclusion of options within the code itself.
   
   Definitely don't need the server, though.  I missed that when I pulled this out of the DUnit.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied commented on a change in pull request #1070: GEODE-3539: Add test coverage to 'alter disk-store'.
URL: https://github.com/apache/geode/pull/1070#discussion_r152691736
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreIntegrationTest.java
 ##########
 @@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import java.io.IOException;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.management.internal.cli.i18n.CliStrings;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
+import org.apache.geode.test.junit.rules.ServerStarterRule;
+
+@Category(IntegrationTest.class)
+public class AlterDiskStoreIntegrationTest {
+  private static final String regionName = "region1";
+  private static final String memberName = "server";
+  private static final String diskStoreName = "disk-store1";
+
+  @Rule
+  public ServerStarterRule server =
 
 Review comment:
   ~~Can the GfshParserRule do that?  I thought that rule only determined if the string could find the function to call, not to test the mutual exclusion of options within the code itself.~~ Oh, I was only looking at `.parse` and not `executeCommandWithInstance`.  Gotcha.
   
   Definitely don't need the server, though.  I missed that when I pulled this out of the DUnit.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied commented on a change in pull request #1070: GEODE-3539: Add test coverage to 'alter disk-store'.
URL: https://github.com/apache/geode/pull/1070#discussion_r152691736
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreIntegrationTest.java
 ##########
 @@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import java.io.IOException;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.management.internal.cli.i18n.CliStrings;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
+import org.apache.geode.test.junit.rules.ServerStarterRule;
+
+@Category(IntegrationTest.class)
+public class AlterDiskStoreIntegrationTest {
+  private static final String regionName = "region1";
+  private static final String memberName = "server";
+  private static final String diskStoreName = "disk-store1";
+
+  @Rule
+  public ServerStarterRule server =
 
 Review comment:
   Can the GfshParserRule do that?  I thought that rule only determined if the string could find the function to call, not to test the mutual exclusion of options within the code itself.
   
   Definitely don't need the server, though.  I missed that when I pulled this out of the DUnit.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied commented on a change in pull request #1070: GEODE-3539: Add test coverage to 'alter disk-store'.
URL: https://github.com/apache/geode/pull/1070#discussion_r152693598
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreDUnitTest.java
 ##########
 @@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.Serializable;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.DataPolicy;
+import org.apache.geode.cache.EvictionAction;
+import org.apache.geode.cache.EvictionAttributes;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.Scope;
+import org.apache.geode.management.internal.cli.i18n.CliStrings;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
+import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
+import org.apache.geode.test.junit.categories.DistributedTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
+
+@Category(DistributedTest.class)
+public class AlterDiskStoreDUnitTest implements Serializable {
+  private static final String regionName = "region1";
+  private static final String diskStoreName = "disk-store1";
+  private static final String diskDirName = "diskStoreDir";
+  private static final String aKey = "key1";
+
+  private static MemberVM locator;
+  private static MemberVM server1;
+
+  @Rule
+  public LocatorServerStartupRule startupRule = new LocatorServerStartupRule().withTempWorkingDir();
 
 Review comment:
   I was a bit worried that just using the `gfsh` working directory could cause problems if the `--remove` test was run first, but that appears to have been a misplaced fear.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on a change in pull request #1070: GEODE-3539: Add test coverage to 'alter disk-store'.
URL: https://github.com/apache/geode/pull/1070#discussion_r153272359
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreIntegrationTest.java
 ##########
 @@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import java.io.IOException;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.management.internal.cli.i18n.CliStrings;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
+import org.apache.geode.test.junit.rules.ServerStarterRule;
+
+@Category(IntegrationTest.class)
+public class AlterDiskStoreIntegrationTest {
 
 Review comment:
   this can be done in a unit test using GfshParserRule

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied closed pull request #1070: GEODE-3539: Add test coverage to 'alter disk-store'.
URL: https://github.com/apache/geode/pull/1070
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreDUnitTest.java
new file mode 100644
index 0000000000..566e88b616
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreDUnitTest.java
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.io.File;
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.DataPolicy;
+import org.apache.geode.cache.EvictionAction;
+import org.apache.geode.cache.EvictionAttributes;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.Scope;
+import org.apache.geode.management.internal.cli.i18n.CliStrings;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
+import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
+import org.apache.geode.test.junit.categories.DistributedTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+import org.apache.geode.test.junit.rules.GfshCommandRule.PortType;
+
+@Category(DistributedTest.class)
+public class AlterDiskStoreDUnitTest {
+  private static final String regionName = "region1";
+  private static final String diskStoreName = "disk-store1";
+  private static final String diskDirName = "diskStoreDir";
+  private static final String aKey = "key1";
+
+  private static MemberVM locator;
+  private static MemberVM server1;
+
+  @Rule
+  public LocatorServerStartupRule startupRule = new LocatorServerStartupRule();
+
+  @Rule
+  public GfshCommandRule gfsh = new GfshCommandRule();
+
+  @Before
+  public void setupCluster() throws Exception {
+
+    File diskStoreDirFile = new File(getDiskDirPathString());
+
+    if (!diskStoreDirFile.exists()) {
+      diskStoreDirFile.mkdirs();
+    }
+
+    locator = startupRule.startLocatorVM(0);
+    server1 = startupRule.startServerVM(1, locator.getPort());
+    String diskDirPathString = getDiskDirPathString();
+    server1.invoke(() -> {
+      Cache cache = LocatorServerStartupRule.getCache();
+      cache.createDiskStoreFactory().setDiskDirs(new File[] {new File(diskDirPathString)})
+          .setMaxOplogSize(1).setAllowForceCompaction(true).setAutoCompact(false)
+          .create(diskStoreName);
+
+      EvictionAttributes ea =
+          EvictionAttributes.createLRUEntryAttributes(1, EvictionAction.OVERFLOW_TO_DISK);
+
+      RegionFactory<String, String> regionFactory = cache.createRegionFactory();
+      Region<String, String> region = regionFactory.setDiskStoreName(diskStoreName)
+          .setDiskSynchronous(true).setDataPolicy(DataPolicy.PERSISTENT_REPLICATE)
+          .setScope(Scope.DISTRIBUTED_ACK).setEvictionAttributes(ea).create(regionName);
+      region.put(aKey, "value");
+    });
+  }
+
+  @Test
+  public void diskStoreIsLockedWhileMemberIsAlive() throws Exception {
+    gfsh.connectAndVerify(locator.getJmxPort(), PortType.jmxManager);
+    String commandString = commandToSetManyVariables();
+    gfsh.executeAndAssertThat(commandString).statusIsError().containsOutput("Could not lock",
+        "Other JVMs might have created diskstore with same name using the same directory");
+  }
+
+  @Test
+  public void alterDiskStoreUpdatesValues() throws Exception {
+    startupRule.stopVM(1);
+
+    gfsh.connectAndVerify(locator.getJmxPort(), PortType.jmxManager);
+    String commandOne = commandToSetManyVariables();
+    gfsh.executeAndAssertThat(commandOne).statusIsSuccess().containsOutput("concurrencyLevel=5",
+        "lruAction=local-destroy", "compressor=org.apache.geode.compression.SnappyCompressor",
+        "initialCapacity=6");
+
+    String commandTwo = commandToSetCompressorToNone();
+    gfsh.executeAndAssertThat(commandTwo).statusIsSuccess().containsOutput("-compressor=none");
+  }
+
+  @Test
+  public void alterDiskStoreWithRemoveDoesRemoveRegion() throws IOException {
+    // Verify to start that there exists the data in the region
+    server1.invoke(() -> {
+      Region region = LocatorServerStartupRule.getCache().getRegion(regionName);
+      assertThat(region).isNotNull();
+      assertThat(region.get(aKey)).isNotNull();
+    });
+
+    // Halt the member and "alter" the disk store with the --remove option
+    startupRule.stopVM(1);
+    String cmd = commandWithRemoveAndNoOtherOption();
+    gfsh.executeAndAssertThat(cmd).statusIsSuccess().containsOutput("The region " + regionName
+        + " was successfully removed from the disk store " + diskStoreName);
+
+    // Restart the member and see that the disk store / region is gone.
+    startupRule.startServerVM(1, locator.getPort());
+    server1.invoke(() -> {
+      Region region = LocatorServerStartupRule.getCache().getRegion(regionName);
+      assertThat(region).isNull();
+    });
+  }
+
+  private String getDiskDirPathString() throws IOException {
+    return gfsh.getWorkingDir().toPath().resolve(diskDirName).toFile().getCanonicalPath();
+  }
+
+  private String commandWithRemoveAndNoOtherOption() throws IOException {
+    CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_DISK_STORE);
+    csb.addOption(CliStrings.ALTER_DISK_STORE__DISKSTORENAME, diskStoreName);
+    csb.addOption(CliStrings.ALTER_DISK_STORE__REGIONNAME, regionName);
+    csb.addOption(CliStrings.ALTER_DISK_STORE__DISKDIRS, getDiskDirPathString());
+    csb.addOption(CliStrings.ALTER_DISK_STORE__REMOVE, "true");
+    return csb.toString();
+  }
+
+  private String commandToSetCompressorToNone() throws IOException {
+    CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_DISK_STORE);
+    csb.addOption(CliStrings.ALTER_DISK_STORE__DISKSTORENAME, diskStoreName);
+    csb.addOption(CliStrings.ALTER_DISK_STORE__REGIONNAME, regionName);
+    csb.addOption(CliStrings.ALTER_DISK_STORE__DISKDIRS, getDiskDirPathString());
+    csb.addOption(CliStrings.ALTER_DISK_STORE__COMPRESSOR, "none");
+    return csb.toString();
+  }
+
+  private String commandToSetManyVariables() throws IOException {
+    CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_DISK_STORE);
+    csb.addOption(CliStrings.ALTER_DISK_STORE__DISKSTORENAME, diskStoreName);
+    csb.addOption(CliStrings.ALTER_DISK_STORE__REGIONNAME, regionName);
+    csb.addOption(CliStrings.ALTER_DISK_STORE__DISKDIRS, getDiskDirPathString());
+    csb.addOption(CliStrings.ALTER_DISK_STORE__CONCURRENCY__LEVEL, "5");
+    csb.addOption(CliStrings.ALTER_DISK_STORE__INITIAL__CAPACITY, "6");
+    csb.addOption(CliStrings.ALTER_DISK_STORE__LRU__EVICTION__ACTION, "local-destroy");
+    csb.addOption(CliStrings.ALTER_DISK_STORE__COMPRESSOR,
+        "org.apache.geode.compression.SnappyCompressor");
+    csb.addOption(CliStrings.ALTER_DISK_STORE__STATISTICS__ENABLED, "true");
+    return csb.toString();
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreJUnitTest.java
new file mode 100644
index 0000000000..0059458aea
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/AlterDiskStoreJUnitTest.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.mockito.Mockito.spy;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.management.internal.cli.i18n.CliStrings;
+import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
+import org.apache.geode.test.junit.categories.UnitTest;
+import org.apache.geode.test.junit.rules.GfshParserRule;
+
+@Category(UnitTest.class)
+public class AlterDiskStoreJUnitTest {
+  @Rule
+  public GfshParserRule gfsh = new GfshParserRule();
+
+  private GfshCommand command;
+
+  @Before
+  public void before() {
+    command = spy(AlterOfflineDiskStoreCommand.class);
+  }
+
+  @Test
+  public void removeOptionMustBeUsedAlone() throws Exception {
+    CommandStringBuilder csb = new CommandStringBuilder(CliStrings.ALTER_DISK_STORE);
+    csb.addOption(CliStrings.ALTER_DISK_STORE__DISKSTORENAME, "diskStoreName");
+    csb.addOption(CliStrings.ALTER_DISK_STORE__REGIONNAME, "regionName");
+    csb.addOption(CliStrings.ALTER_DISK_STORE__DISKDIRS, "./someDirectory");
+    csb.addOption(CliStrings.ALTER_DISK_STORE__CONCURRENCY__LEVEL, "5");
+    csb.addOption(CliStrings.ALTER_DISK_STORE__REMOVE, "true");
+    String commandString = csb.toString();
+
+    gfsh.executeAndAssertThat(command, commandString).statusIsError()
+        .containsOutput("Cannot use the --remove=true parameter with any other parameters");
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsDUnitTest.java
index 448579f3b0..1bc38f2475 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DiskStoreCommandsDUnitTest.java
@@ -238,33 +238,6 @@ public void testDestroyUpdatesSharedConfig() throws Exception {
     assertThat(diskStoreExistsInClusterConfig(locator)).isFalse();
   }
 
-  @Test
-  public void testAlterDiskStore() throws Exception {
-    Properties props = new Properties();
-    props.setProperty("groups", GROUP);
-    MemberVM locator = rule.startLocatorVM(0);
-    MemberVM server1 = rule.startServerVM(1, props, locator.getPort());
-
-    gfsh.connectAndVerify(locator);
-
-    createDiskStoreAndRegion(locator, 1);
-
-    String diskDirs = new File(server1.getWorkingDir(), DISKSTORE).getAbsolutePath();
-    gfsh.executeAndAssertThat(
-        String.format("alter disk-store --name=%s --region=%s --disk-dirs=%s --concurrency-level=5",
-            DISKSTORE, REGION_1, diskDirs))
-        .statusIsError().containsOutput("Could not lock");
-
-    server1.invoke(LocatorServerStartupRule::stopMemberInThisVM);
-
-    gfsh.executeAndAssertThat(String.format(
-        "alter disk-store --name=%s --region=%s --disk-dirs=%s --concurrency-level=5 --initial-capacity=6 --lru-action=local-destroy --compressor=%s --enable-statistics=true",
-        DISKSTORE, REGION_1, diskDirs, SnappyCompressor.class.getName())).statusIsSuccess()
-        .containsOutput("concurrencyLevel=16", "concurrencyLevel=5", "initialCapacity=16",
-            "initialCapacity=6", "lruAction=overflow-to-disk", "lruAction=local-destroy",
-            "compressor=none", "compressor=" + SnappyCompressor.class.getName(),
-            "statisticsEnabled=false", "statisticsEnabled=true");
-  }
 
   @Test
   public void testBackupDiskStore() throws Exception {


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 40f3ed9dcb9c5f38563356c438a73262ce99d00d in geode's branch refs/heads/develop from [~prhomberg]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=40f3ed9 ]

GEODE-3539: Add test coverage to 'alter disk-store'.

* Added AlterDiskStoreJUnitTest for testing of option conflict
* Remove subsumed testing from DiskStoreCommandsDUnitTest

Commit f3a021991d239dfc05357d6250d937a90d971f32 in geode's branch refs/heads/feature/GEODE-3781 from [~prhomberg]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=f3a0219 ]

GEODE-3539: Add missing test coverage to 'list disk-stores' and 'describe disk-stores' commands

* Refactor cumbersome DUnit test to individual IntegrationTests

Commit 40f3ed9dcb9c5f38563356c438a73262ce99d00d in geode's branch refs/heads/feature/GEODE-3781 from [~prhomberg]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=40f3ed9 ]

GEODE-3539: Add test coverage to 'alter disk-store'.

* Added AlterDiskStoreJUnitTest for testing of option conflict
* Remove subsumed testing from DiskStoreCommandsDUnitTest

jinmeiliao opened a new pull request #1093: GEODE-3539: add test coverage for "create async-event-queue" and "lis…
URL: https://github.com/apache/geode/pull/1093
 
 
   …t async-event-queue"
   
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao opened a new pull request #1094: GEODE-3539: add ability to stop a vm without clean out the working dir
URL: https://github.com/apache/geode/pull/1094
 
 
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pdxrunner commented on a change in pull request #1093: GEODE-3539: add test coverage for "create async-event-queue" and "lis…
URL: https://github.com/apache/geode/pull/1093#discussion_r153630136
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAsyncEventQueuesCommandDUnitTest.java
 ##########
 @@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.apache.geode.test.junit.rules.GfshCommandRule.PortType.jmxManager;
+
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.internal.cache.wan.MyAsyncEventListener;
+import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
+import org.apache.geode.test.junit.categories.UnitTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+
+
+@Category(UnitTest.class)
+public class ListAsyncEventQueuesCommandDUnitTest {
+
+  @ClassRule
+  public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
+
+  @Rule
+  public GfshCommandRule gfsh = new GfshCommandRule(locator::getJmxPort, jmxManager);
+
+  private static MemberVM locator;
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    locator = lsRule.startLocatorVM(0);
+    lsRule.startServerVM(1, "group1", locator.getPort());
+    lsRule.startServerVM(2, "group2", locator.getPort());
+  }
+
+  @Test
+  public void list() throws Exception {
+    gfsh.executeAndAssertThat("list async-event-queue").statusIsSuccess()
+        .containsOutput("No Async Event Queues Found");
+
+    gfsh.executeAndAssertThat("create async-event-queue --id=queue1 --group=group1 --listener="
+        + MyAsyncEventListener.class.getName()).statusIsSuccess();
+
+    gfsh.executeAndAssertThat("create async-event-queue --id=queue2 --group=group2 --listener="
+        + MyAsyncEventListener.class.getName()).statusIsSuccess();
+
+    locator.waitTillAsyncEventQueuesAreReadyOnServers("queue1", 1);
+    locator.waitTillAsyncEventQueuesAreReadyOnServers("queue2", 1);
+
+    gfsh.executeAndAssertThat("list async-event-queue").statusIsSuccess()
+        .tableHasRowCount("Member", 2).tableHasRowWithValues("Member", "ID", "server-1", "queue1")
+        .tableHasRowWithValues("Member", "ID", "server-2", "queue2");
+
+    // create another async event queue on the entire cluster, verify that the command will list all
+    gfsh.executeAndAssertThat(
+        "create async-event-queue --id=queue --listener=" + MyAsyncEventListener.class.getName())
+        .statusIsSuccess();
+
+    gfsh.executeAndAssertThat("list async-event-queue").statusIsSuccess()
+        .tableHasRowCount("Member", 4).tableHasRowWithValues("Member", "ID", "server-1", "queue1")
+        .tableHasRowWithValues("Member", "ID", "server-2", "queue2")
+        .tableHasRowWithValues("Member", "ID", "server-1", "queue")
+        .tableHasRowWithValues("Member", "ID", "server-2", "queue");
 
 Review comment:
   Point of discussion (not necessary to change, but something to consider) : the signature of {{tableHasRowWithValues}} has {{headersThenValues}}. I didn't notice this from the previous change to CommandResultAssert, but I think that that ordering of the {{String}} arguments as {{header, value}} pairs is more readable. With only one or two values in the row it's not too confusing, but with a longer list of values of interest, then associating the matching header and values becomes less clear when reviewing code that calls the method.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on a change in pull request #1093: GEODE-3539: add test coverage for "create async-event-queue" and "lis…
URL: https://github.com/apache/geode/pull/1093#discussion_r153632962
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAsyncEventQueuesCommandDUnitTest.java
 ##########
 @@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.apache.geode.test.junit.rules.GfshCommandRule.PortType.jmxManager;
+
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.internal.cache.wan.MyAsyncEventListener;
+import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
+import org.apache.geode.test.junit.categories.UnitTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+
+
+@Category(UnitTest.class)
+public class ListAsyncEventQueuesCommandDUnitTest {
+
+  @ClassRule
+  public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
+
+  @Rule
+  public GfshCommandRule gfsh = new GfshCommandRule(locator::getJmxPort, jmxManager);
+
+  private static MemberVM locator;
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    locator = lsRule.startLocatorVM(0);
+    lsRule.startServerVM(1, "group1", locator.getPort());
+    lsRule.startServerVM(2, "group2", locator.getPort());
+  }
+
+  @Test
+  public void list() throws Exception {
+    gfsh.executeAndAssertThat("list async-event-queue").statusIsSuccess()
+        .containsOutput("No Async Event Queues Found");
+
+    gfsh.executeAndAssertThat("create async-event-queue --id=queue1 --group=group1 --listener="
+        + MyAsyncEventListener.class.getName()).statusIsSuccess();
+
+    gfsh.executeAndAssertThat("create async-event-queue --id=queue2 --group=group2 --listener="
+        + MyAsyncEventListener.class.getName()).statusIsSuccess();
+
+    locator.waitTillAsyncEventQueuesAreReadyOnServers("queue1", 1);
+    locator.waitTillAsyncEventQueuesAreReadyOnServers("queue2", 1);
+
+    gfsh.executeAndAssertThat("list async-event-queue").statusIsSuccess()
+        .tableHasRowCount("Member", 2).tableHasRowWithValues("Member", "ID", "server-1", "queue1")
+        .tableHasRowWithValues("Member", "ID", "server-2", "queue2");
+
+    // create another async event queue on the entire cluster, verify that the command will list all
+    gfsh.executeAndAssertThat(
+        "create async-event-queue --id=queue --listener=" + MyAsyncEventListener.class.getName())
+        .statusIsSuccess();
+
+    gfsh.executeAndAssertThat("list async-event-queue").statusIsSuccess()
+        .tableHasRowCount("Member", 4).tableHasRowWithValues("Member", "ID", "server-1", "queue1")
+        .tableHasRowWithValues("Member", "ID", "server-2", "queue2")
+        .tableHasRowWithValues("Member", "ID", "server-1", "queue")
+        .tableHasRowWithValues("Member", "ID", "server-2", "queue");
 
 Review comment:
   so you are suggesting the caller should call something like: tableHasRowWithValues("Member,server-2", "ID,queue2")
   
   this would make the processing a bit harder, but still doable. It's just the way these GFJsonObject are constructed, We will have to refactor out this entire result object anyway, good things we are lumping all the processing in this CommandResultAssert object so it's one spot to change.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pdxrunner commented on a change in pull request #1093: GEODE-3539: add test coverage for "create async-event-queue" and "lis…
URL: https://github.com/apache/geode/pull/1093#discussion_r153633541
 
 

 ##########
 File path: geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/CreateAsyncEventQueueFunction.java
 ##########
 @@ -130,48 +122,19 @@ public void execute(FunctionContext context) {
 
     } catch (CacheClosedException cce) {
       context.getResultSender().lastResult(new CliFunctionResult(memberId, false, null));
-
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-
-    } catch (Throwable th) {
-      SystemFailure.checkFailure();
+    } catch (Exception th) {
 
 Review comment:
   Since the catch is no longer for {{Throwable}} a better name for the variable would be 'e'

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pdxrunner commented on a change in pull request #1093: GEODE-3539: add test coverage for "create async-event-queue" and "lis…
URL: https://github.com/apache/geode/pull/1093#discussion_r153635536
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAsyncEventQueuesCommandDUnitTest.java
 ##########
 @@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.apache.geode.test.junit.rules.GfshCommandRule.PortType.jmxManager;
+
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.internal.cache.wan.MyAsyncEventListener;
+import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
+import org.apache.geode.test.junit.categories.UnitTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+
+
+@Category(UnitTest.class)
+public class ListAsyncEventQueuesCommandDUnitTest {
+
+  @ClassRule
+  public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
+
+  @Rule
+  public GfshCommandRule gfsh = new GfshCommandRule(locator::getJmxPort, jmxManager);
+
+  private static MemberVM locator;
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    locator = lsRule.startLocatorVM(0);
+    lsRule.startServerVM(1, "group1", locator.getPort());
+    lsRule.startServerVM(2, "group2", locator.getPort());
+  }
+
+  @Test
+  public void list() throws Exception {
+    gfsh.executeAndAssertThat("list async-event-queue").statusIsSuccess()
+        .containsOutput("No Async Event Queues Found");
+
+    gfsh.executeAndAssertThat("create async-event-queue --id=queue1 --group=group1 --listener="
+        + MyAsyncEventListener.class.getName()).statusIsSuccess();
+
+    gfsh.executeAndAssertThat("create async-event-queue --id=queue2 --group=group2 --listener="
+        + MyAsyncEventListener.class.getName()).statusIsSuccess();
+
+    locator.waitTillAsyncEventQueuesAreReadyOnServers("queue1", 1);
+    locator.waitTillAsyncEventQueuesAreReadyOnServers("queue2", 1);
+
+    gfsh.executeAndAssertThat("list async-event-queue").statusIsSuccess()
+        .tableHasRowCount("Member", 2).tableHasRowWithValues("Member", "ID", "server-1", "queue1")
+        .tableHasRowWithValues("Member", "ID", "server-2", "queue2");
+
+    // create another async event queue on the entire cluster, verify that the command will list all
+    gfsh.executeAndAssertThat(
+        "create async-event-queue --id=queue --listener=" + MyAsyncEventListener.class.getName())
+        .statusIsSuccess();
+
+    gfsh.executeAndAssertThat("list async-event-queue").statusIsSuccess()
+        .tableHasRowCount("Member", 4).tableHasRowWithValues("Member", "ID", "server-1", "queue1")
+        .tableHasRowWithValues("Member", "ID", "server-2", "queue2")
+        .tableHasRowWithValues("Member", "ID", "server-1", "queue")
+        .tableHasRowWithValues("Member", "ID", "server-2", "queue");
 
 Review comment:
   No, what I would envision is tableHasRowWithValues(Member, server-2, ID, queue2). I would keep the arguments separate but order arguments as pairs ..., header, value, ... . I agree that processing this wouldn't be quite as straightforward as 
   
       String[] headers = Arrays.copyOfRange(headersThenValues, 0, numberOfColumn);
       String[] expectedValues =
           Arrays.copyOfRange(headersThenValues, numberOfColumn, headersThenValues.length);
   
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao closed pull request #1094: GEODE-3539: add ability to stop a vm without clean out the working dir
URL: https://github.com/apache/geode/pull/1094
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ImportClusterConfigDistributedTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ImportClusterConfigDistributedTest.java
index 46d1f7a83e..11795f7a50 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ImportClusterConfigDistributedTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ImportClusterConfigDistributedTest.java
@@ -75,8 +75,8 @@ public void exportClusterConfig() throws Exception {
         .statusIsSuccess();
 
     gfsh.disconnect();
-    locator.stopMember();
-    server.stopMember();
+    locator.stopMember(true);
+    server.stopMember(true);
 
     assertThat(this.exportedClusterConfig).exists();
     assertThat(this.exportedClusterConfig.length()).isGreaterThan(100);
diff --git a/geode-core/src/test/java/org/apache/geode/test/dunit/rules/LocatorServerStartupRule.java b/geode-core/src/test/java/org/apache/geode/test/dunit/rules/LocatorServerStartupRule.java
index a3c2944898..c9e2c8337c 100644
--- a/geode-core/src/test/java/org/apache/geode/test/dunit/rules/LocatorServerStartupRule.java
+++ b/geode-core/src/test/java/org/apache/geode/test/dunit/rules/LocatorServerStartupRule.java
@@ -301,10 +301,14 @@ public MemberVM startServerAsEmbededLocator(int index, Properties properties) th
   }
 
   public void stopVM(int index) {
+    stopVM(index, true);
+  }
+
+  public void stopVM(int index, boolean cleanWorkingDir) {
     MemberVM member = members.get(index);
     // user has started a server/locator in this VM
     if (member != null) {
-      member.stopMember();
+      member.stopMember(cleanWorkingDir);
     }
     // user may have used this VM as a client VM
     else {
diff --git a/geode-core/src/test/java/org/apache/geode/test/dunit/rules/MemberVM.java b/geode-core/src/test/java/org/apache/geode/test/dunit/rules/MemberVM.java
index 4e04b8eb8b..a61fabb5e3 100644
--- a/geode-core/src/test/java/org/apache/geode/test/dunit/rules/MemberVM.java
+++ b/geode-core/src/test/java/org/apache/geode/test/dunit/rules/MemberVM.java
@@ -101,8 +101,12 @@ public int getEmbeddedLocatorPort() {
     return ((Server) member).getEmbeddedLocatorPort();
   }
 
-  public void stopMember() {
+  public void stopMember(boolean cleanWorkingDir) {
     this.invoke(LocatorServerStartupRule::stopMemberInThisVM);
+    if (!cleanWorkingDir) {
+      return;
+    }
+
     if (tempWorkingDir) {
       /*
        * this temporary workingDir will dynamically change the "user.dir". system property to point


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit df0a85635deb9efb6e62d00bfce3da5d2348c737 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=df0a856 ]

GEODE-3539: add ability to stop a vm without clean out the working dir (#1094)



Commit df0a85635deb9efb6e62d00bfce3da5d2348c737 in geode's branch refs/heads/feature/GEODE-4000 from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=df0a856 ]

GEODE-3539: add ability to stop a vm without clean out the working dir (#1094)



jinmeiliao commented on issue #1093: GEODE-3539: add test coverage for "create async-event-queue" and "lis…
URL: https://github.com/apache/geode/pull/1093#issuecomment-347919650
 
 
   precheckin green

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao closed pull request #1093: GEODE-3539: add test coverage for "create async-event-queue" and "lis…
URL: https://github.com/apache/geode/pull/1093
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/CreateAsyncEventQueueCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/CreateAsyncEventQueueCommand.java
index eb89c21b4a..0b46c0b239 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/CreateAsyncEventQueueCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/CreateAsyncEventQueueCommand.java
@@ -23,16 +23,17 @@
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
 
-import org.apache.geode.SystemFailure;
+import org.apache.geode.cache.asyncqueue.internal.AsyncEventQueueFactoryImpl;
+import org.apache.geode.cache.execute.Function;
 import org.apache.geode.cache.execute.ResultCollector;
 import org.apache.geode.distributed.DistributedMember;
 import org.apache.geode.management.cli.ConverterHint;
 import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.functions.AsyncEventQueueFunctionArgs;
 import org.apache.geode.management.internal.cli.functions.CliFunctionResult;
 import org.apache.geode.management.internal.cli.functions.CreateAsyncEventQueueFunction;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
+import org.apache.geode.management.internal.cli.result.CommandResult;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
 import org.apache.geode.management.internal.cli.result.TabularResultData;
 import org.apache.geode.management.internal.configuration.domain.XmlEntity;
@@ -52,15 +53,15 @@ public Result createAsyncEventQueue(
           help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__GROUP__HELP) String[] groups,
       @CliOption(key = CliStrings.CREATE_ASYNC_EVENT_QUEUE__PARALLEL,
           unspecifiedDefaultValue = "false", specifiedDefaultValue = "true",
-          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__PARALLEL__HELP) Boolean parallel,
+          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__PARALLEL__HELP) boolean parallel,
       @CliOption(key = CliStrings.CREATE_ASYNC_EVENT_QUEUE__ENABLEBATCHCONFLATION,
           unspecifiedDefaultValue = "false", specifiedDefaultValue = "true",
-          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__ENABLEBATCHCONFLATION__HELP) Boolean enableBatchConflation,
+          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__ENABLEBATCHCONFLATION__HELP) boolean enableBatchConflation,
       @CliOption(key = CliStrings.CREATE_ASYNC_EVENT_QUEUE__BATCH_SIZE,
           unspecifiedDefaultValue = "100",
           help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__BATCH_SIZE__HELP) int batchSize,
       @CliOption(key = CliStrings.CREATE_ASYNC_EVENT_QUEUE__BATCHTIMEINTERVAL,
-          unspecifiedDefaultValue = "1000",
+          unspecifiedDefaultValue = AsyncEventQueueFactoryImpl.DEFAULT_BATCH_TIME_INTERVAL + "",
           help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__BATCHTIMEINTERVAL__HELP) int batchTimeInterval,
       @CliOption(key = CliStrings.CREATE_ASYNC_EVENT_QUEUE__PERSISTENT,
           unspecifiedDefaultValue = "false", specifiedDefaultValue = "true",
@@ -69,16 +70,16 @@ public Result createAsyncEventQueue(
           help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__DISK_STORE__HELP) String diskStore,
       @CliOption(key = CliStrings.CREATE_ASYNC_EVENT_QUEUE__DISKSYNCHRONOUS,
           unspecifiedDefaultValue = "true", specifiedDefaultValue = "true",
-          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__DISKSYNCHRONOUS__HELP) Boolean diskSynchronous,
+          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__DISKSYNCHRONOUS__HELP) boolean diskSynchronous,
       @CliOption(key = CliStrings.CREATE_ASYNC_EVENT_QUEUE__FORWARD_EXPIRATION_DESTROY,
-          unspecifiedDefaultValue = "false", specifiedDefaultValue = "false",
-          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__FORWARD_EXPIRATION_DESTROY__HELP) Boolean ignoreEvictionAndExpiration,
+          unspecifiedDefaultValue = "false", specifiedDefaultValue = "true",
+          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__FORWARD_EXPIRATION_DESTROY__HELP) boolean forwardExpirationDestroy,
       @CliOption(key = CliStrings.CREATE_ASYNC_EVENT_QUEUE__MAXIMUM_QUEUE_MEMORY,
           unspecifiedDefaultValue = "100",
           help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__MAXIMUM_QUEUE_MEMORY__HELP) int maxQueueMemory,
       @CliOption(key = CliStrings.CREATE_ASYNC_EVENT_QUEUE__DISPATCHERTHREADS,
           unspecifiedDefaultValue = "1",
-          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__DISPATCHERTHREADS__HELP) Integer dispatcherThreads,
+          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__DISPATCHERTHREADS__HELP) int dispatcherThreads,
       @CliOption(key = CliStrings.CREATE_ASYNC_EVENT_QUEUE__ORDERPOLICY,
           unspecifiedDefaultValue = "KEY",
           help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__ORDERPOLICY__HELP) String orderPolicy,
@@ -97,75 +98,60 @@ public Result createAsyncEventQueue(
     }
     Properties listenerProperties = new Properties();
 
-    try {
-      if (listenerParamsAndValues != null) {
-        for (String listenerParamsAndValue : listenerParamsAndValues) {
-          final int hashPosition = listenerParamsAndValue.indexOf('#');
-          if (hashPosition == -1) {
-            listenerProperties.put(listenerParamsAndValue, "");
-          } else {
-            listenerProperties.put(listenerParamsAndValue.substring(0, hashPosition),
-                listenerParamsAndValue.substring(hashPosition + 1));
-          }
+    if (listenerParamsAndValues != null) {
+      for (String listenerParamsAndValue : listenerParamsAndValues) {
+        final int hashPosition = listenerParamsAndValue.indexOf('#');
+        if (hashPosition == -1) {
+          listenerProperties.put(listenerParamsAndValue, "");
+        } else {
+          listenerProperties.put(listenerParamsAndValue.substring(0, hashPosition),
+              listenerParamsAndValue.substring(hashPosition + 1));
         }
       }
+    }
 
-      TabularResultData tabularData = ResultBuilder.createTabularResultData();
-      boolean accumulatedData = false;
-
-      Set<DistributedMember> targetMembers = CliUtil.findMembers(groups, null);
-
-      if (targetMembers.isEmpty()) {
-        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
-      }
-
-      AsyncEventQueueFunctionArgs aeqArgs = new AsyncEventQueueFunctionArgs(id, parallel,
-          enableBatchConflation, batchSize, batchTimeInterval, persistent, diskStore,
-          diskSynchronous, maxQueueMemory, dispatcherThreads, orderPolicy, gatewayEventFilters,
-          gatewaySubstitutionListener, listener, listenerProperties, ignoreEvictionAndExpiration);
+    Set<DistributedMember> targetMembers = getMembers(groups, null);
 
-      ResultCollector<?, ?> rc =
-          CliUtil.executeFunction(new CreateAsyncEventQueueFunction(), aeqArgs, targetMembers);
+    TabularResultData tabularData = ResultBuilder.createTabularResultData();
+    AsyncEventQueueFunctionArgs aeqArgs = new AsyncEventQueueFunctionArgs(id, parallel,
+        enableBatchConflation, batchSize, batchTimeInterval, persistent, diskStore, diskSynchronous,
+        maxQueueMemory, dispatcherThreads, orderPolicy, gatewayEventFilters,
+        gatewaySubstitutionListener, listener, listenerProperties, forwardExpirationDestroy);
 
-      List<CliFunctionResult> results = CliFunctionResult.cleanResults((List<?>) rc.getResult());
+    CreateAsyncEventQueueFunction function = new CreateAsyncEventQueueFunction();
+    List<CliFunctionResult> results = execute(function, aeqArgs, targetMembers);
 
-      AtomicReference<XmlEntity> xmlEntity = new AtomicReference<>();
-      for (CliFunctionResult result : results) {
-        if (result.getThrowable() != null) {
-          tabularData.accumulate("Member", result.getMemberIdOrName());
-          tabularData.accumulate("Result", "ERROR: " + result.getThrowable().getClass().getName()
-              + ": " + result.getThrowable().getMessage());
-          accumulatedData = true;
-          tabularData.setStatus(Result.Status.ERROR);
-        } else if (result.isSuccessful()) {
-          tabularData.accumulate("Member", result.getMemberIdOrName());
-          tabularData.accumulate("Result", result.getMessage());
-          accumulatedData = true;
+    if (results.size() == 0) {
+      throw new RuntimeException("No results received.");
+    }
 
-          if (xmlEntity.get() == null) {
-            xmlEntity.set(result.getXmlEntity());
-          }
+    AtomicReference<XmlEntity> xmlEntity = new AtomicReference<>();
+    for (CliFunctionResult result : results) {
+      if (!result.isSuccessful()) {
+        tabularData.accumulate("Member", result.getMemberIdOrName());
+        tabularData.accumulate("Result", "ERROR: " + result.getErrorMessage());
+      } else {
+        tabularData.accumulate("Member", result.getMemberIdOrName());
+        tabularData.accumulate("Result", result.getMessage());
+
+        // if one member is successful in creating the AEQ and xmlEntity is not set yet,
+        // save the xmlEntity that is to be persisted
+        if (result.isSuccessful() && xmlEntity.get() == null) {
+          xmlEntity.set(result.getXmlEntity());
         }
       }
-
-      if (!accumulatedData) {
-        return ResultBuilder.createInfoResult("Unable to create async event queue(s).");
-      }
-
-      Result result = ResultBuilder.buildResult(tabularData);
-      if (xmlEntity.get() != null) {
-        persistClusterConfiguration(result,
-            () -> getSharedConfiguration().addXmlEntity(xmlEntity.get(), groups));
-      }
-      return result;
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable th) {
-      SystemFailure.checkFailure();
-      return ResultBuilder.createGemFireErrorResult(
-          CliStrings.format(CliStrings.CREATE_ASYNC_EVENT_QUEUE__ERROR_WHILE_CREATING_REASON_0,
-              new Object[] {th.getMessage()}));
     }
+    CommandResult commandResult = ResultBuilder.buildResult(tabularData);
+    if (xmlEntity.get() != null) {
+      persistClusterConfiguration(commandResult,
+          () -> getSharedConfiguration().addXmlEntity(xmlEntity.get(), groups));
+    }
+    return commandResult;
+  }
+
+  List<CliFunctionResult> execute(Function function, Object args,
+      Set<DistributedMember> targetMembers) {
+    ResultCollector rc = executeFunction(function, args, targetMembers);
+    return CliFunctionResult.cleanResults((List<?>) rc.getResult());
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java
index 6a30378b3d..f94b6d1109 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/GfshCommand.java
@@ -170,12 +170,12 @@ default ManagementService getManagementService() {
     return CliUtil.getRegionAssociatedMembers(regionPath, cache, true);
   }
 
-  default ResultCollector<?, ?> executeFunction(final Function function, Object args,
+  default ResultCollector<?, ?> executeFunction(Function function, Object args,
       final Set<DistributedMember> targetMembers) {
     return CliUtil.executeFunction(function, args, targetMembers);
   }
 
-  default ResultCollector<?, ?> executeFunction(final Function function, Object args,
+  default ResultCollector<?, ?> executeFunction(Function function, Object args,
       final DistributedMember targetMember) {
     return executeFunction(function, args, Collections.singleton(targetMember));
   }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/CliFunctionResult.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/CliFunctionResult.java
index 4bbf389811..23313e7651 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/CliFunctionResult.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/CliFunctionResult.java
@@ -125,7 +125,7 @@ public String getErrorMessage() {
 
     // otherwise use exception's message
     if (throwable != null) {
-      return throwable.getMessage();
+      return throwable.getClass().getName() + ": " + throwable.getMessage();
     }
 
     return null;
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/CreateAsyncEventQueueFunction.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/CreateAsyncEventQueueFunction.java
index 437e276607..12ab783457 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/CreateAsyncEventQueueFunction.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/CreateAsyncEventQueueFunction.java
@@ -21,7 +21,6 @@
 import joptsimple.internal.Strings;
 import org.apache.logging.log4j.Logger;
 
-import org.apache.geode.SystemFailure;
 import org.apache.geode.cache.CacheClosedException;
 import org.apache.geode.cache.Declarable;
 import org.apache.geode.cache.asyncqueue.AsyncEventListener;
@@ -38,7 +37,6 @@
 import org.apache.geode.internal.cache.InternalCache;
 import org.apache.geode.internal.cache.xmlcache.CacheXml;
 import org.apache.geode.internal.logging.LogService;
-import org.apache.geode.management.internal.cli.i18n.CliStrings;
 import org.apache.geode.management.internal.configuration.domain.XmlEntity;
 
 /**
@@ -85,21 +83,15 @@ public void execute(FunctionContext context) {
       String[] gatewayEventFilters = aeqArgs.getGatewayEventFilters();
       if (gatewayEventFilters != null) {
         for (String gatewayEventFilter : gatewayEventFilters) {
-          Class<?> gatewayEventFilterKlass =
-              forName(gatewayEventFilter, CliStrings.CREATE_ASYNC_EVENT_QUEUE__GATEWAYEVENTFILTER);
           asyncEventQueueFactory
-              .addGatewayEventFilter((GatewayEventFilter) newInstance(gatewayEventFilterKlass,
-                  CliStrings.CREATE_ASYNC_EVENT_QUEUE__GATEWAYEVENTFILTER));
+              .addGatewayEventFilter((GatewayEventFilter) newInstance(gatewayEventFilter));
         }
       }
 
       String gatewaySubstitutionFilter = aeqArgs.getGatewaySubstitutionFilter();
       if (gatewaySubstitutionFilter != null) {
-        Class<?> gatewayEventSubstitutionFilterKlass = forName(gatewaySubstitutionFilter,
-            CliStrings.CREATE_ASYNC_EVENT_QUEUE__SUBSTITUTION_FILTER);
         asyncEventQueueFactory.setGatewayEventSubstitutionListener(
-            (GatewayEventSubstitutionFilter<?, ?>) newInstance(gatewayEventSubstitutionFilterKlass,
-                CliStrings.CREATE_ASYNC_EVENT_QUEUE__SUBSTITUTION_FILTER));
+            (GatewayEventSubstitutionFilter<?, ?>) newInstance(gatewaySubstitutionFilter));
       }
 
       String listenerClassName = aeqArgs.getListenerClassName();
@@ -130,48 +122,19 @@ public void execute(FunctionContext context) {
 
     } catch (CacheClosedException cce) {
       context.getResultSender().lastResult(new CliFunctionResult(memberId, false, null));
-
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-
-    } catch (Throwable th) {
-      SystemFailure.checkFailure();
-      logger.error("Could not create async event queue: {}", th.getMessage(), th);
-      context.getResultSender().lastResult(new CliFunctionResult(memberId, th, null));
+    } catch (Exception e) {
+      logger.error("Could not create async event queue: {}", e.getMessage(), e);
+      context.getResultSender().lastResult(new CliFunctionResult(memberId, e, null));
     }
   }
 
-  private Class<?> forName(String className, String neededFor) {
+  private Object newInstance(String className)
+      throws ClassNotFoundException, IllegalAccessException, InstantiationException {
     if (Strings.isNullOrEmpty(className)) {
       return null;
     }
 
-    try {
-      return ClassPathLoader.getLatest().forName(className);
-    } catch (ClassNotFoundException e) {
-      throw new RuntimeException(CliStrings.format(
-          CliStrings.CREATE_ASYNC_EVENT_QUEUE__MSG__COULD_NOT_FIND_CLASS_0_SPECIFIED_FOR_1,
-          className, neededFor), e);
-    } catch (ClassCastException e) {
-      throw new RuntimeException(CliStrings.format(
-          CliStrings.CREATE_ASYNC_EVENT_QUEUE__MSG__CLASS_0_SPECIFIED_FOR_1_IS_NOT_OF_EXPECTED_TYPE,
-          className, neededFor), e);
-    }
-  }
-
-  private static Object newInstance(Class<?> klass, String neededFor) {
-    try {
-      return klass.newInstance();
-    } catch (InstantiationException e) {
-      throw new RuntimeException(CliStrings.format(
-          CliStrings.CREATE_ASYNC_EVENT_QUEUE__MSG__COULD_NOT_INSTANTIATE_CLASS_0_SPECIFIED_FOR_1,
-          klass, neededFor), e);
-    } catch (IllegalAccessException e) {
-      throw new RuntimeException(CliStrings.format(
-          CliStrings.CREATE_ASYNC_EVENT_QUEUE__MSG__COULD_NOT_ACCESS_CLASS_0_SPECIFIED_FOR_1, klass,
-          neededFor), e);
-    }
+    return ClassPathLoader.getLatest().forName(className).newInstance();
   }
 
   @Override
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateAsyncEventQueueCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateAsyncEventQueueCommandDUnitTest.java
new file mode 100644
index 0000000000..cb93b2b423
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateAsyncEventQueueCommandDUnitTest.java
@@ -0,0 +1,128 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.distributed.internal.ClusterConfigurationService;
+import org.apache.geode.internal.cache.wan.MyAsyncEventListener;
+import org.apache.geode.management.internal.configuration.domain.Configuration;
+import org.apache.geode.test.dunit.IgnoredException;
+import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
+import org.apache.geode.test.junit.categories.DistributedTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+
+
+@Category(DistributedTest.class)
+public class CreateAsyncEventQueueCommandDUnitTest {
+
+
+  public static final String COMMAND = "create async-event-queue ";
+  public static final String VALID_COMMAND =
+      COMMAND + "--listener=" + MyAsyncEventListener.class.getName();
+
+  @Rule
+  public LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
+
+  @Rule
+  public GfshCommandRule gfsh = new GfshCommandRule();
+
+  private static MemberVM locator, server;
+
+  @Test
+  public void createQueueWithInvalidClass() throws Exception {
+    server = lsRule.startServerAsJmxManager(0);
+    gfsh.connectAndVerify(server.getJmxPort(), GfshCommandRule.PortType.jmxManager);
+    IgnoredException.addIgnoredException("java.lang.ClassNotFoundException: xyz");
+    gfsh.executeAndAssertThat(COMMAND + " --id=queue --listener=xyz").statusIsSuccess()
+        .tableHasRowCount("Member", 1).tableHasRowWithValues("Member", "Result", "server-0",
+            "ERROR: java.lang.ClassNotFoundException: xyz");
+  }
+
+  @Test
+  public void createQueueWithoutCC() throws Exception {
+    server = lsRule.startServerAsJmxManager(0);
+    gfsh.connectAndVerify(server.getJmxPort(), GfshCommandRule.PortType.jmxManager);
+    gfsh.executeAndAssertThat(VALID_COMMAND + " --id=queue").statusIsSuccess()
+        .containsOutput("Failed to persist the configuration")
+        .tableHasColumnWithExactValuesInAnyOrder("Result", "Success").tableHasRowCount("Member", 1);
+  }
+
+  @Test
+  public void create_sync_event_queue() throws Exception {
+    locator = lsRule.startLocatorVM(0);
+    lsRule.startServerVM(1, "group1", locator.getPort());
+    lsRule.startServerVM(2, "group2", locator.getPort());
+    gfsh.connectAndVerify(locator);
+    // verify a simple create aeq command
+    gfsh.executeAndAssertThat(VALID_COMMAND + " --id=queue").statusIsSuccess()
+        .tableHasRowCount("Member", 2)
+        .tableHasColumnWithExactValuesInAnyOrder("Result", "Success", "Success");
+
+    IgnoredException
+        .addIgnoredException("java.lang.IllegalStateException: A GatewaySender with id  "
+            + "AsyncEventQueue_queue  is already defined in this cache.");
+    // create a queue with the same id would result in failure
+    gfsh.executeAndAssertThat(VALID_COMMAND + " --id=queue").statusIsSuccess()
+        .tableHasRowCount("Member", 2).tableHasColumnWithExactValuesInAnyOrder("Result",
+            "ERROR: java.lang.IllegalStateException: A GatewaySender with id  AsyncEventQueue_queue  is already defined in this cache.",
+            "ERROR: java.lang.IllegalStateException: A GatewaySender with id  AsyncEventQueue_queue  is already defined in this cache.");
+
+    gfsh.executeAndAssertThat("create disk-store --name=diskStore2 --dir=diskstore");
+    locator.waitTillDiskstoreIsReady("diskStore2", 2);
+
+    // create another queue with different configuration
+    gfsh.executeAndAssertThat(VALID_COMMAND + " --id=queue2 --group=group2 "
+        + "--batch-size=1024 --persistent --disk-store=diskStore2 "
+        + "--max-queue-memory=512 --listener-param=param1,param2#value2").statusIsSuccess()
+        .tableHasRowCount("Member", 1);
+
+
+    // list the queue to verify the result
+    gfsh.executeAndAssertThat("list async-event-queue").statusIsSuccess()
+        .tableHasRowCount("Member", 3).tableHasRowWithValues("Member", "ID", "Batch Size",
+            "Persistent", "Disk Store", "Max Memory", "server-2", "queue2", "1024", "true",
+            "diskStore2", "512");
+  }
+
+  @Test
+  public void create_queue_updates_cc() throws Exception {
+    locator = lsRule.startLocatorVM(0);
+    server = lsRule.startServerVM(1, locator.getPort());
+    gfsh.connectAndVerify(locator);
+
+    locator.invoke(() -> {
+      ClusterConfigurationService service =
+          LocatorServerStartupRule.getLocator().getSharedConfiguration();
+      assertThat(service.getConfiguration("cluster").getCacheXmlContent()).isNull();
+    });
+
+    gfsh.executeAndAssertThat(VALID_COMMAND + " --id=queue").statusIsSuccess()
+        .tableHasRowCount("Member", 1).tableHasColumnWithExactValuesInAnyOrder("Result", "Success");
+
+    locator.invoke(() -> {
+      ClusterConfigurationService service =
+          LocatorServerStartupRule.getLocator().getSharedConfiguration();
+      Configuration configuration = service.getConfiguration("cluster");
+      configuration.getCacheXmlContent().contains("id=queue");
+    });
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateAsyncEventQueueCommandTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateAsyncEventQueueCommandTest.java
new file mode 100644
index 0000000000..3fd59af89c
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/CreateAsyncEventQueueCommandTest.java
@@ -0,0 +1,213 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static io.codearte.catchexception.shade.mockito.Matchers.any;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.CREATE_ASYNC_EVENT_QUEUE__BATCHTIMEINTERVAL;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.CREATE_ASYNC_EVENT_QUEUE__BATCH_SIZE;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.CREATE_ASYNC_EVENT_QUEUE__DISKSYNCHRONOUS;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.CREATE_ASYNC_EVENT_QUEUE__DISPATCHERTHREADS;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.CREATE_ASYNC_EVENT_QUEUE__ENABLEBATCHCONFLATION;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.CREATE_ASYNC_EVENT_QUEUE__FORWARD_EXPIRATION_DESTROY;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.CREATE_ASYNC_EVENT_QUEUE__MAXIMUM_QUEUE_MEMORY;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.CREATE_ASYNC_EVENT_QUEUE__ORDERPOLICY;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.CREATE_ASYNC_EVENT_QUEUE__PARALLEL;
+import static org.apache.geode.management.internal.cli.i18n.CliStrings.CREATE_ASYNC_EVENT_QUEUE__PERSISTENT;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.isA;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+
+import org.junit.Before;
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.cache.execute.Function;
+import org.apache.geode.distributed.internal.ClusterConfigurationService;
+import org.apache.geode.management.internal.cli.GfshParseResult;
+import org.apache.geode.management.internal.cli.functions.CliFunctionResult;
+import org.apache.geode.management.internal.configuration.domain.XmlEntity;
+import org.apache.geode.test.junit.categories.UnitTest;
+import org.apache.geode.test.junit.rules.GfshParserRule;
+
+
+@Category(UnitTest.class)
+public class CreateAsyncEventQueueCommandTest {
+
+  public static final String COMMAND = "create async-event-queue ";
+  public static final String MINIUM_COMMAND = COMMAND + "--id=id --listener=xyz";
+  @ClassRule
+  public static GfshParserRule gfsh = new GfshParserRule();
+
+  private CreateAsyncEventQueueCommand command;
+  private ClusterConfigurationService service;
+
+  @Before
+  public void before() throws Exception {
+    command = spy(CreateAsyncEventQueueCommand.class);
+    service = mock(ClusterConfigurationService.class);
+    doReturn(service).when(command).getSharedConfiguration();
+  }
+
+  @Test
+  public void mandatoryId() throws Exception {
+    gfsh.executeAndAssertThat(command, COMMAND + "--listener=xyz").statusIsError()
+        .containsOutput("Invalid command");
+  }
+
+  @Test
+  public void mandatoryListener() throws Exception {
+    gfsh.executeAndAssertThat(command, COMMAND + "--id=id").statusIsError()
+        .containsOutput("Invalid command");
+  }
+
+  @Test
+  public void cannotCreateAEQOnOneMember() throws Exception {
+    // AEQ can not be created on one member since it needs to update CC.
+    // This test is to make sure we don't add this option
+    gfsh.executeAndAssertThat(command, COMMAND + "--id=id --listener=xyz --member=xyz")
+        .statusIsError().containsOutput("Invalid command");
+  }
+
+  @Test
+  public void defaultValues() throws Exception {
+    GfshParseResult result = gfsh.parse(MINIUM_COMMAND);
+    assertThat(result.getParamValue(CREATE_ASYNC_EVENT_QUEUE__BATCHTIMEINTERVAL)).isEqualTo(5);
+    assertThat(result.getParamValue(CREATE_ASYNC_EVENT_QUEUE__BATCH_SIZE)).isEqualTo(100);
+    assertThat(result.getParamValue(CREATE_ASYNC_EVENT_QUEUE__MAXIMUM_QUEUE_MEMORY)).isEqualTo(100);
+    assertThat(result.getParamValue(CREATE_ASYNC_EVENT_QUEUE__DISPATCHERTHREADS)).isEqualTo(1);
+    assertThat(result.getParamValue(CREATE_ASYNC_EVENT_QUEUE__DISKSYNCHRONOUS)).isEqualTo(true);
+    assertThat(result.getParamValue(CREATE_ASYNC_EVENT_QUEUE__PERSISTENT)).isEqualTo(false);
+    assertThat(result.getParamValue(CREATE_ASYNC_EVENT_QUEUE__ENABLEBATCHCONFLATION))
+        .isEqualTo(false);
+    assertThat(result.getParamValue(CREATE_ASYNC_EVENT_QUEUE__PARALLEL)).isEqualTo(false);
+    assertThat(result.getParamValue(CREATE_ASYNC_EVENT_QUEUE__FORWARD_EXPIRATION_DESTROY))
+        .isEqualTo(false);
+    assertThat(result.getParamValue(CREATE_ASYNC_EVENT_QUEUE__ORDERPOLICY)).isEqualTo("KEY");
+
+    result = gfsh.parse(COMMAND + "--id=id --listener=xyz --forward-expiration-destroy");
+    assertThat(result.getParamValue(CREATE_ASYNC_EVENT_QUEUE__FORWARD_EXPIRATION_DESTROY))
+        .isEqualTo(true);
+  }
+
+  @Test
+  public void noMemberFound() throws Exception {
+    doReturn(Collections.emptySet()).when(command).findMembers(any(), any());
+    gfsh.executeAndAssertThat(command, MINIUM_COMMAND).statusIsError()
+        .containsOutput("No Members Found");
+  }
+
+  @Test
+  public void buildResult_all_success() throws Exception {
+    List<CliFunctionResult> functionResults = new ArrayList<>();
+    XmlEntity xmlEntity = mock(XmlEntity.class);
+    functionResults.add(new CliFunctionResult("member1", xmlEntity, "SUCCESS"));
+    functionResults.add(new CliFunctionResult("member2", xmlEntity, "SUCCESS"));
+
+    // this is only to make the code pass that member check
+    doReturn(Collections.emptySet()).when(command).getMembers(any(), any());
+    doReturn(functionResults).when(command).execute(isA(Function.class), isA(Object.class),
+        isA(Set.class));
+
+    gfsh.executeAndAssertThat(command, MINIUM_COMMAND).statusIsSuccess().persisted()
+        .tableHasRowCount("Member", 2)
+        .tableHasRowWithValues("Member", "Result", "member1", "SUCCESS")
+        .tableHasRowWithValues("Member", "Result", "member2", "SUCCESS");
+
+    // addXmlEntity should only be called once
+    verify(service).addXmlEntity(xmlEntity, null);
+  }
+
+
+  @Test
+  public void buildResult_all_failure() throws Exception {
+    List<CliFunctionResult> functionResults = new ArrayList<>();
+    XmlEntity xmlEntity = mock(XmlEntity.class);
+    functionResults.add(new CliFunctionResult("member1", false, "failed"));
+    functionResults
+        .add(new CliFunctionResult("member2", new RuntimeException("exception happened"), null));
+
+    // this is only to make the code pass that member check
+    doReturn(Collections.emptySet()).when(command).getMembers(any(), any());
+    doReturn(functionResults).when(command).execute(isA(Function.class), isA(Object.class),
+        isA(Set.class));
+
+    gfsh.executeAndAssertThat(command, MINIUM_COMMAND).statusIsSuccess().persisted() // need to make
+                                                                                     // sure
+                                                                                     // failToPersist
+                                                                                     // flag is not
+                                                                                     // set, so that
+                                                                                     // we won't
+                                                                                     // print out
+                                                                                     // warning
+                                                                                     // messages.
+        .tableHasRowCount("Member", 2)
+        .tableHasRowWithValues("Member", "Result", "member1", "ERROR: failed")
+        .tableHasRowWithValues("Member", "Result", "member2",
+            "ERROR: java.lang.RuntimeException: exception happened");
+
+    // addXmlEntity should not be called
+    verify(service, times(0)).addXmlEntity(xmlEntity, null);
+  }
+
+  @Test
+  public void buildResult_one_failure_one_success() throws Exception {
+    List<CliFunctionResult> functionResults = new ArrayList<>();
+    XmlEntity xmlEntity = mock(XmlEntity.class);
+    functionResults.add(new CliFunctionResult("member1", xmlEntity, "SUCCESS"));
+    functionResults
+        .add(new CliFunctionResult("member2", new RuntimeException("exception happened"), null));
+
+    // this is only to make the code pass that member check
+    doReturn(Collections.emptySet()).when(command).getMembers(any(), any());
+    doReturn(functionResults).when(command).execute(isA(Function.class), isA(Object.class),
+        isA(Set.class));
+
+    gfsh.executeAndAssertThat(command, MINIUM_COMMAND).statusIsSuccess().persisted()
+        .tableHasRowCount("Member", 2)
+        .tableHasRowWithValues("Member", "Result", "member1", "SUCCESS").tableHasRowWithValues(
+            "Member", "Result", "member2", "ERROR: java.lang.RuntimeException: exception happened");
+
+    // addXmlEntity should be called once
+    verify(service).addXmlEntity(xmlEntity, null);
+  }
+
+  @Test
+  public void command_succeeded_but_no_cluster_config_service() throws Exception {
+    doReturn(null).when(command).getSharedConfiguration();
+    doReturn(Collections.emptySet()).when(command).getMembers(any(), any());
+
+    List<CliFunctionResult> functionResults = new ArrayList<>();
+    XmlEntity xmlEntity = mock(XmlEntity.class);
+    functionResults.add(new CliFunctionResult("member1", xmlEntity, "SUCCESS"));
+    doReturn(functionResults).when(command).execute(isA(Function.class), isA(Object.class),
+        isA(Set.class));
+
+    gfsh.executeAndAssertThat(command, MINIUM_COMMAND).statusIsSuccess().failToPersist();
+
+    // addXmlEntity should not be called
+    verify(service, times(0)).addXmlEntity(xmlEntity, null);
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyGatewaySenderCommandTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyGatewaySenderCommandTest.java
index 78726ee49f..d331c170c4 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyGatewaySenderCommandTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DestroyGatewaySenderCommandTest.java
@@ -102,7 +102,8 @@ public void oneFunctionThrowsGeneralException() throws Exception {
 
     doReturn(mock(Set.class)).when(command).getMembers(any(), any());
     parser.executeAndAssertThat(command, "destroy gateway-sender --id=1").statusIsError()
-        .tableHasColumnWithValuesContaining("Status", "result1", "ERROR: something happened");
+        .tableHasColumnWithValuesContaining("Status", "result1",
+            "ERROR: java.lang.Exception: something happened");
 
   }
 }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAsyncEventQueuesCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAsyncEventQueuesCommandDUnitTest.java
new file mode 100644
index 0000000000..10658480f9
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAsyncEventQueuesCommandDUnitTest.java
@@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.apache.geode.test.junit.rules.GfshCommandRule.PortType.jmxManager;
+
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.internal.cache.wan.MyAsyncEventListener;
+import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
+import org.apache.geode.test.junit.categories.UnitTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+
+
+@Category(UnitTest.class)
+public class ListAsyncEventQueuesCommandDUnitTest {
+
+  @ClassRule
+  public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
+
+  @Rule
+  public GfshCommandRule gfsh = new GfshCommandRule(locator::getJmxPort, jmxManager);
+
+  private static MemberVM locator;
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    locator = lsRule.startLocatorVM(0);
+    lsRule.startServerVM(1, "group1", locator.getPort());
+    lsRule.startServerVM(2, "group2", locator.getPort());
+  }
+
+  @Test
+  public void list() throws Exception {
+    gfsh.executeAndAssertThat("list async-event-queue").statusIsSuccess()
+        .containsOutput("No Async Event Queues Found");
+
+    gfsh.executeAndAssertThat("create async-event-queue --id=queue1 --group=group1 --listener="
+        + MyAsyncEventListener.class.getName()).statusIsSuccess();
+
+    gfsh.executeAndAssertThat("create async-event-queue --id=queue2 --group=group2 --listener="
+        + MyAsyncEventListener.class.getName()).statusIsSuccess();
+
+    locator.waitTillAsyncEventQueuesAreReadyOnServers("queue1", 1);
+    locator.waitTillAsyncEventQueuesAreReadyOnServers("queue2", 1);
+
+    gfsh.executeAndAssertThat("list async-event-queue").statusIsSuccess()
+        .tableHasRowCount("Member", 2).tableHasRowWithValues("Member", "ID", "server-1", "queue1")
+        .tableHasRowWithValues("Member", "ID", "server-2", "queue2");
+
+    // create another async event queue on the entire cluster, verify that the command will list all
+    gfsh.executeAndAssertThat(
+        "create async-event-queue --id=queue --listener=" + MyAsyncEventListener.class.getName())
+        .statusIsSuccess();
+
+    gfsh.executeAndAssertThat("list async-event-queue").statusIsSuccess()
+        .tableHasRowCount("Member", 4).tableHasRowWithValues("Member", "ID", "server-1", "queue1")
+        .tableHasRowWithValues("Member", "ID", "server-2", "queue2")
+        .tableHasRowWithValues("Member", "ID", "server-1", "queue")
+        .tableHasRowWithValues("Member", "ID", "server-2", "queue");
+
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/QueueCommandsDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/QueueCommandsDUnitTest.java
deleted file mode 100644
index 70991c16c8..0000000000
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/QueueCommandsDUnitTest.java
+++ /dev/null
@@ -1,437 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-package org.apache.geode.management.internal.cli.commands;
-
-import static org.apache.geode.distributed.ConfigurationProperties.ENABLE_CLUSTER_CONFIGURATION;
-import static org.apache.geode.distributed.ConfigurationProperties.GROUPS;
-import static org.apache.geode.distributed.ConfigurationProperties.HTTP_SERVICE_PORT;
-import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER;
-import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_BIND_ADDRESS;
-import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_PORT;
-import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_START;
-import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;
-import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;
-import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;
-import static org.apache.geode.distributed.ConfigurationProperties.NAME;
-import static org.apache.geode.distributed.ConfigurationProperties.USE_CLUSTER_CONFIGURATION;
-import static org.apache.geode.test.dunit.Assert.assertEquals;
-import static org.apache.geode.test.dunit.Assert.assertFalse;
-import static org.apache.geode.test.dunit.Assert.assertNotNull;
-import static org.apache.geode.test.dunit.Assert.assertTrue;
-import static org.apache.geode.test.dunit.Assert.fail;
-import static org.apache.geode.test.dunit.LogWriterUtils.getLogWriter;
-import static org.apache.geode.test.dunit.Wait.waitForCriterion;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.nio.file.Files;
-import java.util.List;
-import java.util.Properties;
-import java.util.concurrent.CopyOnWriteArrayList;
-
-import org.apache.commons.io.FileUtils;
-import org.junit.Test;
-import org.junit.experimental.categories.Category;
-
-import org.apache.geode.cache.Cache;
-import org.apache.geode.cache.asyncqueue.AsyncEventQueue;
-import org.apache.geode.distributed.Locator;
-import org.apache.geode.distributed.internal.ClusterConfigurationService;
-import org.apache.geode.distributed.internal.InternalLocator;
-import org.apache.geode.internal.AvailablePort;
-import org.apache.geode.internal.AvailablePortHelper;
-import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.i18n.CliStrings;
-import org.apache.geode.management.internal.cli.result.CommandResult;
-import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
-import org.apache.geode.test.compiler.ClassBuilder;
-import org.apache.geode.test.dunit.Host;
-import org.apache.geode.test.dunit.SerializableRunnable;
-import org.apache.geode.test.dunit.VM;
-import org.apache.geode.test.dunit.WaitCriterion;
-import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.categories.FlakyTest;
-
-/**
- * A distributed test suite of test cases for testing the queue commands that are part of Gfsh.
- *
- * @since GemFire 8.0
- */
-@Category({DistributedTest.class, FlakyTest.class}) // GEODE-1429 GEODE-1976 GEODE-3530
-@SuppressWarnings("serial")
-public class QueueCommandsDUnitTest extends CliCommandTestBase {
-
-  private final List<String> filesToBeDeleted = new CopyOnWriteArrayList<>();
-
-  @Override
-  public final void preSetUp() throws Exception {
-    disconnectAllFromDS();
-  }
-
-  @Test // FlakyTest: GEODE-1429
-  public void testAsyncEventQueue() throws IOException {
-    final String queue1Name = "testAsyncEventQueue1";
-    final String queue2Name = "testAsyncEventQueue2";
-    final String diskStoreName = "testAsyncEventQueueDiskStore";
-
-    Properties localProps = new Properties();
-    localProps.setProperty(GROUPS, "Group0");
-    setUpJmxManagerOnVm0ThenConnect(localProps);
-
-    CommandResult cmdResult = executeCommand(CliStrings.LIST_ASYNC_EVENT_QUEUES);
-    assertEquals(Result.Status.OK, cmdResult.getStatus());
-    assertTrue(commandResultToString(cmdResult).contains("No Async Event Queues Found"));
-
-    final VM vm1 = Host.getHost(0).getVM(1);
-    final String vm1Name = "VM" + vm1.getId();
-    final File diskStoreDir = new File(new File(".").getAbsolutePath(), diskStoreName);
-    this.filesToBeDeleted.add(diskStoreDir.getAbsolutePath());
-    vm1.invoke(new SerializableRunnable() {
-      public void run() {
-        diskStoreDir.mkdirs();
-
-        Properties localProps = new Properties();
-        localProps.setProperty(NAME, vm1Name);
-        localProps.setProperty(GROUPS, "Group1");
-        getSystem(localProps);
-        getCache();
-      }
-    });
-
-    final VM vm2 = Host.getHost(0).getVM(2);
-    final String vm2Name = "VM" + vm2.getId();
-    vm2.invoke(new SerializableRunnable() {
-      public void run() {
-        Properties localProps = new Properties();
-        localProps.setProperty(NAME, vm2Name);
-        localProps.setProperty(GROUPS, "Group2");
-        getSystem(localProps);
-        getCache();
-      }
-    });
-
-    // Deploy a JAR file with an
-    // AsyncEventListener/GatewayEventFilter/GatewayEventSubstitutionFilter
-    // that can be instantiated on each server
-    final File jarFile = new File(new File(".").getAbsolutePath(), "QueueCommandsDUnit.jar");
-    QueueCommandsDUnitTest.this.filesToBeDeleted.add(jarFile.getAbsolutePath());
-
-    ClassBuilder classBuilder = new ClassBuilder();
-    byte[] jarBytes =
-        classBuilder.createJarFromClassContent("com/qcdunit/QueueCommandsDUnitTestHelper",
-            "package com.qcdunit;" + "import java.util.List; import java.util.Properties;"
-                + "import org.apache.geode.internal.cache.xmlcache.Declarable2; import org.apache.geode.cache.asyncqueue.AsyncEvent;"
-                + "import org.apache.geode.cache.wan.GatewayEventFilter; import org.apache.geode.cache.wan.GatewayEventSubstitutionFilter;"
-                + "import org.apache.geode.cache.asyncqueue.AsyncEventListener; import org.apache.geode.cache.wan.GatewayQueueEvent;"
-                + "import org.apache.geode.cache.EntryEvent;"
-                + "public class QueueCommandsDUnitTestHelper implements Declarable2, GatewayEventFilter, GatewayEventSubstitutionFilter, AsyncEventListener {"
-                + "Properties props;"
-                + "public boolean processEvents(List<AsyncEvent> events) { return true; }"
-                + "public void afterAcknowledgement(GatewayQueueEvent event) {}"
-                + "public boolean beforeEnqueue(GatewayQueueEvent event) { return true; }"
-                + "public boolean beforeTransmit(GatewayQueueEvent event) { return true; }"
-                + "public Object getSubstituteValue(EntryEvent event) { return null; }"
-                + "public void close() {}"
-                + "public void init(final Properties props) {this.props = props;}"
-                + "public Properties getConfig() {return this.props;}}");
-    writeJarBytesToFile(jarFile, jarBytes);
-
-    cmdResult = executeCommand("deploy --jar=QueueCommandsDUnit.jar");
-    assertEquals(Result.Status.OK, cmdResult.getStatus());
-
-    CommandStringBuilder commandStringBuilder =
-        new CommandStringBuilder(CliStrings.CREATE_DISK_STORE);
-    commandStringBuilder.addOption(CliStrings.CREATE_DISK_STORE__NAME, diskStoreName);
-    commandStringBuilder.addOption(CliStrings.GROUP, "Group1");
-    commandStringBuilder.addOption(CliStrings.CREATE_DISK_STORE__DIRECTORY_AND_SIZE,
-        diskStoreDir.getAbsolutePath());
-    cmdResult = executeCommand(commandStringBuilder.toString());
-    assertEquals(Result.Status.OK, cmdResult.getStatus());
-    String stringResult = commandResultToString(cmdResult);
-    assertEquals(3, countLinesInString(stringResult, false));
-    assertEquals(false, stringResult.contains("ERROR"));
-    assertTrue(stringContainsLine(stringResult, vm1Name + ".*Success"));
-
-    commandStringBuilder = new CommandStringBuilder(CliStrings.CREATE_ASYNC_EVENT_QUEUE);
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__ID, queue1Name);
-    commandStringBuilder.addOption(CliStrings.GROUP, "Group1");
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__BATCH_SIZE, "514");
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__PERSISTENT, "true");
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__DISK_STORE, diskStoreName);
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__MAXIMUM_QUEUE_MEMORY,
-        "213");
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__BATCHTIMEINTERVAL, "946");
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__PARALLEL, "true");
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__ENABLEBATCHCONFLATION,
-        "true");
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__DISPATCHERTHREADS, "2");
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__ORDERPOLICY, "PARTITION");
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__GATEWAYEVENTFILTER,
-        "com.qcdunit.QueueCommandsDUnitTestHelper");
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__SUBSTITUTION_FILTER,
-        "com.qcdunit.QueueCommandsDUnitTestHelper");
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__DISKSYNCHRONOUS, "false");
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__FORWARD_EXPIRATION_DESTROY,
-        "true");
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__LISTENER,
-        "com.qcdunit.QueueCommandsDUnitTestHelper");
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__LISTENER_PARAM_AND_VALUE,
-        "param1,param2#value2");
-    cmdResult = executeCommand(commandStringBuilder.toString());
-    assertEquals(Result.Status.OK, cmdResult.getStatus());
-    stringResult = commandResultToString(cmdResult);
-    assertEquals(3, countLinesInString(stringResult, false));
-    assertEquals(false, stringResult.contains("ERROR"));
-    assertTrue(stringContainsLine(stringResult, vm1Name + ".*Success"));
-
-    // Verify that the queue was created on the correct member
-    cmdResult = executeCommand(CliStrings.LIST_ASYNC_EVENT_QUEUES);
-    assertEquals(Result.Status.OK, cmdResult.getStatus());
-    stringResult = commandResultToString(cmdResult);
-    assertEquals(3, countLinesInString(stringResult, false));
-    assertTrue(stringContainsLine(stringResult, vm1Name + " .*" + queue1Name + " .*514 .*true .*"
-        + diskStoreName + " .*213 .*" + " .*com.qcdunit.QueueCommandsDUnitTestHelper" + ".*"));
-    assertTrue(stringContainsLine(stringResult, vm1Name + ".*param2=value2.*"));
-    assertTrue(stringContainsLine(stringResult, vm1Name + ".*param1=[^\\w].*"));
-    assertFalse(stringContainsLine(stringResult, vm2Name + ".*" + queue1Name + ".*"));
-
-    vm1.invoke(new SerializableRunnable() {
-      public void run() {
-        Cache cache = getCache();
-        AsyncEventQueue queue = cache.getAsyncEventQueue(queue1Name);
-        assertEquals(queue.getBatchSize(), 514);
-        assertEquals(queue.isPersistent(), true);
-        assertEquals(queue.getDiskStoreName(), diskStoreName);
-        assertEquals(queue.getMaximumQueueMemory(), 213);
-        assertEquals(queue.getBatchTimeInterval(), 946);
-        assertEquals(queue.isParallel(), true);
-        assertEquals(queue.isBatchConflationEnabled(), true);
-        assertEquals(queue.getDispatcherThreads(), 2);
-        assertEquals(queue.getOrderPolicy().toString(), "PARTITION");
-        assertEquals(queue.getGatewayEventFilters().size(), 1);
-        assertEquals(queue.getGatewayEventFilters().get(0).getClass().getName(),
-            "com.qcdunit.QueueCommandsDUnitTestHelper");
-        assertEquals(queue.getGatewayEventSubstitutionFilter().getClass().getName(),
-            "com.qcdunit.QueueCommandsDUnitTestHelper");
-        assertEquals(queue.isDiskSynchronous(), false);
-        assertEquals(queue.isForwardExpirationDestroy(), true);
-        assertEquals(queue.getAsyncEventListener().getClass().getName(),
-            "com.qcdunit.QueueCommandsDUnitTestHelper");
-      }
-    });
-
-    commandStringBuilder = new CommandStringBuilder(CliStrings.CREATE_ASYNC_EVENT_QUEUE);
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__ID, queue2Name);
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__LISTENER,
-        "com.qcdunit.QueueCommandsDUnitTestHelper");
-    cmdResult = executeCommand(commandStringBuilder.toString());
-    assertEquals(Result.Status.OK, cmdResult.getStatus());
-    stringResult = commandResultToString(cmdResult);
-    assertEquals(5, countLinesInString(stringResult, false));
-    assertTrue(stringContainsLine(stringResult, "Manager.*Success"));
-    assertTrue(stringContainsLine(stringResult, vm2Name + ".*Success"));
-    assertTrue(stringContainsLine(stringResult, vm1Name + ".*Success"));
-
-    // Verify that the queue was created on the correct members
-    cmdResult = executeCommand(CliStrings.LIST_ASYNC_EVENT_QUEUES);
-    assertEquals(Result.Status.OK, cmdResult.getStatus());
-    stringResult = commandResultToString(cmdResult);
-    assertEquals(6, countLinesInString(stringResult, false));
-    assertTrue(stringContainsLine(stringResult, "Manager .*" + queue2Name
-        + " .*100 .*false .*null .*100 .*" + " .*com.qcdunit.QueueCommandsDUnitTestHelper"));
-    assertTrue(stringContainsLine(stringResult, vm1Name + " .*" + queue1Name + " .*514 .*true .*"
-        + diskStoreName + " .*213 .*" + " .*com.qcdunit.QueueCommandsDUnitTestHelper" + ".*"));
-    assertTrue(stringContainsLine(stringResult, vm1Name + " .*" + queue2Name
-        + " .*100 .*false .*null .*100 .*" + " .*com.qcdunit.QueueCommandsDUnitTestHelper"));
-    assertTrue(stringContainsLine(stringResult, vm2Name + " .*" + queue2Name
-        + " .*100 .*false .*null .*100 .*" + " .*com.qcdunit.QueueCommandsDUnitTestHelper"));
-  }
-
-  /**
-   * Asserts that creating async event queues correctly updates the shared configuration.
-   */
-  @Test // FlakyTest: GEODE-1976
-  public void testCreateUpdatesSharedConfig() throws IOException {
-    disconnectAllFromDS();
-    final int[] ports = AvailablePortHelper.getRandomAvailableTCPPorts(2);
-    jmxPort = ports[0];
-    httpPort = ports[1];
-    try {
-      jmxHost = InetAddress.getLocalHost().getHostName();
-    } catch (UnknownHostException ignore) {
-      jmxHost = "localhost";
-    }
-
-    final String queueName = "testAsyncEventQueueQueue";
-    final String groupName = "testAsyncEventQueueSharedConfigGroup";
-
-    final Properties locatorProps = new Properties();
-    locatorProps.setProperty(NAME, "Locator");
-    locatorProps.setProperty(MCAST_PORT, "0");
-    locatorProps.setProperty(LOG_LEVEL, "fine");
-    locatorProps.setProperty(ENABLE_CLUSTER_CONFIGURATION, "true");
-    locatorProps.setProperty(JMX_MANAGER, "true");
-    locatorProps.setProperty(JMX_MANAGER_START, "true");
-    locatorProps.setProperty(JMX_MANAGER_BIND_ADDRESS, String.valueOf(jmxHost));
-    locatorProps.setProperty(JMX_MANAGER_PORT, String.valueOf(jmxPort));
-    locatorProps.setProperty(HTTP_SERVICE_PORT, String.valueOf(httpPort));
-
-    // Start the Locator and wait for shared configuration to be available
-    final int locatorPort = AvailablePort.getRandomAvailablePort(AvailablePort.SOCKET);
-    Host.getHost(0).getVM(0).invoke(new SerializableRunnable() {
-      @Override
-      public void run() {
-        final File locatorLogFile = new File("locator-" + locatorPort + ".log");
-
-        try {
-          final InternalLocator locator = (InternalLocator) Locator.startLocatorAndDS(locatorPort,
-              locatorLogFile, null, locatorProps);
-
-          WaitCriterion wc = new WaitCriterion() {
-            @Override
-            public boolean done() {
-              return locator.isSharedConfigurationRunning();
-            }
-
-            @Override
-            public String description() {
-              return "Waiting for shared configuration to be started";
-            }
-          };
-          waitForCriterion(wc, 5000, 500, true);
-        } catch (IOException ioex) {
-          fail("Unable to create a locator with a shared configuration");
-        }
-      }
-    });
-
-    connect(jmxHost, jmxPort, httpPort, getDefaultShell());
-
-    // Create a cache in VM 1
-    VM vm = Host.getHost(0).getVM(1);
-    vm.invoke(new SerializableRunnable() {
-      @Override
-      public void run() {
-        Properties localProps = new Properties();
-        localProps.setProperty(MCAST_PORT, "0");
-        localProps.setProperty(LOCATORS, "localhost[" + locatorPort + "]");
-        localProps.setProperty(GROUPS, groupName);
-        getSystem(localProps);
-        assertNotNull(getCache());
-      }
-    });
-
-    // Deploy a JAR file with an AsyncEventListener that can be instantiated on each server
-    final File jarFile = new File(new File(".").getAbsolutePath(), "QueueCommandsDUnit.jar");
-    QueueCommandsDUnitTest.this.filesToBeDeleted.add(jarFile.getAbsolutePath());
-
-    ClassBuilder classBuilder = new ClassBuilder();
-    byte[] jarBytes =
-        classBuilder.createJarFromClassContent("com/qcdunit/QueueCommandsDUnitTestListener",
-            "package com.qcdunit;" + "import java.util.List; import java.util.Properties;"
-                + "import org.apache.geode.internal.cache.xmlcache.Declarable2; import org.apache.geode.cache.asyncqueue.AsyncEvent;"
-                + "import org.apache.geode.cache.asyncqueue.AsyncEventListener;"
-                + "public class QueueCommandsDUnitTestListener implements Declarable2, AsyncEventListener {"
-                + "Properties props;"
-                + "public boolean processEvents(List<AsyncEvent> events) { return true; }"
-                + "public void close() {}"
-                + "public void init(final Properties props) {this.props = props;}"
-                + "public Properties getConfig() {return this.props;}}");
-    writeJarBytesToFile(jarFile, jarBytes);
-
-    CommandResult cmdResult = executeCommand("deploy --jar=QueueCommandsDUnit.jar");
-    assertEquals(Result.Status.OK, cmdResult.getStatus());
-
-    // Test creating the queue
-    CommandStringBuilder commandStringBuilder =
-        new CommandStringBuilder(CliStrings.CREATE_ASYNC_EVENT_QUEUE);
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__ID, queueName);
-    commandStringBuilder.addOption(CliStrings.GROUP, groupName);
-    commandStringBuilder.addOption(CliStrings.CREATE_ASYNC_EVENT_QUEUE__LISTENER,
-        "com.qcdunit.QueueCommandsDUnitTestListener");
-    cmdResult = executeCommand(commandStringBuilder.toString());
-    assertEquals(Result.Status.OK, cmdResult.getStatus());
-
-    // Make sure the queue exists in the shared config
-    Host.getHost(0).getVM(0).invoke(new SerializableRunnable() {
-      @Override
-      public void run() {
-        ClusterConfigurationService sharedConfig =
-            ((InternalLocator) Locator.getLocator()).getSharedConfiguration();
-        String xmlFromConfig;
-        try {
-          xmlFromConfig = sharedConfig.getConfiguration(groupName).getCacheXmlContent();
-          assertTrue(xmlFromConfig.contains(queueName));
-        } catch (Exception e) {
-          fail("Error occurred in cluster configuration service", e);
-        }
-      }
-    });
-
-    // Close cache in the vm1 and restart it to get the shared configuration
-    vm = Host.getHost(0).getVM(1);
-    vm.invoke(new SerializableRunnable() {
-      @Override
-      public void run() {
-        Cache cache = getCache();
-        assertNotNull(cache);
-        cache.close();
-
-        assertTrue(cache.isClosed());
-
-        Properties localProps = new Properties();
-        localProps.setProperty(MCAST_PORT, "0");
-        localProps.setProperty(LOCATORS, "localhost[" + locatorPort + "]");
-        localProps.setProperty(GROUPS, groupName);
-        localProps.setProperty(USE_CLUSTER_CONFIGURATION, "true");
-        getSystem(localProps);
-        cache = getCache();
-        assertNotNull(cache);
-        AsyncEventQueue aeq = cache.getAsyncEventQueue(queueName);
-
-        assertNotNull(aeq);
-      }
-    });
-  }
-
-  @Override
-  protected final void preTearDownCliCommandTestBase() throws Exception {
-    for (String path : this.filesToBeDeleted) {
-      try {
-        final File fileToDelete = new File(path);
-        if (fileToDelete.isDirectory())
-          FileUtils.deleteDirectory(fileToDelete);
-        else
-          Files.delete(fileToDelete.toPath());
-        if (path.endsWith(".jar")) {
-          executeCommand("undeploy --jar=" + fileToDelete.getName());
-        }
-      } catch (IOException e) {
-        getLogWriter().error("Unable to delete file", e);
-      }
-    }
-    this.filesToBeDeleted.clear();
-  }
-
-  private void writeJarBytesToFile(File jarFile, byte[] jarBytes) throws IOException {
-    final OutputStream outStream = new FileOutputStream(jarFile);
-    outStream.write(jarBytes);
-    outStream.close();
-  }
-}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/CliFunctionResultTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/CliFunctionResultTest.java
index 2f0946b2b3..4a4cd91dc6 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/CliFunctionResultTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/functions/CliFunctionResultTest.java
@@ -37,6 +37,6 @@ public void getErrorMessage() throws Exception {
     assertThat(result.getErrorMessage()).isEqualTo("message");
 
     result = new CliFunctionResult("memberName", new Exception("exception message"), null);
-    assertThat(result.getErrorMessage()).isEqualTo("exception message");
+    assertThat(result.getErrorMessage()).isEqualTo("java.lang.Exception: exception message");
   }
 }
diff --git a/geode-core/src/test/java/org/apache/geode/test/junit/assertions/CommandResultAssert.java b/geode-core/src/test/java/org/apache/geode/test/junit/assertions/CommandResultAssert.java
index 4b0a43b4e3..382b65c941 100644
--- a/geode-core/src/test/java/org/apache/geode/test/junit/assertions/CommandResultAssert.java
+++ b/geode-core/src/test/java/org/apache/geode/test/junit/assertions/CommandResultAssert.java
@@ -101,6 +101,16 @@ public CommandResultAssert statusIsSuccess() {
     return this;
   }
 
+  public CommandResultAssert failToPersist() {
+    Assertions.assertThat(actual.getCommandResult().failedToPersist()).isTrue();
+    return this;
+  }
+
+  public CommandResultAssert persisted() {
+    Assertions.assertThat(actual.getCommandResult().failedToPersist()).isFalse();
+    return this;
+  }
+
   /**
    * Verifies that gfsh executed with status ERROR
    */
@@ -195,7 +205,7 @@ public CommandResultAssert tableHasRowWithValues(String... headersThenValues)
     for (int rowIndex = 0; rowIndex < numberOfRows; rowIndex++) {
       Object[] rowValues = new Object[headers.length];
       for (int columnIndex = 0; columnIndex < headers.length; columnIndex++) {
-        rowValues[columnIndex] = allValues.get(headers[columnIndex]).get(rowIndex);
+        rowValues[columnIndex] = allValues.get(headers[columnIndex]).get(rowIndex).toString();
       }
 
       // check if entire row is equal, but if not, continue to next row
@@ -205,7 +215,7 @@ public CommandResultAssert tableHasRowWithValues(String... headersThenValues)
     }
 
     // did not find any matching rows, then this would pass only if we do not pass in any values
-    assertThat(headersThenValues.length).isEqualTo(0);
+    assertThat(headersThenValues.length).describedAs("No matching row found.").isEqualTo(0);
     return this;
   }
 
diff --git a/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshParserRule.java b/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshParserRule.java
index a6e181d5db..350747959b 100644
--- a/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshParserRule.java
+++ b/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshParserRule.java
@@ -53,6 +53,9 @@ public GfshParseResult parse(String command) {
     return parser.parse(command);
   }
 
+  /**
+   * @deprecated use executeAndAssertThat instead
+   */
   public <T> CommandResult executeCommandWithInstance(T instance, String command) {
     GfshParseResult parseResult = parse(command);
 
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpDUnitTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpDUnitTest.java
index 4844e3550a..99f0b1090e 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpDUnitTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpDUnitTest.java
@@ -29,8 +29,8 @@
  */
 @Category({DistributedTest.class, SecurityTest.class})
 @RunWith(SuiteRunner.class)
-@Suite.SuiteClasses({GemfireDataCommandsDUnitTest.class, QueueCommandsDUnitTest.class,
-    ShellCommandsDUnitTest.class, ShowStackTraceDUnitTest.class})
+@Suite.SuiteClasses({GemfireDataCommandsDUnitTest.class, ShellCommandsDUnitTest.class,
+    ShowStackTraceDUnitTest.class})
 public class CommandOverHttpDUnitTest {
   @ClassRule
   public static ProvideSystemProperty provideSystemProperty =


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit de22c2d1b87878fc457e0e24f62011bb5e13a20b in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=de22c2d ]

GEODE-3539: add test coverage for "create async-event-queue" and "lis… (#1093)




jinmeiliao opened a new pull request #1104: GEODE-3539: enhance rule to start locator joining other locators
URL: https://github.com/apache/geode/pull/1104
 
 
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao closed pull request #1104: GEODE-3539: enhance rule to start locator joining other locators
URL: https://github.com/apache/geode/pull/1104
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandRedeployDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandRedeployDUnitTest.java
index 4b91ce50c4..92e8c9d8bb 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandRedeployDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandRedeployDUnitTest.java
@@ -47,7 +47,7 @@
 import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;
 
 @Category(DistributedTest.class)
-public class DeployCommandRedeployDUnitTest implements Serializable {
+public class DeployCommandRedeployDUnitTest {
   private static final String VERSION1 = "Version1";
   private static final String VERSION2 = "Version2";
 
@@ -173,7 +173,7 @@ private File createJarWithFunctionB(String version) throws Exception {
     return jar;
   }
 
-  private void assertThatFunctionHasVersion(String functionId, String version) {
+  private static void assertThatFunctionHasVersion(String functionId, String version) {
     GemFireCacheImpl gemFireCache = GemFireCacheImpl.getInstance();
     DistributedSystem distributedSystem = gemFireCache.getDistributedSystem();
     Execution execution = FunctionService.onMember(distributedSystem.getDistributedMember());
@@ -181,7 +181,8 @@ private void assertThatFunctionHasVersion(String functionId, String version) {
     assertThat(result.get(0)).isEqualTo(version);
   }
 
-  private void assertThatCanLoad(String jarName, String className) throws ClassNotFoundException {
+  private static void assertThatCanLoad(String jarName, String className)
+      throws ClassNotFoundException {
     assertThat(ClassPathLoader.getLatest().getJarDeployer().findDeployedJar(jarName)).isNotNull();
     assertThat(ClassPathLoader.getLatest().forName(className)).isNotNull();
   }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigDeployJarDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigDeployJarDUnitTest.java
index 0d12a18949..5a1058fb60 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigDeployJarDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfigDeployJarDUnitTest.java
@@ -15,7 +15,6 @@
 package org.apache.geode.management.internal.configuration;
 
 import static org.apache.geode.distributed.ConfigurationProperties.GROUPS;
-import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;
 import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -68,14 +67,8 @@ public void testDeployToNoServer() throws Exception {
   @Test
   public void testDeployToMultipleLocators() throws Exception {
     MemberVM locator = lsRule.startLocatorVM(0, locatorProps);
-    locatorProps.setProperty(LOCATORS, "localhost[" + locator.getPort() + "]");
-    MemberVM locator2 = lsRule.startLocatorVM(1, locatorProps);
-    locatorProps.setProperty(LOCATORS,
-        "localhost[" + locator.getPort() + "],localhost[" + locator2.getPort() + "]");
-    MemberVM locator3 = lsRule.startLocatorVM(2, locatorProps);
-
-    // has to start a server in order to run deploy command
-    lsRule.startServerVM(3, serverProps, locator.getPort());
+    MemberVM locator2 = lsRule.startLocatorVM(1, locator.getPort());
+    MemberVM locator3 = lsRule.startLocatorVM(2, locator.getPort(), locator2.getPort());
 
     gfshConnector.connect(locator);
     assertThat(gfshConnector.isConnected()).isTrue();
diff --git a/geode-core/src/test/java/org/apache/geode/test/dunit/rules/LocatorServerStartupRule.java b/geode-core/src/test/java/org/apache/geode/test/dunit/rules/LocatorServerStartupRule.java
index c9e2c8337c..1399e2bae8 100644
--- a/geode-core/src/test/java/org/apache/geode/test/dunit/rules/LocatorServerStartupRule.java
+++ b/geode-core/src/test/java/org/apache/geode/test/dunit/rules/LocatorServerStartupRule.java
@@ -18,6 +18,7 @@
 
 import static org.apache.geode.distributed.ConfigurationProperties.GROUPS;
 import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER_PORT;
+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;
 import static org.apache.geode.distributed.ConfigurationProperties.NAME;
 import static org.apache.geode.test.dunit.Host.getHost;
 
@@ -25,7 +26,9 @@
 import java.io.IOException;
 import java.io.Serializable;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Properties;
+import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
 import org.junit.rules.ExternalResource;
@@ -136,6 +139,14 @@ public MemberVM startLocatorVM(int index) throws Exception {
     return startLocatorVM(index, new Properties());
   }
 
+  public MemberVM startLocatorVM(int index, int... locatorPort) throws Exception {
+    Properties properties = new Properties();
+    String locators = Arrays.stream(locatorPort).mapToObj(i -> "localhost[" + i + "]")
+        .collect(Collectors.joining(","));
+    properties.setProperty(LOCATORS, locators);
+    return startLocatorVM(index, properties);
+  }
+
   /**
    * Starts a locator instance with the given configuration properties inside
    * {@code getHost(0).getVM(index)}.


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 375d3684d283c8e3d57174d79a37b3be44b8830c in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=375d368 ]

GEODE-3539: enhance rule to start locator joining other locators (#1104)



jinmeiliao opened a new pull request #1108: GEODE-3539: enhance GfshCommandRule
URL: https://github.com/apache/geode/pull/1108
 
 
   * reduce the default timeout
   * add ability to configure the timeout at construction time.
   
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit de22c2d1b87878fc457e0e24f62011bb5e13a20b in geode's branch refs/heads/feature/GEODE-3923 from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=de22c2d ]

GEODE-3539: add test coverage for "create async-event-queue" and "lis… (#1093)




jinmeiliao closed pull request #1108: GEODE-3539: enhance GfshCommandRule
URL: https://github.com/apache/geode/pull/1108
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommandIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommandIntegrationTest.java
index 3edc944ce2..21f3f28ed7 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommandIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommandIntegrationTest.java
@@ -18,10 +18,8 @@
 import java.util.Arrays;
 import java.util.List;
 
-import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.ClassRule;
-import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
@@ -56,12 +54,7 @@ public static void beforeClass() throws Exception {
   }
 
   @ClassRule
-  public static GfshCommandRule gfsh = new GfshCommandRule();
-
-  @Before
-  public void setTimeout() {
-    gfsh.setTimeout(1);
-  }
+  public static GfshCommandRule gfsh = new GfshCommandRule().setTimeout(1);
 
   @Test
   public void commandFailsWithoutOptions() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListDiskStoreCommandIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListDiskStoreCommandIntegrationTest.java
index 25ac49cdbe..fa438716f0 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListDiskStoreCommandIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListDiskStoreCommandIntegrationTest.java
@@ -15,7 +15,6 @@
 
 package org.apache.geode.management.internal.cli.commands;
 
-import org.junit.Before;
 import org.junit.ClassRule;
 import org.junit.Rule;
 import org.junit.Test;
@@ -41,12 +40,7 @@
           .withName(MEMBER_NAME).withJMXManager().withAutoStart();
 
   @Rule
-  public GfshCommandRule gfsh = new GfshCommandRule();
-
-  @Before
-  public void setTimeout() {
-    gfsh.setTimeout(1);
-  }
+  public GfshCommandRule gfsh = new GfshCommandRule().setTimeout(1);
 
   @Test
   public void commandSucceedsWhenConnected() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListMembersCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListMembersCommandDUnitTest.java
index 05b83c96ab..3ad80a91d0 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListMembersCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListMembersCommandDUnitTest.java
@@ -16,6 +16,7 @@
 
 import static org.apache.geode.management.internal.cli.i18n.CliStrings.GROUPS;
 import static org.apache.geode.management.internal.cli.i18n.CliStrings.LIST_MEMBER;
+import static org.apache.geode.test.junit.rules.GfshCommandRule.PortType.jmxManager;
 import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.Properties;
@@ -38,25 +39,27 @@
   private static MemberVM locator;
 
   @Rule
-  public GfshCommandRule gfsh = new GfshCommandRule();
+  public GfshCommandRule gfsh = new GfshCommandRule(locator::getJmxPort, jmxManager);
 
   @BeforeClass
   public static void setup() throws Exception {
-    locator = lsRule.startLocatorVM(0, propertiesForGroup("locatorGroup"));
-    lsRule.startServerVM(1, propertiesForGroup("serverGroup1"), locator.getPort());
-    lsRule.startServerVM(2, propertiesForGroup("serverGroup1"), locator.getPort());
-    lsRule.startServerVM(3, propertiesForGroup("serverGroup2"), locator.getPort());
+    Properties properties = new Properties();
+    properties.setProperty(GROUPS, "locatorGroup");
+    locator = lsRule.startLocatorVM(0, properties);
+    lsRule.startServerVM(1, "serverGroup1", locator.getPort());
+    lsRule.startServerVM(2, "serverGroup1", locator.getPort());
+    lsRule.startServerVM(3, "serverGroup2", locator.getPort());
   }
 
   @Test
   public void listMembersWithoutConnection() throws Exception {
+    gfsh.disconnect();
     gfsh.executeAndAssertThat(LIST_MEMBER).statusIsError()
         .containsOutput("Command 'list members' was found but is not currently available");
   }
 
   @Test
   public void listAllMembers() throws Exception {
-    gfsh.connectAndVerify(locator);
     gfsh.executeAndAssertThat(LIST_MEMBER).statusIsSuccess();
     String output = gfsh.getGfshOutput();
 
@@ -68,7 +71,6 @@ public void listAllMembers() throws Exception {
 
   @Test
   public void listMembersInLocatorGroup() throws Exception {
-    gfsh.connectAndVerify(locator);
     gfsh.executeAndAssertThat(LIST_MEMBER + " --group=locatorGroup").statusIsSuccess();
     String output = gfsh.getGfshOutput();
 
@@ -80,7 +82,6 @@ public void listMembersInLocatorGroup() throws Exception {
 
   @Test
   public void listMembersInServerGroupOne() throws Exception {
-    gfsh.connectAndVerify(locator);
     gfsh.executeAndAssertThat(LIST_MEMBER + " --group=serverGroup1").statusIsSuccess();
     String output = gfsh.getGfshOutput();
 
@@ -92,7 +93,6 @@ public void listMembersInServerGroupOne() throws Exception {
 
   @Test
   public void listMembersInServerGroupTwo() throws Exception {
-    gfsh.connectAndVerify(locator);
     gfsh.executeAndAssertThat(LIST_MEMBER + " --group=serverGroup2").statusIsSuccess();
     String output = gfsh.getGfshOutput();
 
@@ -104,7 +104,6 @@ public void listMembersInServerGroupTwo() throws Exception {
 
   @Test
   public void listMembersInNonExistentGroup() throws Exception {
-    gfsh.connectAndVerify(locator);
     gfsh.executeAndAssertThat(LIST_MEMBER + " --group=foo").statusIsSuccess();
     String output = gfsh.getGfshOutput();
 
@@ -114,10 +113,4 @@ public void listMembersInNonExistentGroup() throws Exception {
     assertThat(output).doesNotContain("server-3");
     assertThat(output).contains("No Members Found");
   }
-
-  private static Properties propertiesForGroup(String group) {
-    Properties properties = new Properties();
-    properties.setProperty(GROUPS, group);
-    return properties;
-  }
 }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListRegionDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListRegionDUnitTest.java
index 4c4a5289c3..7feb2ae12e 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListRegionDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListRegionDUnitTest.java
@@ -15,19 +15,10 @@
 
 package org.apache.geode.management.internal.cli.commands;
 
-import static org.apache.geode.distributed.ConfigurationProperties.ENABLE_TIME_STATISTICS;
-import static org.apache.geode.distributed.ConfigurationProperties.GROUPS;
-import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;
-import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;
-import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;
-import static org.apache.geode.distributed.ConfigurationProperties.NAME;
-import static org.apache.geode.distributed.ConfigurationProperties.STATISTIC_SAMPLING_ENABLED;
 import static org.apache.geode.management.internal.cli.i18n.CliStrings.GROUP;
 import static org.apache.geode.management.internal.cli.i18n.CliStrings.LIST_REGION;
 import static org.apache.geode.management.internal.cli.i18n.CliStrings.MEMBER;
 
-import java.util.Properties;
-
 import org.junit.BeforeClass;
 import org.junit.ClassRule;
 import org.junit.Test;
@@ -66,22 +57,16 @@
   public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
 
   @ClassRule
-  public static GfshCommandRule gfshShellConnectionRule = new GfshCommandRule();
+  public static GfshCommandRule gfsh = new GfshCommandRule();
 
   @BeforeClass
   public static void setupSystem() throws Exception {
-    final Properties locatorProps = createProperties(LOCATOR_NAME, GROUP3_NAME);
-    MemberVM locator = lsRule.startLocatorVM(0, locatorProps);
-
-    final Properties server1Props = createProperties(SERVER1_NAME, GROUP1_NAME);
-    server1Props.setProperty(LOCATORS, "localhost[" + locator.getPort() + "]");
-    MemberVM server1 = lsRule.startServerVM(1, server1Props, locator.getPort());
-
-    final Properties server2Props = createProperties(SERVER2_NAME, GROUP2_NAME);
-    MemberVM server = lsRule.startServerVM(2, server2Props, locator.getPort());
+    MemberVM locator = lsRule.startLocatorVM(0);
+    MemberVM server1 = lsRule.startServerVM(1, GROUP1_NAME, locator.getPort());
+    MemberVM server = lsRule.startServerVM(2, GROUP2_NAME, locator.getPort());
 
     server1.invoke(() -> {
-      final Cache cache = CacheFactory.getAnyInstance();
+      final Cache cache = LocatorServerStartupRule.getCache();
       RegionFactory<String, Integer> dataRegionFactory =
           cache.createRegionFactory(RegionShortcut.PARTITION);
       dataRegionFactory.create(PR1);
@@ -89,20 +74,20 @@ public static void setupSystem() throws Exception {
     });
 
     server.invoke(() -> {
-      final Cache cache = CacheFactory.getAnyInstance();
+      final Cache cache = LocatorServerStartupRule.getCache();
       RegionFactory<String, Integer> dataRegionFactory =
           cache.createRegionFactory(RegionShortcut.PARTITION);
       dataRegionFactory.create(PR1);
       createRegionsWithSubRegions();
     });
 
-    gfshShellConnectionRule.connectAndVerify(locator);
+    gfsh.connectAndVerify(locator);
   }
 
   @Test
   public void listAllRegions() throws Exception {
     String listRegions = new CommandStringBuilder(LIST_REGION).toString();
-    gfshShellConnectionRule.executeAndAssertThat(listRegions).statusIsSuccess().containsOutput(PR1,
+    gfsh.executeAndAssertThat(listRegions).statusIsSuccess().containsOutput(PR1,
         LOCALREGIONONSERVER1, REGION1, REGION2, REGION3);
   }
 
@@ -110,7 +95,7 @@ public void listAllRegions() throws Exception {
   public void listRegionsOnManager() throws Exception {
     String listRegions =
         new CommandStringBuilder(LIST_REGION).addOption(MEMBER, SERVER1_NAME).toString();
-    gfshShellConnectionRule.executeAndAssertThat(listRegions).statusIsSuccess().containsOutput(PR1,
+    gfsh.executeAndAssertThat(listRegions).statusIsSuccess().containsOutput(PR1,
         LOCALREGIONONSERVER1);
   }
 
@@ -118,36 +103,24 @@ public void listRegionsOnManager() throws Exception {
   public void listRegionsOnServer() throws Exception {
     CommandStringBuilder csb = new CommandStringBuilder(LIST_REGION);
     csb.addOption(MEMBER, SERVER2_NAME);
-    gfshShellConnectionRule.executeAndAssertThat(csb.toString()).statusIsSuccess()
-        .containsOutput(PR1, REGION1, REGION2, REGION3, SUBREGION1A);
+    gfsh.executeAndAssertThat(csb.toString()).statusIsSuccess().containsOutput(PR1, REGION1,
+        REGION2, REGION3, SUBREGION1A);
   }
 
   @Test
   public void listRegionsInGroup1() throws Exception {
     CommandStringBuilder csb = new CommandStringBuilder(LIST_REGION);
     csb.addOption(GROUP, GROUP1_NAME);
-    gfshShellConnectionRule.executeAndAssertThat(csb.toString()).statusIsSuccess()
-        .containsOutput(PR1, LOCALREGIONONSERVER1);
+    gfsh.executeAndAssertThat(csb.toString()).statusIsSuccess().containsOutput(PR1,
+        LOCALREGIONONSERVER1);
   }
 
   @Test
   public void listRegionsInGroup2() throws Exception {
     CommandStringBuilder csb = new CommandStringBuilder(LIST_REGION);
     csb.addOption(GROUP, GROUP2_NAME);
-    gfshShellConnectionRule.executeAndAssertThat(csb.toString()).statusIsSuccess()
-        .containsOutput(PR1, REGION1, REGION2, REGION3, SUBREGION1A);
-  }
-
-
-  private static Properties createProperties(String name, String groups) {
-    Properties props = new Properties();
-    props.setProperty(MCAST_PORT, "0");
-    props.setProperty(LOG_LEVEL, "info");
-    props.setProperty(STATISTIC_SAMPLING_ENABLED, "true");
-    props.setProperty(ENABLE_TIME_STATISTICS, "true");
-    props.setProperty(NAME, name);
-    props.setProperty(GROUPS, groups);
-    return props;
+    gfsh.executeAndAssertThat(csb.toString()).statusIsSuccess().containsOutput(PR1, REGION1,
+        REGION2, REGION3, SUBREGION1A);
   }
 
   private static void createLocalRegion(final String regionName) {
diff --git a/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshCommandRule.java b/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshCommandRule.java
index 48e99872a4..fb94fa7f2e 100644
--- a/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshCommandRule.java
+++ b/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshCommandRule.java
@@ -74,6 +74,7 @@
   private Supplier<Integer> portSupplier;
   private PortType portType = PortType.jmxManager;
   private HeadlessGfsh gfsh = null;
+  private int gfshTimeout = 2;
   private boolean connected = false;
   private IgnoredException ignoredException;
   private TemporaryFolder temporaryFolder = new TemporaryFolder();
@@ -98,7 +99,7 @@ public GfshCommandRule(Supplier<Integer> portSupplier, PortType portType) {
   protected void before(Description description) throws Throwable {
     LogWrapper.close();
     workingDir = temporaryFolder.newFolder("gfsh_files");
-    this.gfsh = new HeadlessGfsh(getClass().getName(), 30, workingDir.getAbsolutePath());
+    this.gfsh = new HeadlessGfsh(getClass().getName(), gfshTimeout, workingDir.getAbsolutePath());
     ignoredException =
         addIgnoredException("java.rmi.NoSuchObjectException: no such object in table");
 
@@ -267,8 +268,12 @@ public File getWorkingDir() {
     return workingDir;
   }
 
-  public void setTimeout(long timeoutInSeconds) {
-    gfsh.setTimeout(timeoutInSeconds);
+  public GfshCommandRule setTimeout(int timeoutInSeconds) {
+    this.gfshTimeout = timeoutInSeconds;
+    if (gfsh != null) {
+      gfsh.setTimeout(timeoutInSeconds);
+    }
+    return this;
   }
 
   public enum PortType {


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit c51a455c05d3a94a880569693e8a8e14d176e380 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=c51a455 ]

GEODE-3539: enhance GfshCommandRule (#1108)

* reduce the default timeout
* add ability to configure the timeout at construction time.

jinmeiliao opened a new pull request #1111: GEODE-3539: enhance GfshCommandRule. Rename method for consistency.
URL: https://github.com/apache/geode/pull/1111
 
 
   * reduce the default timeout
   * add ability to configure the timeout at construction time.
   
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao closed pull request #1111: GEODE-3539: enhance GfshCommandRule. Rename method for consistency.
URL: https://github.com/apache/geode/pull/1111
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommandIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommandIntegrationTest.java
index 21f3f28ed7..890337b4f2 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommandIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DescribeDiskStoreCommandIntegrationTest.java
@@ -54,7 +54,7 @@ public static void beforeClass() throws Exception {
   }
 
   @ClassRule
-  public static GfshCommandRule gfsh = new GfshCommandRule().setTimeout(1);
+  public static GfshCommandRule gfsh = new GfshCommandRule().withTimeout(1);
 
   @Test
   public void commandFailsWithoutOptions() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListDiskStoreCommandIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListDiskStoreCommandIntegrationTest.java
index fa438716f0..7961f58a0f 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListDiskStoreCommandIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListDiskStoreCommandIntegrationTest.java
@@ -40,7 +40,7 @@
           .withName(MEMBER_NAME).withJMXManager().withAutoStart();
 
   @Rule
-  public GfshCommandRule gfsh = new GfshCommandRule().setTimeout(1);
+  public GfshCommandRule gfsh = new GfshCommandRule().withTimeout(1);
 
   @Test
   public void commandSucceedsWhenConnected() throws Exception {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListRegionIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListRegionIntegrationTest.java
index 673ebf020c..297893fdd2 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListRegionIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListRegionIntegrationTest.java
@@ -42,11 +42,6 @@
   @Rule
   public GfshCommandRule gfsh = new GfshCommandRule(server::getJmxPort, PortType.jmxManager);
 
-  @Before
-  public void setup() {
-    gfsh.setTimeout(2);
-  }
-
   @Test
   public void commandFailsWhenNotConnected() throws Exception {
     gfsh.disconnect();
diff --git a/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshCommandRule.java b/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshCommandRule.java
index fb94fa7f2e..6ab7908fe8 100644
--- a/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshCommandRule.java
+++ b/geode-core/src/test/java/org/apache/geode/test/junit/rules/GfshCommandRule.java
@@ -268,11 +268,8 @@ public File getWorkingDir() {
     return workingDir;
   }
 
-  public GfshCommandRule setTimeout(int timeoutInSeconds) {
+  public GfshCommandRule withTimeout(int timeoutInSeconds) {
     this.gfshTimeout = timeoutInSeconds;
-    if (gfsh != null) {
-      gfsh.setTimeout(timeoutInSeconds);
-    }
     return this;
   }
 


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit b2d37ecf15d6e83c238007226ec1d5b170d0fa11 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=b2d37ec ]

GEODE-3539: enhance GfshCommandRule. Renmame method for consistency. (#1111)

* reduce the default timeout
* add ability to configure the timeout at construction time.

Commit c51a455c05d3a94a880569693e8a8e14d176e380 in geode's branch refs/heads/feature/GEODE-3637 from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=c51a455 ]

GEODE-3539: enhance GfshCommandRule (#1108)

* reduce the default timeout
* add ability to configure the timeout at construction time.

Commit b2d37ecf15d6e83c238007226ec1d5b170d0fa11 in geode's branch refs/heads/feature/GEODE-3637 from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=b2d37ec ]

GEODE-3539: enhance GfshCommandRule. Renmame method for consistency. (#1111)

* reduce the default timeout
* add ability to configure the timeout at construction time.

jinmeiliao opened a new pull request #1147: GEODE-3539: more multi-user test coverage.
URL: https://github.com/apache/geode/pull/1147
 
 
   * added more logging in Client's subject binding/removing
   * added more tests for multi-clients and muti-user-authentication mode.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao opened a new pull request #1162: GEODE-3539: add tests for ExportStackTraceCommand
URL: https://github.com/apache/geode/pull/1162
 
 
   * add unit tests for the command
   * reworked the DUnit test to use the rules
   
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on issue #1162: GEODE-3539: add tests for ExportStackTraceCommand
URL: https://github.com/apache/geode/pull/1162#issuecomment-351558488
 
 
   precheckin green

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


PurelyApplied commented on a change in pull request #1162: GEODE-3539: add tests for ExportStackTraceCommand
URL: https://github.com/apache/geode/pull/1162#discussion_r157084998
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportStackTraceCommandTest.java
 ##########
 @@ -0,0 +1,72 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.spy;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Collections;
+
+import org.junit.Before;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+import org.junit.rules.TemporaryFolder;
+
+import org.apache.geode.test.junit.categories.UnitTest;
+import org.apache.geode.test.junit.rules.GfshParserRule;
+
+
+@Category(UnitTest.class)
+public class ExportStackTraceCommandTest {
+
+  @ClassRule
+  public static GfshParserRule gfsh = new GfshParserRule();
+
+  @Rule
+  public TemporaryFolder temporaryFolder = new TemporaryFolder();
+
+  private ExportStackTraceCommand command;
+
+  @Before
+  public void before() {
+    command = spy(ExportStackTraceCommand.class);
+  }
+
+  @Test
+  public void noMemberFound() {
+    doReturn(Collections.emptySet()).when(command).findMembers(any(), any());
+    gfsh.executeAndAssertThat(command, "export stack-traces").statusIsError()
+        .containsOutput("No Members Found");
+  }
+
+  @Test
+  public void fileExists() throws IOException {
 
 Review comment:
   At first glance, I thought the second assertion was an accidental redundancy of the test above.  I eventually read your comment and realized the test was verifying that we check for the file existing before anything else.
   
   For clarity, I might prefer a test name like `abortImmediatelyIfFileExists`.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao commented on a change in pull request #1162: GEODE-3539: add tests for ExportStackTraceCommand
URL: https://github.com/apache/geode/pull/1162#discussion_r157237492
 
 

 ##########
 File path: geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportStackTraceCommandTest.java
 ##########
 @@ -0,0 +1,72 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.spy;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Collections;
+
+import org.junit.Before;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+import org.junit.rules.TemporaryFolder;
+
+import org.apache.geode.test.junit.categories.UnitTest;
+import org.apache.geode.test.junit.rules.GfshParserRule;
+
+
+@Category(UnitTest.class)
+public class ExportStackTraceCommandTest {
+
+  @ClassRule
+  public static GfshParserRule gfsh = new GfshParserRule();
+
+  @Rule
+  public TemporaryFolder temporaryFolder = new TemporaryFolder();
+
+  private ExportStackTraceCommand command;
+
+  @Before
+  public void before() {
+    command = spy(ExportStackTraceCommand.class);
+  }
+
+  @Test
+  public void noMemberFound() {
+    doReturn(Collections.emptySet()).when(command).findMembers(any(), any());
+    gfsh.executeAndAssertThat(command, "export stack-traces").statusIsError()
+        .containsOutput("No Members Found");
+  }
+
+  @Test
+  public void fileExists() throws IOException {
 
 Review comment:
   fixed now.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao closed pull request #1162: GEODE-3539: add tests for ExportStackTraceCommand
URL: https://github.com/apache/geode/pull/1162
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportStackTraceCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportStackTraceCommand.java
index 4f8693d382..ddf84dd444 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportStackTraceCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportStackTraceCommand.java
@@ -34,11 +34,9 @@
 import org.apache.geode.cache.execute.ResultCollector;
 import org.apache.geode.distributed.DistributedMember;
 import org.apache.geode.distributed.internal.InternalDistributedSystem;
-import org.apache.geode.internal.cache.InternalCache;
 import org.apache.geode.management.cli.CliMetaData;
 import org.apache.geode.management.cli.ConverterHint;
 import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.cli.domain.StackTracesPerMember;
 import org.apache.geode.management.internal.cli.functions.GetStackTracesFunction;
 import org.apache.geode.management.internal.cli.i18n.CliStrings;
@@ -51,7 +49,8 @@
   private final GetStackTracesFunction getStackTracesFunction = new GetStackTracesFunction();
 
   /**
-   * Current implementation supports writing it to a file and returning the location of the file
+   * Current implementation supports writing it to a locator/server side file and returning the
+   * location of the file
    */
   @CliCommand(value = CliStrings.EXPORT_STACKTRACE, help = CliStrings.EXPORT_STACKTRACE__HELP)
   @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_DEBUG_UTIL})
@@ -68,55 +67,43 @@ public Result exportStackTrace(@CliOption(key = {CliStrings.MEMBER, CliStrings.M
           help = CliStrings.EXPORT_STACKTRACE__FILE__HELP) String fileName,
 
       @CliOption(key = CliStrings.EXPORT_STACKTRACE__FAIL__IF__FILE__PRESENT,
-          unspecifiedDefaultValue = "false",
-          help = CliStrings.EXPORT_STACKTRACE__FAIL__IF__FILE__PRESENT__HELP) boolean failIfFilePresent) {
-
-    Result result;
-    StringBuilder filePrefix = new StringBuilder("stacktrace");
+          unspecifiedDefaultValue = "false", specifiedDefaultValue = "true",
+          help = CliStrings.EXPORT_STACKTRACE__FAIL__IF__FILE__PRESENT__HELP) boolean failIfFilePresent)
+      throws IOException {
 
     if (fileName == null) {
+      StringBuilder filePrefix = new StringBuilder("stacktrace");
       fileName = filePrefix.append("_").append(System.currentTimeMillis()).toString();
     }
     final File outFile = new File(fileName);
-    try {
-      if (outFile.exists() && failIfFilePresent) {
-        return ResultBuilder.createShellClientErrorResult(CliStrings.format(
-            CliStrings.EXPORT_STACKTRACE__ERROR__FILE__PRESENT, outFile.getCanonicalPath()));
-      }
-
 
-      InternalCache cache = getCache();
-      InternalDistributedSystem ads = cache.getInternalDistributedSystem();
+    if (outFile.exists() && failIfFilePresent) {
+      return ResultBuilder.createUserErrorResult(CliStrings
+          .format(CliStrings.EXPORT_STACKTRACE__ERROR__FILE__PRESENT, outFile.getCanonicalPath()));
+    }
 
-      InfoResultData resultData = ResultBuilder.createInfoResultData();
+    Map<String, byte[]> dumps = new HashMap<>();
+    Set<DistributedMember> targetMembers = getMembers(group, memberNameOrId);
 
-      Map<String, byte[]> dumps = new HashMap<>();
-      Set<DistributedMember> targetMembers = CliUtil.findMembers(group, memberNameOrId);
-      if (targetMembers.isEmpty()) {
-        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
-      }
+    InfoResultData resultData = ResultBuilder.createInfoResultData();
 
-      ResultCollector<?, ?> rc =
-          CliUtil.executeFunction(getStackTracesFunction, null, targetMembers);
-      ArrayList<Object> resultList = (ArrayList<Object>) rc.getResult();
+    ResultCollector<?, ?> rc = executeFunction(getStackTracesFunction, null, targetMembers);
+    ArrayList<Object> resultList = (ArrayList<Object>) rc.getResult();
 
-      for (Object resultObj : resultList) {
-        if (resultObj instanceof StackTracesPerMember) {
-          StackTracesPerMember stackTracePerMember = (StackTracesPerMember) resultObj;
-          dumps.put(stackTracePerMember.getMemberNameOrId(), stackTracePerMember.getStackTraces());
-        }
+    for (Object resultObj : resultList) {
+      if (resultObj instanceof StackTracesPerMember) {
+        StackTracesPerMember stackTracePerMember = (StackTracesPerMember) resultObj;
+        dumps.put(stackTracePerMember.getMemberNameOrId(), stackTracePerMember.getStackTraces());
       }
+    }
 
-      String filePath = writeStacksToFile(dumps, fileName);
-      resultData.addLine(CliStrings.format(CliStrings.EXPORT_STACKTRACE__SUCCESS, filePath));
-      resultData.addLine(CliStrings.EXPORT_STACKTRACE__HOST + ads.getDistributedMember().getHost());
+    InternalDistributedSystem ads = getCache().getInternalDistributedSystem();
+    String filePath = writeStacksToFile(dumps, fileName);
+    resultData.addLine(CliStrings.format(CliStrings.EXPORT_STACKTRACE__SUCCESS, filePath));
+    resultData.addLine(CliStrings.EXPORT_STACKTRACE__HOST + ads.getDistributedMember().getHost());
+
+    return ResultBuilder.buildResult(resultData);
 
-      result = ResultBuilder.buildResult(resultData);
-    } catch (IOException ex) {
-      result = ResultBuilder
-          .createGemFireErrorResult(CliStrings.EXPORT_STACKTRACE__ERROR + ex.getMessage());
-    }
-    return result;
   }
 
   /***
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportStackTraceCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportStackTraceCommandDUnitTest.java
new file mode 100644
index 0000000000..eb7ed07389
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportStackTraceCommandDUnitTest.java
@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.io.File;
+
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.test.dunit.rules.LocatorServerStartupRule;
+import org.apache.geode.test.dunit.rules.MemberVM;
+import org.apache.geode.test.junit.categories.DistributedTest;
+import org.apache.geode.test.junit.rules.GfshCommandRule;
+
+
+@Category(DistributedTest.class)
+public class ExportStackTraceCommandDUnitTest {
+
+  @ClassRule
+  public static LocatorServerStartupRule lsRule = new LocatorServerStartupRule();
+
+  @Rule
+  public GfshCommandRule gfsh = new GfshCommandRule();
+
+  private static MemberVM locator;
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    locator = lsRule.startLocatorVM(0);
+    lsRule.startServerVM(1, locator.getPort());
+  }
+
+  @Before
+  public void before() throws Exception {
+    gfsh.connectAndVerify(locator);
+  }
+
+  @Test
+  public void exportStackTrace_no_file() {
+    gfsh.executeAndAssertThat("export stack-traces").statusIsSuccess()
+        .containsOutput("stack-trace(s) exported to file").containsOutput("On host : ");
+    File[] files = locator.getWorkingDir().listFiles(x -> x.getName().startsWith("stacktrace_"));
+    assertThat(files.length).isEqualTo(1);
+    // delete this file afterwards so that we won't pollute the other tests in this class
+    files[0].delete();
+  }
+
+  @Test
+  public void exportStackTrace_on_one_member() {
+    gfsh.executeAndAssertThat("export stack-traces --member=server-1").statusIsSuccess()
+        .containsOutput("stack-trace(s) exported to file").containsOutput("On host : ");
+    File[] files = locator.getWorkingDir().listFiles(x -> x.getName().startsWith("stacktrace_"));
+    assertThat(files.length).isEqualTo(1);
+    // delete this file afterwards so that we won't pollute the other tests in this class
+    files[0].delete();
+  }
+
+  @Test
+  public void exportStackTrace_with_file() {
+    File stackTraceFile = new File(locator.getWorkingDir(), "my_file");
+    gfsh.executeAndAssertThat("export stack-traces --file=" + stackTraceFile.getAbsolutePath())
+        .statusIsSuccess().containsOutput("stack-trace(s) exported to file");
+
+    // make sure file exists afterwards
+    File[] files = locator.getWorkingDir().listFiles(x -> x.getName().startsWith("my_file"));
+    assertThat(files.length).isEqualTo(1);
+
+    // execute the command again with the abort flag
+    gfsh.executeAndAssertThat(
+        "export stack-traces --abort-if-file-exists --file=" + stackTraceFile.getAbsolutePath())
+        .statusIsError().containsOutput("already present");
+
+    // execute the command again without the abort flag
+    gfsh.executeAndAssertThat("export stack-traces --file=" + stackTraceFile.getAbsolutePath())
+        .statusIsSuccess().containsOutput("stack-trace(s) exported to file");
+    // make sure the file is overwritten
+    files = locator.getWorkingDir().listFiles(x -> x.getName().startsWith("my_file"));
+    assertThat(files.length).isEqualTo(1);
+
+    // delete this file afterwards so that we won't pollute the other tests in this class
+    files[0].delete();
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportStackTraceCommandTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportStackTraceCommandTest.java
new file mode 100644
index 0000000000..521e50d9ec
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportStackTraceCommandTest.java
@@ -0,0 +1,72 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.spy;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Collections;
+
+import org.junit.Before;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+import org.junit.rules.TemporaryFolder;
+
+import org.apache.geode.test.junit.categories.UnitTest;
+import org.apache.geode.test.junit.rules.GfshParserRule;
+
+
+@Category(UnitTest.class)
+public class ExportStackTraceCommandTest {
+
+  @ClassRule
+  public static GfshParserRule gfsh = new GfshParserRule();
+
+  @Rule
+  public TemporaryFolder temporaryFolder = new TemporaryFolder();
+
+  private ExportStackTraceCommand command;
+
+  @Before
+  public void before() {
+    command = spy(ExportStackTraceCommand.class);
+  }
+
+  @Test
+  public void noMemberFound() {
+    doReturn(Collections.emptySet()).when(command).findMembers(any(), any());
+    gfsh.executeAndAssertThat(command, "export stack-traces").statusIsError()
+        .containsOutput("No Members Found");
+  }
+
+  @Test
+  public void abortIfFileExists() throws IOException {
+    File file = temporaryFolder.newFile("stackTrace.txt");
+    gfsh.executeAndAssertThat(command,
+        "export stack-traces --abort-if-file-exists --file=" + file.getAbsolutePath())
+        .statusIsError().containsOutput("already present");
+
+    // try again without the flag, the command should continue after the check
+    doReturn(Collections.emptySet()).when(command).findMembers(any(), any());
+    gfsh.executeAndAssertThat(command, "export stack-traces --file=" + file.getAbsolutePath())
+        .statusIsError().containsOutput("No Members Found");
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowStackTraceDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowStackTraceDUnitTest.java
deleted file mode 100644
index b8b96be180..0000000000
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ShowStackTraceDUnitTest.java
+++ /dev/null
@@ -1,269 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-package org.apache.geode.management.internal.cli.commands;
-
-import static org.apache.geode.distributed.ConfigurationProperties.ENABLE_TIME_STATISTICS;
-import static org.apache.geode.distributed.ConfigurationProperties.GROUPS;
-import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;
-import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;
-import static org.apache.geode.distributed.ConfigurationProperties.NAME;
-import static org.apache.geode.distributed.ConfigurationProperties.STATISTIC_SAMPLING_ENABLED;
-import static org.apache.geode.test.dunit.Assert.assertFalse;
-import static org.apache.geode.test.dunit.Assert.assertTrue;
-import static org.apache.geode.test.dunit.LogWriterUtils.getLogWriter;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.Properties;
-
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.experimental.categories.Category;
-import org.junit.rules.TemporaryFolder;
-
-import org.apache.geode.management.cli.Result.Status;
-import org.apache.geode.management.internal.cli.i18n.CliStrings;
-import org.apache.geode.management.internal.cli.json.GfJsonException;
-import org.apache.geode.management.internal.cli.result.CommandResult;
-import org.apache.geode.management.internal.cli.util.CommandStringBuilder;
-import org.apache.geode.test.dunit.Host;
-import org.apache.geode.test.dunit.SerializableRunnable;
-import org.apache.geode.test.dunit.VM;
-import org.apache.geode.test.junit.categories.DistributedTest;
-import org.apache.geode.test.junit.categories.FlakyTest;
-import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;
-
-/**
- * DUnit test for 'show stack-trace' command
- */
-@Category({DistributedTest.class, FlakyTest.class}) // GEODE-3530
-@SuppressWarnings("serial")
-public class ShowStackTraceDUnitTest extends CliCommandTestBase {
-
-  @Rule
-  public TemporaryFolder workDirectory = new SerializableTemporaryFolder();
-
-  private void createCache(Properties props) {
-    getSystem(props);
-    getCache();
-  }
-
-  private Properties createProperties(Host host, String name, String groups) {
-    Properties props = new Properties();
-    props.setProperty(MCAST_PORT, "0");
-    props.setProperty(LOG_LEVEL, "info");
-    props.setProperty(STATISTIC_SAMPLING_ENABLED, "true");
-    props.setProperty(ENABLE_TIME_STATISTICS, "true");
-    props.setProperty(NAME, name);
-    props.setProperty(GROUPS, groups);
-    return props;
-  }
-
-  /***
-   * Sets up a system of 3 peers
-   */
-  private void setupSystem() {
-    disconnectAllFromDS();
-    final Host host = Host.getHost(0);
-    final VM[] servers = {host.getVM(0), host.getVM(1)};
-
-    final Properties propsManager = createProperties(host, "Manager", "G1");
-    final Properties propsServer2 = createProperties(host, "Server", "G2");
-
-    setUpJmxManagerOnVm0ThenConnect(propsManager);
-
-    servers[1].invoke(new SerializableRunnable("Create cache for server1") {
-      public void run() {
-        createCache(propsServer2);
-      }
-    });
-  }
-
-  /***
-   * Tests the default behavior of the show stack-trace command
-   *
-   * @throws ClassNotFoundException
-   * @throws IOException
-   */
-  @Test
-  public void testExportStacktrace() throws ClassNotFoundException, IOException {
-    setupSystem();
-
-    File allStacktracesFile = workDirectory.newFile("allStackTraces.txt");
-    CommandStringBuilder csb = new CommandStringBuilder(CliStrings.EXPORT_STACKTRACE);
-    csb.addOption(CliStrings.EXPORT_STACKTRACE__FILE, allStacktracesFile.getCanonicalPath());
-    String commandString = csb.toString();
-    getLogWriter().info("CommandString : " + commandString);
-    CommandResult commandResult = executeCommand(commandString);
-    getLogWriter().info("Output : \n" + commandResultToString(commandResult));
-    assertTrue(commandResult.getStatus().equals(Status.OK));
-
-    File mgrStacktraceFile = workDirectory.newFile("managerStacktrace.txt");
-    csb = new CommandStringBuilder(CliStrings.EXPORT_STACKTRACE);
-    csb.addOption(CliStrings.EXPORT_STACKTRACE__FILE, mgrStacktraceFile.getCanonicalPath());
-    csb.addOption(CliStrings.MEMBER, "Manager");
-    commandString = csb.toString();
-    getLogWriter().info("CommandString : " + commandString);
-    commandResult = executeCommand(commandString);
-    getLogWriter().info("Output : \n" + commandResultToString(commandResult));
-    assertTrue(commandResult.getStatus().equals(Status.OK));
-
-    File serverStacktraceFile = workDirectory.newFile("serverStacktrace.txt");
-    csb = new CommandStringBuilder(CliStrings.EXPORT_STACKTRACE);
-    csb.addOption(CliStrings.EXPORT_STACKTRACE__FILE, serverStacktraceFile.getCanonicalPath());
-    csb.addOption(CliStrings.MEMBER, "Server");
-    commandString = csb.toString();
-    getLogWriter().info("CommandString : " + commandString);
-    commandResult = executeCommand(commandString);
-    getLogWriter().info("Output : \n" + commandResultToString(commandResult));
-    assertTrue(commandResult.getStatus().equals(Status.OK));
-
-    File groupStacktraceFile = workDirectory.newFile("groupstacktrace.txt");
-    csb = new CommandStringBuilder(CliStrings.EXPORT_STACKTRACE);
-    csb.addOption(CliStrings.EXPORT_STACKTRACE__FILE, groupStacktraceFile.getCanonicalPath());
-    csb.addOption(CliStrings.GROUP, "G2");
-    commandString = csb.toString();
-    getLogWriter().info("CommandString : " + commandString);
-    commandResult = executeCommand(commandString);
-    getLogWriter().info("Output : \n" + commandResultToString(commandResult));
-    assertTrue(commandResult.getStatus().equals(Status.OK));
-
-    File wrongStackTraceFile = workDirectory.newFile("wrongStackTrace.txt");
-    csb = new CommandStringBuilder(CliStrings.EXPORT_STACKTRACE);
-    csb.addOption(CliStrings.EXPORT_STACKTRACE__FILE, wrongStackTraceFile.getCanonicalPath());
-    csb.addOption(CliStrings.MEMBER, "WrongMember");
-    commandString = csb.toString();
-    getLogWriter().info("CommandString : " + commandString);
-    commandResult = executeCommand(commandString);
-    getLogWriter().info("Output : \n" + commandResultToString(commandResult));
-    assertFalse(commandResult.getStatus().equals(Status.OK));
-  }
-
-  /***
-   * Tests the behavior of the show stack-trace command to verify that files with any extension are
-   * allowed Refer: GEODE-734
-   *
-   * @throws ClassNotFoundException
-   * @throws IOException
-   */
-  @Test
-  public void testExportStacktraceWithNonTXTFile() throws ClassNotFoundException, IOException {
-    setupSystem();
-
-    // Test non txt extension file is allowed
-    File stacktracesFile = workDirectory.newFile("allStackTraces.log");
-    CommandStringBuilder commandStringBuilder =
-        new CommandStringBuilder(CliStrings.EXPORT_STACKTRACE);
-    commandStringBuilder.addOption(CliStrings.EXPORT_STACKTRACE__FILE,
-        stacktracesFile.getCanonicalPath());
-    String exportCommandString = commandStringBuilder.toString();
-    getLogWriter().info("CommandString : " + exportCommandString);
-    CommandResult exportCommandResult = executeCommand(exportCommandString);
-    getLogWriter().info("Output : \n" + commandResultToString(exportCommandResult));
-    assertTrue(exportCommandResult.getStatus().equals(Status.OK));
-
-    // test file with-out any extension
-    File allStacktracesFile = workDirectory.newFile("allStackTraces");
-    commandStringBuilder = new CommandStringBuilder(CliStrings.EXPORT_STACKTRACE);
-    commandStringBuilder.addOption(CliStrings.EXPORT_STACKTRACE__FILE,
-        allStacktracesFile.getCanonicalPath());
-    exportCommandString = commandStringBuilder.toString();
-    getLogWriter().info("CommandString : " + exportCommandString);
-    exportCommandResult = executeCommand(exportCommandString);
-    getLogWriter().info("Output : \n" + commandResultToString(exportCommandResult));
-    assertTrue(exportCommandResult.getStatus().equals(Status.OK));
-  }
-
-  /***
-   * Tests the behavior of the show stack-trace command when file is already present and
-   * abort-if-file-exists option is set to false(which is default). As a result it should overwrite
-   * the file and return OK status
-   *
-   * @throws ClassNotFoundException
-   * @throws IOException
-   */
-  @Test
-  public void testExportStacktraceWhenFilePresent() throws ClassNotFoundException, IOException {
-    setupSystem();
-
-    // test pass although file present
-    File stacktracesFile = workDirectory.newFile("allStackTraces.log");
-    CommandStringBuilder commandStringBuilder =
-        new CommandStringBuilder(CliStrings.EXPORT_STACKTRACE);
-    commandStringBuilder.addOption(CliStrings.EXPORT_STACKTRACE__FILE,
-        stacktracesFile.getCanonicalPath());
-    String exportCommandString = commandStringBuilder.toString();
-    getLogWriter().info("CommandString : " + exportCommandString);
-    CommandResult exportCommandResult = executeCommand(exportCommandString);
-    getLogWriter().info("Output : \n" + commandResultToString(exportCommandResult));
-    assertTrue(exportCommandResult.getStatus().equals(Status.OK));
-
-  }
-
-  /***
-   * Tests the behavior of the show stack-trace command when file is already present and when
-   * abort-if-file-exists option is set to true. As a result it should fail with ERROR status
-   *
-   * @throws ClassNotFoundException
-   * @throws IOException
-   */
-  @Test
-  public void testExportStacktraceFilePresentWithAbort()
-      throws ClassNotFoundException, IOException, GfJsonException {
-    setupSystem();
-
-    File stacktracesFile = workDirectory.newFile("allStackTraces.log");
-    CommandStringBuilder commandStringBuilder =
-        new CommandStringBuilder(CliStrings.EXPORT_STACKTRACE);
-    commandStringBuilder.addOption(CliStrings.EXPORT_STACKTRACE__FILE,
-        stacktracesFile.getCanonicalPath());
-    commandStringBuilder.addOption(CliStrings.EXPORT_STACKTRACE__FAIL__IF__FILE__PRESENT,
-        Boolean.TRUE.toString());
-    String exportCommandString = commandStringBuilder.toString();
-    getLogWriter().info("CommandString : " + exportCommandString);
-    CommandResult exportCommandResult = executeCommand(exportCommandString);
-    getLogWriter().info("Output : \n" + commandResultToString(exportCommandResult));
-    assertTrue(exportCommandResult.getStatus().equals(Status.ERROR));
-    assertTrue(((String) exportCommandResult.getResultData().getGfJsonObject()
-        .getJSONObject("content").getJSONArray("message").get(0))
-            .contains("file " + stacktracesFile.getCanonicalPath() + " already present"));
-  }
-
-  /***
-   * Tests the behavior of the show stack-trace command when file option is not provided File should
-   * get auto-generated
-   *
-   * @throws ClassNotFoundException
-   * @throws IOException
-   */
-  @Test
-  public void testExportStacktraceAutoGenerateFile()
-      throws ClassNotFoundException, IOException, GfJsonException {
-    setupSystem();
-
-    // test auto generated file when file name is not provided
-    CommandStringBuilder commandStringBuilder =
-        new CommandStringBuilder(CliStrings.EXPORT_STACKTRACE);
-    String exportCommandString = commandStringBuilder.toString();
-    getLogWriter().info("CommandString : " + exportCommandString);
-    CommandResult exportCommandResult = executeCommand(exportCommandString);
-    getLogWriter().info("Output : \n" + commandResultToString(exportCommandResult));
-    assertTrue(exportCommandResult.getStatus().equals(Status.OK));
-    assertTrue(
-        ((String) exportCommandResult.getResultData().getGfJsonObject().getJSONObject("content")
-            .getJSONArray("message").get(0)).contains("stack-trace(s) exported to file:"));
-
-  }
-}
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpDUnitTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpDUnitTest.java
index 99f0b1090e..3ce3e5abc6 100644
--- a/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpDUnitTest.java
+++ b/geode-web/src/test/java/org/apache/geode/management/internal/cli/commands/CommandOverHttpDUnitTest.java
@@ -29,8 +29,7 @@
  */
 @Category({DistributedTest.class, SecurityTest.class})
 @RunWith(SuiteRunner.class)
-@Suite.SuiteClasses({GemfireDataCommandsDUnitTest.class, ShellCommandsDUnitTest.class,
-    ShowStackTraceDUnitTest.class})
+@Suite.SuiteClasses({GemfireDataCommandsDUnitTest.class, ShellCommandsDUnitTest.class})
 public class CommandOverHttpDUnitTest {
   @ClassRule
   public static ProvideSystemProperty provideSystemProperty =


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit f76eeae1b474cd7a6c86168c8424ab9161e55cee in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=f76eeae ]

GEODE-3539: add tests for ExportStackTraceCommand (#1162)

* GEODE-3539: add tests for ExportStackTraceCommand

* add unit tests for the command
* reworked the DUnit test to use the rules


Commit f76eeae1b474cd7a6c86168c8424ab9161e55cee in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=f76eeae ]

GEODE-3539: add tests for ExportStackTraceCommand (#1162)

* GEODE-3539: add tests for ExportStackTraceCommand

* add unit tests for the command
* reworked the DUnit test to use the rules


Commit f76eeae1b474cd7a6c86168c8424ab9161e55cee in geode's branch refs/heads/feature/GEODE-3781 from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=f76eeae ]

GEODE-3539: add tests for ExportStackTraceCommand (#1162)

* GEODE-3539: add tests for ExportStackTraceCommand

* add unit tests for the command
* reworked the DUnit test to use the rules


Commit f76eeae1b474cd7a6c86168c8424ab9161e55cee in geode's branch refs/heads/feature/GEODE-3781 from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=f76eeae ]

GEODE-3539: add tests for ExportStackTraceCommand (#1162)

* GEODE-3539: add tests for ExportStackTraceCommand

* add unit tests for the command
* reworked the DUnit test to use the rules


jinmeiliao opened a new pull request #1253: GEODE-3539: fix test category
URL: https://github.com/apache/geode/pull/1253
 
 
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao closed pull request #1253: GEODE-3539: fix test category
URL: https://github.com/apache/geode/pull/1253
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAsyncEventQueuesCommandDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAsyncEventQueuesCommandDUnitTest.java
index 1c61e4a30c..0d924c82f5 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAsyncEventQueuesCommandDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ListAsyncEventQueuesCommandDUnitTest.java
@@ -26,11 +26,11 @@
 import org.apache.geode.internal.cache.wan.MyAsyncEventListener;
 import org.apache.geode.test.dunit.rules.ClusterStartupRule;
 import org.apache.geode.test.dunit.rules.MemberVM;
-import org.apache.geode.test.junit.categories.UnitTest;
+import org.apache.geode.test.junit.categories.DistributedTest;
 import org.apache.geode.test.junit.rules.GfshCommandRule;
 
 
-@Category(UnitTest.class)
+@Category(DistributedTest.class)
 public class ListAsyncEventQueuesCommandDUnitTest {
 
   @ClassRule


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit ff008e33a6c3c6a6ab84b96156ec44dad4bc72f7 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=ff008e3 ]

GEODE-3539: fix test category (#1253)



jinmeiliao closed pull request #1242: GEODE-3539: Rule cleanup. delete all files in the workingDir when cleaning up MemberVM
URL: https://github.com/apache/geode/pull/1242
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/JdbcDUnitTest.java b/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/JdbcDUnitTest.java
index d571ecba38..ea1878ffec 100644
--- a/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/JdbcDUnitTest.java
+++ b/geode-connectors/src/test/java/org/apache/geode/connectors/jdbc/JdbcDUnitTest.java
@@ -32,7 +32,6 @@
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
-import org.apache.geode.cache.CacheFactory;
 import org.apache.geode.cache.Region;
 import org.apache.geode.pdx.PdxInstance;
 import org.apache.geode.test.dunit.IgnoredException;
@@ -84,7 +83,6 @@ private void createTable() throws SQLException {
   @After
   public void tearDown() throws Exception {
     server.invoke(() -> {
-      CacheFactory.getAnyInstance().close();
       closeDB();
     });
   }
@@ -112,9 +110,9 @@ public void throwsExceptionWhenNoMappingExistsUsingWriter() throws Exception {
 
     server.invoke(() -> {
       PdxInstance pdxEmployee1 =
-          CacheFactory.getAnyInstance().createPdxInstanceFactory(Employee.class.getName())
+          ClusterStartupRule.getCache().createPdxInstanceFactory(Employee.class.getName())
               .writeString("name", "Emp1").writeInt("age", 55).create();
-      Region region = CacheFactory.getAnyInstance().getRegion(REGION_NAME);
+      Region region = ClusterStartupRule.getCache().getRegion(REGION_NAME);
       assertThatThrownBy(() -> region.put("key1", pdxEmployee1))
           .isExactlyInstanceOf(IllegalStateException.class).hasMessage(
               "JDBC mapping for region employees not found. Create the mapping with the gfsh command 'create jdbc-mapping'.");
@@ -129,12 +127,12 @@ public void throwsExceptionWhenNoMappingExistsUsingAsyncWriter() throws Exceptio
 
     server.invoke(() -> {
       PdxInstance pdxEmployee1 =
-          CacheFactory.getAnyInstance().createPdxInstanceFactory(Employee.class.getName())
+          ClusterStartupRule.getCache().createPdxInstanceFactory(Employee.class.getName())
               .writeString("name", "Emp1").writeInt("age", 55).create();
-      Region region = CacheFactory.getAnyInstance().getRegion(REGION_NAME);
+      Region region = ClusterStartupRule.getCache().getRegion(REGION_NAME);
       region.put("key1", pdxEmployee1);
 
-      JdbcAsyncWriter asyncWriter = (JdbcAsyncWriter) CacheFactory.getAnyInstance()
+      JdbcAsyncWriter asyncWriter = (JdbcAsyncWriter) ClusterStartupRule.getCache()
           .getAsyncEventQueue("JAW").getAsyncEventListener();
       Awaitility.await().atMost(30, TimeUnit.SECONDS).until(() -> {
         assertThat(asyncWriter.getFailedEvents()).isEqualTo(1);
@@ -151,9 +149,9 @@ public void throwsExceptionWhenNoMappingMatches() throws Exception {
 
     server.invoke(() -> {
       PdxInstance pdxEmployee1 =
-          CacheFactory.getAnyInstance().createPdxInstanceFactory(Employee.class.getName())
+          ClusterStartupRule.getCache().createPdxInstanceFactory(Employee.class.getName())
               .writeString("name", "Emp1").writeInt("age", 55).create();
-      Region region = CacheFactory.getAnyInstance().getRegion(REGION_NAME);
+      Region region = ClusterStartupRule.getCache().getRegion(REGION_NAME);
       assertThatThrownBy(() -> region.put("key1", pdxEmployee1))
           .isExactlyInstanceOf(IllegalStateException.class).hasMessage(
               "JDBC mapping for region employees not found. Create the mapping with the gfsh command 'create jdbc-mapping'.");
@@ -167,9 +165,9 @@ public void throwsExceptionWhenNoConnectionExists() throws Exception {
 
     server.invoke(() -> {
       PdxInstance pdxEmployee1 =
-          CacheFactory.getAnyInstance().createPdxInstanceFactory(Employee.class.getName())
+          ClusterStartupRule.getCache().createPdxInstanceFactory(Employee.class.getName())
               .writeString("name", "Emp1").writeInt("age", 55).create();
-      Region region = CacheFactory.getAnyInstance().getRegion(REGION_NAME);
+      Region region = ClusterStartupRule.getCache().getRegion(REGION_NAME);
       assertThatThrownBy(() -> region.put("key1", pdxEmployee1))
           .isExactlyInstanceOf(IllegalStateException.class).hasMessage(
               "JDBC connection with name TestConnection not found. Create the connection with the gfsh command 'create jdbc-connection'");
@@ -183,11 +181,11 @@ public void putWritesToDB() throws Exception {
     createMapping(REGION_NAME, CONNECTION_NAME);
     server.invoke(() -> {
       PdxInstance pdxEmployee1 =
-          CacheFactory.getAnyInstance().createPdxInstanceFactory(Employee.class.getName())
+          ClusterStartupRule.getCache().createPdxInstanceFactory(Employee.class.getName())
               .writeString("id", "key1").writeString("name", "Emp1").writeInt("age", 55).create();
 
       String key = "emp1";
-      CacheFactory.getAnyInstance().getRegion(REGION_NAME).put(key, pdxEmployee1);
+      ClusterStartupRule.getCache().getRegion(REGION_NAME).put(key, pdxEmployee1);
       assertTableHasEmployeeData(1, pdxEmployee1, key);
     });
   }
@@ -199,11 +197,11 @@ public void putAsyncWritesToDB() throws Exception {
     createMapping(REGION_NAME, CONNECTION_NAME);
     server.invoke(() -> {
       PdxInstance pdxEmployee1 =
-          CacheFactory.getAnyInstance().createPdxInstanceFactory(Employee.class.getName())
+          ClusterStartupRule.getCache().createPdxInstanceFactory(Employee.class.getName())
               .writeString("id", "key1").writeString("name", "Emp1").writeInt("age", 55).create();
 
       String key = "emp1";
-      CacheFactory.getAnyInstance().getRegion(REGION_NAME).put(key, pdxEmployee1);
+      ClusterStartupRule.getCache().getRegion(REGION_NAME).put(key, pdxEmployee1);
       assertTableHasEmployeeData(1, pdxEmployee1, key);
     });
   }
@@ -215,7 +213,7 @@ public void getReadsFromEmptyDB() throws Exception {
     createMapping(REGION_NAME, CONNECTION_NAME);
     server.invoke(() -> {
       String key = "emp1";
-      Region region = CacheFactory.getAnyInstance().getRegion(REGION_NAME);
+      Region region = ClusterStartupRule.getCache().getRegion(REGION_NAME);
       region.get(key);
       assertThat(region.size()).isEqualTo(0);
     });
@@ -228,11 +226,11 @@ public void getReadsFromDB() throws Exception {
     createMapping(REGION_NAME, CONNECTION_NAME);
     server.invoke(() -> {
       PdxInstance pdxEmployee1 =
-          CacheFactory.getAnyInstance().createPdxInstanceFactory(Employee.class.getName())
+          ClusterStartupRule.getCache().createPdxInstanceFactory(Employee.class.getName())
               .writeString("id", "id1").writeString("name", "Emp1").writeInt("age", 55).create();
 
       String key = "id1";
-      Region region = CacheFactory.getAnyInstance().getRegion(REGION_NAME);
+      Region region = ClusterStartupRule.getCache().getRegion(REGION_NAME);
       region.put(key, pdxEmployee1);
       region.invalidate(key);
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsDUnitTest.java
index 7ae41b10ef..38598a75bc 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/ExportLogsDUnitTest.java
@@ -65,7 +65,7 @@
   private static final String ERROR_LOG_PREFIX = "[IGNORE]";
 
   @Rule
-  public ClusterStartupRule lsRule = new ClusterStartupRule().withTempWorkingDir().withLogFile();
+  public ClusterStartupRule lsRule = new ClusterStartupRule().withLogFile();
 
   @Rule
   public GfshCommandRule gfshConnector = new GfshCommandRule();
@@ -253,7 +253,6 @@ private void verifyLogFileContents(Set<String> acceptedLogLevels, File dirForMem
 
     File logFileForMember = new File(dirForMember, memberName + ".log");
     assertThat(logFileForMember).exists();
-    assertThat(fileNamesInDir).hasSize(1);
 
     String logFileContents = FileUtils.readLines(logFileForMember, Charset.defaultCharset())
         .stream().collect(joining("\n"));
@@ -283,7 +282,7 @@ private File unzipExportedLogs() throws IOException {
         .describedAs(filesInDir.stream().map(File::getAbsolutePath).collect(joining(",")))
         .hasSize(1);
 
-    File unzippedLogFileDir = lsRule.getTempWorkingDir().newFolder("unzippedLogs");
+    File unzippedLogFileDir = new File(locatorWorkingDir, "unzippedLogs");
     ZipUtils.unzip(zipFilesInDir.get(0).getCanonicalPath(), unzippedLogFileDir.getCanonicalPath());
     return unzippedLogFileDir;
   }
diff --git a/geode-core/src/test/java/org/apache/geode/test/dunit/rules/ClusterStartupRule.java b/geode-core/src/test/java/org/apache/geode/test/dunit/rules/ClusterStartupRule.java
index 89029c65e6..39d3438040 100644
--- a/geode-core/src/test/java/org/apache/geode/test/dunit/rules/ClusterStartupRule.java
+++ b/geode-core/src/test/java/org/apache/geode/test/dunit/rules/ClusterStartupRule.java
@@ -103,8 +103,14 @@ public static ClientCache getClientCache() {
    *
    * use this if you want to examine each member's file system without worrying about it's being
    * contaminated with DUnitLauncher's log files that exists in each dunit/vm folder such as
-   * locator0View.dat and locator0views.log and other random log files. This will cause the VMs to
-   * be bounced after test is done, because it dynamically changes the user.dir system property.
+   * locatorxxxView.dat and locatorxxxviews.log and other random log files.
+   *
+   * If the product code is doing new File(".") or new File("relative-path.log"), it will still
+   * pointing to the a File under the old CWD. So avoid using relative path and always use absolute
+   * path or with a parent dir when creating new File object.
+   *
+   * But this will cause the VMs to be bounced after test is done, because it dynamically changes
+   * the user.dir system property, causing slow running tests. Use with discretion.
    */
   public ClusterStartupRule withTempWorkingDir() {
     tempWorkingDir = new SerializableTemporaryFolder();
diff --git a/geode-core/src/test/java/org/apache/geode/test/dunit/rules/MemberVM.java b/geode-core/src/test/java/org/apache/geode/test/dunit/rules/MemberVM.java
index 96bede2a6e..c9f1212258 100644
--- a/geode-core/src/test/java/org/apache/geode/test/dunit/rules/MemberVM.java
+++ b/geode-core/src/test/java/org/apache/geode/test/dunit/rules/MemberVM.java
@@ -103,10 +103,9 @@ public void stopVM(boolean cleanWorkingDir) {
        */
       vm.bounce();
     } else
-      // if using the dunit/vm dir as the preset working dir, need to cleanup dir except
-      // the locator0view* file, so that regions/indexes won't get persisted across tests
-      Arrays.stream(getWorkingDir().listFiles((dir, name) -> !name.startsWith("locator0view")))
-          .forEach(FileUtils::deleteQuietly);
+      // if using the dunit/vm dir as the preset working dir, need to cleanup dir
+      // so that regions/indexes won't get persisted across tests
+      Arrays.stream(getWorkingDir().listFiles()).forEach(FileUtils::deleteQuietly);
   }
 
   /**


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 48d93ed75f258434d09ae869547352173d6a9015 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=48d93ed ]

GEODE-3539: rule cleanup (#1242)

* add javadoc to explain the issue of with useTempWorkingDir
* properly cleanup all residue files in the working dir
* fix tests that do not need to use a tempWorkingDir

