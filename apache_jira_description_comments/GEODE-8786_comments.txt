nonbinaryprogrammer opened a new pull request #5875:
URL: https://github.com/apache/geode/pull/5875


   - add enum for keyspace increment type
   - remove clearall() method
   - add tests for supported commands that do not update the stats
   - use boolean to indicate if stats should be updated
   - get the s*store command tests working
   - add internal pttl to be called from the expire command to avoid updating the stats
   - move the updateStats boolean up a level
   - remove unused executors
   - change s*store stats integrations tests to reflect behavior in native redis
   - fix bitop test
   - add INTERNAL command type
   
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, check Concourse for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jdeppe-pivotal commented on a change in pull request #5875:
URL: https://github.com/apache/geode/pull/5875#discussion_r552236162



##########
File path: geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/server/AbstractHitsMissesIntegrationTest.java
##########
@@ -286,90 +306,312 @@ public void testHscan() {
     runCommandAndAssertHitsAndMisses("hash", (k, v) -> jedis.hscan(k, v));
   }
 
+  @Test
+  public void testHMSet() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Map<String, String> map = new HashMap<>();
+    map.put("key1", "value1");
+    map.put("key2", "value2");
+
+    jedis.hmset("key", map);

Review comment:
       This could also just end up being a call to `runCommandAndAssertNoStatUpdates`

##########
File path: geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/server/AbstractHitsMissesIntegrationTest.java
##########
@@ -286,90 +306,312 @@ public void testHscan() {
     runCommandAndAssertHitsAndMisses("hash", (k, v) -> jedis.hscan(k, v));
   }
 
+  @Test
+  public void testHMSet() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Map<String, String> map = new HashMap<>();
+    map.put("key1", "value1");
+    map.put("key2", "value2");
+
+    jedis.hmset("key", map);
+
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  // ------------ Connection related commands -----------
+
+  // TODO auth needs some setup. manually verified that auth does not change hit/miss stats
+  // if that changes we'll need to come back to this test
+  @Ignore
+  @Test
+  public void testAuth() {

Review comment:
       I don't think we need tests for these 3 commands since they don't deal with keys at all and don't even manipulate any data.

##########
File path: geode-redis/src/main/java/org/apache/geode/redis/internal/data/CommandHelper.java
##########
@@ -137,37 +140,49 @@ private RedisString checkStringType(RedisData redisData, boolean ignoreTypeMisma
     return (RedisString) redisData;
   }
 
-  RedisString getRedisString(ByteArrayWrapper key) {
+  RedisString getRedisString(ByteArrayWrapper key, boolean updateStats) {
     RedisData redisData = getRedisData(key, NULL_REDIS_STRING);
-    if (redisData == NULL_REDIS_STRING) {
-      redisStats.incKeyspaceMisses();
-    } else {
-      redisStats.incKeyspaceHits();
+    if (updateStats) {
+      if (redisData == NULL_REDIS_STRING) {
+        redisStats.incKeyspaceMisses();
+      } else {
+        redisStats.incKeyspaceHits();
+      }
     }
 
     return checkStringType(redisData, false);
   }
 
-  RedisString getRedisStringIgnoringType(ByteArrayWrapper key) {
+  RedisString getRedisStringIgnoringType(ByteArrayWrapper key, boolean updateStats) {
     RedisData redisData = getRedisData(key, NULL_REDIS_STRING);
-    if (redisData == NULL_REDIS_STRING) {
-      redisStats.incKeyspaceMisses();
-    } else {
-      redisStats.incKeyspaceHits();
+    if (updateStats) {
+      if (redisData == NULL_REDIS_STRING) {
+        redisStats.incKeyspaceMisses();
+      } else {
+        redisStats.incKeyspaceHits();
+      }
     }
+
     return checkStringType(redisData, true);
   }
 
-  RedisString setRedisString(ByteArrayWrapper key, ByteArrayWrapper value) {
+  RedisString setRedisString(ByteArrayWrapper key, ByteArrayWrapper value, boolean updateStats) {

Review comment:
       It looks like this method is only ever called with `updateStats == false` so that parameter can be removed. Since it's also a method that is mutating data it should never be updating the hits/misses stats.

##########
File path: geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/server/AbstractHitsMissesIntegrationTest.java
##########
@@ -286,90 +306,312 @@ public void testHscan() {
     runCommandAndAssertHitsAndMisses("hash", (k, v) -> jedis.hscan(k, v));
   }
 
+  @Test
+  public void testHMSet() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Map<String, String> map = new HashMap<>();
+    map.put("key1", "value1");
+    map.put("key2", "value2");
+
+    jedis.hmset("key", map);
+
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  // ------------ Connection related commands -----------
+
+  // TODO auth needs some setup. manually verified that auth does not change hit/miss stats
+  // if that changes we'll need to come back to this test
+  @Ignore
+  @Test
+  public void testAuth() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.auth("some password");
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  @Test
+  public void testPing() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.ping();
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  @Test
+  public void testQuit() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.quit();
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  // ------------ PubSub related commands -----------
+
+  // TODO test pubsub related commands
+  // tests are currently flaky when run against Native Redis so they have been
+  // ignored for now. Add them back when GEODE-8577 has been resolved
+  @Ignore
+  @Test
+  public void testSubscribeAndUnsubscribe() {
+    MockSubscriber mockSubscriber = new MockSubscriber();
+    Jedis subscriber = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Runnable runnable = () -> subscriber.subscribe(mockSubscriber, "someChannel");
+    Thread subscriberThread = new Thread(runnable);
+    subscriberThread.start();
+
+    try {
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    } finally {
+      mockSubscriber.unsubscribe("someChannel");
+      GeodeAwaitility.await().ignoreExceptions().until(() -> !subscriberThread.isAlive());
+
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    }
+  }
+
+  @Ignore
+  @Test
+  public void testPSubscribeAndPUnsubscribe() {
+    MockSubscriber mockSubscriber = new MockSubscriber();
+    Jedis pSubscriber = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Runnable runnable = () -> pSubscriber.psubscribe(mockSubscriber, "someChannel");
+    Thread subscriberThread = new Thread(runnable);
+    subscriberThread.start();
+
+    try {
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    } finally {
+      mockSubscriber.punsubscribe("someChannel");
+      GeodeAwaitility.await().ignoreExceptions().until(() -> !subscriberThread.isAlive());
+
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    }
+  }
+
+  @Ignore
+  @Test
+  public void testPublish() {
+    MockSubscriber mockSubscriber = new MockSubscriber();
+    Jedis subscriber = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+    Jedis publisher = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Runnable runnable = () -> subscriber.subscribe(mockSubscriber, "someChannel");
+    Thread subscriberThread = new Thread(runnable);
+    subscriberThread.start();
+
+    try {
+      publisher.publish("someChannel", "hello");
+
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    } finally {
+      mockSubscriber.unsubscribe("someChannel");
+      GeodeAwaitility.await().ignoreExceptions().until(() -> !subscriberThread.isAlive());
+    }
+  }
+
+  // ------------ Key related commands -----------
+
+  @Test
+  public void testExpire() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.expire(k, 5));
+  }
+
+  @Test
+  public void testPassiveExpiration() {
+    Map<String, String> info = getInfo(jedis);
+    String currentHits = info.get(HITS);
+    String currentMisses = info.get(MISSES);
+
+    jedis.expire("hash", 1);
+
+    GeodeAwaitility.await().during(Duration.ofSeconds(3)).until(() -> true);
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(currentHits);
+    assertThat(info.get(MISSES)).isEqualTo(currentMisses);
+  }
+
+  @Test
+  public void testExpireAt() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.expireAt(k, 2145916800));
+  }
+
+  @Test
+  public void testPExpire() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.pexpire(k, 1024));
+  }
+
+  @Test
+  public void testPExpireAt() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.pexpireAt(k, 1608247597));
+  }
+
+  @Test
+  public void testPersist() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.persist(k));
+  }
+
+  // ------------ Helper Methods -----------
+
   private void runCommandAndAssertHitsAndMisses(String key, Consumer<String> command) {
-    command.accept(key);
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    command.accept(key);
+    info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("1");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 1));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
 
     command.accept("missed");
     info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("1");
-    assertThat(info.get(MISSES)).isEqualTo("1");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 1));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses + 1));
   }
 
   private void runCommandAndAssertHitsAndMisses(String key, BiConsumer<String, String> command) {
-    command.accept(key, "42");
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
 
-    assertThat(info.get(HITS)).isEqualTo("1");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    command.accept(key, "42");
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 1));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
 
     command.accept("missed", "42");
     info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("1");
-    assertThat(info.get(MISSES)).isEqualTo("1");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 1));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses + 1));
   }
 
   private void runDiffCommandAndAssertHitsAndMisses(String key,
       BiConsumer<String, String> command) {
-    command.accept(key, key);
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
 
-    assertThat(info.get(HITS)).isEqualTo("2");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    command.accept(key, key);
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 2));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
 
     command.accept(key, "missed");
     info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("3");
-    assertThat(info.get(MISSES)).isEqualTo("1");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 3));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses + 1));
   }
 
   /**
    * When storing diff-ish results, hits and misses are never updated
    */
   private void runDiffStoreCommandAndAssertNoStatUpdates(String key,
       TriConsumer<String, String, String> command) {
-    command.accept("destination", key, key);
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
 
-    assertThat(info.get(HITS)).isEqualTo("0");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    command.accept("destination", key, key);
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
 
     command.accept("destination", key, "missed");
     info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("0");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
   }
 
   private void runCommandAndAssertNoStatUpdates(String key, Consumer<String> command) {
-    command.accept(key);
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
 
-    assertThat(info.get(HITS)).isEqualTo("0");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    command.accept(key);
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
   }
 
   private void runCommandAndAssertNoStatUpdates(String key, BiConsumer<String, String> command) {
-    command.accept(key, "42");
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
 
-    assertThat(info.get(HITS)).isEqualTo("0");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    command.accept(key, "42");
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));

Review comment:
       Since these are just string comparisons there's probably no need to do any numeric conversions.

##########
File path: geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/server/AbstractHitsMissesIntegrationTest.java
##########
@@ -82,6 +81,19 @@ public void testPttl() {
     runCommandAndAssertHitsAndMisses("string", k -> jedis.pttl(k));
   }
 
+  @Test
+  public void testRename() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.rename("string", "newString");
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));

Review comment:
       This could probably just become:
   ```
   runCommandAndAssertNoStatUpdates("string", (k, v) -> jedis.rename(k, v));
   ```

##########
File path: geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/server/AbstractHitsMissesIntegrationTest.java
##########
@@ -286,90 +306,312 @@ public void testHscan() {
     runCommandAndAssertHitsAndMisses("hash", (k, v) -> jedis.hscan(k, v));
   }
 
+  @Test
+  public void testHMSet() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Map<String, String> map = new HashMap<>();
+    map.put("key1", "value1");
+    map.put("key2", "value2");
+
+    jedis.hmset("key", map);
+
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  // ------------ Connection related commands -----------
+
+  // TODO auth needs some setup. manually verified that auth does not change hit/miss stats
+  // if that changes we'll need to come back to this test
+  @Ignore
+  @Test
+  public void testAuth() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.auth("some password");
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  @Test
+  public void testPing() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.ping();
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  @Test
+  public void testQuit() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.quit();
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  // ------------ PubSub related commands -----------
+
+  // TODO test pubsub related commands
+  // tests are currently flaky when run against Native Redis so they have been
+  // ignored for now. Add them back when GEODE-8577 has been resolved
+  @Ignore
+  @Test
+  public void testSubscribeAndUnsubscribe() {
+    MockSubscriber mockSubscriber = new MockSubscriber();
+    Jedis subscriber = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Runnable runnable = () -> subscriber.subscribe(mockSubscriber, "someChannel");
+    Thread subscriberThread = new Thread(runnable);
+    subscriberThread.start();
+
+    try {
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    } finally {
+      mockSubscriber.unsubscribe("someChannel");
+      GeodeAwaitility.await().ignoreExceptions().until(() -> !subscriberThread.isAlive());
+
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    }
+  }
+
+  @Ignore
+  @Test
+  public void testPSubscribeAndPUnsubscribe() {
+    MockSubscriber mockSubscriber = new MockSubscriber();
+    Jedis pSubscriber = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Runnable runnable = () -> pSubscriber.psubscribe(mockSubscriber, "someChannel");
+    Thread subscriberThread = new Thread(runnable);
+    subscriberThread.start();
+
+    try {
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    } finally {
+      mockSubscriber.punsubscribe("someChannel");
+      GeodeAwaitility.await().ignoreExceptions().until(() -> !subscriberThread.isAlive());
+
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    }
+  }
+
+  @Ignore
+  @Test
+  public void testPublish() {
+    MockSubscriber mockSubscriber = new MockSubscriber();
+    Jedis subscriber = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+    Jedis publisher = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Runnable runnable = () -> subscriber.subscribe(mockSubscriber, "someChannel");
+    Thread subscriberThread = new Thread(runnable);
+    subscriberThread.start();
+
+    try {
+      publisher.publish("someChannel", "hello");
+
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    } finally {
+      mockSubscriber.unsubscribe("someChannel");
+      GeodeAwaitility.await().ignoreExceptions().until(() -> !subscriberThread.isAlive());
+    }
+  }
+
+  // ------------ Key related commands -----------
+
+  @Test
+  public void testExpire() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.expire(k, 5));
+  }
+
+  @Test
+  public void testPassiveExpiration() {
+    Map<String, String> info = getInfo(jedis);
+    String currentHits = info.get(HITS);
+    String currentMisses = info.get(MISSES);
+
+    jedis.expire("hash", 1);
+
+    GeodeAwaitility.await().during(Duration.ofSeconds(3)).until(() -> true);

Review comment:
       Can also just use `runCommandAndAssertNoStatUpdates1

##########
File path: geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/server/AbstractHitsMissesIntegrationTest.java
##########
@@ -286,90 +306,312 @@ public void testHscan() {
     runCommandAndAssertHitsAndMisses("hash", (k, v) -> jedis.hscan(k, v));
   }
 
+  @Test
+  public void testHMSet() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Map<String, String> map = new HashMap<>();
+    map.put("key1", "value1");
+    map.put("key2", "value2");
+
+    jedis.hmset("key", map);
+
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  // ------------ Connection related commands -----------
+
+  // TODO auth needs some setup. manually verified that auth does not change hit/miss stats
+  // if that changes we'll need to come back to this test
+  @Ignore
+  @Test
+  public void testAuth() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.auth("some password");
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  @Test
+  public void testPing() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.ping();
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  @Test
+  public void testQuit() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.quit();
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  // ------------ PubSub related commands -----------
+
+  // TODO test pubsub related commands
+  // tests are currently flaky when run against Native Redis so they have been
+  // ignored for now. Add them back when GEODE-8577 has been resolved
+  @Ignore
+  @Test
+  public void testSubscribeAndUnsubscribe() {

Review comment:
       Ditto for any pub/sub commands - they never deal with keys so I don't think it makes sense to test them here.

##########
File path: geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/server/AbstractHitsMissesIntegrationTest.java
##########
@@ -286,90 +306,312 @@ public void testHscan() {
     runCommandAndAssertHitsAndMisses("hash", (k, v) -> jedis.hscan(k, v));
   }
 
+  @Test
+  public void testHMSet() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Map<String, String> map = new HashMap<>();
+    map.put("key1", "value1");
+    map.put("key2", "value2");
+
+    jedis.hmset("key", map);
+
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  // ------------ Connection related commands -----------
+
+  // TODO auth needs some setup. manually verified that auth does not change hit/miss stats
+  // if that changes we'll need to come back to this test
+  @Ignore
+  @Test
+  public void testAuth() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.auth("some password");
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  @Test
+  public void testPing() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.ping();
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  @Test
+  public void testQuit() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.quit();
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  // ------------ PubSub related commands -----------
+
+  // TODO test pubsub related commands
+  // tests are currently flaky when run against Native Redis so they have been
+  // ignored for now. Add them back when GEODE-8577 has been resolved
+  @Ignore
+  @Test
+  public void testSubscribeAndUnsubscribe() {
+    MockSubscriber mockSubscriber = new MockSubscriber();
+    Jedis subscriber = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Runnable runnable = () -> subscriber.subscribe(mockSubscriber, "someChannel");
+    Thread subscriberThread = new Thread(runnable);
+    subscriberThread.start();
+
+    try {
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    } finally {
+      mockSubscriber.unsubscribe("someChannel");
+      GeodeAwaitility.await().ignoreExceptions().until(() -> !subscriberThread.isAlive());
+
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    }
+  }
+
+  @Ignore
+  @Test
+  public void testPSubscribeAndPUnsubscribe() {
+    MockSubscriber mockSubscriber = new MockSubscriber();
+    Jedis pSubscriber = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Runnable runnable = () -> pSubscriber.psubscribe(mockSubscriber, "someChannel");
+    Thread subscriberThread = new Thread(runnable);
+    subscriberThread.start();
+
+    try {
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    } finally {
+      mockSubscriber.punsubscribe("someChannel");
+      GeodeAwaitility.await().ignoreExceptions().until(() -> !subscriberThread.isAlive());
+
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    }
+  }
+
+  @Ignore
+  @Test
+  public void testPublish() {
+    MockSubscriber mockSubscriber = new MockSubscriber();
+    Jedis subscriber = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+    Jedis publisher = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Runnable runnable = () -> subscriber.subscribe(mockSubscriber, "someChannel");
+    Thread subscriberThread = new Thread(runnable);
+    subscriberThread.start();
+
+    try {
+      publisher.publish("someChannel", "hello");
+
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    } finally {
+      mockSubscriber.unsubscribe("someChannel");
+      GeodeAwaitility.await().ignoreExceptions().until(() -> !subscriberThread.isAlive());
+    }
+  }
+
+  // ------------ Key related commands -----------
+
+  @Test
+  public void testExpire() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.expire(k, 5));
+  }
+
+  @Test
+  public void testPassiveExpiration() {
+    Map<String, String> info = getInfo(jedis);
+    String currentHits = info.get(HITS);
+    String currentMisses = info.get(MISSES);
+
+    jedis.expire("hash", 1);
+
+    GeodeAwaitility.await().during(Duration.ofSeconds(3)).until(() -> true);
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(currentHits);
+    assertThat(info.get(MISSES)).isEqualTo(currentMisses);
+  }
+
+  @Test
+  public void testExpireAt() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.expireAt(k, 2145916800));
+  }
+
+  @Test
+  public void testPExpire() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.pexpire(k, 1024));
+  }
+
+  @Test
+  public void testPExpireAt() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.pexpireAt(k, 1608247597));
+  }
+
+  @Test
+  public void testPersist() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.persist(k));
+  }
+
+  // ------------ Helper Methods -----------
+
   private void runCommandAndAssertHitsAndMisses(String key, Consumer<String> command) {
-    command.accept(key);
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    command.accept(key);
+    info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("1");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 1));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
 
     command.accept("missed");
     info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("1");
-    assertThat(info.get(MISSES)).isEqualTo("1");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 1));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses + 1));
   }
 
   private void runCommandAndAssertHitsAndMisses(String key, BiConsumer<String, String> command) {
-    command.accept(key, "42");
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
 
-    assertThat(info.get(HITS)).isEqualTo("1");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    command.accept(key, "42");
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 1));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
 
     command.accept("missed", "42");
     info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("1");
-    assertThat(info.get(MISSES)).isEqualTo("1");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 1));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses + 1));
   }
 
   private void runDiffCommandAndAssertHitsAndMisses(String key,
       BiConsumer<String, String> command) {
-    command.accept(key, key);
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
 
-    assertThat(info.get(HITS)).isEqualTo("2");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    command.accept(key, key);
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 2));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
 
     command.accept(key, "missed");
     info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("3");
-    assertThat(info.get(MISSES)).isEqualTo("1");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 3));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses + 1));
   }
 
   /**
    * When storing diff-ish results, hits and misses are never updated
    */
   private void runDiffStoreCommandAndAssertNoStatUpdates(String key,
       TriConsumer<String, String, String> command) {
-    command.accept("destination", key, key);
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
 
-    assertThat(info.get(HITS)).isEqualTo("0");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    command.accept("destination", key, key);
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
 
     command.accept("destination", key, "missed");
     info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("0");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));

Review comment:
       Since these are just string comparisons there's probably no need to do any numeric conversions.

##########
File path: geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/server/AbstractHitsMissesIntegrationTest.java
##########
@@ -286,90 +306,312 @@ public void testHscan() {
     runCommandAndAssertHitsAndMisses("hash", (k, v) -> jedis.hscan(k, v));
   }
 
+  @Test
+  public void testHMSet() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Map<String, String> map = new HashMap<>();
+    map.put("key1", "value1");
+    map.put("key2", "value2");
+
+    jedis.hmset("key", map);
+
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  // ------------ Connection related commands -----------
+
+  // TODO auth needs some setup. manually verified that auth does not change hit/miss stats
+  // if that changes we'll need to come back to this test
+  @Ignore
+  @Test
+  public void testAuth() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.auth("some password");
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  @Test
+  public void testPing() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.ping();
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  @Test
+  public void testQuit() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.quit();
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  // ------------ PubSub related commands -----------
+
+  // TODO test pubsub related commands
+  // tests are currently flaky when run against Native Redis so they have been
+  // ignored for now. Add them back when GEODE-8577 has been resolved
+  @Ignore
+  @Test
+  public void testSubscribeAndUnsubscribe() {
+    MockSubscriber mockSubscriber = new MockSubscriber();
+    Jedis subscriber = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Runnable runnable = () -> subscriber.subscribe(mockSubscriber, "someChannel");
+    Thread subscriberThread = new Thread(runnable);
+    subscriberThread.start();
+
+    try {
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    } finally {
+      mockSubscriber.unsubscribe("someChannel");
+      GeodeAwaitility.await().ignoreExceptions().until(() -> !subscriberThread.isAlive());
+
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    }
+  }
+
+  @Ignore
+  @Test
+  public void testPSubscribeAndPUnsubscribe() {
+    MockSubscriber mockSubscriber = new MockSubscriber();
+    Jedis pSubscriber = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Runnable runnable = () -> pSubscriber.psubscribe(mockSubscriber, "someChannel");
+    Thread subscriberThread = new Thread(runnable);
+    subscriberThread.start();
+
+    try {
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    } finally {
+      mockSubscriber.punsubscribe("someChannel");
+      GeodeAwaitility.await().ignoreExceptions().until(() -> !subscriberThread.isAlive());
+
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    }
+  }
+
+  @Ignore
+  @Test
+  public void testPublish() {
+    MockSubscriber mockSubscriber = new MockSubscriber();
+    Jedis subscriber = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+    Jedis publisher = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Runnable runnable = () -> subscriber.subscribe(mockSubscriber, "someChannel");
+    Thread subscriberThread = new Thread(runnable);
+    subscriberThread.start();
+
+    try {
+      publisher.publish("someChannel", "hello");
+
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    } finally {
+      mockSubscriber.unsubscribe("someChannel");
+      GeodeAwaitility.await().ignoreExceptions().until(() -> !subscriberThread.isAlive());
+    }
+  }
+
+  // ------------ Key related commands -----------
+
+  @Test
+  public void testExpire() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.expire(k, 5));
+  }
+
+  @Test
+  public void testPassiveExpiration() {
+    Map<String, String> info = getInfo(jedis);
+    String currentHits = info.get(HITS);
+    String currentMisses = info.get(MISSES);
+
+    jedis.expire("hash", 1);
+
+    GeodeAwaitility.await().during(Duration.ofSeconds(3)).until(() -> true);
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(currentHits);
+    assertThat(info.get(MISSES)).isEqualTo(currentMisses);
+  }
+
+  @Test
+  public void testExpireAt() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.expireAt(k, 2145916800));
+  }
+
+  @Test
+  public void testPExpire() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.pexpire(k, 1024));
+  }
+
+  @Test
+  public void testPExpireAt() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.pexpireAt(k, 1608247597));
+  }
+
+  @Test
+  public void testPersist() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.persist(k));
+  }
+
+  // ------------ Helper Methods -----------
+
   private void runCommandAndAssertHitsAndMisses(String key, Consumer<String> command) {
-    command.accept(key);
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    command.accept(key);
+    info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("1");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 1));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
 
     command.accept("missed");
     info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("1");
-    assertThat(info.get(MISSES)).isEqualTo("1");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 1));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses + 1));
   }
 
   private void runCommandAndAssertHitsAndMisses(String key, BiConsumer<String, String> command) {
-    command.accept(key, "42");
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
 
-    assertThat(info.get(HITS)).isEqualTo("1");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    command.accept(key, "42");
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 1));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
 
     command.accept("missed", "42");
     info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("1");
-    assertThat(info.get(MISSES)).isEqualTo("1");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 1));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses + 1));
   }
 
   private void runDiffCommandAndAssertHitsAndMisses(String key,
       BiConsumer<String, String> command) {
-    command.accept(key, key);
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
 
-    assertThat(info.get(HITS)).isEqualTo("2");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    command.accept(key, key);
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 2));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
 
     command.accept(key, "missed");
     info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("3");
-    assertThat(info.get(MISSES)).isEqualTo("1");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 3));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses + 1));
   }
 
   /**
    * When storing diff-ish results, hits and misses are never updated
    */
   private void runDiffStoreCommandAndAssertNoStatUpdates(String key,
       TriConsumer<String, String, String> command) {
-    command.accept("destination", key, key);
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
 
-    assertThat(info.get(HITS)).isEqualTo("0");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    command.accept("destination", key, key);
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
 
     command.accept("destination", key, "missed");
     info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("0");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
   }
 
   private void runCommandAndAssertNoStatUpdates(String key, Consumer<String> command) {
-    command.accept(key);
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
 
-    assertThat(info.get(HITS)).isEqualTo("0");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    command.accept(key);
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));

Review comment:
       Since these are just string comparisons there's probably no need to do any numeric conversions.

##########
File path: geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/server/AbstractHitsMissesIntegrationTest.java
##########
@@ -286,90 +306,312 @@ public void testHscan() {
     runCommandAndAssertHitsAndMisses("hash", (k, v) -> jedis.hscan(k, v));
   }
 
+  @Test
+  public void testHMSet() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Map<String, String> map = new HashMap<>();
+    map.put("key1", "value1");
+    map.put("key2", "value2");
+
+    jedis.hmset("key", map);
+
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  // ------------ Connection related commands -----------
+
+  // TODO auth needs some setup. manually verified that auth does not change hit/miss stats
+  // if that changes we'll need to come back to this test
+  @Ignore
+  @Test
+  public void testAuth() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.auth("some password");
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  @Test
+  public void testPing() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.ping();
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  @Test
+  public void testQuit() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.quit();
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+  }
+
+  // ------------ PubSub related commands -----------
+
+  // TODO test pubsub related commands
+  // tests are currently flaky when run against Native Redis so they have been
+  // ignored for now. Add them back when GEODE-8577 has been resolved
+  @Ignore
+  @Test
+  public void testSubscribeAndUnsubscribe() {
+    MockSubscriber mockSubscriber = new MockSubscriber();
+    Jedis subscriber = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Runnable runnable = () -> subscriber.subscribe(mockSubscriber, "someChannel");
+    Thread subscriberThread = new Thread(runnable);
+    subscriberThread.start();
+
+    try {
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    } finally {
+      mockSubscriber.unsubscribe("someChannel");
+      GeodeAwaitility.await().ignoreExceptions().until(() -> !subscriberThread.isAlive());
+
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    }
+  }
+
+  @Ignore
+  @Test
+  public void testPSubscribeAndPUnsubscribe() {
+    MockSubscriber mockSubscriber = new MockSubscriber();
+    Jedis pSubscriber = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Runnable runnable = () -> pSubscriber.psubscribe(mockSubscriber, "someChannel");
+    Thread subscriberThread = new Thread(runnable);
+    subscriberThread.start();
+
+    try {
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    } finally {
+      mockSubscriber.punsubscribe("someChannel");
+      GeodeAwaitility.await().ignoreExceptions().until(() -> !subscriberThread.isAlive());
+
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    }
+  }
+
+  @Ignore
+  @Test
+  public void testPublish() {
+    MockSubscriber mockSubscriber = new MockSubscriber();
+    Jedis subscriber = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+    Jedis publisher = new Jedis("localhost", getPort(), REDIS_CLIENT_TIMEOUT);
+
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Runnable runnable = () -> subscriber.subscribe(mockSubscriber, "someChannel");
+    Thread subscriberThread = new Thread(runnable);
+    subscriberThread.start();
+
+    try {
+      publisher.publish("someChannel", "hello");
+
+      info = getInfo(jedis);
+      assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+      assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
+    } finally {
+      mockSubscriber.unsubscribe("someChannel");
+      GeodeAwaitility.await().ignoreExceptions().until(() -> !subscriberThread.isAlive());
+    }
+  }
+
+  // ------------ Key related commands -----------
+
+  @Test
+  public void testExpire() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.expire(k, 5));
+  }
+
+  @Test
+  public void testPassiveExpiration() {
+    Map<String, String> info = getInfo(jedis);
+    String currentHits = info.get(HITS);
+    String currentMisses = info.get(MISSES);
+
+    jedis.expire("hash", 1);
+
+    GeodeAwaitility.await().during(Duration.ofSeconds(3)).until(() -> true);
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(currentHits);
+    assertThat(info.get(MISSES)).isEqualTo(currentMisses);
+  }
+
+  @Test
+  public void testExpireAt() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.expireAt(k, 2145916800));
+  }
+
+  @Test
+  public void testPExpire() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.pexpire(k, 1024));
+  }
+
+  @Test
+  public void testPExpireAt() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.pexpireAt(k, 1608247597));
+  }
+
+  @Test
+  public void testPersist() {
+    runCommandAndAssertNoStatUpdates("hash", (k) -> jedis.persist(k));
+  }
+
+  // ------------ Helper Methods -----------
+
   private void runCommandAndAssertHitsAndMisses(String key, Consumer<String> command) {
-    command.accept(key);
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    command.accept(key);
+    info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("1");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 1));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
 
     command.accept("missed");
     info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("1");
-    assertThat(info.get(MISSES)).isEqualTo("1");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 1));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses + 1));
   }
 
   private void runCommandAndAssertHitsAndMisses(String key, BiConsumer<String, String> command) {
-    command.accept(key, "42");
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
 
-    assertThat(info.get(HITS)).isEqualTo("1");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    command.accept(key, "42");
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 1));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
 
     command.accept("missed", "42");
     info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("1");
-    assertThat(info.get(MISSES)).isEqualTo("1");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 1));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses + 1));
   }
 
   private void runDiffCommandAndAssertHitsAndMisses(String key,
       BiConsumer<String, String> command) {
-    command.accept(key, key);
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
 
-    assertThat(info.get(HITS)).isEqualTo("2");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    command.accept(key, key);
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 2));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
 
     command.accept(key, "missed");
     info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("3");
-    assertThat(info.get(MISSES)).isEqualTo("1");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits + 3));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses + 1));
   }
 
   /**
    * When storing diff-ish results, hits and misses are never updated
    */
   private void runDiffStoreCommandAndAssertNoStatUpdates(String key,
       TriConsumer<String, String, String> command) {
-    command.accept("destination", key, key);
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
 
-    assertThat(info.get(HITS)).isEqualTo("0");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    command.accept("destination", key, key);
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
 
     command.accept("destination", key, "missed");
     info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("0");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
   }
 
   private void runCommandAndAssertNoStatUpdates(String key, Consumer<String> command) {
-    command.accept(key);
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
 
-    assertThat(info.get(HITS)).isEqualTo("0");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    command.accept(key);
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
   }
 
   private void runCommandAndAssertNoStatUpdates(String key, BiConsumer<String, String> command) {
-    command.accept(key, "42");
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
 
-    assertThat(info.get(HITS)).isEqualTo("0");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    command.accept(key, "42");
+    info = getInfo(jedis);
+
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));
   }
 
   private void runCommandAndAssertNoStatUpdates(String key,
       TriConsumer<String, String, String> command) {
-    command.accept(key, key, "42");
     Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    command.accept(key, key, "42");
+    info = getInfo(jedis);
 
-    assertThat(info.get(HITS)).isEqualTo("0");
-    assertThat(info.get(MISSES)).isEqualTo("0");
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));

Review comment:
       Since these are just string comparisons there's probably no need to do any numeric conversions.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jdeppe-pivotal commented on a change in pull request #5875:
URL: https://github.com/apache/geode/pull/5875#discussion_r552652990



##########
File path: geode-redis/src/main/java/org/apache/geode/redis/internal/data/RedisSetCommandsFunctionExecutor.java
##########
@@ -37,18 +37,22 @@ public RedisSetCommandsFunctionExecutor(
     super(helper);
   }
 
-  private RedisSet getRedisSet(ByteArrayWrapper key) {
-    return helper.getRedisSet(key);
+  private RedisSet getRedisSet(ByteArrayWrapper key, boolean updateStats) {

Review comment:
       This is probably a nit, but for consistency can this class be consistent with the other `*FunctionExecutor`s and either introduce an overloaded `getRedisSet` which updates stats. Or remove the other classes' duplicate `getRedisSet` and just have one method. 




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jhutchison commented on a change in pull request #5875:
URL: https://github.com/apache/geode/pull/5875#discussion_r552789616



##########
File path: geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/server/AbstractHitsMissesIntegrationTest.java
##########
@@ -82,6 +81,19 @@ public void testPttl() {
     runCommandAndAssertHitsAndMisses("string", k -> jedis.pttl(k));
   }
 
+  @Test
+  public void testRename() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    jedis.rename("string", "newString");
+
+    info = getInfo(jedis);
+    assertThat(info.get(HITS)).isEqualTo(String.valueOf(currentHits));
+    assertThat(info.get(MISSES)).isEqualTo(String.valueOf(currentMisses));

Review comment:
       thanks, changed




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jhutchison commented on a change in pull request #5875:
URL: https://github.com/apache/geode/pull/5875#discussion_r552806036



##########
File path: geode-redis/src/integrationTest/java/org/apache/geode/redis/internal/executor/server/AbstractHitsMissesIntegrationTest.java
##########
@@ -286,90 +306,312 @@ public void testHscan() {
     runCommandAndAssertHitsAndMisses("hash", (k, v) -> jedis.hscan(k, v));
   }
 
+  @Test
+  public void testHMSet() {
+    Map<String, String> info = getInfo(jedis);
+    Long currentHits = Long.parseLong(info.get(HITS));
+    Long currentMisses = Long.parseLong(info.get(MISSES));
+
+    Map<String, String> map = new HashMap<>();
+    map.put("key1", "value1");
+    map.put("key2", "value2");
+
+    jedis.hmset("key", map);

Review comment:
       done-  had to create one with a new signature- not sure if this is the best signature...




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


nonbinaryprogrammer commented on a change in pull request #5875:
URL: https://github.com/apache/geode/pull/5875#discussion_r552860024



##########
File path: geode-redis/src/main/java/org/apache/geode/redis/internal/data/RedisSetCommandsFunctionExecutor.java
##########
@@ -37,18 +37,22 @@ public RedisSetCommandsFunctionExecutor(
     super(helper);
   }
 
-  private RedisSet getRedisSet(ByteArrayWrapper key) {
-    return helper.getRedisSet(key);
+  private RedisSet getRedisSet(ByteArrayWrapper key, boolean updateStats) {

Review comment:
       I think I made the change that you suggested but I'm not positive that I understood this correctly




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


nonbinaryprogrammer merged pull request #5875:
URL: https://github.com/apache/geode/pull/5875


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 81cd180f08fde785b13054007887a20c58028e8e in geode's branch refs/heads/develop from Hale Bales
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=81cd180 ]

GEODE-8786 redis info command hit miss ratios (#5875)

* GEODE-8786: fix hit/miss ratios in redis stats

- add enum for keyspace increment type
- remove clearall() method
- add tests for supported commands that do not update the stats
- use boolean to indicate if stats should be updated
- get the s*store command tests working
- add internal pttl to be called from the expire command to avoid updating the stats
- move the updateStats boolean up a level
- remove unused executors
- change s*store stats integrations tests to reflect behavior in native redis
- fix bitop test
- add INTERNAL command type
- fix supported commands dunit tests to allow for new internal commands
- changed tests to use delegate methods
- remove unecessary pubsub and connection tests. they don't have anything to do with key hits/misses
- remove unecessary getRedisString and getRedisHash methods. leaving only the method that takes a boolean for updating the stats

Co-authored-by: Ray Ingles <ringles@vmware.com>
Co-authored-by: john Hutchison <hutchisonjo@vmware.com>

Commit 81cd180f08fde785b13054007887a20c58028e8e in geode's branch refs/heads/develop from Hale Bales
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=81cd180 ]

GEODE-8786 redis info command hit miss ratios (#5875)

* GEODE-8786: fix hit/miss ratios in redis stats

- add enum for keyspace increment type
- remove clearall() method
- add tests for supported commands that do not update the stats
- use boolean to indicate if stats should be updated
- get the s*store command tests working
- add internal pttl to be called from the expire command to avoid updating the stats
- move the updateStats boolean up a level
- remove unused executors
- change s*store stats integrations tests to reflect behavior in native redis
- fix bitop test
- add INTERNAL command type
- fix supported commands dunit tests to allow for new internal commands
- changed tests to use delegate methods
- remove unecessary pubsub and connection tests. they don't have anything to do with key hits/misses
- remove unecessary getRedisString and getRedisHash methods. leaving only the method that takes a boolean for updating the stats

Co-authored-by: Ray Ingles <ringles@vmware.com>
Co-authored-by: john Hutchison <hutchisonjo@vmware.com>

