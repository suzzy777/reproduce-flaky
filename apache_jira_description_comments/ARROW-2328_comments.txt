xhochy commented on a change in pull request #1766: ARROW-2328: [C++] Writing a slice with feather ignores the offset.
URL: https://github.com/apache/arrow/pull/1766#discussion_r175899893
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather.cc
 ##########
 @@ -603,7 +602,12 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {
       }
 
       if (prim_values.values()) {
-        values_buffer = prim_values.values()->data();
+        if (prim_values.offset() != 0 && (fw_type.bit_width() % 8 != 0)) {
+          return arrow::Status::Invalid(
 
 Review comment:
   This should be NotImplemented. We should be able to write them someday.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on a change in pull request #1766: ARROW-2328: [C++] Writing a slice with feather ignores the offset.
URL: https://github.com/apache/arrow/pull/1766#discussion_r175948619
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather.cc
 ##########
 @@ -603,7 +602,12 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {
       }
 
       if (prim_values.values()) {
-        values_buffer = prim_values.values()->data();
+        if (prim_values.offset() != 0 && (fw_type.bit_width() % 8 != 0)) {
+          return arrow::Status::Invalid(
 
 Review comment:
   Thanks for your comments. I've changed the status return code. But I'm having two problems:
   * when I run 'make format' it only changes a whole bunch of files I didn't change. Was master broken when I forked?
   * SliceStringsRoundTrip fails and I'm struggling to understand which of the various offsets needs to be adjusted. I can probably figure that out tomorrow.
   Thanks.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on issue #1766: ARROW-2328: [C++] Writing a slice with feather ignores the offset.
URL: https://github.com/apache/arrow/pull/1766#issuecomment-374799805
 
 
   On further investigation, there is a second bug, in that the null bitmap isn't aligned with the offset either. Hence the SliceStringsRoundTrip test fails.
   Looking at the TableWriter code, to fix this will require creating a new null bitmap, which will require a MemoryPool and hence a change in the api. :(. 
   Without the ability to have nulls, writing sliced tables to feather seems to be mostly broken. I could add the pool as an optional argument, or what would be a preferred approach? I'll have a think tomorrow. 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on issue #1766: ARROW-2328: [C++] Writing a slice with feather ignores the offset.
URL: https://github.com/apache/arrow/pull/1766#issuecomment-374875952
 
 
   In the latest commit I have unit tested and fixed the null bitmap bug. I ended up adding the memory pool argument with a nullptr default and fail if an array is sliced and no pool was passed in.
   I also copy and pasted GetTruncatedBitmap from writer.cpp, I wasn't sure how to share it without it leaking into the public api.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on a change in pull request #1766: ARROW-2328: [C++] Writing a slice with feather ignores the offset.
URL: https://github.com/apache/arrow/pull/1766#discussion_r176107139
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather.cc
 ##########
 @@ -603,7 +602,12 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {
       }
 
       if (prim_values.values()) {
-        values_buffer = prim_values.values()->data();
+        if (prim_values.offset() != 0 && (fw_type.bit_width() % 8 != 0)) {
+          return arrow::Status::Invalid(
 
 Review comment:
   I've now made these changes and more.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


xhochy commented on a change in pull request #1766: ARROW-2328: [C++] Writing a slice with feather ignores the offset.
URL: https://github.com/apache/arrow/pull/1766#discussion_r176529987
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather.cc
 ##########
 @@ -558,8 +577,18 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {
       // byte boundary, and we write this much data into the stream
       int64_t null_bitmap_size = GetOutputLength(BitUtil::BytesForBits(values.length()));
       if (values.null_bitmap()) {
-        RETURN_NOT_OK(WritePadded(stream_.get(), values.null_bitmap()->data(),
-                                  null_bitmap_size, &bytes_written));
+        auto null_bitmap = values.null_bitmap();
+        if (values.offset() > 0) {
+          if (!pool_) {
+            return Status::Invalid(
+                "Require memory pol to write array slice (i.e. offset > 0) with nulls.");
+          }
+          RETURN_NOT_OK(GetTruncatedBitmap(values.offset(), values.length(), null_bitmap,
+                                           pool_, &null_bitmap));
+        }
+
+        RETURN_NOT_OK(WritePadded(stream_.get(), null_bitmap->data(), null_bitmap_size,
 
 Review comment:
   Wouldn't it be better to extend `WritePadded` or write a second version of it that can handle bit-offsets? Using that way we could avoid the memory allocation for `GetTruncatedBitmap` above.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on a change in pull request #1766: ARROW-2328: [C++] Writing a slice with feather ignores the offset.
URL: https://github.com/apache/arrow/pull/1766#discussion_r176562102
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather.cc
 ##########
 @@ -558,8 +577,18 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {
       // byte boundary, and we write this much data into the stream
       int64_t null_bitmap_size = GetOutputLength(BitUtil::BytesForBits(values.length()));
       if (values.null_bitmap()) {
-        RETURN_NOT_OK(WritePadded(stream_.get(), values.null_bitmap()->data(),
-                                  null_bitmap_size, &bytes_written));
+        auto null_bitmap = values.null_bitmap();
+        if (values.offset() > 0) {
+          if (!pool_) {
+            return Status::Invalid(
+                "Require memory pol to write array slice (i.e. offset > 0) with nulls.");
+          }
+          RETURN_NOT_OK(GetTruncatedBitmap(values.offset(), values.length(), null_bitmap,
+                                           pool_, &null_bitmap));
+        }
+
+        RETURN_NOT_OK(WritePadded(stream_.get(), null_bitmap->data(), null_bitmap_size,
 
 Review comment:
   I agree that would be better if it is possible. Same goes for the arrow writing code of course. I can give it a try tomorrow.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on a change in pull request #1766: ARROW-2328: [C++] Writing a slice with feather ignores the offset.
URL: https://github.com/apache/arrow/pull/1766#discussion_r176607118
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather.cc
 ##########
 @@ -558,8 +577,18 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {
       // byte boundary, and we write this much data into the stream
       int64_t null_bitmap_size = GetOutputLength(BitUtil::BytesForBits(values.length()));
       if (values.null_bitmap()) {
-        RETURN_NOT_OK(WritePadded(stream_.get(), values.null_bitmap()->data(),
-                                  null_bitmap_size, &bytes_written));
+        auto null_bitmap = values.null_bitmap();
+        if (values.offset() > 0) {
+          if (!pool_) {
+            return Status::Invalid(
+                "Require memory pol to write array slice (i.e. offset > 0) with nulls.");
+          }
+          RETURN_NOT_OK(GetTruncatedBitmap(values.offset(), values.length(), null_bitmap,
+                                           pool_, &null_bitmap));
+        }
+
+        RETURN_NOT_OK(WritePadded(stream_.get(), null_bitmap->data(), null_bitmap_size,
 
 Review comment:
   I've pushed a change to do as you suggested and added a test.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


wesm commented on issue #1766: ARROW-2328: [C++] Writing a slice with feather ignores the offset.
URL: https://github.com/apache/arrow/pull/1766#issuecomment-375496335
 
 
   Would like to review this more closely, will look when I can

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on issue #1766: ARROW-2328: [C++] Writing a slice with feather ignores the offset.
URL: https://github.com/apache/arrow/pull/1766#issuecomment-375625246
 
 
   I seem to have messed up this branch/pull request by merging the latest changes from arrow/master. Do I need to create a new branch? Any advice appreciated. thanks.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr opened a new pull request #1784: (ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784
 
 
   When writing a slice of a table to feather, both the scalar data and the null bitmap were written out wrongly, i.e. from the beginning of the original table instead of from the offset.
   - scalar data is written from the offset
   - null bitmap is written from the offset.
   
   I messed up my original pull request https://github.com/apache/arrow/pull/1766, hence this replaces it. Hope that helps.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on issue #1766: ARROW-2328: [C++] Writing a slice with feather ignores the offset.
URL: https://github.com/apache/arrow/pull/1766#issuecomment-375644923
 
 
   I've redone the changes in a new branch and pull request (https://github.com/apache/arrow/pull/1784). Hopefully that is a little cleaner.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr closed pull request #1766: ARROW-2328: [C++] Writing a slice with feather ignores the offset.
URL: https://github.com/apache/arrow/pull/1766
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/.travis.yml b/.travis.yml
index b1241e793..03bc8e26a 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -56,6 +56,8 @@ matrix:
     - CC="clang-5.0"
     - CXX="clang++-5.0"
     before_script:
+    # Always run RAT checks, in case another build in matrix breaks RAT
+    - $TRAVIS_BUILD_DIR/ci/travis_release_audit.sh
     # (ARROW_CI_CPP_AFFECTED implies ARROW_CI_PYTHON_AFFECTED)
     - if [ $ARROW_CI_PYTHON_AFFECTED != "1" ]; then exit; fi
     - $TRAVIS_BUILD_DIR/ci/travis_install_linux.sh
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 153159cb7..b38e2b539 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -17,6 +17,274 @@
   under the License.
 -->
 
+# Apache Arrow 0.9.0 (16 March 2018)
+
+## Bug
+
+* ARROW-1345 - [Python] Conversion from nested NumPy arrays fails on integers other than int64, float32
+* ARROW-1646 - [Python] pyarrow.array cannot handle NumPy scalar types
+* ARROW-1856 - [Python] Auto-detect Parquet ABI version when using PARQUET\_HOME
+* ARROW-1909 - [C++] Bug: Build fails on windows with "-DARROW\_BUILD\_BENCHMARKS=ON"
+* ARROW-1912 - [Website] Add org affiliations to committers.html
+* ARROW-1919 - Plasma hanging if object id is not 20 bytes
+* ARROW-1924 - [Python] Bring back pickle=True option for serialization
+* ARROW-1933 - [GLib] Build failure with --with-arrow-cpp-build-dir and GPU enabled Arrow C++
+* ARROW-1940 - [Python] Extra metadata gets added after multiple conversions between pd.DataFrame and pa.Table
+* ARROW-1941 - Table <–> DataFrame roundtrip failing
+* ARROW-1943 - Handle setInitialCapacity() for deeply nested lists of lists
+* ARROW-1944 - FindArrow has wrong ARROW\_STATIC\_LIB
+* ARROW-1945 - [C++] Fix doxygen documentation of array.h
+* ARROW-1946 - Add APIs to decimal vector for writing big endian data
+* ARROW-1948 - [Java] ListVector does not handle ipc with all non-null values with none set
+* ARROW-1950 - [Python] pandas\_type in pandas metadata incorrect for List types
+* ARROW-1953 - [JS] JavaScript builds broken on master
+* ARROW-1958 - [Python] Error in pandas conversion for datetimetz row index
+* ARROW-1961 - [Python] Writing Parquet file with flavor='spark' loses pandas schema metadata
+* ARROW-1966 - [C++] Support JAVA\_HOME paths in HDFS libjvm loading that include the jre directory
+* ARROW-1971 - [Python] Add pandas serialization to the default
+* ARROW-1972 - Deserialization of buffer objects (and pandas dataframes) segfaults on different processes.
+* ARROW-1973 - [Python] Memory leak when converting Arrow tables with array columns to Pandas dataframes.
+* ARROW-1976 - [Python] Handling unicode pandas columns on parquet.read\_table
+* ARROW-1979 - [JS] JS builds handing in es2015:umd tests
+* ARROW-1980 - [Python] Race condition in `write\_to\_dataset`
+* ARROW-1982 - [Python] Return parquet statistics min/max as values instead of strings
+* ARROW-1991 - [GLib] Docker-based documentation build is broken
+* ARROW-1992 - [Python] to\_pandas crashes when using strings\_to\_categoricals on empty string cols on 0.8.0
+* ARROW-1997 - [Python] to\_pandas with strings\_to\_categorical fails
+* ARROW-1998 - [Python] Table.from\_pandas crashes when data frame is empty
+* ARROW-1999 - [Python] from\_numpy\_dtype returns wrong types
+* ARROW-2000 - Deduplicate file descriptors when plasma store replies to get request.
+* ARROW-2002 - use pyarrow download file will raise queue.Full exceptions sometimes
+* ARROW-2003 - [Python] Do not use deprecated kwarg in pandas.core.internals.make\_block
+* ARROW-2005 - [Python] pyflakes warnings on Cython files not failing build
+* ARROW-2008 - [Python] Type inference for int32 NumPy arrays (expecting list<int32>) returns int64 and then conversion fails
+* ARROW-2010 - [C++] Compiler warnings with CHECKIN warning level in ORC adapter
+* ARROW-2017 - Array initialization with  large (>2**31-1) uint64 values fails
+* ARROW-2023 - [C++] Test opening IPC stream reader or file reader on an empty InputStream
+* ARROW-2025 - [Python/C++] HDFS Client disconnect closes all open clients
+* ARROW-2029 - [Python] Program crash on `HdfsFile.tell` if file is closed
+* ARROW-2032 - [C++] ORC ep installs on each call to ninja build (even if no work to do)
+* ARROW-2033 - pa.array() doesn't work with iterators
+* ARROW-2039 - [Python] pyarrow.Buffer().to\_pybytes() segfaults
+* ARROW-2040 - [Python] Deserialized Numpy array must keep ref to underlying tensor
+* ARROW-2047 - [Python] test\_serialization.py uses a python executable in PATH rather than that used for a test run
+* ARROW-2049 - ARROW-2049: [Python] Use python -m cython to run Cython, instead of CYTHON\_EXECUTABLE
+* ARROW-2062 - [C++] Stalled builds in test\_serialization.py in Travis CI
+* ARROW-2070 - [Python] chdir logic in setup.py buggy
+* ARROW-2072 - [Python] decimal128.byte\_width crashes
+* ARROW-2080 - [Python] Update documentation after ARROW-2024
+* ARROW-2085 - HadoopFileSystem.isdir and .isfile should return False if the path doesn't exist 
+* ARROW-2106 - [Python] pyarrow.array can't take a pandas Series of python datetime objects.
+* ARROW-2109 - [C++] Boost 1.66 compilation fails on Windows on linkage stage
+* ARROW-2124 - [Python] ArrowInvalid raised if the first item of a nested list of numpy arrays is empty
+* ARROW-2128 - [Python] Cannot serialize array of empty lists
+* ARROW-2129 - [Python] Segmentation fault on conversion of empty array to Pandas
+* ARROW-2131 - [Python] Serialization test fails on Windows when library has been built in place / not installed
+* ARROW-2133 - [Python] Segmentation fault on conversion of empty nested arrays to Pandas
+* ARROW-2135 - [Python] NaN values silently casted to int64 when passing explicit schema for conversion in Table.from\_pandas
+* ARROW-2145 - [Python] Decimal conversion not working for NaN values
+* ARROW-2150 - [Python] array equality defaults to identity
+* ARROW-2151 - [Python] Error when converting from list of uint64 arrays
+* ARROW-2153 - [C++/Python] Decimal conversion not working for exponential notation
+* ARROW-2157 - [Python] Decimal arrays cannot be constructed from Python lists
+* ARROW-2160 - [C++/Python] Fix decimal precision inference
+* ARROW-2161 - [Python] Skip test\_cython\_api if ARROW\_HOME isn't defined
+* ARROW-2162 - [Python/C++] Decimal Values with too-high precision are multiplied by 100
+* ARROW-2167 - [C++] Building Orc extensions fails with the default BUILD\_WARNING\_LEVEL=Production
+* ARROW-2170 - [Python] construct\_metadata fails on reading files where no index was preserved
+* ARROW-2171 - [Python] OwnedRef is fragile
+* ARROW-2172 - [Python] Incorrect conversion from Numpy array when stride % itemsize != 0
+* ARROW-2173 - [Python] NumPyBuffer destructor should hold the GIL
+* ARROW-2175 - [Python] arrow\_ep build is triggering during parquet-cpp build in Travis CI
+* ARROW-2178 -  [JS] Fix JS html FileReader example
+* ARROW-2179 - [C++] arrow/util/io-util.h missing from libarrow-dev
+* ARROW-2192 - Commits to master should run all builds in CI matrix
+* ARROW-2209 - [Python] Partition columns are not correctly loaded in schema of ParquetDataset
+* ARROW-2210 - [C++] TestBuffer\_ResizeOOM has a memory leak with jemalloc
+* ARROW-2212 - [C++/Python] Build Protobuf in base manylinux 1 docker image
+* ARROW-2223 - [JS] installing umd release throws an error
+* ARROW-2227 - [Python] Table.from\_pandas does not create chunked\_arrays.
+* ARROW-2230 - [Python] JS version number is sometimes picked up
+* ARROW-2232 - [Python] pyarrow.Tensor constructor segfaults
+* ARROW-2234 - [JS] Read timestamp low bits as Uint32s
+* ARROW-2240 - [Python] Array initialization with leading numpy nan fails with exception
+* ARROW-2244 - [C++] Slicing NullArray should not cause the null count on the internal data to be unknown
+* ARROW-2245 - [Python] Revert static linkage of parquet-cpp in manylinux1 wheel
+* ARROW-2246 - [Python] Use namespaced boost in manylinux1 package
+* ARROW-2251 - [GLib] Destroying GArrowBuffer while GArrowTensor that uses the buffer causes a crash
+* ARROW-2254 - [Python] Local in-place dev versions picking up JS tags
+* ARROW-2258 - [C++] Appveyor builds failing on master
+* ARROW-2263 - [Python] test\_cython.py fails if pyarrow is not in import path (e.g. with inplace builds)
+* ARROW-2265 - [Python] Serializing subclasses of np.ndarray returns a np.ndarray.
+* ARROW-2268 - Remove MD5 checksums from release process
+* ARROW-2269 - [Python] Cannot build bdist\_wheel for Python
+* ARROW-2270 - [Python] ForeignBuffer doesn't tie Python object lifetime to C++ buffer lifetime
+* ARROW-2272 - [Python] test\_plasma spams /tmp
+* ARROW-2275 - [C++] Buffer::mutable\_data\_ member uninitialized
+* ARROW-2280 - [Python] pyarrow.Array.buffers should also include the offsets
+* ARROW-2284 - [Python] test\_plasma error on plasma\_store error
+* ARROW-2288 - [Python] slicing logic defective
+* ARROW-2297 - [JS] babel-jest is not listed as a dev dependency
+* ARROW-2304 - [C++] MultipleClients test in io-hdfs-test fails on trunk
+* ARROW-2306 - [Python] HDFS test failures
+* ARROW-2307 - [Python] Unable to read arrow stream containing 0 record batches
+* ARROW-2311 - [Python] Struct array slicing defective
+* ARROW-2312 - [JS] verify-release-candidate-sh must be updated to include JS in integration tests
+* ARROW-2313 - [GLib] Release builds must define NDEBUG
+* ARROW-2316 - [C++] Revert Buffer::mutable\_data member to always inline
+* ARROW-2318 - [C++] TestPlasmaStore.MultipleClientTest is flaky (hangs) in release builds
+* ARROW-2320 - [C++] Vendored Boost build does not build regex library
+
+## Improvement
+
+* ARROW-1021 - [Python] Add documentation about using pyarrow from other Cython and C++ projects
+* ARROW-1035 - [Python] Add ASV benchmarks for streaming columnar deserialization
+* ARROW-1463 - [JAVA] Restructure ValueVector hierarchy to minimize compile-time generated code
+* ARROW-1579 - [Java] Add dockerized test setup to validate Spark integration
+* ARROW-1580 - [Python] Instructions for setting up nightly builds on Linux
+* ARROW-1623 - [C++] Add convenience method to construct Buffer from a string that owns its memory
+* ARROW-1632 - [Python] Permit categorical conversions in Table.to\_pandas on a per-column basis
+* ARROW-1643 - [Python] Accept hdfs:// prefixes in parquet.read\_table and attempt to connect to HDFS
+* ARROW-1706 - [Python] StructArray.from\_arrays should handle sequences that are coercible to arrays
+* ARROW-1712 - [C++] Add method to BinaryBuilder to reserve space for value data
+* ARROW-1835 - [C++] Create Arrow schema from std::tuple types
+* ARROW-1861 - [Python] Fix up ASV setup, add developer instructions for writing new benchmarks and running benchmark suite locally
+* ARROW-1872 - [Website] Populate hard-coded fields for current release from a YAML file
+* ARROW-1927 - [Plasma] Implement delete function
+* ARROW-1929 - [C++] Move various Arrow testing utility code from Parquet to Arrow codebase
+* ARROW-1937 - [Python] Add documentation for different forms of constructing nested arrays from Python data structures 
+* ARROW-1942 - [C++] Hash table specializations for small integers
+* ARROW-1947 - [Plasma] Change Client Create and Get to use Buffers
+* ARROW-1951 - Add memcopy\_threads to serialization context
+* ARROW-1962 - [Java] Add reset() to ValueVector interface
+* ARROW-1969 - [C++] Do not build ORC adapter by default
+* ARROW-1977 - [C++] Update windows dev docs
+* ARROW-1978 - [Website] Add more visible link to "Powered By" page to front page, simplify Powered By
+* ARROW-2004 - [C++] Add shrink\_to\_fit option in BufferBuilder::Resize
+* ARROW-2007 - [Python] Sequence converter for float32 not implemented
+* ARROW-2011 - Allow setting the pickler to use in pyarrow serialization.
+* ARROW-2012 - [GLib] Support "make distclean"
+* ARROW-2018 - [C++] Build instruction on macOS and Homebrew is incomplete
+* ARROW-2019 - Control the memory allocated for inner vector in LIST
+* ARROW-2024 - [Python] Remove global SerializationContext variables
+* ARROW-2028 - [Python] extra\_cmake\_args needs to be passed through shlex.split
+* ARROW-2031 - HadoopFileSystem isn't pickleable
+* ARROW-2035 - [C++] Update vendored cpplint.py to a Py3-compatible one
+* ARROW-2036 - NativeFile should support standard IOBase methods
+* ARROW-2042 - [Plasma] Revert API change of plasma::Create to output a MutableBuffer
+* ARROW-2043 - [C++] Change description from OS X to macOS
+* ARROW-2046 - [Python] Add support for PEP519 - pathlib and similar objects
+* ARROW-2048 - [Python/C++] Upate Thrift pin to 0.11
+* ARROW-2050 - Support `setup.py pytest` to automatically fetch the test dependencies
+* ARROW-2064 - [GLib] Add common build problems link to the install section
+* ARROW-2065 - Fix bug in SerializationContext.clone().
+* ARROW-2068 - [Python] Expose Array's buffers to Python users
+* ARROW-2069 - [Python] Document that Plasma is not (yet) supported on Windows
+* ARROW-2071 - [Python] Reduce runtime of builds in Travis CI
+* ARROW-2073 - [Python] Create StructArray from sequence of tuples given a known data type
+* ARROW-2076 - [Python] Display slowest test durations
+* ARROW-2083 - Support skipping builds
+* ARROW-2084 - [C++] Support newer Brotli static library names
+* ARROW-2086 - [Python] Shrink size of arrow\_manylinux1\_x86\_64\_base docker image
+* ARROW-2087 - [Python] Binaries of 3rdparty are not stripped in manylinux1 base image
+* ARROW-2088 - [GLib] Add GArrowNumericArray
+* ARROW-2089 - [GLib] Rename to GARROW\_TYPE\_BOOLEAN for consistency
+* ARROW-2090 - [Python] Add context manager methods to ParquetWriter
+* ARROW-2093 - [Python] Possibly do not test pytorch serialization in Travis CI
+* ARROW-2094 - [Python] Use toolchain libraries and PROTOBUF\_HOME for protocol buffers
+* ARROW-2095 - [C++] Suppress ORC EP build logging by default
+* ARROW-2096 - [C++] Turn off Boost\_DEBUG to trim build output
+* ARROW-2099 - [Python] Support DictionaryArray::FromArrays in Python bindings
+* ARROW-2107 - [GLib] Follow arrow::gpu::CudaIpcMemHandle API change
+* ARROW-2110 - [Python] Only require pytest-runner on test commands
+* ARROW-2111 - [C++] Linting could be faster
+* ARROW-2117 - [C++] Pin clang to version 5.0
+* ARROW-2118 - [Python] Improve error message when calling parquet.read\_table on an empty file
+* ARROW-2120 - Add possibility to use empty \_MSVC\_STATIC\_LIB\_SUFFIX for Thirdparties
+* ARROW-2121 - [Python] Consider special casing object arrays in pandas serializers.
+* ARROW-2132 - [Doc] Add links / mentions of Plasma store to main README
+* ARROW-2137 - [Python] Don't print paths that are ignored when reading Parquet files
+* ARROW-2138 - [C++] Have FatalLog abort instead of exiting
+* ARROW-2142 - [Python] Conversion from Numpy struct array unimplemented
+* ARROW-2143 - [Python] Provide a manylinux1 wheel for cp27m
+* ARROW-2146 - [GLib] Implement Slice for ChunkedArray
+* ARROW-2154 - [Python] \_\_eq\_\_ unimplemented on Buffer
+* ARROW-2155 - [Python] pa.frombuffer(bytearray) returns immutable Buffer
+* ARROW-2163 - Install apt dependencies separate from built-in Travis commands, retry on flakiness
+* ARROW-2168 - [C++] Build toolchain builds with jemalloc
+* ARROW-2169 - [C++] MSVC is complaining about uncaptured variables
+* ARROW-2174 - [JS] Export format and schema enums
+* ARROW-2177 - [C++] Remove support for specifying negative scale values in DecimalType
+* ARROW-2180 - [C++] Remove APIs deprecated in 0.8.0 release
+* ARROW-2181 - [Python] Add concat\_tables to API reference, add documentation on use
+* ARROW-2184 - [C++] Add static constructor for FileOutputStream returning shared\_ptr to base OutputStream
+* ARROW-2185 - Remove CI directives from squashed commit messages
+* ARROW-2191 - [C++] Only use specific version of jemalloc
+* ARROW-2198 - [Python] Docstring for parquet.read\_table is misleading or incorrect
+* ARROW-2199 - [JAVA] Follow up fixes for ARROW-2019. Ensure density driven capacity is never less than 1 and propagate density throughout the vector tree
+* ARROW-2203 - [C++] StderrStream class
+* ARROW-2204 - [C++] Build fails with TLS error on parquet-cpp clone
+* ARROW-2206 - [JS] Add Perspective as a community project
+* ARROW-2218 - [Python] PythonFile should infer mode when not given
+* ARROW-2231 - [CI] Use clcache on AppVeyor
+* ARROW-2238 - [C++] Detect clcache in cmake configuration
+* ARROW-2250 - plasma\_store process should cleanup on INT and TERM signals
+* ARROW-2261 - [GLib] Can't share the same memory in GArrowBuffer safely
+* ARROW-2279 - [Python] Better error message if lib cannot be found
+* ARROW-2282 - [Python] Create StringArray from buffers
+* ARROW-2283 - [C++] Support Arrow C++ installed in /usr detection by pkg-config
+* ARROW-2289 - [GLib] Add  Numeric, Integer and FloatingPoint data types
+* ARROW-2291 - [C++] README missing instructions for libboost-regex-dev
+* ARROW-2292 - [Python] More consistent / intuitive name for pyarrow.frombuffer
+* ARROW-2321 - [C++] Release verification script fails with if CMAKE\_INSTALL\_LIBDIR is not $ARROW\_HOME/lib
+* ARROW-764 - [C++] Improve performance of CopyBitmap, add benchmarks
+
+## New Feature
+
+* ARROW-1394 - [Plasma] Add optional extension for allocating memory on GPUs
+* ARROW-1705 - [Python] Create StructArray from sequence of dicts given a known data type
+* ARROW-1757 - [C++] Add DictionaryArray::FromArrays alternate ctor that can check or sanitized "untrusted" indices
+* ARROW-1832 - [JS] Implement JSON reader for integration tests
+* ARROW-1920 - Add support for reading ORC files
+* ARROW-1926 - [GLib] Add garrow\_timestamp\_data\_type\_get\_unit()
+* ARROW-1930 - [C++] Implement Slice for ChunkedArray and Column
+* ARROW-1931 - [C++] w4996 warning due to std::tr1 failing builds on Visual Studio 2017
+* ARROW-1965 - [GLib] Add garrow\_array\_builder\_get\_value\_data\_type() and garrow\_array\_builder\_get\_value\_type()
+* ARROW-1970 - [GLib] Add garrow\_chunked\_array\_get\_value\_data\_type() and garrow\_chunked\_array\_get\_value\_type()
+* ARROW-2166 - [GLib] Implement Slice for Column
+* ARROW-2176 - [C++] Extend DictionaryBuilder to support delta dictionaries
+* ARROW-2190 - [GLib] Add add/remove field functions for RecordBatch.
+* ARROW-2205 - [Python] Option for integer object nulls
+* ARROW-2252 - [Python] Create buffer from address, size and base
+* ARROW-2253 - [Python] Support \_\_eq\_\_ on scalar values
+* ARROW-2262 - [Python] Support slicing on pyarrow.ChunkedArray
+* ARROW-232 - C++/Parquet: Support writing chunked arrays as part of a table 
+* ARROW-633 - [Java] Add support for FixedSizeBinary type
+* ARROW-634 - Add integration tests for FixedSizeBinary
+* ARROW-969 - [C++/Python] Add add/remove field functions for RecordBatch
+
+## Sub-task
+
+* ARROW-1815 - [Java] Rename MapVector to StructVector
+
+## Task
+
+* ARROW-2052 - Unify OwnedRef and ScopedRef
+* ARROW-2054 - Compilation warnings
+* ARROW-2108 - [Python] Update instructions for ASV
+* ARROW-2114 - [Python] Pull latest docker manylinux1 image
+* ARROW-2123 - [JS] Upgrade to TS 2.7.1
+* ARROW-2134 - [CI] Make Travis commit inspection more robust
+* ARROW-2149 - [Python] reorganize test\_convert\_pandas.py
+* ARROW-2156 - [CI] Isolate Sphinx dependencies
+* ARROW-2197 - Document "undefined symbol" issue and workaround
+* ARROW-2239 - [C++] Update build docs for Windows
+* ARROW-2309 - [C++] Use std::make\_unsigned
+
+## Test
+
+* ARROW-1589 - [C++] Fuzzing for certain input formats
+
 # Apache Arrow 0.8.0 (12 December 2017)
 
 ## Bug
@@ -1576,3 +1844,4 @@
 
 
 
+
diff --git a/c_glib/Brewfile b/c_glib/Brewfile
index 955072e1e..e4ad9880b 100644
--- a/c_glib/Brewfile
+++ b/c_glib/Brewfile
@@ -16,7 +16,7 @@
 # under the License.
 
 brew "autoconf-archive"
-brew "boost", args: ["1.65.0"]
+brew "boost", args: ["1.66.0"]
 brew "ccache"
 brew "cmake"
 brew "git"
diff --git a/ci/travis_release_audit.sh b/ci/travis_release_audit.sh
new file mode 100755
index 000000000..8da71a09c
--- /dev/null
+++ b/ci/travis_release_audit.sh
@@ -0,0 +1,24 @@
+#!/usr/bin/env bash
+
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+set -e
+
+# Check licenses according to Apache policy
+git archive HEAD --prefix=apache-arrow/ --output=arrow-src.tar.gz
+./dev/release/run-rat.sh arrow-src.tar.gz
diff --git a/ci/travis_script_cpp.sh b/ci/travis_script_cpp.sh
index 3d61bc5b8..27ab88ba9 100755
--- a/ci/travis_script_cpp.sh
+++ b/ci/travis_script_cpp.sh
@@ -21,10 +21,6 @@ set -e
 
 source $TRAVIS_BUILD_DIR/ci/travis_env_common.sh
 
-# Check licenses according to Apache policy
-git archive HEAD --prefix=apache-arrow/ --output=arrow-src.tar.gz
-./dev/release/run-rat.sh arrow-src.tar.gz
-
 pushd $CPP_BUILD_DIR
 
 ctest -VV -L unittest
diff --git a/cpp/src/arrow/array.cc b/cpp/src/arrow/array.cc
index 7e66999a3..80d64c871 100644
--- a/cpp/src/arrow/array.cc
+++ b/cpp/src/arrow/array.cc
@@ -47,6 +47,13 @@ std::shared_ptr<ArrayData> ArrayData::Make(const std::shared_ptr<DataType>& type
                                      offset);
 }
 
+std::shared_ptr<ArrayData> ArrayData::Make(
+    const std::shared_ptr<DataType>& type, int64_t length,
+    const std::vector<std::shared_ptr<Buffer>>& buffers, int64_t null_count,
+    int64_t offset) {
+  return std::make_shared<ArrayData>(type, length, buffers, null_count, offset);
+}
+
 std::shared_ptr<ArrayData> ArrayData::Make(const std::shared_ptr<DataType>& type,
                                            int64_t length, int64_t null_count,
                                            int64_t offset) {
diff --git a/cpp/src/arrow/array.h b/cpp/src/arrow/array.h
index 0a155af7e..660d0c3e5 100644
--- a/cpp/src/arrow/array.h
+++ b/cpp/src/arrow/array.h
@@ -111,6 +111,11 @@ struct ARROW_EXPORT ArrayData {
                                          int64_t null_count = kUnknownNullCount,
                                          int64_t offset = 0);
 
+  static std::shared_ptr<ArrayData> Make(
+      const std::shared_ptr<DataType>& type, int64_t length,
+      const std::vector<std::shared_ptr<Buffer>>& buffers,
+      int64_t null_count = kUnknownNullCount, int64_t offset = 0);
+
   static std::shared_ptr<ArrayData> Make(const std::shared_ptr<DataType>& type,
                                          int64_t length,
                                          int64_t null_count = kUnknownNullCount,
diff --git a/cpp/src/arrow/ipc/feather-test.cc b/cpp/src/arrow/ipc/feather-test.cc
index 8ec3b0e4a..21eacf696 100644
--- a/cpp/src/arrow/ipc/feather-test.cc
+++ b/cpp/src/arrow/ipc/feather-test.cc
@@ -406,6 +406,105 @@ TEST_F(TestTableWriter, PrimitiveNullRoundTrip) {
   }
 }
 
+TEST_F(TestTableWriter, SliceRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeIntBatchSized(300, &batch));
+  batch = batch->Slice(100, 100);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_F(TestTableWriter, SliceStringsRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeStringTypesRecordBatchWithNulls(&batch, false));
+  batch = batch->Slice(320, 30);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  SCOPED_TRACE(col->data()->chunk(0)->ToString() + "\n" + batch->column(0)->ToString());
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_F(TestTableWriter, SliceStringsWithNullsRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeStringTypesRecordBatchWithNulls(&batch, true));
+  batch = batch->Slice(320, 30);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  SCOPED_TRACE(col->data()->chunk(0)->ToString() + "\n" + batch->column(0)->ToString());
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_F(TestTableWriter, SliceAtNonEightOffsetStringsWithNullsRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeStringTypesRecordBatchWithNulls(&batch, true));
+  batch = batch->Slice(323, 30);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  SCOPED_TRACE(col->data()->chunk(0)->ToString() + "\n" + batch->column(0)->ToString());
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_F(TestTableWriter, SliceAtNonEightOffsetStringsWithNullsMultipleChunksRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeStringTypesRecordBatchWithNulls(&batch, true));
+  batch = batch->Slice(100, 300);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  SCOPED_TRACE(col->data()->chunk(0)->ToString() + "\n" + batch->column(0)->ToString());
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
 }  // namespace feather
 }  // namespace ipc
 }  // namespace arrow
diff --git a/cpp/src/arrow/ipc/feather.cc b/cpp/src/arrow/ipc/feather.cc
index faf6a08df..5761f4750 100644
--- a/cpp/src/arrow/ipc/feather.cc
+++ b/cpp/src/arrow/ipc/feather.cc
@@ -75,6 +75,44 @@ static Status WritePadded(io::OutputStream* stream, const uint8_t* data, int64_t
   return Status::OK();
 }
 
+static Status WritePaddedWithOffset(io::OutputStream* stream, const uint8_t* data,
+                                    int64_t bit_offset, const int64_t length,
+                                    int64_t* bytes_written) {
+  data = data + bit_offset / 8;
+  bit_offset = bit_offset % 8;
+  if (bit_offset == 0) {
+    RETURN_NOT_OK(stream->Write(data, length));
+  } else {
+    constexpr int64_t buffersize = 256;
+    uint8_t buffer[buffersize];
+    const uint8_t lshift = 8 - bit_offset;
+    const uint8_t* buffer_end = buffer + buffersize;
+    uint8_t* buffer_it = buffer;
+
+    for (const uint8_t* end = data + length; data != end;) {
+      uint8_t r = *data++ >> bit_offset;
+      uint8_t l = *data << lshift;
+      uint8_t value = l | r;
+      *buffer_it++ = value;
+      if (buffer_it == buffer_end) {
+        RETURN_NOT_OK(stream->Write(buffer, buffersize));
+        buffer_it = buffer;
+      }
+    }
+    if (buffer_it != buffer) {
+      RETURN_NOT_OK(stream->Write(buffer, buffer_it - buffer));
+      buffer_it = buffer;
+    }
+  }
+
+  int64_t remainder = PaddedLength(length) - length;
+  if (remainder != 0) {
+    RETURN_NOT_OK(stream->Write(kPaddingBytes, remainder));
+  }
+  *bytes_written = length + remainder;
+  return Status::OK();
+}
+
 /// For compability, we need to write any data sometimes just to keep producing
 /// files that can be read with an older reader.
 static Status WritePaddedBlank(io::OutputStream* stream, int64_t length,
@@ -558,8 +596,10 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {
       // byte boundary, and we write this much data into the stream
       int64_t null_bitmap_size = GetOutputLength(BitUtil::BytesForBits(values.length()));
       if (values.null_bitmap()) {
-        RETURN_NOT_OK(WritePadded(stream_.get(), values.null_bitmap()->data(),
-                                  null_bitmap_size, &bytes_written));
+        auto null_bitmap = values.null_bitmap();
+        RETURN_NOT_OK(WritePaddedWithOffset(stream_.get(), null_bitmap->data(),
+                                            values.offset(), null_bitmap_size,
+                                            &bytes_written));
       } else {
         RETURN_NOT_OK(WritePaddedBlank(stream_.get(), null_bitmap_size, &bytes_written));
       }
@@ -603,7 +643,12 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {
       }
 
       if (prim_values.values()) {
-        values_buffer = prim_values.values()->data();
+        if (prim_values.offset() != 0 && (fw_type.bit_width() % 8 != 0)) {
+          return arrow::Status::NotImplemented(
+              "Buffer offset only allowed for table with byte sized data");
+        }
+        values_buffer = prim_values.values()->data() +
+                        (prim_values.offset() * fw_type.bit_width() / 8);
       }
     }
     if (values_buffer) {
diff --git a/cpp/src/arrow/ipc/test-common.h b/cpp/src/arrow/ipc/test-common.h
index 6f8a0dcc6..8f1581452 100644
--- a/cpp/src/arrow/ipc/test-common.h
+++ b/cpp/src/arrow/ipc/test-common.h
@@ -223,7 +223,8 @@ Status MakeRandomBinaryArray(int64_t length, bool include_nulls, MemoryPool* poo
     if (include_nulls && values_index == 0) {
       RETURN_NOT_OK(builder.AppendNull());
     } else {
-      const std::string& value = values[values_index];
+      const std::string value =
+          i < int64_t(values.size()) ? values[values_index] : std::to_string(i);
       RETURN_NOT_OK(builder.Append(reinterpret_cast<const RawType*>(value.data()),
                                    static_cast<int32_t>(value.size())));
     }
@@ -231,7 +232,8 @@ Status MakeRandomBinaryArray(int64_t length, bool include_nulls, MemoryPool* poo
   return builder.Finish(out);
 }
 
-Status MakeStringTypesRecordBatch(std::shared_ptr<RecordBatch>* out) {
+Status MakeStringTypesRecordBatchWithNulls(std::shared_ptr<RecordBatch>* out,
+                                           bool with_nulls = true) {
   const int64_t length = 500;
   auto string_type = utf8();
   auto binary_type = binary();
@@ -244,18 +246,22 @@ Status MakeStringTypesRecordBatch(std::shared_ptr<RecordBatch>* out) {
 
   // Quirk with RETURN_NOT_OK macro and templated functions
   {
-    auto s = MakeRandomBinaryArray<StringBuilder, char>(length, true, pool, &a0);
+    auto s = MakeRandomBinaryArray<StringBuilder, char>(length, with_nulls, pool, &a0);
     RETURN_NOT_OK(s);
   }
 
   {
-    auto s = MakeRandomBinaryArray<BinaryBuilder, uint8_t>(length, true, pool, &a1);
+    auto s = MakeRandomBinaryArray<BinaryBuilder, uint8_t>(length, with_nulls, pool, &a1);
     RETURN_NOT_OK(s);
   }
   *out = RecordBatch::Make(schema, length, {a0, a1});
   return Status::OK();
 }
 
+Status MakeStringTypesRecordBatch(std::shared_ptr<RecordBatch>* out) {
+  return MakeStringTypesRecordBatchWithNulls(out, true);
+}
+
 Status MakeNullRecordBatch(std::shared_ptr<RecordBatch>* out) {
   const int64_t length = 500;
   auto f0 = field("f0", null());
diff --git a/dev/gen_apidocs/create_documents.sh b/dev/gen_apidocs/create_documents.sh
index 3100d3b98..6332ac989 100755
--- a/dev/gen_apidocs/create_documents.sh
+++ b/dev/gen_apidocs/create_documents.sh
@@ -47,6 +47,7 @@ export PATH=$(pwd)/apache-maven-3.5.2/bin:$PATH
 
 pushd arrow/java
 rm -rf target/site/apidocs/*
+mvn -Drat.skip=true clean
 mvn -Drat.skip=true install
 mvn -Drat.skip=true site
 mkdir -p ../site/asf-site/docs/java/
diff --git a/dev/release/README b/dev/release/README
index 7868c9438..dceb484ef 100644
--- a/dev/release/README
+++ b/dev/release/README
@@ -2,7 +2,9 @@ requirements:
 - being a committer to be able to push to dist and maven repository
 - a gpg key to sign the artifacts
 - use java 7. check your JAVA_HOME environment variable (at least for now. See ARROW-930)
-- have the build requirements for cpp and c_glibg installed (see their README)
+- Maven configured to publish artifacts to Apache repositories (see
+  http://www.apache.org/dev/publishing-maven-artifacts.html)
+- have the build requirements for cpp and c_glib installed (see their README)
 
 to release, run the following (replace 0.1.0 with version to release):
 
diff --git a/dev/release/RELEASE_MANAGEMENT.md b/dev/release/RELEASE_MANAGEMENT.md
index 0f8c2202f..0069a2af8 100644
--- a/dev/release/RELEASE_MANAGEMENT.md
+++ b/dev/release/RELEASE_MANAGEMENT.md
@@ -180,7 +180,10 @@ same time because they are interdependent.
 
 ### Updating Java Maven artifacts in Maven central
 
-See instructions at end of https://github.com/apache/arrow/blob/master/dev/release/README
+See instructions at end of
+https://github.com/apache/arrow/blob/master/dev/release/README. You must set up
+Maven to be able to publish to Apache's repositories. Read more at
+http://www.apache.org/dev/publishing-maven-artifacts.html.
 
 [1]: https://github.com/apache/arrow/blob/master/dev/release/README
 [2]: https://github.com/apache/arrow-dist
diff --git a/dev/release/changelog.py b/dev/release/changelog.py
index 23ac4189d..94c74bd6b 100644
--- a/dev/release/changelog.py
+++ b/dev/release/changelog.py
@@ -43,7 +43,7 @@
                             basic_auth=(JIRA_USERNAME, JIRA_PASSWORD))
 
 
-locale.setlocale(locale.LC_ALL, 'en_US.utf8')
+locale.setlocale(locale.LC_ALL, 'en_US.utf-8')
 
 
 def get_issues_for_version(version):
@@ -84,7 +84,8 @@ def format_changelog_website(issues, out):
         'Wish': NEW_FEATURE,
         'Task': NEW_FEATURE,
         'Test': BUGFIX,
-        'Bug': BUGFIX
+        'Bug': BUGFIX,
+        'Sub-task': NEW_FEATURE
     }
 
     issues_by_category = defaultdict(list)
diff --git a/dev/release/rat_exclude_files.txt b/dev/release/rat_exclude_files.txt
index bf962bcd4..eb735604f 100644
--- a/dev/release/rat_exclude_files.txt
+++ b/dev/release/rat_exclude_files.txt
@@ -39,6 +39,11 @@ cpp/src/plasma/thirdparty/dlmalloc.c
 cpp/src/plasma/thirdparty/xxhash.cc
 cpp/src/plasma/thirdparty/xxhash.h
 dev/release/rat_exclude_files.txt
+go/arrow/Gopkg.lock
+go/arrow/internal/cpu/*
+go/arrow/type_string.go
+go/*.tmpldata
+go/*.s
 js/.npmignore
 js/closure-compiler-scripts/*
 python/cmake_modules
diff --git a/dev/run_site/run_site.sh b/dev/run_site/run_site.sh
index 8527b2b16..088eabdda 100755
--- a/dev/run_site/run_site.sh
+++ b/dev/run_site/run_site.sh
@@ -21,4 +21,6 @@ export BUNDLE_PATH=$(pwd)
 export HOME=$(pwd)
 bundle install --path .
 HOST_IP=$(grep $(hostname) /etc/hosts | cut -f 1)
-bundle exec jekyll serve -c _config.yml -s asf-site --host ${HOST_IP} --port 4000
+pushd asf-site
+bundle exec jekyll serve -c ../_config.yml -s . --host ${HOST_IP} --port 4000
+popd
diff --git a/go/arrow/.editorconfig b/go/arrow/.editorconfig
new file mode 100644
index 000000000..a7ceaf938
--- /dev/null
+++ b/go/arrow/.editorconfig
@@ -0,0 +1,21 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+root = true
+
+[*.tmpl]
+indent_style = tab
+indent_size = 4
\ No newline at end of file
diff --git a/go/arrow/.gitignore b/go/arrow/.gitignore
new file mode 100644
index 000000000..d4b831ae8
--- /dev/null
+++ b/go/arrow/.gitignore
@@ -0,0 +1,35 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+### Go template
+# Binaries for programs and plugins
+*.exe
+*.dll
+*.so
+*.dylib
+*.o
+
+# Test binary, build with `go test -c`
+*.test
+
+# Output of the go coverage tool, specifically when used with LiteIDE
+*.out
+
+# Project-local glide cache, RE: https://github.com/Masterminds/glide/issues/736
+.glide/
+
+bin/
+vendor/
\ No newline at end of file
diff --git a/go/arrow/Gopkg.lock b/go/arrow/Gopkg.lock
new file mode 100644
index 000000000..30a0d82f4
--- /dev/null
+++ b/go/arrow/Gopkg.lock
@@ -0,0 +1,27 @@
+# This file is autogenerated, do not edit; changes may be undone by the next 'dep ensure'.
+
+
+[[projects]]
+  name = "github.com/davecgh/go-spew"
+  packages = ["spew"]
+  revision = "346938d642f2ec3594ed81d874461961cd0faa76"
+  version = "v1.1.0"
+
+[[projects]]
+  name = "github.com/pmezard/go-difflib"
+  packages = ["difflib"]
+  revision = "792786c7400a136282c1664665ae0a8db921c6c2"
+  version = "v1.0.0"
+
+[[projects]]
+  name = "github.com/stretchr/testify"
+  packages = ["assert"]
+  revision = "b91bfb9ebec76498946beb6af7c0230c7cc7ba6c"
+  version = "v1.2.0"
+
+[solve-meta]
+  analyzer-name = "dep"
+  analyzer-version = 1
+  inputs-digest = "a9dd4821c4522b2069722c1be94b191e7aff1736aeb5c12ab0070f87cdbc5af2"
+  solver-name = "gps-cdcl"
+  solver-version = 1
diff --git a/go/arrow/Gopkg.toml b/go/arrow/Gopkg.toml
new file mode 100644
index 000000000..03bbeba1c
--- /dev/null
+++ b/go/arrow/Gopkg.toml
@@ -0,0 +1,19 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+[[constraint]]
+  name = "github.com/stretchr/testify"
+  version = "1.2.0"
diff --git a/go/arrow/Makefile b/go/arrow/Makefile
new file mode 100644
index 000000000..a1fd22589
--- /dev/null
+++ b/go/arrow/Makefile
@@ -0,0 +1,54 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+GO_BUILD=go build
+GO_GEN=go generate
+GO_TEST?=go test
+GOPATH=$(realpath ../../../../../..)
+
+GO_SOURCES  := $(shell find . -path ./_lib -prune -o -name '*.go' -not -name '*_test.go')
+ALL_SOURCES := $(shell find . -path ./_lib -prune -o -name '*.go' -name '*.s' -not -name '*_test.go')
+SOURCES_NO_VENDOR := $(shell find . -path ./vendor -prune -o -name "*.go" -not -name '*_test.go' -print)
+
+.PHONEY: test bench assembly generate
+
+assembly:
+	@$(MAKE) -C memory assembly
+	@$(MAKE) -C math assembly
+
+generate: bin/tmpl
+	bin/tmpl -i -data=numeric.tmpldata type_traits_numeric.gen.go.tmpl array/numeric.gen.go.tmpl array/numericbuilder.gen.go.tmpl array/bufferbuilder_numeric.gen.go.tmpl
+	bin/tmpl -i -data=datatype_numeric.gen.go.tmpldata datatype_numeric.gen.go.tmpl
+	@$(MAKE) -C math generate
+
+fmt: $(SOURCES_NO_VENDOR)
+	goimports -w $^
+
+bench: $(GO_SOURCES) | assembly
+	$(GO_TEST) $(GO_TEST_ARGS) -bench=. -run=- ./...
+
+bench-noasm: $(GO_SOURCES)
+	$(GO_TEST) $(GO_TEST_ARGS) -tags='noasm' -bench=. -run=- ./...
+
+test: $(GO_SOURCES) | assembly
+	$(GO_TEST) $(GO_TEST_ARGS) ./...
+
+test-noasm: $(GO_SOURCES)
+	$(GO_TEST) $(GO_TEST_ARGS) -tags='noasm' ./...
+
+bin/tmpl: _tools/tmpl/main.go
+	$(GO_BUILD) -o $@ ./_tools/tmpl
+
diff --git a/go/arrow/README.md b/go/arrow/README.md
new file mode 100644
index 000000000..e4d349de9
--- /dev/null
+++ b/go/arrow/README.md
@@ -0,0 +1,174 @@
+<!---
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements.  See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership.  The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License.  You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing,
+  software distributed under the License is distributed on an
+  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  KIND, either express or implied.  See the License for the
+  specific language governing permissions and limitations
+  under the License.
+-->
+
+Apache Arrow for Go
+===================
+
+[Apache Arrow][arrow] is a cross-language development platform for in-memory data. It specifies a 
+standardized language-independent columnar memory format for flat and hierarchical data, 
+organized for efficient analytic operations on modern hardware. It also provides computational 
+libraries and zero-copy streaming messaging and inter-process communication.
+
+
+Reference Counting
+------------------
+
+arrow makes use of reference counting so that it can track when memory buffers are no longer used. This allows 
+arrow to update resource accounting, pool memory such and track overall memory usage as objects are created 
+and released. Types expose two methods to deal with this pattern. The `Retain` method will increase the 
+reference count by 1 and `Release` method will reduce the count by 1. Once the reference count of an object 
+is zero, any associated object will be freed. `Retain` and `Release` are safe to call from multiple goroutines.
+
+### When to call `Retain` / `Release`?
+
+* If you are passed an object and wish to take ownership of it, you must call `Retain`. You must later pair this 
+  with a call to `Release` when you no longer need the object.  "Taking ownership" typically means you
+  wish to access the object outside the scope of the current function call.
+  
+* You own any object you create via functions whose name begins with `New` or `Copy` or when receiving
+  an object over a channel. Therefore you must call `Release` once you no longer need the object.
+  
+* If you send an object over a channel, you must call `Retain` before sending it as the receiver is
+  assumed to own the object and will later call `Release` when it no longer needs the object. 
+
+
+Performance
+-----------
+
+The arrow package makes extensive use of [c2goasm][] to leverage LLVM's advanced optimizer and generate PLAN9 
+assembly functions from C/C++ code. The arrow package can be compiled without these optimizations using the `noasm` 
+build tag. Alternatively, by configuring an environment variable, it is possible to dynamically configure which 
+architecture optimizations are used at runtime. 
+See the `cpu` package [README](internal/cpu/README.md) for a description of this environment variable.
+
+### Example Usage
+
+The following benchmarks demonstrate summing an array of 8192 values using various optimizations. 
+
+Disable no architecture optimizations (thus using AVX2):
+
+```sh
+$ INTEL_DISABLE_EXT=NONE go test -bench=8192 -run=. ./math
+goos: darwin
+goarch: amd64
+pkg: github.com/apache/arrow/go/arrow/math
+BenchmarkFloat64Funcs_Sum_8192-8   	 2000000	       687 ns/op	95375.41 MB/s
+BenchmarkInt64Funcs_Sum_8192-8     	 2000000	       719 ns/op	91061.06 MB/s
+BenchmarkUint64Funcs_Sum_8192-8    	 2000000	       691 ns/op	94797.29 MB/s
+PASS
+ok  	github.com/apache/arrow/go/arrow/math	6.444s
+```
+
+**NOTE:** `NONE` is simply ignored, thus enabling optimizations for AVX2 and SSE4
+
+----
+
+Disable AVX2 architecture optimizations:
+
+```sh
+$ INTEL_DISABLE_EXT=AVX2 go test -bench=8192 -run=. ./math
+goos: darwin
+goarch: amd64
+pkg: github.com/apache/arrow/go/arrow/math
+BenchmarkFloat64Funcs_Sum_8192-8   	 1000000	      1912 ns/op	34263.63 MB/s
+BenchmarkInt64Funcs_Sum_8192-8     	 1000000	      1392 ns/op	47065.57 MB/s
+BenchmarkUint64Funcs_Sum_8192-8    	 1000000	      1405 ns/op	46636.41 MB/s
+PASS
+ok  	github.com/apache/arrow/go/arrow/math	4.786s
+```
+
+----
+
+Disable ALL architecture optimizations, thus using pure Go implementation:
+
+```sh
+$ INTEL_DISABLE_EXT=ALL go test -bench=8192 -run=. ./math
+goos: darwin
+goarch: amd64
+pkg: github.com/apache/arrow/go/arrow/math
+BenchmarkFloat64Funcs_Sum_8192-8   	  200000	     10285 ns/op	6371.41 MB/s
+BenchmarkInt64Funcs_Sum_8192-8     	  500000	      3892 ns/op	16837.37 MB/s
+BenchmarkUint64Funcs_Sum_8192-8    	  500000	      3929 ns/op	16680.00 MB/s
+PASS
+ok  	github.com/apache/arrow/go/arrow/math	6.179s
+```
+
+Status
+------
+
+The first milestone was to implement the necessary Array types in order to use
+them internally in the [ifql][] execution engine and storage layers of [InfluxDB][].
+
+
+### Memory Management
+
+- [x] Allocations are 64-byte aligned and padded to 8-bytes
+
+
+### Array and builder support
+
+**Primitive types**
+
+- [x] Signed and unsigned 8, 16, 32 and 64 bit integers
+- [x] 32 and 64 bit floats
+- [x] Packed LSB booleans
+- [x] Variable-length binary
+- [ ] String (valid UTF-8)
+- [ ] Half-float (16-bit)
+- [ ] Null (no physical storage)
+
+**Parametric types**
+
+- [x] Timestamp
+- [ ] Interval (year/month or day/time)
+- [ ] Date32 (days since UNIX epoch)
+- [ ] Date64 (milliseconds since UNIX epoch)
+- [ ] Time32 (seconds or milliseconds since midnight)
+- [ ] Time64 (microseconds or nanoseconds since midnight)
+- [ ] Decimal (128-bit)
+- [ ] Fixed-sized binary
+- [ ] List
+- [ ] Struct
+- [ ] Union
+    - [ ] Dense
+    - [ ] Sparse
+- [ ] Dictionary 
+    - [ ] Dictionary encoding
+
+### Type metadata
+
+- [x] Data types (implemented arrays)
+- [ ] Field
+- [ ] Schema
+  
+
+### I/O 
+
+Serialization is planned for a future iteration.
+
+- [ ] Flat buffers for serializing metadata
+- [ ] Record Batch
+- [ ] Table
+
+
+
+[arrow]:    https://arrow.apache.org
+[ifql]:     https://github.com/influxdata/ifql
+[InfluxDB]: https://github.com/influxdata/influxdb
+[c2goasm]:  https://github.com/minio/c2goasm
\ No newline at end of file
diff --git a/go/arrow/_examples/helloworld/main.go b/go/arrow/_examples/helloworld/main.go
new file mode 100644
index 000000000..ab21f6b42
--- /dev/null
+++ b/go/arrow/_examples/helloworld/main.go
@@ -0,0 +1,32 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package main
+
+import (
+	"github.com/apache/arrow/go/arrow/array"
+	"github.com/apache/arrow/go/arrow/math"
+	"github.com/apache/arrow/go/arrow/memory"
+)
+
+func main() {
+	fb := array.NewFloat64Builder(memory.DefaultAllocator)
+
+	fb.AppendValues([]float64{1, 3, 5, 7, 9, 11}, nil)
+
+	vec := fb.NewFloat64Array()
+	math.Float64.Sum(vec)
+}
diff --git a/go/arrow/_tools/tmpl/main.go b/go/arrow/_tools/tmpl/main.go
new file mode 100644
index 000000000..0cabef3db
--- /dev/null
+++ b/go/arrow/_tools/tmpl/main.go
@@ -0,0 +1,267 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package main
+
+import (
+	"bytes"
+	"encoding/json"
+	"flag"
+	"fmt"
+	"go/format"
+	"io/ioutil"
+	"os"
+	"os/exec"
+	"path/filepath"
+	"strings"
+	"text/template"
+)
+
+const Ext = ".tmpl"
+
+type pathSpec struct {
+	in, out string
+}
+
+func (p *pathSpec) String() string { return p.in + " → " + p.out }
+func (p *pathSpec) IsGoFile() bool { return filepath.Ext(p.out) == ".go" }
+
+func parsePath(path string) (string, string) {
+	p := strings.IndexByte(path, '=')
+	if p == -1 {
+		if filepath.Ext(path) != Ext {
+			errExit("template file '%s' must have .tmpl extension", path)
+		}
+		return path, path[:len(path)-len(Ext)]
+	}
+
+	return path[:p], path[p+1:]
+}
+
+type data struct {
+	In interface{}
+	D  listValue
+}
+
+func errExit(format string, a ...interface{}) {
+	fmt.Fprintf(os.Stderr, format, a...)
+	fmt.Fprintln(os.Stderr)
+	os.Exit(1)
+}
+
+type listValue map[string]string
+
+func (l listValue) String() string {
+	res := make([]string, 0, len(l))
+	for k, v := range l {
+		res = append(res, fmt.Sprintf("%s=%s", k, v))
+	}
+	return strings.Join(res, ", ")
+}
+
+func (l listValue) Set(v string) error {
+	nv := strings.Split(v, "=")
+	if len(nv) != 2 {
+		return fmt.Errorf("expected NAME=VALUE, got %s", v)
+	}
+	l[nv[0]] = nv[1]
+	return nil
+}
+
+func main() {
+	var (
+		dataArg = flag.String("data", "", "input JSON data")
+		gi      = flag.Bool("i", false, "run goimports")
+		in      = &data{D: make(listValue)}
+	)
+
+	flag.Var(&in.D, "d", "-d NAME=VALUE")
+
+	flag.Parse()
+	if *dataArg == "" {
+		errExit("data option is required")
+	}
+
+	if *gi {
+		if _, err := exec.LookPath("goimports"); err != nil {
+			errExit("failed to find goimports: %s", err.Error())
+		}
+		formatter = formatSource
+	} else {
+		formatter = format.Source
+	}
+
+	paths := flag.Args()
+	if len(paths) == 0 {
+		errExit("no tmpl files specified")
+	}
+
+	specs := make([]pathSpec, len(paths))
+	for i, p := range paths {
+		in, out := parsePath(p)
+		specs[i] = pathSpec{in: in, out: out}
+	}
+
+	in.In = readData(*dataArg)
+	process(in, specs)
+}
+
+func mustReadAll(path string) []byte {
+	data, err := ioutil.ReadFile(path)
+	if err != nil {
+		errExit(err.Error())
+	}
+
+	return data
+}
+
+func readData(path string) interface{} {
+	data := mustReadAll(path)
+	var v interface{}
+	if err := json.Unmarshal(StripComments(data), &v); err != nil {
+		errExit("invalid JSON data: %s", err.Error())
+	}
+	return v
+}
+
+func fileMode(path string) os.FileMode {
+	stat, err := os.Stat(path)
+	if err != nil {
+		errExit(err.Error())
+	}
+	return stat.Mode()
+}
+
+var funcs = template.FuncMap{
+	"lower": strings.ToLower,
+	"upper": strings.ToUpper,
+}
+
+func process(data interface{}, specs []pathSpec) {
+	for _, spec := range specs {
+		var (
+			t   *template.Template
+			err error
+		)
+		t, err = template.New("gen").Funcs(funcs).Parse(string(mustReadAll(spec.in)))
+		if err != nil {
+			errExit("error processing template '%s': %s", spec.in, err.Error())
+		}
+
+		var buf bytes.Buffer
+		if spec.IsGoFile() {
+			// preamble
+			fmt.Fprintf(&buf, "// Code generated by %s. DO NOT EDIT.\n", spec.in)
+			fmt.Fprintln(&buf)
+		}
+		err = t.Execute(&buf, data)
+		if err != nil {
+			errExit("error executing template '%s': %s", spec.in, err.Error())
+		}
+
+		generated := buf.Bytes()
+		if spec.IsGoFile() {
+			generated, err = formatter(generated)
+			if err != nil {
+				errExit("error formatting '%s': %s", spec.in, err.Error())
+			}
+		}
+
+		ioutil.WriteFile(spec.out, generated, fileMode(spec.in))
+	}
+}
+
+var (
+	formatter func([]byte) ([]byte, error)
+)
+
+func formatSource(in []byte) ([]byte, error) {
+	r := bytes.NewReader(in)
+	cmd := exec.Command("goimports")
+	cmd.Stdin = r
+	out, err := cmd.Output()
+	if err != nil {
+		if ee, ok := err.(*exec.ExitError); ok {
+			return nil, fmt.Errorf("error running goimports: %s", string(ee.Stderr))
+		}
+		return nil, fmt.Errorf("error running goimports: %s", string(out))
+	}
+
+	return out, nil
+}
+
+func StripComments(raw []byte) []byte {
+	var (
+		quoted, esc bool
+		comment     bool
+	)
+
+	buf := bytes.Buffer{}
+
+	for i := 0; i < len(raw); i++ {
+		b := raw[i]
+
+		if comment {
+			switch b {
+			case '/':
+				comment = false
+				j := bytes.IndexByte(raw[i+1:], '\n')
+				if j == -1 {
+					i = len(raw)
+				} else {
+					i += j // keep new line
+				}
+			case '*':
+				j := bytes.Index(raw[i+1:], []byte("*/"))
+				if j == -1 {
+					i = len(raw)
+				} else {
+					i += j + 2
+					comment = false
+				}
+			}
+			continue
+		}
+
+		if esc {
+			esc = false
+			continue
+		}
+
+		if b == '\\' && quoted {
+			esc = true
+			continue
+		}
+
+		if b == '"' || b == '\'' {
+			quoted = !quoted
+		}
+
+		if b == '/' && !quoted {
+			comment = true
+			continue
+		}
+
+		buf.WriteByte(b)
+	}
+
+	if quoted || esc || comment {
+		// unexpected state, so return raw bytes
+		return raw
+	}
+
+	return buf.Bytes()
+}
diff --git a/go/arrow/_tools/tmpl/main_test.go b/go/arrow/_tools/tmpl/main_test.go
new file mode 100644
index 000000000..831cf791e
--- /dev/null
+++ b/go/arrow/_tools/tmpl/main_test.go
@@ -0,0 +1,73 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package main
+
+import (
+	"testing"
+)
+
+func TestStripComments(t *testing.T) {
+	tests := []struct {
+		name string
+		in   string
+		exp  string
+	}{
+		{name: "none", in: `[1,2,3]`, exp: `[1,2,3]`},
+		{name: "single-line, line comment at end", in: `[1,2,3] // foo bar`, exp: `[1,2,3] `},
+		{name: "single-line, block comment at end", in: `[1,2,3] /* foo bar */  `, exp: `[1,2,3]   `},
+		{name: "single-line, block comment at end", in: `[1,2,3] /* /* // */`, exp: `[1,2,3] `},
+		{name: "single-line, block comment in middle", in: `[1,/* foo bar */2,3]`, exp: `[1,2,3]`},
+		{name: "single-line, block comment in string", in: `[1,"/* foo bar */"]`, exp: `[1,"/* foo bar */"]`},
+		{name: "single-line, malformed block comment", in: `[1,2,/*]`, exp: `[1,2,/*]`},
+		{name: "single-line, malformed JSON", in: `[1,2,/]`, exp: `[1,2,/]`},
+
+		{
+			name: "multi-line",
+			in: `[
+  1,
+  2,
+  3
+]`,
+			exp: `[
+  1,
+  2,
+  3
+]`,
+		},
+		{
+			name: "multi-line, multiple line comments",
+			in: `[ // foo
+  1, // bar
+  2,
+  3
+] // fit`,
+			exp: `[ 
+  1, 
+  2,
+  3
+] `,
+		},
+	}
+	for _, test := range tests {
+		t.Run(test.name, func(t *testing.T) {
+			got := string(StripComments([]byte(test.in)))
+			if got != test.exp {
+				t.Errorf("got:\n%s\nexp:\n%s", got, test.exp)
+			}
+		})
+	}
+}
diff --git a/go/arrow/array/array.go b/go/arrow/array/array.go
new file mode 100644
index 000000000..a789d75b3
--- /dev/null
+++ b/go/arrow/array/array.go
@@ -0,0 +1,185 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+import (
+	"sync/atomic"
+
+	"github.com/apache/arrow/go/arrow"
+	"github.com/apache/arrow/go/arrow/internal/bitutil"
+	"github.com/apache/arrow/go/arrow/internal/debug"
+)
+
+// A type which satisfies array.Interface represents an immutable sequence of values.
+type Interface interface {
+	// DataType returns the type metadata for this instance.
+	DataType() arrow.DataType
+
+	// NullN returns the number of null values in the array.
+	NullN() int
+
+	// NullBitmapBytes returns a byte slice of the validity bitmap.
+	NullBitmapBytes() []byte
+
+	// IsNull returns true if value at index is null.
+	// NOTE: IsNull will panic if NullBitmapBytes is not empty and 0 > i ≥ Len.
+	IsNull(i int) bool
+
+	// IsValid returns true if value at index is not null.
+	// NOTE: IsValid will panic if NullBitmapBytes is not empty and 0 > i ≥ Len.
+	IsValid(i int) bool
+
+	Data() *Data
+
+	// Len returns the number of elements in the array.
+	Len() int
+
+	// Retain increases the reference count by 1.
+	// Retain may be called simultaneously from multiple goroutines.
+	Retain()
+
+	// Release decreases the reference count by 1.
+	// Release may be called simultaneously from multiple goroutines.
+	// When the reference count goes to zero, the memory is freed.
+	Release()
+}
+
+const (
+	// UnknownNullCount specifies the NullN should be calculated from the null bitmap buffer.
+	UnknownNullCount = -1
+)
+
+type array struct {
+	refCount        int64
+	data            *Data
+	nullBitmapBytes []byte
+}
+
+// Retain increases the reference count by 1.
+// Retain may be called simultaneously from multiple goroutines.
+func (a *array) Retain() {
+	atomic.AddInt64(&a.refCount, 1)
+}
+
+// Release decreases the reference count by 1.
+// Release may be called simultaneously from multiple goroutines.
+// When the reference count goes to zero, the memory is freed.
+func (a *array) Release() {
+	debug.Assert(atomic.LoadInt64(&a.refCount) > 0, "too many releases")
+
+	if atomic.AddInt64(&a.refCount, -1) == 0 {
+		a.data.Release()
+		a.data, a.nullBitmapBytes = nil, nil
+	}
+}
+
+// DataType returns the type metadata for this instance.
+func (a *array) DataType() arrow.DataType { return a.data.typE }
+
+// NullN returns the number of null values in the array.
+func (a *array) NullN() int {
+	if a.data.nullN < 0 {
+		a.data.nullN = a.data.length - bitutil.CountSetBits(a.nullBitmapBytes, a.data.length)
+	}
+	return a.data.nullN
+}
+
+// NullBitmapBytes returns a byte slice of the validity bitmap.
+func (a *array) NullBitmapBytes() []byte { return a.nullBitmapBytes }
+
+func (a *array) Data() *Data { return a.data }
+
+// Len returns the number of elements in the array.
+func (a *array) Len() int { return a.data.length }
+
+// IsNull returns true if value at index is null.
+// NOTE: IsNull will panic if NullBitmapBytes is not empty and 0 > i ≥ Len.
+func (a *array) IsNull(i int) bool {
+	return len(a.nullBitmapBytes) != 0 && bitutil.BitIsNotSet(a.nullBitmapBytes, i)
+}
+
+// IsValid returns true if value at index is not null.
+// NOTE: IsValid will panic if NullBitmapBytes is not empty and 0 > i ≥ Len.
+func (a *array) IsValid(i int) bool {
+	return len(a.nullBitmapBytes) == 0 || bitutil.BitIsSet(a.nullBitmapBytes, i)
+}
+
+func (a *array) setData(data *Data) {
+	if a.data != nil {
+		a.data.Release()
+	}
+
+	data.Retain()
+	if len(data.buffers) > 0 && data.buffers[0] != nil {
+		a.nullBitmapBytes = data.buffers[0].Bytes()
+	}
+	a.data = data
+}
+
+type arrayConstructorFn func(*Data) Interface
+
+var (
+	makeArrayFn = [...]arrayConstructorFn{
+		arrow.NULL:              unsupportedArrayType,
+		arrow.BOOL:              func(data *Data) Interface { return NewBooleanData(data) },
+		arrow.UINT8:             unsupportedArrayType,
+		arrow.INT8:              unsupportedArrayType,
+		arrow.UINT16:            unsupportedArrayType,
+		arrow.INT16:             unsupportedArrayType,
+		arrow.UINT32:            unsupportedArrayType,
+		arrow.INT32:             func(data *Data) Interface { return NewInt32Data(data) },
+		arrow.UINT64:            func(data *Data) Interface { return NewUint64Data(data) },
+		arrow.INT64:             func(data *Data) Interface { return NewInt64Data(data) },
+		arrow.HALF_FLOAT:        unsupportedArrayType,
+		arrow.FLOAT32:           unsupportedArrayType,
+		arrow.FLOAT64:           func(data *Data) Interface { return NewFloat64Data(data) },
+		arrow.STRING:            unsupportedArrayType,
+		arrow.BINARY:            func(data *Data) Interface { return NewBinaryData(data) },
+		arrow.FIXED_SIZE_BINARY: unsupportedArrayType,
+		arrow.DATE32:            unsupportedArrayType,
+		arrow.DATE64:            unsupportedArrayType,
+		arrow.TIMESTAMP:         func(data *Data) Interface { return NewTimestampData(data) },
+		arrow.TIME32:            unsupportedArrayType,
+		arrow.TIME64:            unsupportedArrayType,
+		arrow.INTERVAL:          unsupportedArrayType,
+		arrow.DECIMAL:           unsupportedArrayType,
+		arrow.LIST:              unsupportedArrayType,
+		arrow.STRUCT:            unsupportedArrayType,
+		arrow.UNION:             unsupportedArrayType,
+		arrow.DICTIONARY:        unsupportedArrayType,
+		arrow.MAP:               unsupportedArrayType,
+
+		// invalid data types to fill out array size 2⁵-1
+		28: invalidDataType,
+		29: invalidDataType,
+		30: invalidDataType,
+		31: invalidDataType,
+	}
+)
+
+func unsupportedArrayType(data *Data) Interface {
+	panic("unsupported data type: " + data.typE.ID().String())
+}
+
+func invalidDataType(data *Data) Interface {
+	panic("invalid data type: " + data.typE.ID().String())
+}
+
+// MakeFromData constructs a strongly-typed array instance from generic Data.
+func MakeFromData(data *Data) Interface {
+	return makeArrayFn[byte(data.typE.ID()&0x1f)](data)
+}
diff --git a/go/arrow/array/array_test.go b/go/arrow/array/array_test.go
new file mode 100644
index 000000000..6d505cf9f
--- /dev/null
+++ b/go/arrow/array/array_test.go
@@ -0,0 +1,99 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array_test
+
+import (
+	"testing"
+
+	"github.com/apache/arrow/go/arrow"
+	"github.com/apache/arrow/go/arrow/array"
+	"github.com/apache/arrow/go/arrow/internal/testing/tools"
+	"github.com/apache/arrow/go/arrow/memory"
+	"github.com/stretchr/testify/assert"
+)
+
+type testDataType struct {
+	id arrow.Type
+}
+
+func (d *testDataType) ID() arrow.Type { return d.id }
+func (d *testDataType) Name() string   { panic("implement me") }
+
+func TestMakeFromData(t *testing.T) {
+	tests := []struct {
+		name     string
+		d        arrow.DataType
+		expPanic bool
+		expError string
+	}{
+		// unsupported types
+		{name: "null", d: &testDataType{arrow.NULL}, expPanic: true, expError: "unsupported data type: NULL"},
+		{name: "map", d: &testDataType{arrow.MAP}, expPanic: true, expError: "unsupported data type: MAP"},
+
+		// supported types
+		{name: "bool", d: &testDataType{arrow.BOOL}},
+
+		// invalid types
+		{name: "invalid(-1)", d: &testDataType{arrow.Type(-1)}, expPanic: true, expError: "invalid data type: Type(-1)"},
+		{name: "invalid(28)", d: &testDataType{arrow.Type(28)}, expPanic: true, expError: "invalid data type: Type(28)"},
+	}
+	for _, test := range tests {
+		t.Run(test.name, func(t *testing.T) {
+			var b [4]*memory.Buffer
+			data := array.NewData(test.d, 0, b[:], 0)
+
+			if test.expPanic {
+				assert.PanicsWithValue(t, test.expError, func() {
+					array.MakeFromData(data)
+				})
+			} else {
+				assert.NotNil(t, array.MakeFromData(data))
+			}
+		})
+	}
+}
+
+func bbits(v ...int32) []byte {
+	return tools.IntsToBitsLSB(v...)
+}
+
+func TestArray_NullN(t *testing.T) {
+	tests := []struct {
+		name string
+		l    int
+		bm   []byte
+		n    int
+		exp  int
+	}{
+		{name: "unknown,l16", l: 16, bm: bbits(0x11001010, 0x00110011), n: array.UnknownNullCount, exp: 8},
+		{name: "unknown,l12,ignores last nibble", l: 12, bm: bbits(0x11001010, 0x00111111), n: array.UnknownNullCount, exp: 6},
+		{name: "unknown,l12,12 nulls", l: 12, bm: bbits(0x00000000, 0x00000000), n: array.UnknownNullCount, exp: 12},
+		{name: "unknown,l12,00 nulls", l: 12, bm: bbits(0x11111111, 0x11111111), n: array.UnknownNullCount, exp: 0},
+	}
+	for _, test := range tests {
+		t.Run(test.name, func(t *testing.T) {
+			buf := memory.NewBufferBytes(test.bm)
+			data := array.NewData(arrow.FixedWidthTypes.Boolean, test.l, []*memory.Buffer{buf, nil}, test.n)
+			buf.Release()
+			ar := array.MakeFromData(data)
+			data.Release()
+			got := ar.NullN()
+			ar.Release()
+			assert.Equal(t, test.exp, got)
+		})
+	}
+}
diff --git a/go/arrow/array/binary.go b/go/arrow/array/binary.go
new file mode 100644
index 000000000..0b89b7e58
--- /dev/null
+++ b/go/arrow/array/binary.go
@@ -0,0 +1,69 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+import (
+	"unsafe"
+
+	"github.com/apache/arrow/go/arrow"
+)
+
+// A type which represents an immutable sequence of variable-length binary strings.
+type Binary struct {
+	array
+	valueOffsets []int32
+	valueBytes   []byte
+}
+
+// NewBinaryData constructs a new Binary array from data.
+func NewBinaryData(data *Data) *Binary {
+	a := &Binary{}
+	a.refCount = 1
+	a.setData(data)
+	return a
+}
+
+// Value returns the slice at index i. This value should not be mutated.
+func (a *Binary) Value(i int) []byte { return a.valueBytes[a.valueOffsets[i]:a.valueOffsets[i+1]] }
+
+// ValueString returns the string at index i without performing additional allocations.
+// The string is only valid for the lifetime of the Binary array.
+func (a *Binary) ValueString(i int) string {
+	b := a.Value(i)
+	return *(*string)(unsafe.Pointer(&b))
+}
+
+func (a *Binary) ValueOffset(i int) int { return int(a.valueOffsets[i]) }
+func (a *Binary) ValueLen(i int) int    { return int(a.valueOffsets[i+1] - a.valueOffsets[i]) }
+func (a *Binary) ValueOffsets() []int32 { return a.valueOffsets }
+func (a *Binary) ValueBytes() []byte    { return a.valueBytes }
+
+func (a *Binary) setData(data *Data) {
+	if len(data.buffers) != 3 {
+		panic("len(data.buffers) != 3")
+	}
+
+	a.array.setData(data)
+
+	if valueData := data.buffers[2]; valueData != nil {
+		a.valueBytes = valueData.Bytes()
+	}
+
+	if valueOffsets := data.buffers[1]; valueOffsets != nil {
+		a.valueOffsets = arrow.Int32Traits.CastFromBytes(valueOffsets.Bytes())
+	}
+}
diff --git a/go/arrow/array/binarybuilder.go b/go/arrow/array/binarybuilder.go
new file mode 100644
index 000000000..71aa4ccd5
--- /dev/null
+++ b/go/arrow/array/binarybuilder.go
@@ -0,0 +1,184 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+import (
+	"math"
+	"sync/atomic"
+
+	"github.com/apache/arrow/go/arrow"
+	"github.com/apache/arrow/go/arrow/internal/debug"
+	"github.com/apache/arrow/go/arrow/memory"
+)
+
+const (
+	binaryArrayMaximumCapacity = math.MaxInt32
+)
+
+// A BinaryBuilder is used to build a Binary array using the Append methods.
+type BinaryBuilder struct {
+	builder
+
+	typE    arrow.BinaryDataType
+	offsets *int32BufferBuilder
+	values  *byteBufferBuilder
+}
+
+func NewBinaryBuilder(mem memory.Allocator, typE arrow.BinaryDataType) *BinaryBuilder {
+	b := &BinaryBuilder{
+		builder: builder{refCount: 1, mem: mem},
+		typE:    typE,
+		offsets: newInt32BufferBuilder(mem),
+		values:  newByteBufferBuilder(mem),
+	}
+	return b
+}
+
+// Release decreases the reference count by 1.
+// When the reference count goes to zero, the memory is freed.
+// Release may be called simultaneously from multiple goroutines.
+func (b *BinaryBuilder) Release() {
+	debug.Assert(atomic.LoadInt64(&b.refCount) > 0, "too many releases")
+
+	if atomic.AddInt64(&b.refCount, -1) == 0 {
+		if b.nullBitmap != nil {
+			b.nullBitmap.Release()
+			b.nullBitmap = nil
+		}
+		if b.offsets != nil {
+			b.offsets.Release()
+			b.offsets = nil
+		}
+		if b.values != nil {
+			b.values.Release()
+			b.values = nil
+		}
+	}
+}
+
+func (b *BinaryBuilder) Append(v []byte) {
+	b.Reserve(1)
+	b.appendNextOffset()
+	b.values.Append(v)
+	b.UnsafeAppendBoolToBitmap(true)
+}
+
+func (b *BinaryBuilder) AppendString(v string) {
+	b.Append([]byte(v))
+}
+
+func (b *BinaryBuilder) AppendNull() {
+	b.Reserve(1)
+	b.appendNextOffset()
+	b.UnsafeAppendBoolToBitmap(false)
+}
+
+// AppendValues will append the values in the v slice. The valid slice determines which values
+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,
+// all values in v are appended and considered valid.
+func (b *BinaryBuilder) AppendValues(v [][]byte, valid []bool) {
+	if len(v) != len(valid) && len(valid) != 0 {
+		panic("len(v) != len(valid) && len(valid) != 0")
+	}
+
+	b.Reserve(len(v))
+	for _, vv := range v {
+		b.appendNextOffset()
+		b.values.Append(vv)
+	}
+
+	b.builder.unsafeAppendBoolsToBitmap(valid, len(v))
+}
+
+// AppendStringValues will append the values in the v slice. The valid slice determines which values
+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,
+// all values in v are appended and considered valid.
+func (b *BinaryBuilder) AppendStringValues(v []string, valid []bool) {
+	if len(v) != len(valid) && len(valid) != 0 {
+		panic("len(v) != len(valid) && len(valid) != 0")
+	}
+
+	b.Reserve(len(v))
+	for _, vv := range v {
+		b.appendNextOffset()
+		b.values.Append([]byte(vv))
+	}
+
+	b.builder.unsafeAppendBoolsToBitmap(valid, len(v))
+}
+
+func (b *BinaryBuilder) Value(i int) []byte {
+	offsets := b.offsets.Values()
+	start := int(offsets[i])
+	var end int
+	if i == (b.length - 1) {
+		end = b.values.Len()
+	} else {
+		end = int(offsets[i+1])
+	}
+	return b.values.Bytes()[start:end]
+}
+
+func (b *BinaryBuilder) init(capacity int) {
+	b.builder.init(capacity)
+	b.offsets.resize((capacity + 1) * arrow.Int32SizeBytes)
+}
+
+// Reserve ensures there is enough space for appending n elements
+// by checking the capacity and calling Resize if necessary.
+func (b *BinaryBuilder) Reserve(n int) {
+	b.builder.reserve(n, b.Resize)
+}
+
+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),
+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.
+func (b *BinaryBuilder) Resize(n int) {
+	b.offsets.resize((n + 1) * arrow.Int32SizeBytes)
+	b.builder.resize(n, b.init)
+}
+
+// NewBinaryArray creates a Binary array from the memory buffers used by the builder and resets the BinaryBuilder
+// so it can be used to build a new array.
+func (b *BinaryBuilder) NewBinaryArray() (a *Binary) {
+	data := b.newData()
+	a = NewBinaryData(data)
+	data.Release()
+	return
+}
+
+func (b *BinaryBuilder) newData() (data *Data) {
+	b.appendNextOffset()
+	offsets, values := b.offsets.Finish(), b.values.Finish()
+	data = NewData(b.typE, b.length, []*memory.Buffer{b.nullBitmap, offsets, values}, b.nullN)
+	if offsets != nil {
+		offsets.Release()
+	}
+
+	if values != nil {
+		values.Release()
+	}
+
+	b.builder.reset()
+
+	return
+}
+
+func (b *BinaryBuilder) appendNextOffset() {
+	numBytes := b.values.Len()
+	// TODO(sgc): check binaryArrayMaximumCapacity?
+	b.offsets.AppendValue(int32(numBytes))
+}
diff --git a/go/arrow/array/binarybuilder_test.go b/go/arrow/array/binarybuilder_test.go
new file mode 100644
index 000000000..4de512499
--- /dev/null
+++ b/go/arrow/array/binarybuilder_test.go
@@ -0,0 +1,61 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array_test
+
+import (
+	"testing"
+
+	"github.com/apache/arrow/go/arrow"
+	"github.com/apache/arrow/go/arrow/array"
+	"github.com/apache/arrow/go/arrow/memory"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestBinaryBuilder(t *testing.T) {
+	mem := memory.NewCheckedAllocator(memory.NewGoAllocator())
+	defer mem.AssertSize(t, 0)
+
+	ab := array.NewBinaryBuilder(mem, arrow.BinaryTypes.Binary)
+
+	exp := [][]byte{[]byte("foo"), []byte("bar"), nil, []byte("sydney"), []byte("cameron")}
+	for _, v := range exp {
+		if v == nil {
+			ab.AppendNull()
+		} else {
+			ab.Append(v)
+		}
+	}
+
+	assert.Equal(t, len(exp), ab.Len(), "unexpected Len()")
+	assert.Equal(t, 1, ab.NullN(), "unexpected NullN()")
+
+	for i, v := range exp {
+		if v == nil {
+			v = []byte{}
+		}
+		assert.Equal(t, v, ab.Value(i), "unexpected BinaryArrayBuilder.Value(%d)", i)
+	}
+
+	ar := ab.NewBinaryArray()
+	ab.Release()
+	ar.Release()
+
+	// check state of builder after NewBinaryArray
+	assert.Zero(t, ab.Len(), "unexpected ArrayBuilder.Len(), NewBinaryArray did not reset state")
+	assert.Zero(t, ab.Cap(), "unexpected ArrayBuilder.Cap(), NewBinaryArray did not reset state")
+	assert.Zero(t, ab.NullN(), "unexpected ArrayBuilder.NullN(), NewBinaryArray did not reset state")
+}
diff --git a/go/arrow/array/boolean.go b/go/arrow/array/boolean.go
new file mode 100644
index 000000000..0d41381b0
--- /dev/null
+++ b/go/arrow/array/boolean.go
@@ -0,0 +1,53 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+import (
+	"github.com/apache/arrow/go/arrow"
+	"github.com/apache/arrow/go/arrow/internal/bitutil"
+	"github.com/apache/arrow/go/arrow/memory"
+)
+
+// A type which represents an immutable sequence of boolean values.
+type Boolean struct {
+	array
+	values []byte
+}
+
+// NewBoolean creates a boolean array from the data memory.Buffer and contains length elements.
+// The nullBitmap buffer can be nil of there are no null values.
+// If nullN is not known, use UnknownNullCount to calculate the value of NullN at runtime from the nullBitmap buffer.
+func NewBoolean(length int, data *memory.Buffer, nullBitmap *memory.Buffer, nullN int) *Boolean {
+	return NewBooleanData(NewData(arrow.FixedWidthTypes.Boolean, length, []*memory.Buffer{nullBitmap, data}, nullN))
+}
+
+func NewBooleanData(data *Data) *Boolean {
+	a := &Boolean{}
+	a.refCount = 1
+	a.setData(data)
+	return a
+}
+
+func (a *Boolean) Value(i int) bool { return bitutil.BitIsSet(a.values, i) }
+
+func (a *Boolean) setData(data *Data) {
+	a.array.setData(data)
+	vals := data.buffers[1]
+	if vals != nil {
+		a.values = vals.Bytes()
+	}
+}
diff --git a/go/arrow/array/booleanbuilder.go b/go/arrow/array/booleanbuilder.go
new file mode 100644
index 000000000..05e506fb2
--- /dev/null
+++ b/go/arrow/array/booleanbuilder.go
@@ -0,0 +1,150 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+import (
+	"sync/atomic"
+
+	"github.com/apache/arrow/go/arrow"
+	"github.com/apache/arrow/go/arrow/internal/bitutil"
+	"github.com/apache/arrow/go/arrow/internal/debug"
+	"github.com/apache/arrow/go/arrow/memory"
+)
+
+type BooleanBuilder struct {
+	builder
+
+	data    *memory.Buffer
+	rawData []byte
+}
+
+func NewBooleanBuilder(mem memory.Allocator) *BooleanBuilder {
+	return &BooleanBuilder{builder: builder{refCount: 1, mem: mem}}
+}
+
+// Release decreases the reference count by 1.
+// When the reference count goes to zero, the memory is freed.
+// Release may be called simultaneously from multiple goroutines.
+func (b *BooleanBuilder) Release() {
+	debug.Assert(atomic.LoadInt64(&b.refCount) > 0, "too many releases")
+
+	if atomic.AddInt64(&b.refCount, -1) == 0 {
+		if b.nullBitmap != nil {
+			b.nullBitmap.Release()
+			b.nullBitmap = nil
+		}
+		if b.data != nil {
+			b.data.Release()
+			b.data = nil
+		}
+	}
+}
+
+func (b *BooleanBuilder) Append(v bool) {
+	b.Reserve(1)
+	b.UnsafeAppend(v)
+}
+
+func (b *BooleanBuilder) AppendByte(v byte) {
+	b.Reserve(1)
+	b.UnsafeAppend(v != 0)
+}
+
+func (b *BooleanBuilder) AppendNull() {
+	b.Reserve(1)
+	b.UnsafeAppendBoolToBitmap(false)
+}
+
+func (b *BooleanBuilder) UnsafeAppend(v bool) {
+	bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	if v {
+		bitutil.SetBit(b.rawData, b.length)
+	} else {
+		bitutil.ClearBit(b.rawData, b.length)
+	}
+	b.length++
+}
+
+func (b *BooleanBuilder) AppendValues(v []bool, valid []bool) {
+	if len(v) != len(valid) && len(valid) != 0 {
+		panic("len(v) != len(valid) && len(valid) != 0")
+	}
+
+	b.Reserve(len(v))
+	for i, vv := range v {
+		bitutil.SetBitTo(b.rawData, b.length+i, vv)
+	}
+	b.builder.unsafeAppendBoolsToBitmap(valid, len(v))
+}
+
+func (b *BooleanBuilder) init(capacity int) {
+	b.builder.init(capacity)
+
+	b.data = memory.NewResizableBuffer(b.mem)
+	bytesN := arrow.BooleanTraits.BytesRequired(capacity)
+	b.data.Resize(bytesN)
+	b.rawData = b.data.Bytes()
+}
+
+// Reserve ensures there is enough space for appending n elements
+// by checking the capacity and calling Resize if necessary.
+func (b *BooleanBuilder) Reserve(n int) {
+	b.builder.reserve(n, b.Resize)
+}
+
+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),
+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.
+func (b *BooleanBuilder) Resize(n int) {
+	if n < minBuilderCapacity {
+		n = minBuilderCapacity
+	}
+
+	if b.capacity == 0 {
+		b.init(n)
+	} else {
+		b.builder.resize(n, b.init)
+		b.data.Resize(arrow.BooleanTraits.BytesRequired(n))
+		b.rawData = b.data.Bytes()
+	}
+}
+
+// NewBooleanArray creates a Boolean array from the memory buffers used by the builder and resets the BooleanBuilder
+// so it can be used to build a new array.
+func (b *BooleanBuilder) NewBooleanArray() (a *Boolean) {
+	data := b.newData()
+	a = NewBooleanData(data)
+	data.Release()
+	return
+}
+
+func (b *BooleanBuilder) newData() *Data {
+	bytesRequired := arrow.BooleanTraits.BytesRequired(b.length)
+	if bytesRequired > 0 && bytesRequired < b.data.Len() {
+		// trim buffers
+		b.data.Resize(bytesRequired)
+	}
+	res := NewData(arrow.FixedWidthTypes.Boolean, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)
+	b.reset()
+
+	if b.data != nil {
+		b.data.Release()
+		b.data = nil
+		b.rawData = nil
+	}
+
+	return res
+}
diff --git a/go/arrow/array/booleanbuilder_test.go b/go/arrow/array/booleanbuilder_test.go
new file mode 100644
index 000000000..5540c9b33
--- /dev/null
+++ b/go/arrow/array/booleanbuilder_test.go
@@ -0,0 +1,45 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array_test
+
+import (
+	"testing"
+
+	"github.com/apache/arrow/go/arrow/array"
+	"github.com/apache/arrow/go/arrow/internal/testing/tools"
+	"github.com/apache/arrow/go/arrow/memory"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestBooleanBuilder_AppendValues(t *testing.T) {
+	mem := memory.NewCheckedAllocator(memory.NewGoAllocator())
+	defer mem.AssertSize(t, 0)
+
+	b := array.NewBooleanBuilder(mem)
+
+	exp := tools.Bools(1, 1, 0, 1, 1, 0, 1, 0)
+	got := make([]bool, len(exp))
+
+	b.AppendValues(exp, nil)
+	a := b.NewBooleanArray()
+	b.Release()
+	for i := 0; i < a.Len(); i++ {
+		got[i] = a.Value(i)
+	}
+	assert.Equal(t, exp, got)
+	a.Release()
+}
diff --git a/go/arrow/array/bufferbuilder.go b/go/arrow/array/bufferbuilder.go
new file mode 100644
index 000000000..29d97fc8d
--- /dev/null
+++ b/go/arrow/array/bufferbuilder.go
@@ -0,0 +1,127 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+import (
+	"sync/atomic"
+
+	"github.com/apache/arrow/go/arrow/internal/bitutil"
+	"github.com/apache/arrow/go/arrow/internal/debug"
+	"github.com/apache/arrow/go/arrow/memory"
+)
+
+// A bufferBuilder provides common functionality for populating memory with a sequence of type-specific values.
+// Specialized implementations provide type-safe APIs for appending and accessing the memory.
+type bufferBuilder struct {
+	refCount int64
+	mem      memory.Allocator
+	buffer   *memory.Buffer
+	length   int
+	capacity int
+
+	bytes []byte
+}
+
+// Retain increases the reference count by 1.
+// Retain may be called simultaneously from multiple goroutines.
+func (b *bufferBuilder) Retain() {
+	atomic.AddInt64(&b.refCount, 1)
+}
+
+// Release decreases the reference count by 1.
+// When the reference count goes to zero, the memory is freed.
+// Release may be called simultaneously from multiple goroutines.
+func (b *bufferBuilder) Release() {
+	debug.Assert(atomic.LoadInt64(&b.refCount) > 0, "too many releases")
+
+	if atomic.AddInt64(&b.refCount, -1) == 0 {
+		if b.buffer != nil {
+			b.buffer.Release()
+			b.buffer, b.bytes = nil, nil
+		}
+	}
+}
+
+// Len returns the length of the memory buffer in bytes.
+func (b *bufferBuilder) Len() int { return b.length }
+
+// Cap returns the total number of bytes that can be stored without allocating additional memory.
+func (b *bufferBuilder) Cap() int { return b.capacity }
+
+// Bytes returns a slice of length b.Len().
+// The slice is only valid for use until the next buffer modification. That is, until the next call
+// to Advance, Reset, Finish or any Append function. The slice aliases the buffer content at least until the next
+// buffer modification.
+func (b *bufferBuilder) Bytes() []byte { return b.bytes[:b.length] }
+
+func (b *bufferBuilder) resize(elements int) {
+	if b.buffer == nil {
+		b.buffer = memory.NewResizableBuffer(b.mem)
+	}
+
+	b.buffer.Resize(elements)
+	oldCapacity := b.capacity
+	b.capacity = b.buffer.Cap()
+	b.bytes = b.buffer.Buf()
+
+	if b.capacity > oldCapacity {
+		memory.Set(b.bytes[oldCapacity:], 0)
+	}
+}
+
+// Advance increases the buffer by length and initializes the skipped bytes to zero.
+func (b *bufferBuilder) Advance(length int) {
+	if b.capacity < b.length+length {
+		newCapacity := bitutil.NextPowerOf2(b.length + length)
+		b.resize(newCapacity)
+	}
+	b.length += length
+}
+
+// Append appends the contents of v to the buffer, resizing it if necessary.
+func (b *bufferBuilder) Append(v []byte) {
+	if b.capacity < b.length+len(v) {
+		newCapacity := bitutil.NextPowerOf2(b.length + len(v))
+		b.resize(newCapacity)
+	}
+	b.unsafeAppend(v)
+}
+
+// Reset returns the buffer to an empty state. Reset releases the memory and sets the length and capacity to zero.
+func (b *bufferBuilder) Reset() {
+	if b.buffer != nil {
+		b.buffer.Release()
+	}
+	b.buffer, b.bytes = nil, nil
+	b.capacity, b.length = 0, 0
+}
+
+// Finish TODO(sgc)
+func (b *bufferBuilder) Finish() (buffer *memory.Buffer) {
+	if b.length > 0 {
+		b.buffer.ResizeNoShrink(b.length)
+	}
+	buffer = b.buffer
+	b.buffer = nil
+	b.Reset()
+	return
+}
+
+func (b *bufferBuilder) unsafeAppend(data []byte) {
+	copy(b.bytes[b.length:], data)
+	b.length += len(data)
+}
diff --git a/go/arrow/array/bufferbuilder_byte.go b/go/arrow/array/bufferbuilder_byte.go
new file mode 100644
index 000000000..f5f5445b7
--- /dev/null
+++ b/go/arrow/array/bufferbuilder_byte.go
@@ -0,0 +1,30 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+import "github.com/apache/arrow/go/arrow/memory"
+
+type byteBufferBuilder struct {
+	bufferBuilder
+}
+
+func newByteBufferBuilder(mem memory.Allocator) *byteBufferBuilder {
+	return &byteBufferBuilder{bufferBuilder: bufferBuilder{refCount: 1, mem: mem}}
+}
+
+func (b *byteBufferBuilder) Values() []byte   { return b.Bytes() }
+func (b *byteBufferBuilder) Value(i int) byte { return b.bytes[i] }
diff --git a/go/arrow/array/bufferbuilder_numeric.gen.go b/go/arrow/array/bufferbuilder_numeric.gen.go
new file mode 100644
index 000000000..e39b2528a
--- /dev/null
+++ b/go/arrow/array/bufferbuilder_numeric.gen.go
@@ -0,0 +1,58 @@
+// Code generated by array/bufferbuilder_numeric.gen.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+import (
+	"github.com/apache/arrow/go/arrow"
+	"github.com/apache/arrow/go/arrow/internal/bitutil"
+	"github.com/apache/arrow/go/arrow/memory"
+)
+
+type int32BufferBuilder struct {
+	bufferBuilder
+}
+
+func newInt32BufferBuilder(mem memory.Allocator) *int32BufferBuilder {
+	return &int32BufferBuilder{bufferBuilder: bufferBuilder{refCount: 1, mem: mem}}
+}
+
+// AppendValues appends the contents of v to the buffer, growing the buffer as needed.
+func (b *int32BufferBuilder) AppendValues(v []int32) { b.Append(arrow.Int32Traits.CastToBytes(v)) }
+
+// Values returns a slice of length b.Len().
+// The slice is only valid for use until the next buffer modification. That is, until the next call
+// to Advance, Reset, Finish or any Append function. The slice aliases the buffer content at least until the next
+// buffer modification.
+func (b *int32BufferBuilder) Values() []int32 { return arrow.Int32Traits.CastFromBytes(b.Bytes()) }
+
+// Value returns the int32 element at the index i. Value will panic if i is negative or ≥ Len.
+func (b *int32BufferBuilder) Value(i int) int32 { return b.Values()[i] }
+
+// Len returns the number of int32 elements in the buffer.
+func (b *int32BufferBuilder) Len() int { return b.length / arrow.Int32SizeBytes }
+
+// AppendValue appends v to the buffer, growing the buffer as needed.
+func (b *int32BufferBuilder) AppendValue(v int32) {
+	if b.capacity < b.length+arrow.Int32SizeBytes {
+		newCapacity := bitutil.NextPowerOf2(b.length + arrow.Int32SizeBytes)
+		b.resize(newCapacity)
+	}
+	arrow.Int32Traits.PutValue(b.bytes[b.length:], v)
+	b.length += arrow.Int32SizeBytes
+}
diff --git a/go/arrow/array/bufferbuilder_numeric.gen.go.tmpl b/go/arrow/array/bufferbuilder_numeric.gen.go.tmpl
new file mode 100644
index 000000000..d8b03b06c
--- /dev/null
+++ b/go/arrow/array/bufferbuilder_numeric.gen.go.tmpl
@@ -0,0 +1,61 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+import (
+	"github.com/apache/arrow/go/arrow"
+	"github.com/apache/arrow/go/arrow/internal/bitutil"
+	"github.com/apache/arrow/go/arrow/memory"
+)
+
+{{range .In}}
+{{$TypeNamePrefix := .name}}
+{{if .Opt.BufferBuilder}}
+type {{$TypeNamePrefix}}BufferBuilder struct {
+	bufferBuilder
+}
+
+func new{{.Name}}BufferBuilder(mem memory.Allocator) *{{$TypeNamePrefix}}BufferBuilder {
+	return &{{$TypeNamePrefix}}BufferBuilder{bufferBuilder:bufferBuilder{refCount: 1, mem:mem}}
+}
+
+// AppendValues appends the contents of v to the buffer, growing the buffer as needed.
+func (b *{{$TypeNamePrefix}}BufferBuilder) AppendValues(v []{{.Type}}) { b.Append(arrow.{{.Name}}Traits.CastToBytes(v)) }
+
+// Values returns a slice of length b.Len().
+// The slice is only valid for use until the next buffer modification. That is, until the next call
+// to Advance, Reset, Finish or any Append function. The slice aliases the buffer content at least until the next
+// buffer modification.
+func (b *{{$TypeNamePrefix}}BufferBuilder) Values() []{{.Type}}           { return arrow.{{.Name}}Traits.CastFromBytes(b.Bytes()) }
+
+// Value returns the {{.Type}} element at the index i. Value will panic if i is negative or ≥ Len.
+func (b *{{$TypeNamePrefix}}BufferBuilder) Value(i int) {{.Type}}         { return b.Values()[i] }
+
+// Len returns the number of {{.Type}} elements in the buffer.
+func (b *{{$TypeNamePrefix}}BufferBuilder) Len() int                      { return b.length/arrow.{{.Name}}SizeBytes }
+
+// AppendValue appends v to the buffer, growing the buffer as needed.
+func (b *{{$TypeNamePrefix}}BufferBuilder) AppendValue(v {{.Type}}) {
+	if b.capacity < b.length+arrow.{{.Name}}SizeBytes {
+		newCapacity := bitutil.NextPowerOf2(b.length + arrow.{{.Name}}SizeBytes)
+		b.resize(newCapacity)
+	}
+	arrow.{{.Name}}Traits.PutValue(b.bytes[b.length:], v)
+	b.length+=arrow.{{.Name}}SizeBytes
+}
+{{end}}
+{{end}}
\ No newline at end of file
diff --git a/go/arrow/array/bufferbuilder_numeric_test.go b/go/arrow/array/bufferbuilder_numeric_test.go
new file mode 100644
index 000000000..a2205ea48
--- /dev/null
+++ b/go/arrow/array/bufferbuilder_numeric_test.go
@@ -0,0 +1,81 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+import (
+	"testing"
+	"unsafe"
+
+	"github.com/apache/arrow/go/arrow/memory"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestInt32BufferBuilder(t *testing.T) {
+	mem := memory.NewCheckedAllocator(memory.NewGoAllocator())
+	defer mem.AssertSize(t, 0)
+
+	bb := newInt32BufferBuilder(mem)
+	exp := []int32{0x01020304, 0x05060708, 0x090a0b0c, 0x0d0e0f01, 0x02030405, 0x06070809}
+	bb.AppendValues(exp[:3])
+	bb.AppendValues(exp[3:])
+
+	expBuf := []byte{
+		0x04, 0x03, 0x02, 0x01,
+		0x08, 0x07, 0x06, 0x05,
+		0x0c, 0x0b, 0x0a, 0x09,
+		0x01, 0x0f, 0x0e, 0x0d,
+		0x05, 0x04, 0x03, 0x02,
+		0x09, 0x08, 0x07, 0x06,
+	}
+	assert.Equal(t, expBuf, bb.Bytes(), "unexpected byte values")
+	assert.Equal(t, exp, bb.Values(), "unexpected int32 values")
+	assert.Equal(t, len(exp), bb.Len(), "unexpected Len()")
+
+	buflen := bb.Len()
+	bfr := bb.Finish()
+	assert.Equal(t, buflen*int(unsafe.Sizeof(int32(0))), bfr.Len(), "Buffer was not resized")
+	assert.Len(t, bfr.Bytes(), bfr.Len(), "Buffer.Bytes() != Buffer.Len()")
+	bfr.Release()
+
+	assert.Len(t, bb.Bytes(), 0, "BufferBuilder was not reset after Finish")
+	assert.Zero(t, bb.Len(), "BufferBuilder was not reset after Finish")
+	bb.Release()
+}
+
+func TestInt32BufferBuilder_AppendValue(t *testing.T) {
+	mem := memory.NewCheckedAllocator(memory.NewGoAllocator())
+	defer mem.AssertSize(t, 0)
+
+	bb := newInt32BufferBuilder(mem)
+	exp := []int32{0x01020304, 0x05060708, 0x090a0b0c, 0x0d0e0f01, 0x02030405, 0x06070809}
+	for _, v := range exp {
+		bb.AppendValue(v)
+	}
+
+	expBuf := []byte{
+		0x04, 0x03, 0x02, 0x01,
+		0x08, 0x07, 0x06, 0x05,
+		0x0c, 0x0b, 0x0a, 0x09,
+		0x01, 0x0f, 0x0e, 0x0d,
+		0x05, 0x04, 0x03, 0x02,
+		0x09, 0x08, 0x07, 0x06,
+	}
+	assert.Equal(t, expBuf, bb.Bytes(), "unexpected byte values")
+	assert.Equal(t, exp, bb.Values(), "unexpected int32 values")
+	assert.Equal(t, len(exp), bb.Len(), "unexpected Len()")
+	bb.Release()
+}
diff --git a/go/arrow/array/builder.go b/go/arrow/array/builder.go
new file mode 100644
index 000000000..bde12fbc8
--- /dev/null
+++ b/go/arrow/array/builder.go
@@ -0,0 +1,164 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+import (
+	"sync/atomic"
+
+	"github.com/apache/arrow/go/arrow/internal/bitutil"
+	"github.com/apache/arrow/go/arrow/memory"
+)
+
+const (
+	minBuilderCapacity = 1 << 5
+)
+
+// builder provides common functionality for managing the validity bitmap (nulls) when building arrays.
+type builder struct {
+	refCount   int64
+	mem        memory.Allocator
+	nullBitmap *memory.Buffer
+	nullN      int
+	length     int
+	capacity   int
+}
+
+// Retain increases the reference count by 1.
+// Retain may be called simultaneously from multiple goroutines.
+func (b *builder) Retain() {
+	atomic.AddInt64(&b.refCount, 1)
+}
+
+// Len returns the number of elements in the array builder.
+func (b *builder) Len() int { return b.length }
+
+// Cap returns the total number of elements that can be stored without allocating additional memory.
+func (b *builder) Cap() int { return b.capacity }
+
+// NullN returns the number of null values in the array builder.
+func (b *builder) NullN() int { return b.nullN }
+
+func (b *builder) init(capacity int) {
+	toAlloc := bitutil.CeilByte(capacity) / 8
+	b.nullBitmap = memory.NewResizableBuffer(b.mem)
+	b.nullBitmap.Resize(toAlloc)
+	b.capacity = capacity
+	memory.Set(b.nullBitmap.Buf(), 0)
+}
+
+func (b *builder) reset() {
+	if b.nullBitmap != nil {
+		b.nullBitmap.Release()
+		b.nullBitmap = nil
+	}
+
+	b.nullN = 0
+	b.length = 0
+	b.capacity = 0
+}
+
+func (b *builder) resize(newBits int, init func(int)) {
+	if b.nullBitmap == nil {
+		init(newBits)
+		return
+	}
+
+	newBytesN := bitutil.CeilByte(newBits) / 8
+	oldBytesN := b.nullBitmap.Len()
+	b.nullBitmap.Resize(newBytesN)
+	b.capacity = newBits
+	if oldBytesN < newBytesN {
+		// TODO(sgc): necessary?
+		memory.Set(b.nullBitmap.Buf()[oldBytesN:], 0)
+	}
+}
+
+func (b *builder) reserve(elements int, resize func(int)) {
+	if b.length+elements > b.capacity {
+		newCap := bitutil.NextPowerOf2(b.length + elements)
+		resize(newCap)
+	}
+}
+
+// unsafeAppendBoolsToBitmap appends the contents of valid to the validity bitmap.
+// As an optimization, if the valid slice is empty, the next length bits will be set to valid (not null).
+func (b *builder) unsafeAppendBoolsToBitmap(valid []bool, length int) {
+	if len(valid) == 0 {
+		b.unsafeSetValid(length)
+		return
+	}
+
+	byteOffset := b.length / 8
+	bitOffset := byte(b.length % 8)
+	nullBitmap := b.nullBitmap.Bytes()
+	bitSet := nullBitmap[byteOffset]
+
+	for _, v := range valid {
+		if bitOffset == 8 {
+			bitOffset = 0
+			nullBitmap[byteOffset] = bitSet
+			byteOffset++
+			bitSet = nullBitmap[byteOffset]
+		}
+
+		if v {
+			bitSet |= bitutil.BitMask[bitOffset]
+		} else {
+			bitSet &= bitutil.FlippedBitMask[bitOffset]
+			b.nullN++
+		}
+		bitOffset++
+	}
+
+	if bitOffset != 0 {
+		nullBitmap[byteOffset] = bitSet
+	}
+	b.length += len(valid)
+}
+
+// unsafeSetValid sets the next length bits to valid in the validity bitmap.
+func (b *builder) unsafeSetValid(length int) {
+	padToByte := min(8-(b.length%8), length)
+	if padToByte == 8 {
+		padToByte = 0
+	}
+	bits := b.nullBitmap.Bytes()
+	for i := b.length; i < b.length+padToByte; i++ {
+		bitutil.SetBit(bits, i)
+	}
+
+	start := (b.length + padToByte) / 8
+	fastLength := (length - padToByte) / 8
+	memory.Set(bits[start:start+fastLength], 0xff)
+
+	newLength := b.length + length
+	// trailing bytes
+	for i := b.length + padToByte + (fastLength * 8); i < newLength; i++ {
+		bitutil.SetBit(bits, i)
+	}
+
+	b.length = newLength
+}
+
+func (b *builder) UnsafeAppendBoolToBitmap(isValid bool) {
+	if isValid {
+		bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	} else {
+		b.nullN++
+	}
+	b.length++
+}
diff --git a/go/arrow/array/builder_test.go b/go/arrow/array/builder_test.go
new file mode 100644
index 000000000..1ac8f5aa7
--- /dev/null
+++ b/go/arrow/array/builder_test.go
@@ -0,0 +1,57 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+import (
+	"testing"
+
+	"github.com/apache/arrow/go/arrow/internal/testing/tools"
+	"github.com/apache/arrow/go/arrow/memory"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestBuilder_Init(t *testing.T) {
+	type exp struct{ size int }
+	tests := []struct {
+		name string
+		cap  int
+
+		exp exp
+	}{
+		{"07 bits", 07, exp{size: 1}},
+		{"19 bits", 19, exp{size: 3}},
+	}
+	for _, test := range tests {
+		t.Run(test.name, func(t *testing.T) {
+			ab := &builder{mem: memory.NewGoAllocator()}
+			ab.init(test.cap)
+			assert.Equal(t, test.cap, ab.Cap(), "invalid capacity")
+			assert.Equal(t, test.exp.size, ab.nullBitmap.Len(), "invalid length")
+		})
+	}
+}
+
+func TestBuilder_UnsafeSetValid(t *testing.T) {
+	ab := &builder{mem: memory.NewGoAllocator()}
+	ab.init(32)
+	ab.unsafeAppendBoolsToBitmap(tools.Bools(0, 0, 0, 0, 0), 5)
+	assert.Equal(t, 5, ab.Len())
+	assert.Equal(t, []byte{0, 0, 0, 0}, ab.nullBitmap.Bytes())
+
+	ab.unsafeSetValid(17)
+	assert.Equal(t, []byte{0xe0, 0xff, 0x3f, 0}, ab.nullBitmap.Bytes())
+}
diff --git a/go/arrow/array/data.go b/go/arrow/array/data.go
new file mode 100644
index 000000000..e689f0fe4
--- /dev/null
+++ b/go/arrow/array/data.go
@@ -0,0 +1,81 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+import (
+	"sync/atomic"
+
+	"github.com/apache/arrow/go/arrow"
+	"github.com/apache/arrow/go/arrow/internal/debug"
+	"github.com/apache/arrow/go/arrow/memory"
+)
+
+// A type which represents the memory and metadata for an Arrow array.
+type Data struct {
+	refCount  int64
+	typE      arrow.DataType
+	nullN     int
+	length    int
+	buffers   []*memory.Buffer // TODO(sgc): should this be an interface?
+	childData []*Data          // TODO(sgc): managed by ListArray, StructArray and UnionArray types
+}
+
+func NewData(typE arrow.DataType, length int, buffers []*memory.Buffer, nullN int) *Data {
+	for _, b := range buffers {
+		if b != nil {
+			b.Retain()
+		}
+	}
+
+	return &Data{
+		refCount: 1,
+		typE:     typE,
+		nullN:    nullN,
+		length:   length,
+		buffers:  buffers,
+	}
+}
+
+// Retain increases the reference count by 1.
+// Retain may be called simultaneously from multiple goroutines.
+func (d *Data) Retain() {
+	atomic.AddInt64(&d.refCount, 1)
+}
+
+// Release decreases the reference count by 1.
+// When the reference count goes to zero, the memory is freed.
+// Release may be called simultaneously from multiple goroutines.
+func (d *Data) Release() {
+	debug.Assert(atomic.LoadInt64(&d.refCount) > 0, "too many releases")
+
+	if atomic.AddInt64(&d.refCount, -1) == 0 {
+		for _, b := range d.buffers {
+			if b != nil {
+				b.Release()
+			}
+		}
+
+		for _, b := range d.childData {
+			b.Release()
+		}
+		d.buffers, d.childData = nil, nil
+	}
+}
+
+func (d *Data) DataType() arrow.DataType { return d.typE }
+func (d *Data) NullN() int               { return d.nullN }
+func (d *Data) Len() int                 { return d.length }
diff --git a/go/arrow/array/doc.go b/go/arrow/array/doc.go
new file mode 100644
index 000000000..5cf854086
--- /dev/null
+++ b/go/arrow/array/doc.go
@@ -0,0 +1,20 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*
+Package array provides implementations of various Arrow array types.
+*/
+package array
diff --git a/go/arrow/array/numeric.gen.go b/go/arrow/array/numeric.gen.go
new file mode 100644
index 000000000..02903f9e3
--- /dev/null
+++ b/go/arrow/array/numeric.gen.go
@@ -0,0 +1,287 @@
+// Code generated by array/numeric.gen.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+import (
+	"github.com/apache/arrow/go/arrow"
+)
+
+// A type which represents an immutable sequence of int64 values.
+type Int64 struct {
+	array
+	values []int64
+}
+
+func NewInt64Data(data *Data) *Int64 {
+	a := &Int64{}
+	a.refCount = 1
+	a.setData(data)
+	return a
+}
+
+func (a *Int64) Value(i int) int64    { return a.values[i] }
+func (a *Int64) Int64Values() []int64 { return a.values }
+
+func (a *Int64) setData(data *Data) {
+	a.array.setData(data)
+	vals := data.buffers[1]
+	if vals != nil {
+		a.values = arrow.Int64Traits.CastFromBytes(vals.Bytes())
+	}
+}
+
+// A type which represents an immutable sequence of uint64 values.
+type Uint64 struct {
+	array
+	values []uint64
+}
+
+func NewUint64Data(data *Data) *Uint64 {
+	a := &Uint64{}
+	a.refCount = 1
+	a.setData(data)
+	return a
+}
+
+func (a *Uint64) Value(i int) uint64     { return a.values[i] }
+func (a *Uint64) Uint64Values() []uint64 { return a.values }
+
+func (a *Uint64) setData(data *Data) {
+	a.array.setData(data)
+	vals := data.buffers[1]
+	if vals != nil {
+		a.values = arrow.Uint64Traits.CastFromBytes(vals.Bytes())
+	}
+}
+
+// A type which represents an immutable sequence of float64 values.
+type Float64 struct {
+	array
+	values []float64
+}
+
+func NewFloat64Data(data *Data) *Float64 {
+	a := &Float64{}
+	a.refCount = 1
+	a.setData(data)
+	return a
+}
+
+func (a *Float64) Value(i int) float64      { return a.values[i] }
+func (a *Float64) Float64Values() []float64 { return a.values }
+
+func (a *Float64) setData(data *Data) {
+	a.array.setData(data)
+	vals := data.buffers[1]
+	if vals != nil {
+		a.values = arrow.Float64Traits.CastFromBytes(vals.Bytes())
+	}
+}
+
+// A type which represents an immutable sequence of int32 values.
+type Int32 struct {
+	array
+	values []int32
+}
+
+func NewInt32Data(data *Data) *Int32 {
+	a := &Int32{}
+	a.refCount = 1
+	a.setData(data)
+	return a
+}
+
+func (a *Int32) Value(i int) int32    { return a.values[i] }
+func (a *Int32) Int32Values() []int32 { return a.values }
+
+func (a *Int32) setData(data *Data) {
+	a.array.setData(data)
+	vals := data.buffers[1]
+	if vals != nil {
+		a.values = arrow.Int32Traits.CastFromBytes(vals.Bytes())
+	}
+}
+
+// A type which represents an immutable sequence of uint32 values.
+type Uint32 struct {
+	array
+	values []uint32
+}
+
+func NewUint32Data(data *Data) *Uint32 {
+	a := &Uint32{}
+	a.refCount = 1
+	a.setData(data)
+	return a
+}
+
+func (a *Uint32) Value(i int) uint32     { return a.values[i] }
+func (a *Uint32) Uint32Values() []uint32 { return a.values }
+
+func (a *Uint32) setData(data *Data) {
+	a.array.setData(data)
+	vals := data.buffers[1]
+	if vals != nil {
+		a.values = arrow.Uint32Traits.CastFromBytes(vals.Bytes())
+	}
+}
+
+// A type which represents an immutable sequence of float32 values.
+type Float32 struct {
+	array
+	values []float32
+}
+
+func NewFloat32Data(data *Data) *Float32 {
+	a := &Float32{}
+	a.refCount = 1
+	a.setData(data)
+	return a
+}
+
+func (a *Float32) Value(i int) float32      { return a.values[i] }
+func (a *Float32) Float32Values() []float32 { return a.values }
+
+func (a *Float32) setData(data *Data) {
+	a.array.setData(data)
+	vals := data.buffers[1]
+	if vals != nil {
+		a.values = arrow.Float32Traits.CastFromBytes(vals.Bytes())
+	}
+}
+
+// A type which represents an immutable sequence of int16 values.
+type Int16 struct {
+	array
+	values []int16
+}
+
+func NewInt16Data(data *Data) *Int16 {
+	a := &Int16{}
+	a.refCount = 1
+	a.setData(data)
+	return a
+}
+
+func (a *Int16) Value(i int) int16    { return a.values[i] }
+func (a *Int16) Int16Values() []int16 { return a.values }
+
+func (a *Int16) setData(data *Data) {
+	a.array.setData(data)
+	vals := data.buffers[1]
+	if vals != nil {
+		a.values = arrow.Int16Traits.CastFromBytes(vals.Bytes())
+	}
+}
+
+// A type which represents an immutable sequence of uint16 values.
+type Uint16 struct {
+	array
+	values []uint16
+}
+
+func NewUint16Data(data *Data) *Uint16 {
+	a := &Uint16{}
+	a.refCount = 1
+	a.setData(data)
+	return a
+}
+
+func (a *Uint16) Value(i int) uint16     { return a.values[i] }
+func (a *Uint16) Uint16Values() []uint16 { return a.values }
+
+func (a *Uint16) setData(data *Data) {
+	a.array.setData(data)
+	vals := data.buffers[1]
+	if vals != nil {
+		a.values = arrow.Uint16Traits.CastFromBytes(vals.Bytes())
+	}
+}
+
+// A type which represents an immutable sequence of int8 values.
+type Int8 struct {
+	array
+	values []int8
+}
+
+func NewInt8Data(data *Data) *Int8 {
+	a := &Int8{}
+	a.refCount = 1
+	a.setData(data)
+	return a
+}
+
+func (a *Int8) Value(i int) int8   { return a.values[i] }
+func (a *Int8) Int8Values() []int8 { return a.values }
+
+func (a *Int8) setData(data *Data) {
+	a.array.setData(data)
+	vals := data.buffers[1]
+	if vals != nil {
+		a.values = arrow.Int8Traits.CastFromBytes(vals.Bytes())
+	}
+}
+
+// A type which represents an immutable sequence of uint8 values.
+type Uint8 struct {
+	array
+	values []uint8
+}
+
+func NewUint8Data(data *Data) *Uint8 {
+	a := &Uint8{}
+	a.refCount = 1
+	a.setData(data)
+	return a
+}
+
+func (a *Uint8) Value(i int) uint8    { return a.values[i] }
+func (a *Uint8) Uint8Values() []uint8 { return a.values }
+
+func (a *Uint8) setData(data *Data) {
+	a.array.setData(data)
+	vals := data.buffers[1]
+	if vals != nil {
+		a.values = arrow.Uint8Traits.CastFromBytes(vals.Bytes())
+	}
+}
+
+// A type which represents an immutable sequence of arrow.Timestamp values.
+type Timestamp struct {
+	array
+	values []arrow.Timestamp
+}
+
+func NewTimestampData(data *Data) *Timestamp {
+	a := &Timestamp{}
+	a.refCount = 1
+	a.setData(data)
+	return a
+}
+
+func (a *Timestamp) Value(i int) arrow.Timestamp        { return a.values[i] }
+func (a *Timestamp) TimestampValues() []arrow.Timestamp { return a.values }
+
+func (a *Timestamp) setData(data *Data) {
+	a.array.setData(data)
+	vals := data.buffers[1]
+	if vals != nil {
+		a.values = arrow.TimestampTraits.CastFromBytes(vals.Bytes())
+	}
+}
diff --git a/go/arrow/array/numeric.gen.go.tmpl b/go/arrow/array/numeric.gen.go.tmpl
new file mode 100644
index 000000000..5c33a36d5
--- /dev/null
+++ b/go/arrow/array/numeric.gen.go.tmpl
@@ -0,0 +1,48 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+import (
+	"github.com/apache/arrow/go/arrow"
+)
+
+{{range .In}}
+
+// A type which represents an immutable sequence of {{or .QualifiedType .Type}} values.
+type {{.Name}} struct {
+	array
+	values []{{or .QualifiedType .Type}}
+}
+
+func New{{.Name}}Data(data *Data) *{{.Name}} {
+	a := &{{.Name}}{}
+	a.refCount = 1
+	a.setData(data)
+	return a
+}
+
+func (a *{{.Name}}) Value(i int)      {{or .QualifiedType .Type}} { return a.values[i] }
+func (a *{{.Name}}) {{.Name}}Values() []{{or .QualifiedType .Type}} { return a.values }
+
+func (a *{{.Name}}) setData(data *Data) {
+	a.array.setData(data)
+	vals := data.buffers[1]
+	if vals != nil {
+		a.values = arrow.{{.Name}}Traits.CastFromBytes(vals.Bytes())
+	}
+}
+{{end}}
\ No newline at end of file
diff --git a/go/arrow/array/numeric_test.go b/go/arrow/array/numeric_test.go
new file mode 100644
index 000000000..d5b798f3d
--- /dev/null
+++ b/go/arrow/array/numeric_test.go
@@ -0,0 +1,36 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array_test
+
+import (
+	"testing"
+
+	"github.com/apache/arrow/go/arrow"
+	"github.com/apache/arrow/go/arrow/array"
+	"github.com/apache/arrow/go/arrow/memory"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestNewFloat64Data(t *testing.T) {
+	exp := []float64{1.0, 2.0, 4.0, 8.0, 16.0}
+
+	ad := array.NewData(arrow.PrimitiveTypes.Float64, len(exp), []*memory.Buffer{nil, memory.NewBufferBytes(arrow.Float64Traits.CastToBytes(exp))}, 0)
+	fa := array.NewFloat64Data(ad)
+
+	assert.Equal(t, len(exp), fa.Len(), "unexpected Len()")
+	assert.Equal(t, exp, fa.Float64Values(), "unexpected Float64Values()")
+}
diff --git a/go/arrow/array/numericbuilder.gen.go b/go/arrow/array/numericbuilder.gen.go
new file mode 100644
index 000000000..c4e3508bb
--- /dev/null
+++ b/go/arrow/array/numericbuilder.gen.go
@@ -0,0 +1,1415 @@
+// Code generated by array/numericbuilder.gen.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+import (
+	"sync/atomic"
+
+	"github.com/apache/arrow/go/arrow"
+	"github.com/apache/arrow/go/arrow/internal/bitutil"
+	"github.com/apache/arrow/go/arrow/internal/debug"
+	"github.com/apache/arrow/go/arrow/memory"
+)
+
+type Int64Builder struct {
+	builder
+
+	data    *memory.Buffer
+	rawData []int64
+}
+
+func NewInt64Builder(mem memory.Allocator) *Int64Builder {
+	return &Int64Builder{builder: builder{refCount: 1, mem: mem}}
+}
+
+// Release decreases the reference count by 1.
+// When the reference count goes to zero, the memory is freed.
+func (b *Int64Builder) Release() {
+	debug.Assert(atomic.LoadInt64(&b.refCount) > 0, "too many releases")
+
+	if atomic.AddInt64(&b.refCount, -1) == 0 {
+		if b.nullBitmap != nil {
+			b.nullBitmap.Release()
+			b.nullBitmap = nil
+		}
+		if b.data != nil {
+			b.data.Release()
+			b.data = nil
+		}
+	}
+}
+
+func (b *Int64Builder) Append(v int64) {
+	b.Reserve(1)
+	b.UnsafeAppend(v)
+}
+
+func (b *Int64Builder) AppendNull() {
+	b.Reserve(1)
+	b.UnsafeAppendBoolToBitmap(false)
+}
+
+func (b *Int64Builder) UnsafeAppend(v int64) {
+	bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	b.rawData[b.length] = v
+	b.length++
+}
+
+func (b *Int64Builder) UnsafeAppendBoolToBitmap(isValid bool) {
+	if isValid {
+		bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	} else {
+		b.nullN++
+	}
+	b.length++
+}
+
+// AppendValues will append the values in the v slice. The valid slice determines which values
+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,
+// all values in v are appended and considered valid.
+func (b *Int64Builder) AppendValues(v []int64, valid []bool) {
+	if len(v) != len(valid) && len(valid) != 0 {
+		panic("len(v) != len(valid) && len(valid) != 0")
+	}
+
+	b.Reserve(len(v))
+	if len(v) > 0 {
+		arrow.Int64Traits.Copy(b.rawData[b.length:], v)
+	}
+	b.builder.unsafeAppendBoolsToBitmap(valid, len(v))
+}
+
+func (b *Int64Builder) init(capacity int) {
+	b.builder.init(capacity)
+
+	b.data = memory.NewResizableBuffer(b.mem)
+	bytesN := arrow.Int64Traits.BytesRequired(capacity)
+	b.data.Resize(bytesN)
+	b.rawData = arrow.Int64Traits.CastFromBytes(b.data.Bytes())
+}
+
+// Reserve ensures there is enough space for appending n elements
+// by checking the capacity and calling Resize if necessary.
+func (b *Int64Builder) Reserve(n int) {
+	b.builder.reserve(n, b.Resize)
+}
+
+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),
+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.
+func (b *Int64Builder) Resize(n int) {
+	if n < minBuilderCapacity {
+		n = minBuilderCapacity
+	}
+
+	if b.capacity == 0 {
+		b.init(n)
+	} else {
+		b.builder.resize(n, b.init)
+		b.data.Resize(arrow.Int64Traits.BytesRequired(n))
+		b.rawData = arrow.Int64Traits.CastFromBytes(b.data.Bytes())
+	}
+}
+
+// NewInt64Array creates a Int64 array from the memory buffers used by the builder and resets the Int64Builder
+// so it can be used to build a new array.
+func (b *Int64Builder) NewInt64Array() (a *Int64) {
+	data := b.newData()
+	a = NewInt64Data(data)
+	data.Release()
+	return
+}
+
+func (b *Int64Builder) newData() (data *Data) {
+	bytesRequired := arrow.Int64Traits.BytesRequired(b.length)
+	if bytesRequired > 0 && bytesRequired < b.data.Len() {
+		// trim buffers
+		b.data.Resize(bytesRequired)
+	}
+	data = NewData(arrow.PrimitiveTypes.Int64, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)
+	b.reset()
+
+	if b.data != nil {
+		b.data.Release()
+		b.data = nil
+		b.rawData = nil
+	}
+
+	return
+}
+
+type Uint64Builder struct {
+	builder
+
+	data    *memory.Buffer
+	rawData []uint64
+}
+
+func NewUint64Builder(mem memory.Allocator) *Uint64Builder {
+	return &Uint64Builder{builder: builder{refCount: 1, mem: mem}}
+}
+
+// Release decreases the reference count by 1.
+// When the reference count goes to zero, the memory is freed.
+func (b *Uint64Builder) Release() {
+	debug.Assert(atomic.LoadInt64(&b.refCount) > 0, "too many releases")
+
+	if atomic.AddInt64(&b.refCount, -1) == 0 {
+		if b.nullBitmap != nil {
+			b.nullBitmap.Release()
+			b.nullBitmap = nil
+		}
+		if b.data != nil {
+			b.data.Release()
+			b.data = nil
+		}
+	}
+}
+
+func (b *Uint64Builder) Append(v uint64) {
+	b.Reserve(1)
+	b.UnsafeAppend(v)
+}
+
+func (b *Uint64Builder) AppendNull() {
+	b.Reserve(1)
+	b.UnsafeAppendBoolToBitmap(false)
+}
+
+func (b *Uint64Builder) UnsafeAppend(v uint64) {
+	bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	b.rawData[b.length] = v
+	b.length++
+}
+
+func (b *Uint64Builder) UnsafeAppendBoolToBitmap(isValid bool) {
+	if isValid {
+		bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	} else {
+		b.nullN++
+	}
+	b.length++
+}
+
+// AppendValues will append the values in the v slice. The valid slice determines which values
+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,
+// all values in v are appended and considered valid.
+func (b *Uint64Builder) AppendValues(v []uint64, valid []bool) {
+	if len(v) != len(valid) && len(valid) != 0 {
+		panic("len(v) != len(valid) && len(valid) != 0")
+	}
+
+	b.Reserve(len(v))
+	if len(v) > 0 {
+		arrow.Uint64Traits.Copy(b.rawData[b.length:], v)
+	}
+	b.builder.unsafeAppendBoolsToBitmap(valid, len(v))
+}
+
+func (b *Uint64Builder) init(capacity int) {
+	b.builder.init(capacity)
+
+	b.data = memory.NewResizableBuffer(b.mem)
+	bytesN := arrow.Uint64Traits.BytesRequired(capacity)
+	b.data.Resize(bytesN)
+	b.rawData = arrow.Uint64Traits.CastFromBytes(b.data.Bytes())
+}
+
+// Reserve ensures there is enough space for appending n elements
+// by checking the capacity and calling Resize if necessary.
+func (b *Uint64Builder) Reserve(n int) {
+	b.builder.reserve(n, b.Resize)
+}
+
+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),
+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.
+func (b *Uint64Builder) Resize(n int) {
+	if n < minBuilderCapacity {
+		n = minBuilderCapacity
+	}
+
+	if b.capacity == 0 {
+		b.init(n)
+	} else {
+		b.builder.resize(n, b.init)
+		b.data.Resize(arrow.Uint64Traits.BytesRequired(n))
+		b.rawData = arrow.Uint64Traits.CastFromBytes(b.data.Bytes())
+	}
+}
+
+// NewUint64Array creates a Uint64 array from the memory buffers used by the builder and resets the Uint64Builder
+// so it can be used to build a new array.
+func (b *Uint64Builder) NewUint64Array() (a *Uint64) {
+	data := b.newData()
+	a = NewUint64Data(data)
+	data.Release()
+	return
+}
+
+func (b *Uint64Builder) newData() (data *Data) {
+	bytesRequired := arrow.Uint64Traits.BytesRequired(b.length)
+	if bytesRequired > 0 && bytesRequired < b.data.Len() {
+		// trim buffers
+		b.data.Resize(bytesRequired)
+	}
+	data = NewData(arrow.PrimitiveTypes.Uint64, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)
+	b.reset()
+
+	if b.data != nil {
+		b.data.Release()
+		b.data = nil
+		b.rawData = nil
+	}
+
+	return
+}
+
+type Float64Builder struct {
+	builder
+
+	data    *memory.Buffer
+	rawData []float64
+}
+
+func NewFloat64Builder(mem memory.Allocator) *Float64Builder {
+	return &Float64Builder{builder: builder{refCount: 1, mem: mem}}
+}
+
+// Release decreases the reference count by 1.
+// When the reference count goes to zero, the memory is freed.
+func (b *Float64Builder) Release() {
+	debug.Assert(atomic.LoadInt64(&b.refCount) > 0, "too many releases")
+
+	if atomic.AddInt64(&b.refCount, -1) == 0 {
+		if b.nullBitmap != nil {
+			b.nullBitmap.Release()
+			b.nullBitmap = nil
+		}
+		if b.data != nil {
+			b.data.Release()
+			b.data = nil
+		}
+	}
+}
+
+func (b *Float64Builder) Append(v float64) {
+	b.Reserve(1)
+	b.UnsafeAppend(v)
+}
+
+func (b *Float64Builder) AppendNull() {
+	b.Reserve(1)
+	b.UnsafeAppendBoolToBitmap(false)
+}
+
+func (b *Float64Builder) UnsafeAppend(v float64) {
+	bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	b.rawData[b.length] = v
+	b.length++
+}
+
+func (b *Float64Builder) UnsafeAppendBoolToBitmap(isValid bool) {
+	if isValid {
+		bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	} else {
+		b.nullN++
+	}
+	b.length++
+}
+
+// AppendValues will append the values in the v slice. The valid slice determines which values
+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,
+// all values in v are appended and considered valid.
+func (b *Float64Builder) AppendValues(v []float64, valid []bool) {
+	if len(v) != len(valid) && len(valid) != 0 {
+		panic("len(v) != len(valid) && len(valid) != 0")
+	}
+
+	b.Reserve(len(v))
+	if len(v) > 0 {
+		arrow.Float64Traits.Copy(b.rawData[b.length:], v)
+	}
+	b.builder.unsafeAppendBoolsToBitmap(valid, len(v))
+}
+
+func (b *Float64Builder) init(capacity int) {
+	b.builder.init(capacity)
+
+	b.data = memory.NewResizableBuffer(b.mem)
+	bytesN := arrow.Float64Traits.BytesRequired(capacity)
+	b.data.Resize(bytesN)
+	b.rawData = arrow.Float64Traits.CastFromBytes(b.data.Bytes())
+}
+
+// Reserve ensures there is enough space for appending n elements
+// by checking the capacity and calling Resize if necessary.
+func (b *Float64Builder) Reserve(n int) {
+	b.builder.reserve(n, b.Resize)
+}
+
+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),
+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.
+func (b *Float64Builder) Resize(n int) {
+	if n < minBuilderCapacity {
+		n = minBuilderCapacity
+	}
+
+	if b.capacity == 0 {
+		b.init(n)
+	} else {
+		b.builder.resize(n, b.init)
+		b.data.Resize(arrow.Float64Traits.BytesRequired(n))
+		b.rawData = arrow.Float64Traits.CastFromBytes(b.data.Bytes())
+	}
+}
+
+// NewFloat64Array creates a Float64 array from the memory buffers used by the builder and resets the Float64Builder
+// so it can be used to build a new array.
+func (b *Float64Builder) NewFloat64Array() (a *Float64) {
+	data := b.newData()
+	a = NewFloat64Data(data)
+	data.Release()
+	return
+}
+
+func (b *Float64Builder) newData() (data *Data) {
+	bytesRequired := arrow.Float64Traits.BytesRequired(b.length)
+	if bytesRequired > 0 && bytesRequired < b.data.Len() {
+		// trim buffers
+		b.data.Resize(bytesRequired)
+	}
+	data = NewData(arrow.PrimitiveTypes.Float64, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)
+	b.reset()
+
+	if b.data != nil {
+		b.data.Release()
+		b.data = nil
+		b.rawData = nil
+	}
+
+	return
+}
+
+type Int32Builder struct {
+	builder
+
+	data    *memory.Buffer
+	rawData []int32
+}
+
+func NewInt32Builder(mem memory.Allocator) *Int32Builder {
+	return &Int32Builder{builder: builder{refCount: 1, mem: mem}}
+}
+
+// Release decreases the reference count by 1.
+// When the reference count goes to zero, the memory is freed.
+func (b *Int32Builder) Release() {
+	debug.Assert(atomic.LoadInt64(&b.refCount) > 0, "too many releases")
+
+	if atomic.AddInt64(&b.refCount, -1) == 0 {
+		if b.nullBitmap != nil {
+			b.nullBitmap.Release()
+			b.nullBitmap = nil
+		}
+		if b.data != nil {
+			b.data.Release()
+			b.data = nil
+		}
+	}
+}
+
+func (b *Int32Builder) Append(v int32) {
+	b.Reserve(1)
+	b.UnsafeAppend(v)
+}
+
+func (b *Int32Builder) AppendNull() {
+	b.Reserve(1)
+	b.UnsafeAppendBoolToBitmap(false)
+}
+
+func (b *Int32Builder) UnsafeAppend(v int32) {
+	bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	b.rawData[b.length] = v
+	b.length++
+}
+
+func (b *Int32Builder) UnsafeAppendBoolToBitmap(isValid bool) {
+	if isValid {
+		bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	} else {
+		b.nullN++
+	}
+	b.length++
+}
+
+// AppendValues will append the values in the v slice. The valid slice determines which values
+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,
+// all values in v are appended and considered valid.
+func (b *Int32Builder) AppendValues(v []int32, valid []bool) {
+	if len(v) != len(valid) && len(valid) != 0 {
+		panic("len(v) != len(valid) && len(valid) != 0")
+	}
+
+	b.Reserve(len(v))
+	if len(v) > 0 {
+		arrow.Int32Traits.Copy(b.rawData[b.length:], v)
+	}
+	b.builder.unsafeAppendBoolsToBitmap(valid, len(v))
+}
+
+func (b *Int32Builder) init(capacity int) {
+	b.builder.init(capacity)
+
+	b.data = memory.NewResizableBuffer(b.mem)
+	bytesN := arrow.Int32Traits.BytesRequired(capacity)
+	b.data.Resize(bytesN)
+	b.rawData = arrow.Int32Traits.CastFromBytes(b.data.Bytes())
+}
+
+// Reserve ensures there is enough space for appending n elements
+// by checking the capacity and calling Resize if necessary.
+func (b *Int32Builder) Reserve(n int) {
+	b.builder.reserve(n, b.Resize)
+}
+
+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),
+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.
+func (b *Int32Builder) Resize(n int) {
+	if n < minBuilderCapacity {
+		n = minBuilderCapacity
+	}
+
+	if b.capacity == 0 {
+		b.init(n)
+	} else {
+		b.builder.resize(n, b.init)
+		b.data.Resize(arrow.Int32Traits.BytesRequired(n))
+		b.rawData = arrow.Int32Traits.CastFromBytes(b.data.Bytes())
+	}
+}
+
+// NewInt32Array creates a Int32 array from the memory buffers used by the builder and resets the Int32Builder
+// so it can be used to build a new array.
+func (b *Int32Builder) NewInt32Array() (a *Int32) {
+	data := b.newData()
+	a = NewInt32Data(data)
+	data.Release()
+	return
+}
+
+func (b *Int32Builder) newData() (data *Data) {
+	bytesRequired := arrow.Int32Traits.BytesRequired(b.length)
+	if bytesRequired > 0 && bytesRequired < b.data.Len() {
+		// trim buffers
+		b.data.Resize(bytesRequired)
+	}
+	data = NewData(arrow.PrimitiveTypes.Int32, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)
+	b.reset()
+
+	if b.data != nil {
+		b.data.Release()
+		b.data = nil
+		b.rawData = nil
+	}
+
+	return
+}
+
+type Uint32Builder struct {
+	builder
+
+	data    *memory.Buffer
+	rawData []uint32
+}
+
+func NewUint32Builder(mem memory.Allocator) *Uint32Builder {
+	return &Uint32Builder{builder: builder{refCount: 1, mem: mem}}
+}
+
+// Release decreases the reference count by 1.
+// When the reference count goes to zero, the memory is freed.
+func (b *Uint32Builder) Release() {
+	debug.Assert(atomic.LoadInt64(&b.refCount) > 0, "too many releases")
+
+	if atomic.AddInt64(&b.refCount, -1) == 0 {
+		if b.nullBitmap != nil {
+			b.nullBitmap.Release()
+			b.nullBitmap = nil
+		}
+		if b.data != nil {
+			b.data.Release()
+			b.data = nil
+		}
+	}
+}
+
+func (b *Uint32Builder) Append(v uint32) {
+	b.Reserve(1)
+	b.UnsafeAppend(v)
+}
+
+func (b *Uint32Builder) AppendNull() {
+	b.Reserve(1)
+	b.UnsafeAppendBoolToBitmap(false)
+}
+
+func (b *Uint32Builder) UnsafeAppend(v uint32) {
+	bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	b.rawData[b.length] = v
+	b.length++
+}
+
+func (b *Uint32Builder) UnsafeAppendBoolToBitmap(isValid bool) {
+	if isValid {
+		bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	} else {
+		b.nullN++
+	}
+	b.length++
+}
+
+// AppendValues will append the values in the v slice. The valid slice determines which values
+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,
+// all values in v are appended and considered valid.
+func (b *Uint32Builder) AppendValues(v []uint32, valid []bool) {
+	if len(v) != len(valid) && len(valid) != 0 {
+		panic("len(v) != len(valid) && len(valid) != 0")
+	}
+
+	b.Reserve(len(v))
+	if len(v) > 0 {
+		arrow.Uint32Traits.Copy(b.rawData[b.length:], v)
+	}
+	b.builder.unsafeAppendBoolsToBitmap(valid, len(v))
+}
+
+func (b *Uint32Builder) init(capacity int) {
+	b.builder.init(capacity)
+
+	b.data = memory.NewResizableBuffer(b.mem)
+	bytesN := arrow.Uint32Traits.BytesRequired(capacity)
+	b.data.Resize(bytesN)
+	b.rawData = arrow.Uint32Traits.CastFromBytes(b.data.Bytes())
+}
+
+// Reserve ensures there is enough space for appending n elements
+// by checking the capacity and calling Resize if necessary.
+func (b *Uint32Builder) Reserve(n int) {
+	b.builder.reserve(n, b.Resize)
+}
+
+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),
+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.
+func (b *Uint32Builder) Resize(n int) {
+	if n < minBuilderCapacity {
+		n = minBuilderCapacity
+	}
+
+	if b.capacity == 0 {
+		b.init(n)
+	} else {
+		b.builder.resize(n, b.init)
+		b.data.Resize(arrow.Uint32Traits.BytesRequired(n))
+		b.rawData = arrow.Uint32Traits.CastFromBytes(b.data.Bytes())
+	}
+}
+
+// NewUint32Array creates a Uint32 array from the memory buffers used by the builder and resets the Uint32Builder
+// so it can be used to build a new array.
+func (b *Uint32Builder) NewUint32Array() (a *Uint32) {
+	data := b.newData()
+	a = NewUint32Data(data)
+	data.Release()
+	return
+}
+
+func (b *Uint32Builder) newData() (data *Data) {
+	bytesRequired := arrow.Uint32Traits.BytesRequired(b.length)
+	if bytesRequired > 0 && bytesRequired < b.data.Len() {
+		// trim buffers
+		b.data.Resize(bytesRequired)
+	}
+	data = NewData(arrow.PrimitiveTypes.Uint32, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)
+	b.reset()
+
+	if b.data != nil {
+		b.data.Release()
+		b.data = nil
+		b.rawData = nil
+	}
+
+	return
+}
+
+type Float32Builder struct {
+	builder
+
+	data    *memory.Buffer
+	rawData []float32
+}
+
+func NewFloat32Builder(mem memory.Allocator) *Float32Builder {
+	return &Float32Builder{builder: builder{refCount: 1, mem: mem}}
+}
+
+// Release decreases the reference count by 1.
+// When the reference count goes to zero, the memory is freed.
+func (b *Float32Builder) Release() {
+	debug.Assert(atomic.LoadInt64(&b.refCount) > 0, "too many releases")
+
+	if atomic.AddInt64(&b.refCount, -1) == 0 {
+		if b.nullBitmap != nil {
+			b.nullBitmap.Release()
+			b.nullBitmap = nil
+		}
+		if b.data != nil {
+			b.data.Release()
+			b.data = nil
+		}
+	}
+}
+
+func (b *Float32Builder) Append(v float32) {
+	b.Reserve(1)
+	b.UnsafeAppend(v)
+}
+
+func (b *Float32Builder) AppendNull() {
+	b.Reserve(1)
+	b.UnsafeAppendBoolToBitmap(false)
+}
+
+func (b *Float32Builder) UnsafeAppend(v float32) {
+	bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	b.rawData[b.length] = v
+	b.length++
+}
+
+func (b *Float32Builder) UnsafeAppendBoolToBitmap(isValid bool) {
+	if isValid {
+		bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	} else {
+		b.nullN++
+	}
+	b.length++
+}
+
+// AppendValues will append the values in the v slice. The valid slice determines which values
+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,
+// all values in v are appended and considered valid.
+func (b *Float32Builder) AppendValues(v []float32, valid []bool) {
+	if len(v) != len(valid) && len(valid) != 0 {
+		panic("len(v) != len(valid) && len(valid) != 0")
+	}
+
+	b.Reserve(len(v))
+	if len(v) > 0 {
+		arrow.Float32Traits.Copy(b.rawData[b.length:], v)
+	}
+	b.builder.unsafeAppendBoolsToBitmap(valid, len(v))
+}
+
+func (b *Float32Builder) init(capacity int) {
+	b.builder.init(capacity)
+
+	b.data = memory.NewResizableBuffer(b.mem)
+	bytesN := arrow.Float32Traits.BytesRequired(capacity)
+	b.data.Resize(bytesN)
+	b.rawData = arrow.Float32Traits.CastFromBytes(b.data.Bytes())
+}
+
+// Reserve ensures there is enough space for appending n elements
+// by checking the capacity and calling Resize if necessary.
+func (b *Float32Builder) Reserve(n int) {
+	b.builder.reserve(n, b.Resize)
+}
+
+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),
+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.
+func (b *Float32Builder) Resize(n int) {
+	if n < minBuilderCapacity {
+		n = minBuilderCapacity
+	}
+
+	if b.capacity == 0 {
+		b.init(n)
+	} else {
+		b.builder.resize(n, b.init)
+		b.data.Resize(arrow.Float32Traits.BytesRequired(n))
+		b.rawData = arrow.Float32Traits.CastFromBytes(b.data.Bytes())
+	}
+}
+
+// NewFloat32Array creates a Float32 array from the memory buffers used by the builder and resets the Float32Builder
+// so it can be used to build a new array.
+func (b *Float32Builder) NewFloat32Array() (a *Float32) {
+	data := b.newData()
+	a = NewFloat32Data(data)
+	data.Release()
+	return
+}
+
+func (b *Float32Builder) newData() (data *Data) {
+	bytesRequired := arrow.Float32Traits.BytesRequired(b.length)
+	if bytesRequired > 0 && bytesRequired < b.data.Len() {
+		// trim buffers
+		b.data.Resize(bytesRequired)
+	}
+	data = NewData(arrow.PrimitiveTypes.Float32, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)
+	b.reset()
+
+	if b.data != nil {
+		b.data.Release()
+		b.data = nil
+		b.rawData = nil
+	}
+
+	return
+}
+
+type Int16Builder struct {
+	builder
+
+	data    *memory.Buffer
+	rawData []int16
+}
+
+func NewInt16Builder(mem memory.Allocator) *Int16Builder {
+	return &Int16Builder{builder: builder{refCount: 1, mem: mem}}
+}
+
+// Release decreases the reference count by 1.
+// When the reference count goes to zero, the memory is freed.
+func (b *Int16Builder) Release() {
+	debug.Assert(atomic.LoadInt64(&b.refCount) > 0, "too many releases")
+
+	if atomic.AddInt64(&b.refCount, -1) == 0 {
+		if b.nullBitmap != nil {
+			b.nullBitmap.Release()
+			b.nullBitmap = nil
+		}
+		if b.data != nil {
+			b.data.Release()
+			b.data = nil
+		}
+	}
+}
+
+func (b *Int16Builder) Append(v int16) {
+	b.Reserve(1)
+	b.UnsafeAppend(v)
+}
+
+func (b *Int16Builder) AppendNull() {
+	b.Reserve(1)
+	b.UnsafeAppendBoolToBitmap(false)
+}
+
+func (b *Int16Builder) UnsafeAppend(v int16) {
+	bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	b.rawData[b.length] = v
+	b.length++
+}
+
+func (b *Int16Builder) UnsafeAppendBoolToBitmap(isValid bool) {
+	if isValid {
+		bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	} else {
+		b.nullN++
+	}
+	b.length++
+}
+
+// AppendValues will append the values in the v slice. The valid slice determines which values
+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,
+// all values in v are appended and considered valid.
+func (b *Int16Builder) AppendValues(v []int16, valid []bool) {
+	if len(v) != len(valid) && len(valid) != 0 {
+		panic("len(v) != len(valid) && len(valid) != 0")
+	}
+
+	b.Reserve(len(v))
+	if len(v) > 0 {
+		arrow.Int16Traits.Copy(b.rawData[b.length:], v)
+	}
+	b.builder.unsafeAppendBoolsToBitmap(valid, len(v))
+}
+
+func (b *Int16Builder) init(capacity int) {
+	b.builder.init(capacity)
+
+	b.data = memory.NewResizableBuffer(b.mem)
+	bytesN := arrow.Int16Traits.BytesRequired(capacity)
+	b.data.Resize(bytesN)
+	b.rawData = arrow.Int16Traits.CastFromBytes(b.data.Bytes())
+}
+
+// Reserve ensures there is enough space for appending n elements
+// by checking the capacity and calling Resize if necessary.
+func (b *Int16Builder) Reserve(n int) {
+	b.builder.reserve(n, b.Resize)
+}
+
+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),
+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.
+func (b *Int16Builder) Resize(n int) {
+	if n < minBuilderCapacity {
+		n = minBuilderCapacity
+	}
+
+	if b.capacity == 0 {
+		b.init(n)
+	} else {
+		b.builder.resize(n, b.init)
+		b.data.Resize(arrow.Int16Traits.BytesRequired(n))
+		b.rawData = arrow.Int16Traits.CastFromBytes(b.data.Bytes())
+	}
+}
+
+// NewInt16Array creates a Int16 array from the memory buffers used by the builder and resets the Int16Builder
+// so it can be used to build a new array.
+func (b *Int16Builder) NewInt16Array() (a *Int16) {
+	data := b.newData()
+	a = NewInt16Data(data)
+	data.Release()
+	return
+}
+
+func (b *Int16Builder) newData() (data *Data) {
+	bytesRequired := arrow.Int16Traits.BytesRequired(b.length)
+	if bytesRequired > 0 && bytesRequired < b.data.Len() {
+		// trim buffers
+		b.data.Resize(bytesRequired)
+	}
+	data = NewData(arrow.PrimitiveTypes.Int16, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)
+	b.reset()
+
+	if b.data != nil {
+		b.data.Release()
+		b.data = nil
+		b.rawData = nil
+	}
+
+	return
+}
+
+type Uint16Builder struct {
+	builder
+
+	data    *memory.Buffer
+	rawData []uint16
+}
+
+func NewUint16Builder(mem memory.Allocator) *Uint16Builder {
+	return &Uint16Builder{builder: builder{refCount: 1, mem: mem}}
+}
+
+// Release decreases the reference count by 1.
+// When the reference count goes to zero, the memory is freed.
+func (b *Uint16Builder) Release() {
+	debug.Assert(atomic.LoadInt64(&b.refCount) > 0, "too many releases")
+
+	if atomic.AddInt64(&b.refCount, -1) == 0 {
+		if b.nullBitmap != nil {
+			b.nullBitmap.Release()
+			b.nullBitmap = nil
+		}
+		if b.data != nil {
+			b.data.Release()
+			b.data = nil
+		}
+	}
+}
+
+func (b *Uint16Builder) Append(v uint16) {
+	b.Reserve(1)
+	b.UnsafeAppend(v)
+}
+
+func (b *Uint16Builder) AppendNull() {
+	b.Reserve(1)
+	b.UnsafeAppendBoolToBitmap(false)
+}
+
+func (b *Uint16Builder) UnsafeAppend(v uint16) {
+	bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	b.rawData[b.length] = v
+	b.length++
+}
+
+func (b *Uint16Builder) UnsafeAppendBoolToBitmap(isValid bool) {
+	if isValid {
+		bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	} else {
+		b.nullN++
+	}
+	b.length++
+}
+
+// AppendValues will append the values in the v slice. The valid slice determines which values
+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,
+// all values in v are appended and considered valid.
+func (b *Uint16Builder) AppendValues(v []uint16, valid []bool) {
+	if len(v) != len(valid) && len(valid) != 0 {
+		panic("len(v) != len(valid) && len(valid) != 0")
+	}
+
+	b.Reserve(len(v))
+	if len(v) > 0 {
+		arrow.Uint16Traits.Copy(b.rawData[b.length:], v)
+	}
+	b.builder.unsafeAppendBoolsToBitmap(valid, len(v))
+}
+
+func (b *Uint16Builder) init(capacity int) {
+	b.builder.init(capacity)
+
+	b.data = memory.NewResizableBuffer(b.mem)
+	bytesN := arrow.Uint16Traits.BytesRequired(capacity)
+	b.data.Resize(bytesN)
+	b.rawData = arrow.Uint16Traits.CastFromBytes(b.data.Bytes())
+}
+
+// Reserve ensures there is enough space for appending n elements
+// by checking the capacity and calling Resize if necessary.
+func (b *Uint16Builder) Reserve(n int) {
+	b.builder.reserve(n, b.Resize)
+}
+
+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),
+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.
+func (b *Uint16Builder) Resize(n int) {
+	if n < minBuilderCapacity {
+		n = minBuilderCapacity
+	}
+
+	if b.capacity == 0 {
+		b.init(n)
+	} else {
+		b.builder.resize(n, b.init)
+		b.data.Resize(arrow.Uint16Traits.BytesRequired(n))
+		b.rawData = arrow.Uint16Traits.CastFromBytes(b.data.Bytes())
+	}
+}
+
+// NewUint16Array creates a Uint16 array from the memory buffers used by the builder and resets the Uint16Builder
+// so it can be used to build a new array.
+func (b *Uint16Builder) NewUint16Array() (a *Uint16) {
+	data := b.newData()
+	a = NewUint16Data(data)
+	data.Release()
+	return
+}
+
+func (b *Uint16Builder) newData() (data *Data) {
+	bytesRequired := arrow.Uint16Traits.BytesRequired(b.length)
+	if bytesRequired > 0 && bytesRequired < b.data.Len() {
+		// trim buffers
+		b.data.Resize(bytesRequired)
+	}
+	data = NewData(arrow.PrimitiveTypes.Uint16, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)
+	b.reset()
+
+	if b.data != nil {
+		b.data.Release()
+		b.data = nil
+		b.rawData = nil
+	}
+
+	return
+}
+
+type Int8Builder struct {
+	builder
+
+	data    *memory.Buffer
+	rawData []int8
+}
+
+func NewInt8Builder(mem memory.Allocator) *Int8Builder {
+	return &Int8Builder{builder: builder{refCount: 1, mem: mem}}
+}
+
+// Release decreases the reference count by 1.
+// When the reference count goes to zero, the memory is freed.
+func (b *Int8Builder) Release() {
+	debug.Assert(atomic.LoadInt64(&b.refCount) > 0, "too many releases")
+
+	if atomic.AddInt64(&b.refCount, -1) == 0 {
+		if b.nullBitmap != nil {
+			b.nullBitmap.Release()
+			b.nullBitmap = nil
+		}
+		if b.data != nil {
+			b.data.Release()
+			b.data = nil
+		}
+	}
+}
+
+func (b *Int8Builder) Append(v int8) {
+	b.Reserve(1)
+	b.UnsafeAppend(v)
+}
+
+func (b *Int8Builder) AppendNull() {
+	b.Reserve(1)
+	b.UnsafeAppendBoolToBitmap(false)
+}
+
+func (b *Int8Builder) UnsafeAppend(v int8) {
+	bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	b.rawData[b.length] = v
+	b.length++
+}
+
+func (b *Int8Builder) UnsafeAppendBoolToBitmap(isValid bool) {
+	if isValid {
+		bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	} else {
+		b.nullN++
+	}
+	b.length++
+}
+
+// AppendValues will append the values in the v slice. The valid slice determines which values
+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,
+// all values in v are appended and considered valid.
+func (b *Int8Builder) AppendValues(v []int8, valid []bool) {
+	if len(v) != len(valid) && len(valid) != 0 {
+		panic("len(v) != len(valid) && len(valid) != 0")
+	}
+
+	b.Reserve(len(v))
+	if len(v) > 0 {
+		arrow.Int8Traits.Copy(b.rawData[b.length:], v)
+	}
+	b.builder.unsafeAppendBoolsToBitmap(valid, len(v))
+}
+
+func (b *Int8Builder) init(capacity int) {
+	b.builder.init(capacity)
+
+	b.data = memory.NewResizableBuffer(b.mem)
+	bytesN := arrow.Int8Traits.BytesRequired(capacity)
+	b.data.Resize(bytesN)
+	b.rawData = arrow.Int8Traits.CastFromBytes(b.data.Bytes())
+}
+
+// Reserve ensures there is enough space for appending n elements
+// by checking the capacity and calling Resize if necessary.
+func (b *Int8Builder) Reserve(n int) {
+	b.builder.reserve(n, b.Resize)
+}
+
+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),
+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.
+func (b *Int8Builder) Resize(n int) {
+	if n < minBuilderCapacity {
+		n = minBuilderCapacity
+	}
+
+	if b.capacity == 0 {
+		b.init(n)
+	} else {
+		b.builder.resize(n, b.init)
+		b.data.Resize(arrow.Int8Traits.BytesRequired(n))
+		b.rawData = arrow.Int8Traits.CastFromBytes(b.data.Bytes())
+	}
+}
+
+// NewInt8Array creates a Int8 array from the memory buffers used by the builder and resets the Int8Builder
+// so it can be used to build a new array.
+func (b *Int8Builder) NewInt8Array() (a *Int8) {
+	data := b.newData()
+	a = NewInt8Data(data)
+	data.Release()
+	return
+}
+
+func (b *Int8Builder) newData() (data *Data) {
+	bytesRequired := arrow.Int8Traits.BytesRequired(b.length)
+	if bytesRequired > 0 && bytesRequired < b.data.Len() {
+		// trim buffers
+		b.data.Resize(bytesRequired)
+	}
+	data = NewData(arrow.PrimitiveTypes.Int8, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)
+	b.reset()
+
+	if b.data != nil {
+		b.data.Release()
+		b.data = nil
+		b.rawData = nil
+	}
+
+	return
+}
+
+type Uint8Builder struct {
+	builder
+
+	data    *memory.Buffer
+	rawData []uint8
+}
+
+func NewUint8Builder(mem memory.Allocator) *Uint8Builder {
+	return &Uint8Builder{builder: builder{refCount: 1, mem: mem}}
+}
+
+// Release decreases the reference count by 1.
+// When the reference count goes to zero, the memory is freed.
+func (b *Uint8Builder) Release() {
+	debug.Assert(atomic.LoadInt64(&b.refCount) > 0, "too many releases")
+
+	if atomic.AddInt64(&b.refCount, -1) == 0 {
+		if b.nullBitmap != nil {
+			b.nullBitmap.Release()
+			b.nullBitmap = nil
+		}
+		if b.data != nil {
+			b.data.Release()
+			b.data = nil
+		}
+	}
+}
+
+func (b *Uint8Builder) Append(v uint8) {
+	b.Reserve(1)
+	b.UnsafeAppend(v)
+}
+
+func (b *Uint8Builder) AppendNull() {
+	b.Reserve(1)
+	b.UnsafeAppendBoolToBitmap(false)
+}
+
+func (b *Uint8Builder) UnsafeAppend(v uint8) {
+	bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	b.rawData[b.length] = v
+	b.length++
+}
+
+func (b *Uint8Builder) UnsafeAppendBoolToBitmap(isValid bool) {
+	if isValid {
+		bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	} else {
+		b.nullN++
+	}
+	b.length++
+}
+
+// AppendValues will append the values in the v slice. The valid slice determines which values
+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,
+// all values in v are appended and considered valid.
+func (b *Uint8Builder) AppendValues(v []uint8, valid []bool) {
+	if len(v) != len(valid) && len(valid) != 0 {
+		panic("len(v) != len(valid) && len(valid) != 0")
+	}
+
+	b.Reserve(len(v))
+	if len(v) > 0 {
+		arrow.Uint8Traits.Copy(b.rawData[b.length:], v)
+	}
+	b.builder.unsafeAppendBoolsToBitmap(valid, len(v))
+}
+
+func (b *Uint8Builder) init(capacity int) {
+	b.builder.init(capacity)
+
+	b.data = memory.NewResizableBuffer(b.mem)
+	bytesN := arrow.Uint8Traits.BytesRequired(capacity)
+	b.data.Resize(bytesN)
+	b.rawData = arrow.Uint8Traits.CastFromBytes(b.data.Bytes())
+}
+
+// Reserve ensures there is enough space for appending n elements
+// by checking the capacity and calling Resize if necessary.
+func (b *Uint8Builder) Reserve(n int) {
+	b.builder.reserve(n, b.Resize)
+}
+
+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),
+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.
+func (b *Uint8Builder) Resize(n int) {
+	if n < minBuilderCapacity {
+		n = minBuilderCapacity
+	}
+
+	if b.capacity == 0 {
+		b.init(n)
+	} else {
+		b.builder.resize(n, b.init)
+		b.data.Resize(arrow.Uint8Traits.BytesRequired(n))
+		b.rawData = arrow.Uint8Traits.CastFromBytes(b.data.Bytes())
+	}
+}
+
+// NewUint8Array creates a Uint8 array from the memory buffers used by the builder and resets the Uint8Builder
+// so it can be used to build a new array.
+func (b *Uint8Builder) NewUint8Array() (a *Uint8) {
+	data := b.newData()
+	a = NewUint8Data(data)
+	data.Release()
+	return
+}
+
+func (b *Uint8Builder) newData() (data *Data) {
+	bytesRequired := arrow.Uint8Traits.BytesRequired(b.length)
+	if bytesRequired > 0 && bytesRequired < b.data.Len() {
+		// trim buffers
+		b.data.Resize(bytesRequired)
+	}
+	data = NewData(arrow.PrimitiveTypes.Uint8, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)
+	b.reset()
+
+	if b.data != nil {
+		b.data.Release()
+		b.data = nil
+		b.rawData = nil
+	}
+
+	return
+}
+
+type TimestampBuilder struct {
+	builder
+
+	typE    *arrow.TimestampType
+	data    *memory.Buffer
+	rawData []arrow.Timestamp
+}
+
+func NewTimestampBuilder(mem memory.Allocator, typE *arrow.TimestampType) *TimestampBuilder {
+	return &TimestampBuilder{builder: builder{refCount: 1, mem: mem}, typE: typE}
+}
+
+// Release decreases the reference count by 1.
+// When the reference count goes to zero, the memory is freed.
+func (b *TimestampBuilder) Release() {
+	debug.Assert(atomic.LoadInt64(&b.refCount) > 0, "too many releases")
+
+	if atomic.AddInt64(&b.refCount, -1) == 0 {
+		if b.nullBitmap != nil {
+			b.nullBitmap.Release()
+			b.nullBitmap = nil
+		}
+		if b.data != nil {
+			b.data.Release()
+			b.data = nil
+		}
+	}
+}
+
+func (b *TimestampBuilder) Append(v arrow.Timestamp) {
+	b.Reserve(1)
+	b.UnsafeAppend(v)
+}
+
+func (b *TimestampBuilder) AppendNull() {
+	b.Reserve(1)
+	b.UnsafeAppendBoolToBitmap(false)
+}
+
+func (b *TimestampBuilder) UnsafeAppend(v arrow.Timestamp) {
+	bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	b.rawData[b.length] = v
+	b.length++
+}
+
+func (b *TimestampBuilder) UnsafeAppendBoolToBitmap(isValid bool) {
+	if isValid {
+		bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	} else {
+		b.nullN++
+	}
+	b.length++
+}
+
+// AppendValues will append the values in the v slice. The valid slice determines which values
+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,
+// all values in v are appended and considered valid.
+func (b *TimestampBuilder) AppendValues(v []arrow.Timestamp, valid []bool) {
+	if len(v) != len(valid) && len(valid) != 0 {
+		panic("len(v) != len(valid) && len(valid) != 0")
+	}
+
+	b.Reserve(len(v))
+	if len(v) > 0 {
+		arrow.TimestampTraits.Copy(b.rawData[b.length:], v)
+	}
+	b.builder.unsafeAppendBoolsToBitmap(valid, len(v))
+}
+
+func (b *TimestampBuilder) init(capacity int) {
+	b.builder.init(capacity)
+
+	b.data = memory.NewResizableBuffer(b.mem)
+	bytesN := arrow.TimestampTraits.BytesRequired(capacity)
+	b.data.Resize(bytesN)
+	b.rawData = arrow.TimestampTraits.CastFromBytes(b.data.Bytes())
+}
+
+// Reserve ensures there is enough space for appending n elements
+// by checking the capacity and calling Resize if necessary.
+func (b *TimestampBuilder) Reserve(n int) {
+	b.builder.reserve(n, b.Resize)
+}
+
+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),
+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.
+func (b *TimestampBuilder) Resize(n int) {
+	if n < minBuilderCapacity {
+		n = minBuilderCapacity
+	}
+
+	if b.capacity == 0 {
+		b.init(n)
+	} else {
+		b.builder.resize(n, b.init)
+		b.data.Resize(arrow.TimestampTraits.BytesRequired(n))
+		b.rawData = arrow.TimestampTraits.CastFromBytes(b.data.Bytes())
+	}
+}
+
+// NewTimestampArray creates a Timestamp array from the memory buffers used by the builder and resets the TimestampBuilder
+// so it can be used to build a new array.
+func (b *TimestampBuilder) NewTimestampArray() (a *Timestamp) {
+	data := b.newData()
+	a = NewTimestampData(data)
+	data.Release()
+	return
+}
+
+func (b *TimestampBuilder) newData() (data *Data) {
+	bytesRequired := arrow.TimestampTraits.BytesRequired(b.length)
+	if bytesRequired > 0 && bytesRequired < b.data.Len() {
+		// trim buffers
+		b.data.Resize(bytesRequired)
+	}
+	data = NewData(b.typE, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)
+	b.reset()
+
+	if b.data != nil {
+		b.data.Release()
+		b.data = nil
+		b.rawData = nil
+	}
+
+	return
+}
diff --git a/go/arrow/array/numericbuilder.gen.go.tmpl b/go/arrow/array/numericbuilder.gen.go.tmpl
new file mode 100644
index 000000000..1b2aaf08a
--- /dev/null
+++ b/go/arrow/array/numericbuilder.gen.go.tmpl
@@ -0,0 +1,165 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+import (
+	"github.com/apache/arrow/go/arrow"
+	"github.com/apache/arrow/go/arrow/internal/debug"
+	"github.com/apache/arrow/go/arrow/memory"
+)
+
+{{range .In}}
+
+type {{.Name}}Builder struct {
+	builder
+
+{{if .Opt.Parametric -}}
+	typE    *arrow.{{.Name}}Type
+{{end -}}
+	data    *memory.Buffer
+	rawData []{{or .QualifiedType .Type}}
+}
+
+{{if .Opt.Parametric}}
+func New{{.Name}}Builder(mem memory.Allocator, typE *arrow.{{.Name}}Type) *{{.Name}}Builder {
+	return &{{.Name}}Builder{builder: builder{refCount:1, mem: mem}, typE: typE}
+}
+{{else}}
+func New{{.Name}}Builder(mem memory.Allocator) *{{.Name}}Builder {
+	return &{{.Name}}Builder{builder: builder{refCount:1, mem: mem}}
+}
+{{end}}
+
+// Release decreases the reference count by 1.
+// When the reference count goes to zero, the memory is freed.
+func (b *{{.Name}}Builder) Release() {
+	debug.Assert(atomic.LoadInt64(&b.refCount) > 0, "too many releases")
+
+	if atomic.AddInt64(&b.refCount, -1) == 0 {
+		if b.nullBitmap != nil {
+			b.nullBitmap.Release()
+			b.nullBitmap = nil
+		}
+		if b.data != nil {
+			b.data.Release()
+			b.data = nil
+		}
+	}
+}
+
+func (b *{{.Name}}Builder) Append(v {{or .QualifiedType .Type}}) {
+	b.Reserve(1)
+	b.UnsafeAppend(v)
+}
+
+func (b *{{.Name}}Builder) AppendNull() {
+	b.Reserve(1)
+	b.UnsafeAppendBoolToBitmap(false)
+}
+
+func (b *{{.Name}}Builder) UnsafeAppend(v {{or .QualifiedType .Type}}) {
+	bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	b.rawData[b.length] = v
+	b.length++
+}
+
+func (b *{{.Name}}Builder) UnsafeAppendBoolToBitmap(isValid bool) {
+	if isValid {
+		bitutil.SetBit(b.nullBitmap.Bytes(), b.length)
+	} else {
+		b.nullN++
+	}
+	b.length++
+}
+
+// AppendValues will append the values in the v slice. The valid slice determines which values
+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,
+// all values in v are appended and considered valid.
+func (b *{{.Name}}Builder) AppendValues(v []{{or .QualifiedType .Type}}, valid []bool) {
+	if len(v) != len(valid) && len(valid) != 0 {
+		panic("len(v) != len(valid) && len(valid) != 0")
+	}
+
+	b.Reserve(len(v))
+	if len(v) > 0 {
+		arrow.{{.Name}}Traits.Copy(b.rawData[b.length:], v)
+	}
+	b.builder.unsafeAppendBoolsToBitmap(valid, len(v))
+}
+
+func (b *{{.Name}}Builder) init(capacity int) {
+	b.builder.init(capacity)
+
+	b.data = memory.NewResizableBuffer(b.mem)
+	bytesN := arrow.{{.Name}}Traits.BytesRequired(capacity)
+	b.data.Resize(bytesN)
+	b.rawData = arrow.{{.Name}}Traits.CastFromBytes(b.data.Bytes())
+}
+
+// Reserve ensures there is enough space for appending n elements
+// by checking the capacity and calling Resize if necessary.
+func (b *{{.Name}}Builder) Reserve(n int) {
+	b.builder.reserve(n, b.Resize)
+}
+
+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),
+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.
+func (b *{{.Name}}Builder) Resize(n int) {
+	if n < minBuilderCapacity {
+		n = minBuilderCapacity
+	}
+
+	if b.capacity == 0 {
+		b.init(n)
+	} else {
+		b.builder.resize(n, b.init)
+		b.data.Resize(arrow.{{.Name}}Traits.BytesRequired(n))
+		b.rawData = arrow.{{.Name}}Traits.CastFromBytes(b.data.Bytes())
+	}
+}
+
+// New{{.Name}}Array creates a {{.Name}} array from the memory buffers used by the builder and resets the {{.Name}}Builder
+// so it can be used to build a new array.
+func (b *{{.Name}}Builder) New{{.Name}}Array() (a *{{.Name}}) {
+	data := b.newData()
+	a = New{{.Name}}Data(data)
+	data.Release()
+	return
+}
+
+func (b *{{.Name}}Builder) newData() (data *Data) {
+	bytesRequired := arrow.{{.Name}}Traits.BytesRequired(b.length)
+	if bytesRequired > 0 && bytesRequired < b.data.Len() {
+		// trim buffers
+		b.data.Resize(bytesRequired)
+	}
+{{if .Opt.Parametric -}}
+	data = NewData(b.typE, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)
+{{else -}}
+	data = NewData(arrow.PrimitiveTypes.{{.Name}}, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)
+{{end -}}
+	b.reset()
+
+	if b.data != nil {
+		b.data.Release()
+		b.data = nil
+		b.rawData = nil
+	}
+
+	return
+}
+{{end}}
\ No newline at end of file
diff --git a/go/arrow/array/numericbuilder_test.go b/go/arrow/array/numericbuilder_test.go
new file mode 100644
index 000000000..c0cd7adc2
--- /dev/null
+++ b/go/arrow/array/numericbuilder_test.go
@@ -0,0 +1,107 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array_test
+
+import (
+	"testing"
+
+	"github.com/apache/arrow/go/arrow/array"
+	"github.com/apache/arrow/go/arrow/memory"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestNewFloat64Builder(t *testing.T) {
+	mem := memory.NewCheckedAllocator(memory.NewGoAllocator())
+	defer mem.AssertSize(t, 0)
+
+	ab := array.NewFloat64Builder(mem)
+
+	ab.Append(1)
+	ab.Append(2)
+	ab.Append(3)
+	ab.AppendNull()
+	ab.Append(5)
+	ab.Append(6)
+	ab.AppendNull()
+	ab.Append(8)
+	ab.Append(9)
+	ab.Append(10)
+
+	// check state of builder before NewFloat64Array
+	assert.Equal(t, 10, ab.Len(), "unexpected Len()")
+	assert.Equal(t, 2, ab.NullN(), "unexpected NullN()")
+
+	a := ab.NewFloat64Array()
+
+	// check state of builder after NewFloat64Array
+	assert.Zero(t, ab.Len(), "unexpected ArrayBuilder.Len(), NewFloat64Array did not reset state")
+	assert.Zero(t, ab.Cap(), "unexpected ArrayBuilder.Cap(), NewFloat64Array did not reset state")
+	assert.Zero(t, ab.NullN(), "unexpected ArrayBuilder.NullN(), NewFloat64Array did not reset state")
+
+	// check state of array
+	assert.Equal(t, 2, a.NullN(), "unexpected null count")
+	assert.Equal(t, []float64{1, 2, 3, 0, 5, 6, 0, 8, 9, 10}, a.Float64Values(), "unexpected Float64Values")
+	assert.Equal(t, []byte{0xb7}, a.NullBitmapBytes()[:1]) // 4 bytes due to minBuilderCapacity
+	assert.Len(t, a.Float64Values(), 10, "unexpected length of Float64Values")
+
+	a.Release()
+
+	ab.Append(7)
+	ab.Append(8)
+
+	a = ab.NewFloat64Array()
+
+	assert.Equal(t, 0, a.NullN())
+	assert.Equal(t, []float64{7, 8}, a.Float64Values())
+	assert.Len(t, a.Float64Values(), 2)
+
+	a.Release()
+}
+
+func TestFloat32Builder_AppendValues(t *testing.T) {
+	mem := memory.NewCheckedAllocator(memory.NewGoAllocator())
+	defer mem.AssertSize(t, 0)
+
+	ab := array.NewFloat64Builder(mem)
+
+	exp := []float64{1.0, 1.1, 1.2, 1.3}
+	ab.AppendValues(exp, nil)
+	a := ab.NewFloat64Array()
+	assert.Equal(t, exp, a.Float64Values())
+
+	a.Release()
+	ab.Release()
+}
+
+func TestFloat32Builder_Empty(t *testing.T) {
+	mem := memory.NewCheckedAllocator(memory.NewGoAllocator())
+	defer mem.AssertSize(t, 0)
+
+	ab := array.NewFloat64Builder(mem)
+
+	exp := []float64{1.0, 1.1, 1.2, 1.3}
+	ab.AppendValues(exp, nil)
+	a := ab.NewFloat64Array()
+	assert.Equal(t, exp, a.Float64Values())
+	a.Release()
+
+	a = ab.NewFloat64Array()
+	assert.Zero(t, a.Len())
+	a.Release()
+
+	ab.Release()
+}
diff --git a/go/arrow/array/util.go b/go/arrow/array/util.go
new file mode 100644
index 000000000..c8d7e17c2
--- /dev/null
+++ b/go/arrow/array/util.go
@@ -0,0 +1,24 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package array
+
+func min(a, b int) int {
+	if a < b {
+		return a
+	}
+	return b
+}
diff --git a/go/arrow/datatype.go b/go/arrow/datatype.go
new file mode 100644
index 000000000..3329e5085
--- /dev/null
+++ b/go/arrow/datatype.go
@@ -0,0 +1,133 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package arrow
+
+// Type is a logical type. They can be expressed as
+// either a primitive physical type (bytes or bits of some fixed size), a
+// nested type consisting of other data types, or another data type (e.g. a
+// timestamp encoded as an int64)
+type Type int
+
+const (
+	// NULL type having no physical storage
+	NULL Type = iota
+
+	// BOOL is a 1 bit, LSB bit-packed ordering
+	BOOL
+
+	// UINT8 is an Unsigned 8-bit little-endian integer
+	UINT8
+
+	// INT8 is a Signed 8-bit little-endian integer
+	INT8
+
+	// UINT16 is an Unsigned 16-bit little-endian integer
+	UINT16
+
+	// INT16 is a Signed 16-bit little-endian integer
+	INT16
+
+	// UINT32 is an Unsigned 32-bit little-endian integer
+	UINT32
+
+	// INT32 is a Signed 32-bit little-endian integer
+	INT32
+
+	// UINT64 is an Unsigned 64-bit little-endian integer
+	UINT64
+
+	// INT64 is a Signed 64-bit little-endian integer
+	INT64
+
+	// HALF_FLOAT is a 2-byte floating point value
+	HALF_FLOAT
+
+	// FLOAT32 is a 4-byte floating point value
+	FLOAT32
+
+	// FLOAT64 is an 8-byte floating point value
+	FLOAT64
+
+	// STRING is a UTF8 variable-length string
+	STRING
+
+	// BINARY is a Variable-length byte type (no guarantee of UTF8-ness)
+	BINARY
+
+	// FIXED_SIZE_BINARY is a binary where each value occupies the same number of bytes
+	FIXED_SIZE_BINARY
+
+	// DATE32 is int32 days since the UNIX epoch
+	DATE32
+
+	// DATE64 is int64 milliseconds since the UNIX epoch
+	DATE64
+
+	// TIMESTAMP is an exact timestamp encoded with int64 since UNIX epoch
+	// Default unit millisecond
+	TIMESTAMP
+
+	// TIME32 is a signed 32-bit integer, representing either seconds or
+	// milliseconds since midnight
+	TIME32
+
+	// TIME64 is a signed 64-bit integer, representing either microseconds or
+	// nanoseconds since midnight
+	TIME64
+
+	// INTERVAL is YEAR_MONTH or DAY_TIME interval in SQL style
+	INTERVAL
+
+	// DECIMAL is a precision- and scale-based decimal type. Storage type depends on the
+	// parameters.
+	DECIMAL
+
+	// LIST is a list of some logical data type
+	LIST
+
+	// STRUCT of logical types
+	STRUCT
+
+	// UNION of logical types
+	UNION
+
+	// DICTIONARY aka Category type
+	DICTIONARY
+
+	// MAP is a repeated struct logical type
+	MAP
+)
+
+// DataType is the representation of an Arrow type.
+type DataType interface {
+	ID() Type
+	// Name is name of the data type.
+	Name() string
+}
+
+// FixedWidthDataType is the representation of an Arrow type that
+// requires a fixed number of bits in memory for each element.
+type FixedWidthDataType interface {
+	DataType
+	// BitWidth returns the number of bits required to store a single element of this data type in memory.
+	BitWidth() int
+}
+
+type BinaryDataType interface {
+	DataType
+	binary()
+}
diff --git a/go/arrow/datatype_binary.go b/go/arrow/datatype_binary.go
new file mode 100644
index 000000000..40ab860de
--- /dev/null
+++ b/go/arrow/datatype_binary.go
@@ -0,0 +1,39 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package arrow
+
+type BinaryType struct{}
+
+func (t *BinaryType) ID() Type     { return BINARY }
+func (t *BinaryType) Name() string { return "binary" }
+func (t *BinaryType) binary()      {}
+
+type StringType struct{}
+
+func (t *StringType) ID() Type     { return STRING }
+func (t *StringType) Name() string { return "utf8" }
+func (t *StringType) binary()      {}
+
+var (
+	BinaryTypes = struct {
+		Binary BinaryDataType
+		String BinaryDataType
+	}{
+		Binary: &BinaryType{},
+		String: &StringType{},
+	}
+)
diff --git a/go/arrow/datatype_fixedwidth.go b/go/arrow/datatype_fixedwidth.go
new file mode 100644
index 000000000..de96ccba4
--- /dev/null
+++ b/go/arrow/datatype_fixedwidth.go
@@ -0,0 +1,61 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package arrow
+
+type BooleanType struct{}
+
+func (t *BooleanType) ID() Type     { return BOOL }
+func (t *BooleanType) Name() string { return "bool" }
+
+// BitWidth returns the number of bits required to store a single element of this data type in memory.
+func (t *BooleanType) BitWidth() int { return 1 }
+
+type (
+	Timestamp int64
+	TimeUnit  int
+)
+
+const (
+	Nanosecond TimeUnit = iota
+	Microsecond
+	Millisecond
+	Second
+)
+
+func (u TimeUnit) String() string { return [...]string{"ns", "µs", "ms", "s"}[uint(u)&3] }
+
+// TimestampType is encoded as a 64-bit signed integer since the UNIX epoch (2017-01-01T00:00:00Z).
+// The zero-value is a nanosecond and time zone neutral. Time zone neutral can be
+// considered UTC without having "UTC" as a time zone.
+type TimestampType struct {
+	Unit     TimeUnit
+	TimeZone string
+}
+
+func (*TimestampType) ID() Type     { return TIMESTAMP }
+func (*TimestampType) Name() string { return "timestamp" }
+
+// BitWidth returns the number of bits required to store a single element of this data type in memory.
+func (*TimestampType) BitWidth() int { return 64 }
+
+var (
+	FixedWidthTypes = struct {
+		Boolean FixedWidthDataType
+	}{
+		Boolean: &BooleanType{},
+	}
+)
diff --git a/go/arrow/datatype_fixedwidth_test.go b/go/arrow/datatype_fixedwidth_test.go
new file mode 100644
index 000000000..44fbdd135
--- /dev/null
+++ b/go/arrow/datatype_fixedwidth_test.go
@@ -0,0 +1,42 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package arrow_test
+
+import (
+	"testing"
+
+	"github.com/apache/arrow/go/arrow"
+	"github.com/stretchr/testify/assert"
+)
+
+// TestTimeUnit_String verifies each time unit matches its string representation.
+func TestTimeUnit_String(t *testing.T) {
+	tests := []struct {
+		u   arrow.TimeUnit
+		exp string
+	}{
+		{arrow.Nanosecond, "ns"},
+		{arrow.Microsecond, "µs"},
+		{arrow.Millisecond, "ms"},
+		{arrow.Second, "s"},
+	}
+	for _, test := range tests {
+		t.Run(test.exp, func(t *testing.T) {
+			assert.Equal(t, test.exp, test.u.String())
+		})
+	}
+}
diff --git a/go/arrow/datatype_numeric.gen.go b/go/arrow/datatype_numeric.gen.go
new file mode 100644
index 000000000..30537be74
--- /dev/null
+++ b/go/arrow/datatype_numeric.gen.go
@@ -0,0 +1,96 @@
+// Code generated by datatype_numeric.gen.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package arrow
+
+type Int8Type struct{}
+
+func (t *Int8Type) ID() Type     { return INT8 }
+func (t *Int8Type) Name() string { return "int8" }
+
+type Int16Type struct{}
+
+func (t *Int16Type) ID() Type     { return INT16 }
+func (t *Int16Type) Name() string { return "int16" }
+
+type Int32Type struct{}
+
+func (t *Int32Type) ID() Type     { return INT32 }
+func (t *Int32Type) Name() string { return "int32" }
+
+type Int64Type struct{}
+
+func (t *Int64Type) ID() Type     { return INT64 }
+func (t *Int64Type) Name() string { return "int64" }
+
+type Uint8Type struct{}
+
+func (t *Uint8Type) ID() Type     { return UINT8 }
+func (t *Uint8Type) Name() string { return "uint8" }
+
+type Uint16Type struct{}
+
+func (t *Uint16Type) ID() Type     { return UINT16 }
+func (t *Uint16Type) Name() string { return "uint16" }
+
+type Uint32Type struct{}
+
+func (t *Uint32Type) ID() Type     { return UINT32 }
+func (t *Uint32Type) Name() string { return "uint32" }
+
+type Uint64Type struct{}
+
+func (t *Uint64Type) ID() Type     { return UINT64 }
+func (t *Uint64Type) Name() string { return "uint64" }
+
+type Float32Type struct{}
+
+func (t *Float32Type) ID() Type     { return FLOAT32 }
+func (t *Float32Type) Name() string { return "float32" }
+
+type Float64Type struct{}
+
+func (t *Float64Type) ID() Type     { return FLOAT64 }
+func (t *Float64Type) Name() string { return "float64" }
+
+var (
+	PrimitiveTypes = struct {
+		Int8    DataType
+		Int16   DataType
+		Int32   DataType
+		Int64   DataType
+		Uint8   DataType
+		Uint16  DataType
+		Uint32  DataType
+		Uint64  DataType
+		Float32 DataType
+		Float64 DataType
+	}{
+
+		Int8:    &Int8Type{},
+		Int16:   &Int16Type{},
+		Int32:   &Int32Type{},
+		Int64:   &Int64Type{},
+		Uint8:   &Uint8Type{},
+		Uint16:  &Uint16Type{},
+		Uint32:  &Uint32Type{},
+		Uint64:  &Uint64Type{},
+		Float32: &Float32Type{},
+		Float64: &Float64Type{},
+	}
+)
diff --git a/go/arrow/datatype_numeric.gen.go.tmpl b/go/arrow/datatype_numeric.gen.go.tmpl
new file mode 100644
index 000000000..582c89525
--- /dev/null
+++ b/go/arrow/datatype_numeric.gen.go.tmpl
@@ -0,0 +1,38 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package arrow
+
+{{range .In}}
+type {{.Name}}Type struct {}
+
+func (t *{{.Name}}Type) ID() Type { return {{.Name|upper}} }
+func (t *{{.Name}}Type) Name() string { return "{{.Name|lower}}" }
+
+
+{{end}}
+
+var (
+        PrimitiveTypes = struct {
+{{range .In}}
+                {{.Name}} DataType
+{{- end}}
+        }{
+{{range .In}}
+                {{.Name}}: &{{.Name}}Type{},
+{{- end}}
+        }
+)
\ No newline at end of file
diff --git a/go/arrow/datatype_numeric.gen.go.tmpldata b/go/arrow/datatype_numeric.gen.go.tmpldata
new file mode 100644
index 000000000..1f40fd502
--- /dev/null
+++ b/go/arrow/datatype_numeric.gen.go.tmpldata
@@ -0,0 +1,32 @@
+[
+  {
+    "Name": "Int8"
+  },
+  {
+    "Name": "Int16"
+  },
+  {
+    "Name": "Int32"
+  },
+  {
+    "Name": "Int64"
+  },
+  {
+    "Name": "Uint8"
+  },
+  {
+    "Name": "Uint16"
+  },
+  {
+    "Name": "Uint32"
+  },
+  {
+    "Name": "Uint64"
+  },
+  {
+    "Name": "Float32"
+  },
+  {
+    "Name": "Float64"
+  }
+]
\ No newline at end of file
diff --git a/go/arrow/doc.go b/go/arrow/doc.go
new file mode 100644
index 000000000..6ee0c2a43
--- /dev/null
+++ b/go/arrow/doc.go
@@ -0,0 +1,38 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*
+Package arrow provides an implementation of Apache Arrow.
+
+Apache Arrow is a cross-language development platform for in-memory data. It specifies a standardized
+language-independent columnar memory format for flat and hierarchical data, organized for efficient analytic
+operations on modern hardware. It also provides computational libraries and zero-copy streaming
+messaging and inter-process communication.
+
+Basics
+
+The fundamental data structure in Arrow is an Array, which holds a sequence of values of the same type. An array
+consists of memory holding the data and an additional validity bitmap that indicates if the corresponding entry in the
+array is valid (not null). If the array has no null entries, it is possible to omit this bitmap.
+
+*/
+package arrow
+
+//go:generate go run _tools/tmpl/main.go -i -data=numeric.tmpldata type_traits_numeric.gen.go.tmpl array/numeric.gen.go.tmpl array/numericbuilder.gen.go.tmpl array/bufferbuilder_numeric.gen.go.tmpl
+//go:generate go run _tools/tmpl/main.go -i -data=datatype_numeric.gen.go.tmpldata datatype_numeric.gen.go.tmpl
+
+// stringer
+//go:generate stringer -type=Type
diff --git a/go/arrow/example_test.go b/go/arrow/example_test.go
new file mode 100644
index 000000000..96fd3e55f
--- /dev/null
+++ b/go/arrow/example_test.go
@@ -0,0 +1,116 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package arrow_test
+
+import (
+	"fmt"
+
+	"github.com/apache/arrow/go/arrow/array"
+	"github.com/apache/arrow/go/arrow/memory"
+)
+
+// This example demonstrates how to build an array of int64 values using a builder and Append.
+// Whilst convenient for small arrays,
+func Example_minimal() {
+	// Create an allocator.
+	pool := memory.NewGoAllocator()
+
+	// Create an int64 array builder.
+	builder := array.NewInt64Builder(pool)
+
+	builder.Append(1)
+	builder.Append(2)
+	builder.Append(3)
+	builder.AppendNull()
+	builder.Append(5)
+	builder.Append(6)
+	builder.Append(7)
+	builder.Append(8)
+
+	// Finish building the int64 array and reset the builder.
+	ints := builder.NewInt64Array()
+
+	// Enumerate the values.
+	for i, v := range ints.Int64Values() {
+		fmt.Printf("ints[%d] = ", i)
+		if ints.IsNull(i) {
+			fmt.Println("(null)")
+		} else {
+			fmt.Println(v)
+		}
+	}
+
+	// Output:
+	// ints[0] = 1
+	// ints[1] = 2
+	// ints[2] = 3
+	// ints[3] = (null)
+	// ints[4] = 5
+	// ints[5] = 6
+	// ints[6] = 7
+	// ints[7] = 8
+}
+
+// This example demonstrates creating an array, sourcing the values and
+// null bitmaps directly from byte slices. The null count is set to
+// UnknownNullCount, instructing the array to calculate the
+// null count from the bitmap when NullN is called.
+func Example_fromMemory() {
+	// create LSB packed bits with the following pattern:
+	// 01010011 11000101
+	data := memory.NewBufferBytes([]byte{0xca, 0xa3})
+
+	// create LSB packed validity (null) bitmap, where every 4th element is null:
+	// 11101110 11101110
+	nullBitmap := memory.NewBufferBytes([]byte{0x77, 0x77})
+
+	// Create a boolean array and lazily determine NullN using UnknownNullCount
+	bools := array.NewBoolean(16, data, nullBitmap, array.UnknownNullCount)
+
+	// Show the null count
+	fmt.Printf("NullN()  = %d\n", bools.NullN())
+
+	// Enumerate the values.
+	n := bools.Len()
+	for i := 0; i < n; i++ {
+		fmt.Printf("bools[%d] = ", i)
+		if bools.IsNull(i) {
+			fmt.Println("(null)")
+		} else {
+			fmt.Printf("%t\n", bools.Value(i))
+		}
+	}
+
+	// Output:
+	// NullN()  = 4
+	// bools[0] = false
+	// bools[1] = true
+	// bools[2] = false
+	// bools[3] = (null)
+	// bools[4] = false
+	// bools[5] = false
+	// bools[6] = true
+	// bools[7] = (null)
+	// bools[8] = true
+	// bools[9] = true
+	// bools[10] = false
+	// bools[11] = (null)
+	// bools[12] = false
+	// bools[13] = true
+	// bools[14] = false
+	// bools[15] = (null)
+}
diff --git a/go/arrow/internal/bitutil/bitutil.go b/go/arrow/internal/bitutil/bitutil.go
new file mode 100644
index 000000000..00f169336
--- /dev/null
+++ b/go/arrow/internal/bitutil/bitutil.go
@@ -0,0 +1,95 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package bitutil
+
+import (
+	"math/bits"
+	"reflect"
+	"unsafe"
+)
+
+var (
+	BitMask        = [8]byte{1, 2, 4, 8, 16, 32, 64, 128}
+	FlippedBitMask = [8]byte{254, 253, 251, 247, 239, 223, 191, 127}
+)
+
+// NextPowerOf2 rounds x to the next power of two.
+func NextPowerOf2(x int) int { return 1 << uint(bits.Len(uint(x))) }
+
+// CeilByte rounds size to the next multiple of 8.
+func CeilByte(size int) int { return (size + 7) &^ 7 }
+
+// BitIsSet returns true if the bit at index i in buf is set (1).
+func BitIsSet(buf []byte, i int) bool { return (buf[uint(i)/8] & BitMask[byte(i)%8]) != 0 }
+
+// BitIsNotSet returns true if the bit at index i in buf is not set (0).
+func BitIsNotSet(buf []byte, i int) bool { return (buf[uint(i)/8] & BitMask[byte(i)%8]) == 0 }
+
+// SetBit sets the bit at index i in buf to 1.
+func SetBit(buf []byte, i int) { buf[uint(i)/8] |= BitMask[byte(i)%8] }
+
+// ClearBit sets the bit at index i in buf to 0.
+func ClearBit(buf []byte, i int) { buf[uint(i)/8] &= FlippedBitMask[byte(i)%8] }
+
+// SetBitTo sets the bit at index i in buf to val.
+func SetBitTo(buf []byte, i int, val bool) {
+	if val {
+		SetBit(buf, i)
+	} else {
+		ClearBit(buf, i)
+	}
+}
+
+// CountSetBits counts the number of 1's in buf up to n bits.
+func CountSetBits(buf []byte, n int) int {
+	count := 0
+
+	uint64Bytes := n / uint64SizeBits * 8
+	for _, v := range bytesToUint64(buf[:uint64Bytes]) {
+		count += bits.OnesCount64(v)
+	}
+
+	for _, v := range buf[uint64Bytes : n/8] {
+		count += bits.OnesCount8(v)
+	}
+
+	// tail bits
+	for i := n &^ 0x7; i < n; i++ {
+		if BitIsSet(buf, i) {
+			count++
+		}
+	}
+
+	return count
+}
+
+const (
+	uint64SizeBytes = int(unsafe.Sizeof(uint64(0)))
+	uint64SizeBits  = uint64SizeBytes * 8
+)
+
+func bytesToUint64(b []byte) []uint64 {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []uint64
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len / uint64SizeBytes
+	s.Cap = h.Cap / uint64SizeBytes
+
+	return res
+}
diff --git a/go/arrow/internal/bitutil/bitutil_test.go b/go/arrow/internal/bitutil/bitutil_test.go
new file mode 100644
index 000000000..b1890ec4f
--- /dev/null
+++ b/go/arrow/internal/bitutil/bitutil_test.go
@@ -0,0 +1,190 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package bitutil_test
+
+import (
+	"testing"
+
+	"github.com/apache/arrow/go/arrow/internal/bitutil"
+	"github.com/apache/arrow/go/arrow/internal/testing/tools"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestCeilByte(t *testing.T) {
+	tests := []struct {
+		name    string
+		in, exp int
+	}{
+		{"zero", 0, 0},
+		{"five", 5, 8},
+		{"sixteen", 16, 16},
+	}
+	for _, test := range tests {
+		t.Run(test.name, func(t *testing.T) {
+			got := bitutil.CeilByte(test.in)
+			assert.Equal(t, test.exp, got)
+		})
+	}
+}
+
+func TestBitIsSet(t *testing.T) {
+	buf := make([]byte, 2)
+	buf[0] = 0xa1
+	buf[1] = 0xc2
+	exp := []bool{true, false, false, false, false, true, false, true, false, true, false, false, false, false, true, true}
+	var got []bool
+	for i := 0; i < 0x10; i++ {
+		got = append(got, bitutil.BitIsSet(buf, i))
+	}
+	assert.Equal(t, exp, got)
+}
+
+func TestBitIsNotSet(t *testing.T) {
+	buf := make([]byte, 2)
+	buf[0] = 0xa1
+	buf[1] = 0xc2
+	exp := []bool{false, true, true, true, true, false, true, false, true, false, true, true, true, true, false, false}
+	var got []bool
+	for i := 0; i < 0x10; i++ {
+		got = append(got, bitutil.BitIsNotSet(buf, i))
+	}
+	assert.Equal(t, exp, got)
+}
+
+func TestClearBit(t *testing.T) {
+	buf := make([]byte, 2)
+	buf[0] = 0xff
+	buf[1] = 0xff
+	for i, v := range []bool{false, true, true, true, true, false, true, false, true, false, true, true, true, true, false, false} {
+		if v {
+			bitutil.ClearBit(buf, i)
+		}
+	}
+	assert.Equal(t, []byte{0xa1, 0xc2}, buf)
+}
+
+func TestSetBit(t *testing.T) {
+	buf := make([]byte, 2)
+	for i, v := range []bool{true, false, false, false, false, true, false, true, false, true, false, false, false, false, true, true} {
+		if v {
+			bitutil.SetBit(buf, i)
+		}
+	}
+	assert.Equal(t, []byte{0xa1, 0xc2}, buf)
+}
+
+func TestSetBitTo(t *testing.T) {
+	buf := make([]byte, 2)
+	for i, v := range []bool{true, false, false, false, false, true, false, true, false, true, false, false, false, false, true, true} {
+		bitutil.SetBitTo(buf, i, v)
+	}
+	assert.Equal(t, []byte{0xa1, 0xc2}, buf)
+}
+
+func TestCountSetBits(t *testing.T) {
+	tests := []struct {
+		name string
+		buf  []byte
+		n    int
+		exp  int
+	}{
+		{"some 03 bits", bbits(0x11000000), 3, 2},
+		{"some 11 bits", bbits(0x11000011, 0x01000000), 11, 5},
+		{"some 72 bits", bbits(0x11001010, 0x11110000, 0x00001111, 0x11000011, 0x11001010, 0x11110000, 0x00001111, 0x11000011, 0x10001001), 9 * 8, 35},
+		{"all  03 bits", bbits(0x11100001), 3, 3},
+		{"all  11 bits", bbits(0x11111111, 0x11111111), 11, 11},
+		{"all  72 bits", bbits(0x11111111, 0x11111111, 0x11111111, 0x11111111, 0x11111111, 0x11111111, 0x11111111, 0x11111111, 0x11111111), 9 * 8, 72},
+		{"none 03 bits", bbits(0x00000001), 3, 0},
+		{"none 11 bits", bbits(0x00000000, 0x00000000), 11, 0},
+		{"none 72 bits", bbits(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), 9 * 8, 0},
+	}
+	for _, test := range tests {
+		t.Run(test.name, func(t *testing.T) {
+			got := bitutil.CountSetBits(test.buf, test.n)
+			assert.Equal(t, test.exp, got)
+		})
+	}
+}
+
+func bbits(v ...int32) []byte {
+	return tools.IntsToBitsLSB(v...)
+}
+
+func BenchmarkBitIsSet(b *testing.B) {
+	buf := make([]byte, 32)
+	b.ResetTimer()
+	for i := 0; i < b.N; i++ {
+		bitutil.BitIsSet(buf, (i%32)&0x1a)
+	}
+}
+
+func BenchmarkSetBit(b *testing.B) {
+	buf := make([]byte, 32)
+	b.ResetTimer()
+	for i := 0; i < b.N; i++ {
+		bitutil.SetBit(buf, (i%32)&0x1a)
+	}
+}
+
+func BenchmarkSetBitTo(b *testing.B) {
+	vals := []bool{true, false, false, false, false, true, false, true, false, true, false, false, false, false, true, true}
+	buf := make([]byte, 32)
+	b.ResetTimer()
+	for i := 0; i < b.N; i++ {
+		bitutil.SetBitTo(buf, i%32, vals[i%len(vals)])
+	}
+}
+
+var (
+	intval int
+)
+
+func benchmarkCountSetBitsN(b *testing.B, n int) {
+	nn := n/8 + 1
+	buf := make([]byte, nn)
+	//src := [4]byte{0x1f, 0xaa, 0xba, 0x11}
+	src := [4]byte{0x01, 0x01, 0x01, 0x01}
+	for i := 0; i < nn; i++ {
+		buf[i] = src[i&0x3]
+	}
+	b.ResetTimer()
+	var res int
+	for i := 0; i < b.N; i++ {
+		res = bitutil.CountSetBits(buf, n)
+	}
+	intval = res
+}
+
+func BenchmarkCountSetBits_3(b *testing.B) {
+	benchmarkCountSetBitsN(b, 3)
+}
+
+func BenchmarkCountSetBits_32(b *testing.B) {
+	benchmarkCountSetBitsN(b, 32)
+}
+
+func BenchmarkCountSetBits_128(b *testing.B) {
+	benchmarkCountSetBitsN(b, 128)
+}
+
+func BenchmarkCountSetBits_1000(b *testing.B) {
+	benchmarkCountSetBitsN(b, 1000)
+}
+
+func BenchmarkCountSetBits_1024(b *testing.B) {
+	benchmarkCountSetBitsN(b, 1024)
+}
diff --git a/go/arrow/internal/cpu/README.md b/go/arrow/internal/cpu/README.md
new file mode 100644
index 000000000..2619b38c1
--- /dev/null
+++ b/go/arrow/internal/cpu/README.md
@@ -0,0 +1,42 @@
+<!---
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements.  See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership.  The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License.  You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing,
+  software distributed under the License is distributed on an
+  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  KIND, either express or implied.  See the License for the
+  specific language governing permissions and limitations
+  under the License.
+-->
+
+# Package cpu
+
+Copied from Go src/internal/cpu
+
+## Extras
+
+### Intel
+
+The `INTEL_DISABLE_EXT` environment variable can control which CPU extensions are available for
+the running process. It should be a comma-separate list of upper-case strings as follows
+
+|   Flag   | Description |
+| -------- | ----------- |
+| `ALL`    | Disable all CPU extensions and fall back to Go implementation |
+| `AVX2`   | Disable AVX2 optimizations |  
+| `AVX`    | Disable AVX optimizations |  
+| `SSE`    | Disable all SSE optimizations |  
+| `SSE4`   | Disable SSE42, SSE41 optimizations |  
+| `SSSE3`  | Disable supplemental SSE3 optimizations |  
+| `SSE3`   | Disable SSE3 optimizations |  
+| `SSE2`   | Disable SSE2 optimizations |
+
+Any unrecognized flags will be ignored and therefore it is possible to leave the environment variable with a bogus value such as `NONE` when experimenting.
\ No newline at end of file
diff --git a/go/arrow/internal/cpu/cpu.go b/go/arrow/internal/cpu/cpu.go
new file mode 100644
index 000000000..22fc56100
--- /dev/null
+++ b/go/arrow/internal/cpu/cpu.go
@@ -0,0 +1,77 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package cpu implements processor feature detection
+// used by the Go standard library.
+package cpu
+
+var X86 x86
+
+// The booleans in x86 contain the correspondingly named cpuid feature bit.
+// HasAVX and HasAVX2 are only set if the OS does support XMM and YMM registers
+// in addition to the cpuid feature bit being set.
+// The struct is padded to avoid false sharing.
+type x86 struct {
+	_            [CacheLineSize]byte
+	HasAES       bool
+	HasADX       bool
+	HasAVX       bool
+	HasAVX2      bool
+	HasBMI1      bool
+	HasBMI2      bool
+	HasERMS      bool
+	HasFMA       bool
+	HasOSXSAVE   bool
+	HasPCLMULQDQ bool
+	HasPOPCNT    bool
+	HasSSE2      bool
+	HasSSE3      bool
+	HasSSSE3     bool
+	HasSSE41     bool
+	HasSSE42     bool
+	_            [CacheLineSize]byte
+}
+
+var PPC64 ppc64
+
+// For ppc64x, it is safe to check only for ISA level starting on ISA v3.00,
+// since there are no optional categories. There are some exceptions that also
+// require kernel support to work (darn, scv), so there are capability bits for
+// those as well. The minimum processor requirement is POWER8 (ISA 2.07), so we
+// maintain some of the old capability checks for optional categories for
+// safety.
+// The struct is padded to avoid false sharing.
+type ppc64 struct {
+	_          [CacheLineSize]byte
+	HasVMX     bool // Vector unit (Altivec)
+	HasDFP     bool // Decimal Floating Point unit
+	HasVSX     bool // Vector-scalar unit
+	HasHTM     bool // Hardware Transactional Memory
+	HasISEL    bool // Integer select
+	HasVCRYPTO bool // Vector cryptography
+	HasHTMNOSC bool // HTM: kernel-aborted transaction in syscalls
+	HasDARN    bool // Hardware random number generator (requires kernel enablement)
+	HasSCV     bool // Syscall vectored (requires kernel enablement)
+	IsPOWER8   bool // ISA v2.07 (POWER8)
+	IsPOWER9   bool // ISA v3.00 (POWER9)
+	_          [CacheLineSize]byte
+}
+
+var ARM64 arm64
+
+// The booleans in arm64 contain the correspondingly named cpu feature bit.
+// The struct is padded to avoid false sharing.
+type arm64 struct {
+	_          [CacheLineSize]byte
+	HasFP      bool
+	HasASIMD   bool
+	HasEVTSTRM bool
+	HasAES     bool
+	HasPMULL   bool
+	HasSHA1    bool
+	HasSHA2    bool
+	HasCRC32   bool
+	HasATOMICS bool
+	_          [CacheLineSize]byte
+}
diff --git a/go/arrow/internal/cpu/cpu_test.go b/go/arrow/internal/cpu/cpu_test.go
new file mode 100644
index 000000000..02f09d3d5
--- /dev/null
+++ b/go/arrow/internal/cpu/cpu_test.go
@@ -0,0 +1,51 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package cpu_test
+
+import (
+	"runtime"
+	"testing"
+
+	"github.com/apache/arrow/go/arrow/internal/cpu"
+)
+
+func TestAMD64minimalFeatures(t *testing.T) {
+	if runtime.GOARCH == "amd64" {
+		if !cpu.X86.HasSSE2 {
+			t.Fatalf("HasSSE2 expected true, got false")
+		}
+	}
+}
+
+func TestAVX2hasAVX(t *testing.T) {
+	if runtime.GOARCH == "amd64" {
+		if cpu.X86.HasAVX2 && !cpu.X86.HasAVX {
+			t.Fatalf("HasAVX expected true, got false")
+		}
+	}
+}
+
+func TestPPC64minimalFeatures(t *testing.T) {
+	if runtime.GOARCH == "ppc64" || runtime.GOARCH == "ppc64le" {
+		if !cpu.PPC64.IsPOWER8 {
+			t.Fatalf("IsPOWER8 expected true, got false")
+		}
+		if !cpu.PPC64.HasVMX {
+			t.Fatalf("HasVMX expected true, got false")
+		}
+		if !cpu.PPC64.HasDFP {
+			t.Fatalf("HasDFP expected true, got false")
+		}
+		if !cpu.PPC64.HasVSX {
+			t.Fatalf("HasVSX expected true, got false")
+		}
+		if !cpu.PPC64.HasISEL {
+			t.Fatalf("HasISEL expected true, got false")
+		}
+		if !cpu.PPC64.HasVCRYPTO {
+			t.Fatalf("HasVCRYPTO expected true, got false")
+		}
+	}
+}
diff --git a/go/arrow/internal/cpu/cpu_x86.go b/go/arrow/internal/cpu/cpu_x86.go
new file mode 100644
index 000000000..777269f1a
--- /dev/null
+++ b/go/arrow/internal/cpu/cpu_x86.go
@@ -0,0 +1,107 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build 386 amd64 amd64p32
+
+package cpu
+
+import (
+	"os"
+	"strings"
+)
+
+const CacheLineSize = 64
+
+// cpuid is implemented in cpu_x86.s.
+func cpuid(eaxArg, ecxArg uint32) (eax, ebx, ecx, edx uint32)
+
+// xgetbv with ecx = 0 is implemented in cpu_x86.s.
+func xgetbv() (eax, edx uint32)
+
+func init() {
+	maxID, _, _, _ := cpuid(0, 0)
+
+	if maxID < 1 {
+		return
+	}
+
+	_, _, ecx1, edx1 := cpuid(1, 0)
+	X86.HasSSE2 = isSet(26, edx1)
+
+	X86.HasSSE3 = isSet(0, ecx1)
+	X86.HasPCLMULQDQ = isSet(1, ecx1)
+	X86.HasSSSE3 = isSet(9, ecx1)
+	X86.HasFMA = isSet(12, ecx1)
+	X86.HasSSE41 = isSet(19, ecx1)
+	X86.HasSSE42 = isSet(20, ecx1)
+	X86.HasPOPCNT = isSet(23, ecx1)
+	X86.HasAES = isSet(25, ecx1)
+	X86.HasOSXSAVE = isSet(27, ecx1)
+
+	osSupportsAVX := false
+	// For XGETBV, OSXSAVE bit is required and sufficient.
+	if X86.HasOSXSAVE {
+		eax, _ := xgetbv()
+		// Check if XMM and YMM registers have OS support.
+		osSupportsAVX = isSet(1, eax) && isSet(2, eax)
+	}
+
+	X86.HasAVX = isSet(28, ecx1) && osSupportsAVX
+
+	if maxID < 7 {
+		return
+	}
+
+	_, ebx7, _, _ := cpuid(7, 0)
+	X86.HasBMI1 = isSet(3, ebx7)
+	X86.HasAVX2 = isSet(5, ebx7) && osSupportsAVX
+	X86.HasBMI2 = isSet(8, ebx7)
+	X86.HasERMS = isSet(9, ebx7)
+	X86.HasADX = isSet(19, ebx7)
+
+	// NOTE(sgc): added ability to disable extension via environment
+	checkEnvironment()
+}
+func checkEnvironment() {
+	if ext, ok := os.LookupEnv("INTEL_DISABLE_EXT"); ok {
+		exts := strings.Split(ext, ",")
+
+		for _, x := range exts {
+			switch x {
+			case "ALL":
+				X86.HasAVX2 = false
+				X86.HasAVX = false
+				X86.HasSSE42 = false
+				X86.HasSSE41 = false
+				X86.HasSSSE3 = false
+				X86.HasSSE3 = false
+				X86.HasSSE2 = false
+
+			case "AVX2":
+				X86.HasAVX2 = false
+			case "AVX":
+				X86.HasAVX = false
+			case "SSE":
+				X86.HasSSE42 = false
+				X86.HasSSE41 = false
+				X86.HasSSSE3 = false
+				X86.HasSSE3 = false
+				X86.HasSSE2 = false
+			case "SSE4":
+				X86.HasSSE42 = false
+				X86.HasSSE41 = false
+			case "SSSE3":
+				X86.HasSSSE3 = false
+			case "SSE3":
+				X86.HasSSE3 = false
+			case "SSE2":
+				X86.HasSSE2 = false
+			}
+		}
+	}
+}
+
+func isSet(bitpos uint, value uint32) bool {
+	return value&(1<<bitpos) != 0
+}
diff --git a/go/arrow/internal/cpu/cpu_x86.s b/go/arrow/internal/cpu/cpu_x86.s
new file mode 100644
index 000000000..228fbcf6d
--- /dev/null
+++ b/go/arrow/internal/cpu/cpu_x86.s
@@ -0,0 +1,32 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build 386 amd64 amd64p32
+
+#include "textflag.h"
+
+// func cpuid(eaxArg, ecxArg uint32) (eax, ebx, ecx, edx uint32)
+TEXT ·cpuid(SB), NOSPLIT, $0-24
+	MOVL eaxArg+0(FP), AX
+	MOVL ecxArg+4(FP), CX
+	CPUID
+	MOVL AX, eax+8(FP)
+	MOVL BX, ebx+12(FP)
+	MOVL CX, ecx+16(FP)
+	MOVL DX, edx+20(FP)
+	RET
+
+// func xgetbv() (eax, edx uint32)
+TEXT ·xgetbv(SB),NOSPLIT,$0-8
+#ifdef GOOS_nacl
+	// nacl does not support XGETBV.
+	MOVL $0, eax+0(FP)
+	MOVL $0, edx+4(FP)
+#else
+	MOVL $0, CX
+	XGETBV
+	MOVL AX, eax+0(FP)
+	MOVL DX, edx+4(FP)
+#endif
+	RET
diff --git a/go/arrow/internal/debug/assert_off.go b/go/arrow/internal/debug/assert_off.go
new file mode 100644
index 000000000..52b9a2331
--- /dev/null
+++ b/go/arrow/internal/debug/assert_off.go
@@ -0,0 +1,24 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !assert
+
+package debug
+
+// Assert will panic with msg if cond is false.
+//
+// msg must be a string, func() string or fmt.Stringer.
+func Assert(cond bool, msg interface{}) {}
diff --git a/go/arrow/internal/debug/assert_on.go b/go/arrow/internal/debug/assert_on.go
new file mode 100644
index 000000000..2aa5d6ace
--- /dev/null
+++ b/go/arrow/internal/debug/assert_on.go
@@ -0,0 +1,28 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build assert
+
+package debug
+
+// Assert will panic with msg if cond is false.
+//
+// msg must be a string, func() string or fmt.Stringer.
+func Assert(cond bool, msg interface{}) {
+	if !cond {
+		panic(getStringValue(msg))
+	}
+}
diff --git a/go/arrow/internal/debug/doc.go b/go/arrow/internal/debug/doc.go
new file mode 100644
index 000000000..3ee1783ca
--- /dev/null
+++ b/go/arrow/internal/debug/doc.go
@@ -0,0 +1,32 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*
+Package debug provides APIs for conditional runtime assertions and debug logging.
+
+
+Using Assert
+
+To enable runtime assertions, build with the assert tag. When the assert tag is omitted,
+the code for the assertion will be omitted from the binary.
+
+
+Using Log
+
+To enable runtime debug logs, build with the debug tag. When the debug tag is omitted,
+the code for logging will be omitted from the binary.
+*/
+package debug
diff --git a/go/arrow/internal/debug/log_off.go b/go/arrow/internal/debug/log_off.go
new file mode 100644
index 000000000..48da8e1ee
--- /dev/null
+++ b/go/arrow/internal/debug/log_off.go
@@ -0,0 +1,21 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !debug
+
+package debug
+
+func Log(interface{}) {}
diff --git a/go/arrow/internal/debug/log_on.go b/go/arrow/internal/debug/log_on.go
new file mode 100644
index 000000000..99d0c8ae3
--- /dev/null
+++ b/go/arrow/internal/debug/log_on.go
@@ -0,0 +1,32 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build debug
+
+package debug
+
+import (
+	"log"
+	"os"
+)
+
+var (
+	debug = log.New(os.Stderr, "[D] ", log.LstdFlags)
+)
+
+func Log(msg interface{}) {
+	debug.Output(1, getStringValue(msg))
+}
diff --git a/go/arrow/internal/debug/util.go b/go/arrow/internal/debug/util.go
new file mode 100644
index 000000000..7bd3d5389
--- /dev/null
+++ b/go/arrow/internal/debug/util.go
@@ -0,0 +1,37 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build debug assert
+
+package debug
+
+import "fmt"
+
+func getStringValue(v interface{}) string {
+	switch a := v.(type) {
+	case func() string:
+		return a()
+
+	case string:
+		return a
+
+	case fmt.Stringer:
+		return a.String()
+
+	default:
+		panic(fmt.Sprintf("unexpected type, %t", v))
+	}
+}
diff --git a/go/arrow/internal/testing/tools/bits.go b/go/arrow/internal/testing/tools/bits.go
new file mode 100644
index 000000000..c123573e2
--- /dev/null
+++ b/go/arrow/internal/testing/tools/bits.go
@@ -0,0 +1,40 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tools
+
+import "math/bits"
+
+// IntsToBitsLSB encodes ints as LSB 0 bit numbering per https://en.wikipedia.org/wiki/Bit_numbering#LSB_0_bit_numbering
+// The low bit of each nibble is tested, therefore integers should be written as 8-digit
+// hex numbers consisting of 1s or 0s.
+//
+//     IntsToBitsLSB(0x11001010) -> 0x35
+func IntsToBitsLSB(v ...int32) []byte {
+	res := make([]byte, 0, len(v))
+	for _, b := range v {
+		c := uint8(0)
+		for i := uint(0); i < 8; i++ {
+			if b&1 == 1 {
+				c |= 1 << i
+			}
+			b >>= 4
+		}
+		c = bits.Reverse8(c)
+		res = append(res, c)
+	}
+	return res
+}
diff --git a/go/arrow/internal/testing/tools/bits_test.go b/go/arrow/internal/testing/tools/bits_test.go
new file mode 100644
index 000000000..ba790eabc
--- /dev/null
+++ b/go/arrow/internal/testing/tools/bits_test.go
@@ -0,0 +1,42 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tools_test
+
+import (
+	"fmt"
+	"testing"
+
+	"github.com/apache/arrow/go/arrow/internal/testing/tools"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestIntsToBitsLSB(t *testing.T) {
+	tests := []struct {
+		in  int32
+		exp byte
+	}{
+		{0x11001010, 0x53},
+		{0x00001111, 0xf0},
+		{0x11110000, 0x0f},
+	}
+	for _, test := range tests {
+		t.Run(fmt.Sprintf("%08x", test.in), func(t *testing.T) {
+			got := tools.IntsToBitsLSB(test.in)
+			assert.Equal(t, []byte{test.exp}, got)
+		})
+	}
+}
diff --git a/go/arrow/internal/testing/tools/bool.go b/go/arrow/internal/testing/tools/bool.go
new file mode 100644
index 000000000..757a8f528
--- /dev/null
+++ b/go/arrow/internal/testing/tools/bool.go
@@ -0,0 +1,25 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package tools
+
+func Bools(v ...int) []bool {
+	res := make([]bool, len(v))
+	for i, b := range v {
+		res[i] = b != 0
+	}
+	return res
+}
diff --git a/go/arrow/math/Makefile b/go/arrow/math/Makefile
new file mode 100644
index 000000000..89f5d2fa5
--- /dev/null
+++ b/go/arrow/math/Makefile
@@ -0,0 +1,90 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+GO_BUILD=go build
+GO_GEN=go generate
+GO_TEST=go test
+GOPATH=$(realpath ../../../../../..)
+
+# this converts rotate instructions from "ro[lr] <reg>" -> "ro[lr] <reg>, 1" for yasm compatibility
+PERL_FIXUP_ROTATE=perl -i -pe 's/(ro[rl]\s+\w{2,3})$$/\1, 1/'
+
+C2GOASM=c2goasm -a -f
+CC=clang
+C_FLAGS=-target x86_64-unknown-none -masm=intel -mno-red-zone -mstackrealign -mllvm -inline-threshold=1000 -fno-asynchronous-unwind-tables \
+	-fno-exceptions -fno-rtti -O3 -fno-builtin -ffast-math -fno-jump-tables -I_lib
+ASM_FLAGS_AVX2=-mavx2 -mfma -mllvm -force-vector-width=32
+ASM_FLAGS_SSE4=-msse4
+
+GO_SOURCES  := $(shell find . -path ./_lib -prune -o -name '*.go' -not -name '*_test.go')
+ALL_SOURCES := $(shell find . -path ./_lib -prune -o -name '*.go' -name '*.s' -not -name '*_test.go')
+
+INTEL_SOURCES := \
+	float64_avx2_amd64.s float64_sse4_amd64.s \
+	int64_avx2_amd64.s int64_sse4_amd64.s \
+	uint64_avx2_amd64.s uint64_sse4_amd64.s
+
+.PHONEY: assembly
+
+assembly: $(INTEL_SOURCES)
+
+generate: ../bin/tmpl
+	../bin/tmpl -i -data=float64.tmpldata type.go.tmpl=float64.go type_amd64.go.tmpl=float64_amd64.go type_noasm.go.tmpl=float64_noasm.go type_test.go.tmpl=float64_test.go
+	../bin/tmpl -i -data=float64.tmpldata -d arch=avx2 type_simd_amd64.go.tmpl=float64_avx2_amd64.go
+	../bin/tmpl -i -data=float64.tmpldata -d arch=sse4 type_simd_amd64.go.tmpl=float64_sse4_amd64.go
+	../bin/tmpl -i -data=int64.tmpldata type.go.tmpl=int64.go type_amd64.go.tmpl=int64_amd64.go type_noasm.go.tmpl=int64_noasm.go type_test.go.tmpl=int64_test.go
+	../bin/tmpl -i -data=int64.tmpldata -d arch=avx2 type_simd_amd64.go.tmpl=int64_avx2_amd64.go
+	../bin/tmpl -i -data=int64.tmpldata -d arch=sse4 type_simd_amd64.go.tmpl=int64_sse4_amd64.go
+	../bin/tmpl -i -data=uint64.tmpldata type.go.tmpl=uint64.go type_amd64.go.tmpl=uint64_amd64.go type_noasm.go.tmpl=uint64_noasm.go type_test.go.tmpl=uint64_test.go
+	../bin/tmpl -i -data=uint64.tmpldata -d arch=avx2 type_simd_amd64.go.tmpl=uint64_avx2_amd64.go
+	../bin/tmpl -i -data=uint64.tmpldata -d arch=sse4 type_simd_amd64.go.tmpl=uint64_sse4_amd64.go
+
+_lib/float64_avx2.s: _lib/float64.c
+	$(CC) -S $(C_FLAGS) $(ASM_FLAGS_AVX2) $^ -o $@ ; $(PERL_FIXUP_ROTATE) $@
+
+_lib/float64_sse4.s: _lib/float64.c
+	$(CC) -S $(C_FLAGS) $(ASM_FLAGS_SSE4) $^ -o $@ ; $(PERL_FIXUP_ROTATE) $@
+
+float64_avx2_amd64.s: _lib/float64_avx2.s
+	$(C2GOASM) -a -f $^ $@
+
+float64_sse4_amd64.s: _lib/float64_sse4.s
+	$(C2GOASM) -a -f $^ $@
+
+_lib/int64_avx2.s: _lib/int64.c
+	$(CC) -S $(C_FLAGS) $(ASM_FLAGS_AVX2) $^ -o $@ ; $(PERL_FIXUP_ROTATE) $@
+
+_lib/int64_sse4.s: _lib/int64.c
+	$(CC) -S $(C_FLAGS) $(ASM_FLAGS_SSE4) $^ -o $@ ; $(PERL_FIXUP_ROTATE) $@
+
+int64_avx2_amd64.s: _lib/int64_avx2.s
+	$(C2GOASM) -a -f $^ $@
+
+int64_sse4_amd64.s: _lib/int64_sse4.s
+	$(C2GOASM) -a -f $^ $@
+
+_lib/uint64_avx2.s: _lib/uint64.c
+	$(CC) -S $(C_FLAGS) $(ASM_FLAGS_AVX2) $^ -o $@ ; $(PERL_FIXUP_ROTATE) $@
+
+_lib/uint64_sse4.s: _lib/uint64.c
+	$(CC) -S $(C_FLAGS) $(ASM_FLAGS_SSE4) $^ -o $@ ; $(PERL_FIXUP_ROTATE) $@
+
+uint64_avx2_amd64.s: _lib/uint64_avx2.s
+	$(C2GOASM) -a -f $^ $@
+
+uint64_sse4_amd64.s: _lib/uint64_sse4.s
+	$(C2GOASM) -a -f $^ $@
+
diff --git a/go/arrow/math/_lib/.gitignore b/go/arrow/math/_lib/.gitignore
new file mode 100644
index 000000000..72757d396
--- /dev/null
+++ b/go/arrow/math/_lib/.gitignore
@@ -0,0 +1,18 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+.idea
+cmake-build-*
\ No newline at end of file
diff --git a/go/arrow/math/_lib/CMakeLists.txt b/go/arrow/math/_lib/CMakeLists.txt
new file mode 100644
index 000000000..ec1558b25
--- /dev/null
+++ b/go/arrow/math/_lib/CMakeLists.txt
@@ -0,0 +1,24 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+cmake_minimum_required(VERSION 3.6)
+
+project(math-func)
+set(CMAKE_C_STANDARD 99)
+
+add_library(memory STATIC float64.c int64.c uint64.c)
+
+
diff --git a/go/arrow/math/_lib/arch.h b/go/arrow/math/_lib/arch.h
new file mode 100644
index 000000000..d9c7d98bf
--- /dev/null
+++ b/go/arrow/math/_lib/arch.h
@@ -0,0 +1,27 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#undef FULL_NAME
+
+#if  defined(__AVX2__)
+    #define FULL_NAME(x) x##_avx2
+#elif __SSE4_2__ == 1
+    #define FULL_NAME(x) x##_sse4
+#elif __SSE3__ == 1
+    #define FULL_NAME(x) x##_sse3
+#else
+    #define FULL_NAME(x) x##_x86
+#endif
\ No newline at end of file
diff --git a/go/arrow/math/_lib/float64.c b/go/arrow/math/_lib/float64.c
new file mode 100644
index 000000000..24f8c6105
--- /dev/null
+++ b/go/arrow/math/_lib/float64.c
@@ -0,0 +1,26 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <arch.h>
+#include <memory.h>
+
+void FULL_NAME(sum_float64)(double buf[], size_t len, double *res) {
+    double acc = 0.0;
+    for(int i = 0; i < len; i++) {
+        acc += buf[i];
+    }
+    *res = acc;
+}
\ No newline at end of file
diff --git a/go/arrow/math/_lib/float64_avx2.s b/go/arrow/math/_lib/float64_avx2.s
new file mode 100644
index 000000000..8d90a9493
--- /dev/null
+++ b/go/arrow/math/_lib/float64_avx2.s
@@ -0,0 +1,176 @@
+	.text
+	.intel_syntax noprefix
+	.file	"_lib/float64.c"
+	.globl	sum_float64_avx2
+	.p2align	4, 0x90
+	.type	sum_float64_avx2,@function
+sum_float64_avx2:                       # @sum_float64_avx2
+# BB#0:
+	push	rbp
+	mov	rbp, rsp
+	and	rsp, -8
+	vxorpd	xmm0, xmm0, xmm0
+	test	rsi, rsi
+	je	.LBB0_14
+# BB#1:
+	cmp	rsi, 31
+	jbe	.LBB0_2
+# BB#5:
+	mov	r9, rsi
+	and	r9, -32
+	je	.LBB0_2
+# BB#6:
+	lea	r8, [r9 - 32]
+	mov	eax, r8d
+	shr	eax, 5
+	inc	eax
+	and	rax, 7
+	je	.LBB0_7
+# BB#8:
+	neg	rax
+	vxorpd	ymm0, ymm0, ymm0
+	xor	ecx, ecx
+	vxorpd	ymm1, ymm1, ymm1
+	vxorpd	ymm2, ymm2, ymm2
+	vxorpd	ymm3, ymm3, ymm3
+	vxorpd	ymm4, ymm4, ymm4
+	vxorpd	ymm5, ymm5, ymm5
+	vxorpd	ymm6, ymm6, ymm6
+	vxorpd	ymm7, ymm7, ymm7
+	.p2align	4, 0x90
+.LBB0_9:                                # =>This Inner Loop Header: Depth=1
+	vaddpd	ymm0, ymm0, ymmword ptr [rdi + 8*rcx]
+	vaddpd	ymm1, ymm1, ymmword ptr [rdi + 8*rcx + 32]
+	vaddpd	ymm2, ymm2, ymmword ptr [rdi + 8*rcx + 64]
+	vaddpd	ymm3, ymm3, ymmword ptr [rdi + 8*rcx + 96]
+	vaddpd	ymm4, ymm4, ymmword ptr [rdi + 8*rcx + 128]
+	vaddpd	ymm5, ymm5, ymmword ptr [rdi + 8*rcx + 160]
+	vaddpd	ymm6, ymm6, ymmword ptr [rdi + 8*rcx + 192]
+	vaddpd	ymm7, ymm7, ymmword ptr [rdi + 8*rcx + 224]
+	add	rcx, 32
+	inc	rax
+	jne	.LBB0_9
+	jmp	.LBB0_10
+.LBB0_2:
+	xor	r9d, r9d
+.LBB0_3:
+	lea	rax, [rdi + 8*r9]
+	sub	rsi, r9
+	.p2align	4, 0x90
+.LBB0_4:                                # =>This Inner Loop Header: Depth=1
+	vaddsd	xmm0, xmm0, qword ptr [rax]
+	add	rax, 8
+	dec	rsi
+	jne	.LBB0_4
+.LBB0_14:
+	vmovsd	qword ptr [rdx], xmm0
+	mov	rsp, rbp
+	pop	rbp
+	vzeroupper
+	ret
+.LBB0_7:
+	xor	ecx, ecx
+	vxorpd	ymm0, ymm0, ymm0
+	vxorpd	ymm1, ymm1, ymm1
+	vxorpd	ymm2, ymm2, ymm2
+	vxorpd	ymm3, ymm3, ymm3
+	vxorpd	ymm4, ymm4, ymm4
+	vxorpd	ymm5, ymm5, ymm5
+	vxorpd	ymm6, ymm6, ymm6
+	vxorpd	ymm7, ymm7, ymm7
+.LBB0_10:
+	cmp	r8, 224
+	jb	.LBB0_13
+# BB#11:
+	mov	rax, r9
+	sub	rax, rcx
+	lea	rcx, [rdi + 8*rcx + 1792]
+	.p2align	4, 0x90
+.LBB0_12:                               # =>This Inner Loop Header: Depth=1
+	vaddpd	ymm7, ymm7, ymmword ptr [rcx - 1568]
+	vaddpd	ymm6, ymm6, ymmword ptr [rcx - 1600]
+	vaddpd	ymm5, ymm5, ymmword ptr [rcx - 1632]
+	vaddpd	ymm4, ymm4, ymmword ptr [rcx - 1664]
+	vaddpd	ymm3, ymm3, ymmword ptr [rcx - 1696]
+	vaddpd	ymm2, ymm2, ymmword ptr [rcx - 1728]
+	vaddpd	ymm1, ymm1, ymmword ptr [rcx - 1760]
+	vaddpd	ymm0, ymm0, ymmword ptr [rcx - 1792]
+	vaddpd	ymm0, ymm0, ymmword ptr [rcx - 1536]
+	vaddpd	ymm1, ymm1, ymmword ptr [rcx - 1504]
+	vaddpd	ymm2, ymm2, ymmword ptr [rcx - 1472]
+	vaddpd	ymm3, ymm3, ymmword ptr [rcx - 1440]
+	vaddpd	ymm4, ymm4, ymmword ptr [rcx - 1408]
+	vaddpd	ymm5, ymm5, ymmword ptr [rcx - 1376]
+	vaddpd	ymm6, ymm6, ymmword ptr [rcx - 1344]
+	vaddpd	ymm7, ymm7, ymmword ptr [rcx - 1312]
+	vaddpd	ymm7, ymm7, ymmword ptr [rcx - 1056]
+	vaddpd	ymm6, ymm6, ymmword ptr [rcx - 1088]
+	vaddpd	ymm5, ymm5, ymmword ptr [rcx - 1120]
+	vaddpd	ymm4, ymm4, ymmword ptr [rcx - 1152]
+	vaddpd	ymm3, ymm3, ymmword ptr [rcx - 1184]
+	vaddpd	ymm2, ymm2, ymmword ptr [rcx - 1216]
+	vaddpd	ymm1, ymm1, ymmword ptr [rcx - 1248]
+	vaddpd	ymm0, ymm0, ymmword ptr [rcx - 1280]
+	vaddpd	ymm0, ymm0, ymmword ptr [rcx - 1024]
+	vaddpd	ymm1, ymm1, ymmword ptr [rcx - 992]
+	vaddpd	ymm2, ymm2, ymmword ptr [rcx - 960]
+	vaddpd	ymm3, ymm3, ymmword ptr [rcx - 928]
+	vaddpd	ymm4, ymm4, ymmword ptr [rcx - 896]
+	vaddpd	ymm5, ymm5, ymmword ptr [rcx - 864]
+	vaddpd	ymm6, ymm6, ymmword ptr [rcx - 832]
+	vaddpd	ymm7, ymm7, ymmword ptr [rcx - 800]
+	vaddpd	ymm7, ymm7, ymmword ptr [rcx - 544]
+	vaddpd	ymm6, ymm6, ymmword ptr [rcx - 576]
+	vaddpd	ymm5, ymm5, ymmword ptr [rcx - 608]
+	vaddpd	ymm4, ymm4, ymmword ptr [rcx - 640]
+	vaddpd	ymm3, ymm3, ymmword ptr [rcx - 672]
+	vaddpd	ymm2, ymm2, ymmword ptr [rcx - 704]
+	vaddpd	ymm1, ymm1, ymmword ptr [rcx - 736]
+	vaddpd	ymm0, ymm0, ymmword ptr [rcx - 768]
+	vaddpd	ymm0, ymm0, ymmword ptr [rcx - 512]
+	vaddpd	ymm1, ymm1, ymmword ptr [rcx - 480]
+	vaddpd	ymm2, ymm2, ymmword ptr [rcx - 448]
+	vaddpd	ymm3, ymm3, ymmword ptr [rcx - 416]
+	vaddpd	ymm4, ymm4, ymmword ptr [rcx - 384]
+	vaddpd	ymm5, ymm5, ymmword ptr [rcx - 352]
+	vaddpd	ymm6, ymm6, ymmword ptr [rcx - 320]
+	vaddpd	ymm7, ymm7, ymmword ptr [rcx - 288]
+	vaddpd	ymm7, ymm7, ymmword ptr [rcx - 32]
+	vaddpd	ymm6, ymm6, ymmword ptr [rcx - 64]
+	vaddpd	ymm5, ymm5, ymmword ptr [rcx - 96]
+	vaddpd	ymm4, ymm4, ymmword ptr [rcx - 128]
+	vaddpd	ymm3, ymm3, ymmword ptr [rcx - 160]
+	vaddpd	ymm2, ymm2, ymmword ptr [rcx - 192]
+	vaddpd	ymm1, ymm1, ymmword ptr [rcx - 224]
+	vaddpd	ymm0, ymm0, ymmword ptr [rcx - 256]
+	vaddpd	ymm0, ymm0, ymmword ptr [rcx]
+	vaddpd	ymm1, ymm1, ymmword ptr [rcx + 32]
+	vaddpd	ymm2, ymm2, ymmword ptr [rcx + 64]
+	vaddpd	ymm3, ymm3, ymmword ptr [rcx + 96]
+	vaddpd	ymm4, ymm4, ymmword ptr [rcx + 128]
+	vaddpd	ymm5, ymm5, ymmword ptr [rcx + 160]
+	vaddpd	ymm6, ymm6, ymmword ptr [rcx + 192]
+	vaddpd	ymm7, ymm7, ymmword ptr [rcx + 224]
+	add	rcx, 2048
+	add	rax, -256
+	jne	.LBB0_12
+.LBB0_13:
+	vaddpd	ymm1, ymm1, ymm5
+	vaddpd	ymm3, ymm3, ymm7
+	vaddpd	ymm0, ymm0, ymm4
+	vaddpd	ymm2, ymm2, ymm6
+	vaddpd	ymm0, ymm0, ymm2
+	vaddpd	ymm1, ymm1, ymm3
+	vaddpd	ymm0, ymm0, ymm1
+	vextractf128	xmm1, ymm0, 1
+	vaddpd	ymm0, ymm0, ymm1
+	vhaddpd	ymm0, ymm0, ymm0
+	cmp	r9, rsi
+	jne	.LBB0_3
+	jmp	.LBB0_14
+.Lfunc_end0:
+	.size	sum_float64_avx2, .Lfunc_end0-sum_float64_avx2
+
+
+	.ident	"Apple LLVM version 9.0.0 (clang-900.0.39.2)"
+	.section	".note.GNU-stack","",@progbits
diff --git a/go/arrow/math/_lib/float64_sse4.s b/go/arrow/math/_lib/float64_sse4.s
new file mode 100644
index 000000000..7a454ee2d
--- /dev/null
+++ b/go/arrow/math/_lib/float64_sse4.s
@@ -0,0 +1,103 @@
+	.text
+	.intel_syntax noprefix
+	.file	"_lib/float64.c"
+	.globl	sum_float64_sse4
+	.p2align	4, 0x90
+	.type	sum_float64_sse4,@function
+sum_float64_sse4:                       # @sum_float64_sse4
+# BB#0:
+	push	rbp
+	mov	rbp, rsp
+	and	rsp, -8
+	xorpd	xmm0, xmm0
+	test	rsi, rsi
+	je	.LBB0_14
+# BB#1:
+	cmp	rsi, 3
+	jbe	.LBB0_2
+# BB#5:
+	mov	r9, rsi
+	and	r9, -4
+	je	.LBB0_2
+# BB#6:
+	lea	r8, [r9 - 4]
+	mov	eax, r8d
+	shr	eax, 2
+	inc	eax
+	and	rax, 3
+	je	.LBB0_7
+# BB#8:
+	neg	rax
+	xorpd	xmm0, xmm0
+	xor	ecx, ecx
+	xorpd	xmm1, xmm1
+	.p2align	4, 0x90
+.LBB0_9:                                # =>This Inner Loop Header: Depth=1
+	movupd	xmm2, xmmword ptr [rdi + 8*rcx]
+	movupd	xmm3, xmmword ptr [rdi + 8*rcx + 16]
+	addpd	xmm0, xmm2
+	addpd	xmm1, xmm3
+	add	rcx, 4
+	inc	rax
+	jne	.LBB0_9
+	jmp	.LBB0_10
+.LBB0_2:
+	xor	r9d, r9d
+.LBB0_3:
+	lea	rax, [rdi + 8*r9]
+	sub	rsi, r9
+	.p2align	4, 0x90
+.LBB0_4:                                # =>This Inner Loop Header: Depth=1
+	addsd	xmm0, qword ptr [rax]
+	add	rax, 8
+	dec	rsi
+	jne	.LBB0_4
+.LBB0_14:
+	movsd	qword ptr [rdx], xmm0
+	mov	rsp, rbp
+	pop	rbp
+	ret
+.LBB0_7:
+	xor	ecx, ecx
+	xorpd	xmm0, xmm0
+	xorpd	xmm1, xmm1
+.LBB0_10:
+	cmp	r8, 12
+	jb	.LBB0_13
+# BB#11:
+	mov	rax, r9
+	sub	rax, rcx
+	lea	rcx, [rdi + 8*rcx + 112]
+	.p2align	4, 0x90
+.LBB0_12:                               # =>This Inner Loop Header: Depth=1
+	movupd	xmm2, xmmword ptr [rcx - 112]
+	movupd	xmm3, xmmword ptr [rcx - 96]
+	movupd	xmm4, xmmword ptr [rcx - 80]
+	movupd	xmm5, xmmword ptr [rcx - 64]
+	addpd	xmm2, xmm0
+	addpd	xmm3, xmm1
+	movupd	xmm6, xmmword ptr [rcx - 48]
+	movupd	xmm7, xmmword ptr [rcx - 32]
+	addpd	xmm6, xmm4
+	addpd	xmm6, xmm2
+	addpd	xmm7, xmm5
+	addpd	xmm7, xmm3
+	movupd	xmm0, xmmword ptr [rcx - 16]
+	movupd	xmm1, xmmword ptr [rcx]
+	addpd	xmm0, xmm6
+	addpd	xmm1, xmm7
+	sub	rcx, -128
+	add	rax, -16
+	jne	.LBB0_12
+.LBB0_13:
+	addpd	xmm0, xmm1
+	haddpd	xmm0, xmm0
+	cmp	r9, rsi
+	jne	.LBB0_3
+	jmp	.LBB0_14
+.Lfunc_end0:
+	.size	sum_float64_sse4, .Lfunc_end0-sum_float64_sse4
+
+
+	.ident	"Apple LLVM version 9.0.0 (clang-900.0.39.2)"
+	.section	".note.GNU-stack","",@progbits
diff --git a/go/arrow/math/_lib/int64.c b/go/arrow/math/_lib/int64.c
new file mode 100644
index 000000000..5afe505f4
--- /dev/null
+++ b/go/arrow/math/_lib/int64.c
@@ -0,0 +1,27 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <arch.h>
+#include <memory.h>
+#include <stdint.h>
+
+void FULL_NAME(sum_int64)(int64_t buf[], size_t len, int64_t *res) {
+    int64_t acc = 0;
+    for(int i = 0; i < len; i++) {
+        acc += buf[i];
+    }
+    *res = acc;
+}
\ No newline at end of file
diff --git a/go/arrow/math/_lib/int64_avx2.s b/go/arrow/math/_lib/int64_avx2.s
new file mode 100644
index 000000000..f088c49e8
--- /dev/null
+++ b/go/arrow/math/_lib/int64_avx2.s
@@ -0,0 +1,181 @@
+	.text
+	.intel_syntax noprefix
+	.file	"_lib/int64.c"
+	.globl	sum_int64_avx2
+	.p2align	4, 0x90
+	.type	sum_int64_avx2,@function
+sum_int64_avx2:                         # @sum_int64_avx2
+# BB#0:
+	push	rbp
+	mov	rbp, rsp
+	and	rsp, -8
+	test	rsi, rsi
+	je	.LBB0_1
+# BB#2:
+	cmp	rsi, 31
+	jbe	.LBB0_3
+# BB#6:
+	mov	r9, rsi
+	and	r9, -32
+	je	.LBB0_3
+# BB#7:
+	lea	r8, [r9 - 32]
+	mov	eax, r8d
+	shr	eax, 5
+	inc	eax
+	and	rax, 7
+	je	.LBB0_8
+# BB#9:
+	neg	rax
+	vpxor	ymm0, ymm0, ymm0
+	xor	ecx, ecx
+	vpxor	ymm1, ymm1, ymm1
+	vpxor	ymm2, ymm2, ymm2
+	vpxor	ymm3, ymm3, ymm3
+	vpxor	ymm4, ymm4, ymm4
+	vpxor	ymm5, ymm5, ymm5
+	vpxor	ymm6, ymm6, ymm6
+	vpxor	ymm7, ymm7, ymm7
+	.p2align	4, 0x90
+.LBB0_10:                               # =>This Inner Loop Header: Depth=1
+	vpaddq	ymm0, ymm0, ymmword ptr [rdi + 8*rcx]
+	vpaddq	ymm1, ymm1, ymmword ptr [rdi + 8*rcx + 32]
+	vpaddq	ymm2, ymm2, ymmword ptr [rdi + 8*rcx + 64]
+	vpaddq	ymm3, ymm3, ymmword ptr [rdi + 8*rcx + 96]
+	vpaddq	ymm4, ymm4, ymmword ptr [rdi + 8*rcx + 128]
+	vpaddq	ymm5, ymm5, ymmword ptr [rdi + 8*rcx + 160]
+	vpaddq	ymm6, ymm6, ymmword ptr [rdi + 8*rcx + 192]
+	vpaddq	ymm7, ymm7, ymmword ptr [rdi + 8*rcx + 224]
+	add	rcx, 32
+	inc	rax
+	jne	.LBB0_10
+	jmp	.LBB0_11
+.LBB0_3:
+	xor	r9d, r9d
+	xor	eax, eax
+.LBB0_4:
+	lea	rcx, [rdi + 8*r9]
+	sub	rsi, r9
+	.p2align	4, 0x90
+.LBB0_5:                                # =>This Inner Loop Header: Depth=1
+	add	rax, qword ptr [rcx]
+	add	rcx, 8
+	dec	rsi
+	jne	.LBB0_5
+	jmp	.LBB0_15
+.LBB0_1:
+	xor	eax, eax
+.LBB0_15:
+	mov	qword ptr [rdx], rax
+	mov	rsp, rbp
+	pop	rbp
+	vzeroupper
+	ret
+.LBB0_8:
+	xor	ecx, ecx
+	vpxor	ymm0, ymm0, ymm0
+	vpxor	ymm1, ymm1, ymm1
+	vpxor	ymm2, ymm2, ymm2
+	vpxor	ymm3, ymm3, ymm3
+	vpxor	ymm4, ymm4, ymm4
+	vpxor	ymm5, ymm5, ymm5
+	vpxor	ymm6, ymm6, ymm6
+	vpxor	ymm7, ymm7, ymm7
+.LBB0_11:
+	cmp	r8, 224
+	jb	.LBB0_14
+# BB#12:
+	mov	rax, r9
+	sub	rax, rcx
+	lea	rcx, [rdi + 8*rcx + 1792]
+	.p2align	4, 0x90
+.LBB0_13:                               # =>This Inner Loop Header: Depth=1
+	vpaddq	ymm7, ymm7, ymmword ptr [rcx - 1568]
+	vpaddq	ymm6, ymm6, ymmword ptr [rcx - 1600]
+	vpaddq	ymm5, ymm5, ymmword ptr [rcx - 1632]
+	vpaddq	ymm4, ymm4, ymmword ptr [rcx - 1664]
+	vpaddq	ymm3, ymm3, ymmword ptr [rcx - 1696]
+	vpaddq	ymm2, ymm2, ymmword ptr [rcx - 1728]
+	vpaddq	ymm1, ymm1, ymmword ptr [rcx - 1760]
+	vpaddq	ymm0, ymm0, ymmword ptr [rcx - 1792]
+	vpaddq	ymm0, ymm0, ymmword ptr [rcx - 1536]
+	vpaddq	ymm1, ymm1, ymmword ptr [rcx - 1504]
+	vpaddq	ymm2, ymm2, ymmword ptr [rcx - 1472]
+	vpaddq	ymm3, ymm3, ymmword ptr [rcx - 1440]
+	vpaddq	ymm4, ymm4, ymmword ptr [rcx - 1408]
+	vpaddq	ymm5, ymm5, ymmword ptr [rcx - 1376]
+	vpaddq	ymm6, ymm6, ymmword ptr [rcx - 1344]
+	vpaddq	ymm7, ymm7, ymmword ptr [rcx - 1312]
+	vpaddq	ymm7, ymm7, ymmword ptr [rcx - 1056]
+	vpaddq	ymm6, ymm6, ymmword ptr [rcx - 1088]
+	vpaddq	ymm5, ymm5, ymmword ptr [rcx - 1120]
+	vpaddq	ymm4, ymm4, ymmword ptr [rcx - 1152]
+	vpaddq	ymm3, ymm3, ymmword ptr [rcx - 1184]
+	vpaddq	ymm2, ymm2, ymmword ptr [rcx - 1216]
+	vpaddq	ymm1, ymm1, ymmword ptr [rcx - 1248]
+	vpaddq	ymm0, ymm0, ymmword ptr [rcx - 1280]
+	vpaddq	ymm0, ymm0, ymmword ptr [rcx - 1024]
+	vpaddq	ymm1, ymm1, ymmword ptr [rcx - 992]
+	vpaddq	ymm2, ymm2, ymmword ptr [rcx - 960]
+	vpaddq	ymm3, ymm3, ymmword ptr [rcx - 928]
+	vpaddq	ymm4, ymm4, ymmword ptr [rcx - 896]
+	vpaddq	ymm5, ymm5, ymmword ptr [rcx - 864]
+	vpaddq	ymm6, ymm6, ymmword ptr [rcx - 832]
+	vpaddq	ymm7, ymm7, ymmword ptr [rcx - 800]
+	vpaddq	ymm7, ymm7, ymmword ptr [rcx - 544]
+	vpaddq	ymm6, ymm6, ymmword ptr [rcx - 576]
+	vpaddq	ymm5, ymm5, ymmword ptr [rcx - 608]
+	vpaddq	ymm4, ymm4, ymmword ptr [rcx - 640]
+	vpaddq	ymm3, ymm3, ymmword ptr [rcx - 672]
+	vpaddq	ymm2, ymm2, ymmword ptr [rcx - 704]
+	vpaddq	ymm1, ymm1, ymmword ptr [rcx - 736]
+	vpaddq	ymm0, ymm0, ymmword ptr [rcx - 768]
+	vpaddq	ymm0, ymm0, ymmword ptr [rcx - 512]
+	vpaddq	ymm1, ymm1, ymmword ptr [rcx - 480]
+	vpaddq	ymm2, ymm2, ymmword ptr [rcx - 448]
+	vpaddq	ymm3, ymm3, ymmword ptr [rcx - 416]
+	vpaddq	ymm4, ymm4, ymmword ptr [rcx - 384]
+	vpaddq	ymm5, ymm5, ymmword ptr [rcx - 352]
+	vpaddq	ymm6, ymm6, ymmword ptr [rcx - 320]
+	vpaddq	ymm7, ymm7, ymmword ptr [rcx - 288]
+	vpaddq	ymm7, ymm7, ymmword ptr [rcx - 32]
+	vpaddq	ymm6, ymm6, ymmword ptr [rcx - 64]
+	vpaddq	ymm5, ymm5, ymmword ptr [rcx - 96]
+	vpaddq	ymm4, ymm4, ymmword ptr [rcx - 128]
+	vpaddq	ymm3, ymm3, ymmword ptr [rcx - 160]
+	vpaddq	ymm2, ymm2, ymmword ptr [rcx - 192]
+	vpaddq	ymm1, ymm1, ymmword ptr [rcx - 224]
+	vpaddq	ymm0, ymm0, ymmword ptr [rcx - 256]
+	vpaddq	ymm0, ymm0, ymmword ptr [rcx]
+	vpaddq	ymm1, ymm1, ymmword ptr [rcx + 32]
+	vpaddq	ymm2, ymm2, ymmword ptr [rcx + 64]
+	vpaddq	ymm3, ymm3, ymmword ptr [rcx + 96]
+	vpaddq	ymm4, ymm4, ymmword ptr [rcx + 128]
+	vpaddq	ymm5, ymm5, ymmword ptr [rcx + 160]
+	vpaddq	ymm6, ymm6, ymmword ptr [rcx + 192]
+	vpaddq	ymm7, ymm7, ymmword ptr [rcx + 224]
+	add	rcx, 2048
+	add	rax, -256
+	jne	.LBB0_13
+.LBB0_14:
+	vpaddq	ymm1, ymm1, ymm5
+	vpaddq	ymm3, ymm3, ymm7
+	vpaddq	ymm0, ymm0, ymm4
+	vpaddq	ymm2, ymm2, ymm6
+	vpaddq	ymm0, ymm0, ymm2
+	vpaddq	ymm1, ymm1, ymm3
+	vpaddq	ymm0, ymm0, ymm1
+	vextracti128	xmm1, ymm0, 1
+	vpaddq	ymm0, ymm0, ymm1
+	vpshufd	xmm1, xmm0, 78          # xmm1 = xmm0[2,3,0,1]
+	vpaddq	ymm0, ymm0, ymm1
+	vmovq	rax, xmm0
+	cmp	r9, rsi
+	jne	.LBB0_4
+	jmp	.LBB0_15
+.Lfunc_end0:
+	.size	sum_int64_avx2, .Lfunc_end0-sum_int64_avx2
+
+
+	.ident	"Apple LLVM version 9.0.0 (clang-900.0.39.2)"
+	.section	".note.GNU-stack","",@progbits
diff --git a/go/arrow/math/_lib/int64_sse4.s b/go/arrow/math/_lib/int64_sse4.s
new file mode 100644
index 000000000..d433260f7
--- /dev/null
+++ b/go/arrow/math/_lib/int64_sse4.s
@@ -0,0 +1,108 @@
+	.text
+	.intel_syntax noprefix
+	.file	"_lib/int64.c"
+	.globl	sum_int64_sse4
+	.p2align	4, 0x90
+	.type	sum_int64_sse4,@function
+sum_int64_sse4:                         # @sum_int64_sse4
+# BB#0:
+	push	rbp
+	mov	rbp, rsp
+	and	rsp, -8
+	test	rsi, rsi
+	je	.LBB0_1
+# BB#2:
+	cmp	rsi, 3
+	jbe	.LBB0_3
+# BB#6:
+	mov	r9, rsi
+	and	r9, -4
+	je	.LBB0_3
+# BB#7:
+	lea	r8, [r9 - 4]
+	mov	eax, r8d
+	shr	eax, 2
+	inc	eax
+	and	rax, 3
+	je	.LBB0_8
+# BB#9:
+	neg	rax
+	pxor	xmm0, xmm0
+	xor	ecx, ecx
+	pxor	xmm1, xmm1
+	.p2align	4, 0x90
+.LBB0_10:                               # =>This Inner Loop Header: Depth=1
+	movdqu	xmm2, xmmword ptr [rdi + 8*rcx]
+	movdqu	xmm3, xmmword ptr [rdi + 8*rcx + 16]
+	paddq	xmm0, xmm2
+	paddq	xmm1, xmm3
+	add	rcx, 4
+	inc	rax
+	jne	.LBB0_10
+	jmp	.LBB0_11
+.LBB0_3:
+	xor	r9d, r9d
+	xor	eax, eax
+.LBB0_4:
+	lea	rcx, [rdi + 8*r9]
+	sub	rsi, r9
+	.p2align	4, 0x90
+.LBB0_5:                                # =>This Inner Loop Header: Depth=1
+	add	rax, qword ptr [rcx]
+	add	rcx, 8
+	dec	rsi
+	jne	.LBB0_5
+	jmp	.LBB0_15
+.LBB0_1:
+	xor	eax, eax
+.LBB0_15:
+	mov	qword ptr [rdx], rax
+	mov	rsp, rbp
+	pop	rbp
+	ret
+.LBB0_8:
+	xor	ecx, ecx
+	pxor	xmm0, xmm0
+	pxor	xmm1, xmm1
+.LBB0_11:
+	cmp	r8, 12
+	jb	.LBB0_14
+# BB#12:
+	mov	rax, r9
+	sub	rax, rcx
+	lea	rcx, [rdi + 8*rcx + 112]
+	.p2align	4, 0x90
+.LBB0_13:                               # =>This Inner Loop Header: Depth=1
+	movdqu	xmm2, xmmword ptr [rcx - 112]
+	movdqu	xmm3, xmmword ptr [rcx - 96]
+	movdqu	xmm4, xmmword ptr [rcx - 80]
+	movdqu	xmm5, xmmword ptr [rcx - 64]
+	paddq	xmm2, xmm0
+	paddq	xmm3, xmm1
+	movdqu	xmm6, xmmword ptr [rcx - 48]
+	movdqu	xmm7, xmmword ptr [rcx - 32]
+	paddq	xmm6, xmm4
+	paddq	xmm6, xmm2
+	paddq	xmm7, xmm5
+	paddq	xmm7, xmm3
+	movdqu	xmm0, xmmword ptr [rcx - 16]
+	movdqu	xmm1, xmmword ptr [rcx]
+	paddq	xmm0, xmm6
+	paddq	xmm1, xmm7
+	sub	rcx, -128
+	add	rax, -16
+	jne	.LBB0_13
+.LBB0_14:
+	paddq	xmm0, xmm1
+	pshufd	xmm1, xmm0, 78          # xmm1 = xmm0[2,3,0,1]
+	paddq	xmm1, xmm0
+	movq	rax, xmm1
+	cmp	r9, rsi
+	jne	.LBB0_4
+	jmp	.LBB0_15
+.Lfunc_end0:
+	.size	sum_int64_sse4, .Lfunc_end0-sum_int64_sse4
+
+
+	.ident	"Apple LLVM version 9.0.0 (clang-900.0.39.2)"
+	.section	".note.GNU-stack","",@progbits
diff --git a/go/arrow/math/_lib/uint64.c b/go/arrow/math/_lib/uint64.c
new file mode 100644
index 000000000..91d3d9add
--- /dev/null
+++ b/go/arrow/math/_lib/uint64.c
@@ -0,0 +1,27 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <arch.h>
+#include <memory.h>
+#include <stdint.h>
+
+void FULL_NAME(sum_uint64)(uint64_t buf[], size_t len, uint64_t *res) {
+    uint64_t acc = 0;
+    for(int i = 0; i < len; i++) {
+        acc += buf[i];
+    }
+    *res = acc;
+}
\ No newline at end of file
diff --git a/go/arrow/math/_lib/uint64_avx2.s b/go/arrow/math/_lib/uint64_avx2.s
new file mode 100644
index 000000000..e4502ee06
--- /dev/null
+++ b/go/arrow/math/_lib/uint64_avx2.s
@@ -0,0 +1,181 @@
+	.text
+	.intel_syntax noprefix
+	.file	"_lib/uint64.c"
+	.globl	sum_uint64_avx2
+	.p2align	4, 0x90
+	.type	sum_uint64_avx2,@function
+sum_uint64_avx2:                        # @sum_uint64_avx2
+# BB#0:
+	push	rbp
+	mov	rbp, rsp
+	and	rsp, -8
+	test	rsi, rsi
+	je	.LBB0_1
+# BB#2:
+	cmp	rsi, 31
+	jbe	.LBB0_3
+# BB#6:
+	mov	r9, rsi
+	and	r9, -32
+	je	.LBB0_3
+# BB#7:
+	lea	r8, [r9 - 32]
+	mov	eax, r8d
+	shr	eax, 5
+	inc	eax
+	and	rax, 7
+	je	.LBB0_8
+# BB#9:
+	neg	rax
+	vpxor	ymm0, ymm0, ymm0
+	xor	ecx, ecx
+	vpxor	ymm1, ymm1, ymm1
+	vpxor	ymm2, ymm2, ymm2
+	vpxor	ymm3, ymm3, ymm3
+	vpxor	ymm4, ymm4, ymm4
+	vpxor	ymm5, ymm5, ymm5
+	vpxor	ymm6, ymm6, ymm6
+	vpxor	ymm7, ymm7, ymm7
+	.p2align	4, 0x90
+.LBB0_10:                               # =>This Inner Loop Header: Depth=1
+	vpaddq	ymm0, ymm0, ymmword ptr [rdi + 8*rcx]
+	vpaddq	ymm1, ymm1, ymmword ptr [rdi + 8*rcx + 32]
+	vpaddq	ymm2, ymm2, ymmword ptr [rdi + 8*rcx + 64]
+	vpaddq	ymm3, ymm3, ymmword ptr [rdi + 8*rcx + 96]
+	vpaddq	ymm4, ymm4, ymmword ptr [rdi + 8*rcx + 128]
+	vpaddq	ymm5, ymm5, ymmword ptr [rdi + 8*rcx + 160]
+	vpaddq	ymm6, ymm6, ymmword ptr [rdi + 8*rcx + 192]
+	vpaddq	ymm7, ymm7, ymmword ptr [rdi + 8*rcx + 224]
+	add	rcx, 32
+	inc	rax
+	jne	.LBB0_10
+	jmp	.LBB0_11
+.LBB0_3:
+	xor	r9d, r9d
+	xor	eax, eax
+.LBB0_4:
+	lea	rcx, [rdi + 8*r9]
+	sub	rsi, r9
+	.p2align	4, 0x90
+.LBB0_5:                                # =>This Inner Loop Header: Depth=1
+	add	rax, qword ptr [rcx]
+	add	rcx, 8
+	dec	rsi
+	jne	.LBB0_5
+	jmp	.LBB0_15
+.LBB0_1:
+	xor	eax, eax
+.LBB0_15:
+	mov	qword ptr [rdx], rax
+	mov	rsp, rbp
+	pop	rbp
+	vzeroupper
+	ret
+.LBB0_8:
+	xor	ecx, ecx
+	vpxor	ymm0, ymm0, ymm0
+	vpxor	ymm1, ymm1, ymm1
+	vpxor	ymm2, ymm2, ymm2
+	vpxor	ymm3, ymm3, ymm3
+	vpxor	ymm4, ymm4, ymm4
+	vpxor	ymm5, ymm5, ymm5
+	vpxor	ymm6, ymm6, ymm6
+	vpxor	ymm7, ymm7, ymm7
+.LBB0_11:
+	cmp	r8, 224
+	jb	.LBB0_14
+# BB#12:
+	mov	rax, r9
+	sub	rax, rcx
+	lea	rcx, [rdi + 8*rcx + 1792]
+	.p2align	4, 0x90
+.LBB0_13:                               # =>This Inner Loop Header: Depth=1
+	vpaddq	ymm7, ymm7, ymmword ptr [rcx - 1568]
+	vpaddq	ymm6, ymm6, ymmword ptr [rcx - 1600]
+	vpaddq	ymm5, ymm5, ymmword ptr [rcx - 1632]
+	vpaddq	ymm4, ymm4, ymmword ptr [rcx - 1664]
+	vpaddq	ymm3, ymm3, ymmword ptr [rcx - 1696]
+	vpaddq	ymm2, ymm2, ymmword ptr [rcx - 1728]
+	vpaddq	ymm1, ymm1, ymmword ptr [rcx - 1760]
+	vpaddq	ymm0, ymm0, ymmword ptr [rcx - 1792]
+	vpaddq	ymm0, ymm0, ymmword ptr [rcx - 1536]
+	vpaddq	ymm1, ymm1, ymmword ptr [rcx - 1504]
+	vpaddq	ymm2, ymm2, ymmword ptr [rcx - 1472]
+	vpaddq	ymm3, ymm3, ymmword ptr [rcx - 1440]
+	vpaddq	ymm4, ymm4, ymmword ptr [rcx - 1408]
+	vpaddq	ymm5, ymm5, ymmword ptr [rcx - 1376]
+	vpaddq	ymm6, ymm6, ymmword ptr [rcx - 1344]
+	vpaddq	ymm7, ymm7, ymmword ptr [rcx - 1312]
+	vpaddq	ymm7, ymm7, ymmword ptr [rcx - 1056]
+	vpaddq	ymm6, ymm6, ymmword ptr [rcx - 1088]
+	vpaddq	ymm5, ymm5, ymmword ptr [rcx - 1120]
+	vpaddq	ymm4, ymm4, ymmword ptr [rcx - 1152]
+	vpaddq	ymm3, ymm3, ymmword ptr [rcx - 1184]
+	vpaddq	ymm2, ymm2, ymmword ptr [rcx - 1216]
+	vpaddq	ymm1, ymm1, ymmword ptr [rcx - 1248]
+	vpaddq	ymm0, ymm0, ymmword ptr [rcx - 1280]
+	vpaddq	ymm0, ymm0, ymmword ptr [rcx - 1024]
+	vpaddq	ymm1, ymm1, ymmword ptr [rcx - 992]
+	vpaddq	ymm2, ymm2, ymmword ptr [rcx - 960]
+	vpaddq	ymm3, ymm3, ymmword ptr [rcx - 928]
+	vpaddq	ymm4, ymm4, ymmword ptr [rcx - 896]
+	vpaddq	ymm5, ymm5, ymmword ptr [rcx - 864]
+	vpaddq	ymm6, ymm6, ymmword ptr [rcx - 832]
+	vpaddq	ymm7, ymm7, ymmword ptr [rcx - 800]
+	vpaddq	ymm7, ymm7, ymmword ptr [rcx - 544]
+	vpaddq	ymm6, ymm6, ymmword ptr [rcx - 576]
+	vpaddq	ymm5, ymm5, ymmword ptr [rcx - 608]
+	vpaddq	ymm4, ymm4, ymmword ptr [rcx - 640]
+	vpaddq	ymm3, ymm3, ymmword ptr [rcx - 672]
+	vpaddq	ymm2, ymm2, ymmword ptr [rcx - 704]
+	vpaddq	ymm1, ymm1, ymmword ptr [rcx - 736]
+	vpaddq	ymm0, ymm0, ymmword ptr [rcx - 768]
+	vpaddq	ymm0, ymm0, ymmword ptr [rcx - 512]
+	vpaddq	ymm1, ymm1, ymmword ptr [rcx - 480]
+	vpaddq	ymm2, ymm2, ymmword ptr [rcx - 448]
+	vpaddq	ymm3, ymm3, ymmword ptr [rcx - 416]
+	vpaddq	ymm4, ymm4, ymmword ptr [rcx - 384]
+	vpaddq	ymm5, ymm5, ymmword ptr [rcx - 352]
+	vpaddq	ymm6, ymm6, ymmword ptr [rcx - 320]
+	vpaddq	ymm7, ymm7, ymmword ptr [rcx - 288]
+	vpaddq	ymm7, ymm7, ymmword ptr [rcx - 32]
+	vpaddq	ymm6, ymm6, ymmword ptr [rcx - 64]
+	vpaddq	ymm5, ymm5, ymmword ptr [rcx - 96]
+	vpaddq	ymm4, ymm4, ymmword ptr [rcx - 128]
+	vpaddq	ymm3, ymm3, ymmword ptr [rcx - 160]
+	vpaddq	ymm2, ymm2, ymmword ptr [rcx - 192]
+	vpaddq	ymm1, ymm1, ymmword ptr [rcx - 224]
+	vpaddq	ymm0, ymm0, ymmword ptr [rcx - 256]
+	vpaddq	ymm0, ymm0, ymmword ptr [rcx]
+	vpaddq	ymm1, ymm1, ymmword ptr [rcx + 32]
+	vpaddq	ymm2, ymm2, ymmword ptr [rcx + 64]
+	vpaddq	ymm3, ymm3, ymmword ptr [rcx + 96]
+	vpaddq	ymm4, ymm4, ymmword ptr [rcx + 128]
+	vpaddq	ymm5, ymm5, ymmword ptr [rcx + 160]
+	vpaddq	ymm6, ymm6, ymmword ptr [rcx + 192]
+	vpaddq	ymm7, ymm7, ymmword ptr [rcx + 224]
+	add	rcx, 2048
+	add	rax, -256
+	jne	.LBB0_13
+.LBB0_14:
+	vpaddq	ymm1, ymm1, ymm5
+	vpaddq	ymm3, ymm3, ymm7
+	vpaddq	ymm0, ymm0, ymm4
+	vpaddq	ymm2, ymm2, ymm6
+	vpaddq	ymm0, ymm0, ymm2
+	vpaddq	ymm1, ymm1, ymm3
+	vpaddq	ymm0, ymm0, ymm1
+	vextracti128	xmm1, ymm0, 1
+	vpaddq	ymm0, ymm0, ymm1
+	vpshufd	xmm1, xmm0, 78          # xmm1 = xmm0[2,3,0,1]
+	vpaddq	ymm0, ymm0, ymm1
+	vmovq	rax, xmm0
+	cmp	r9, rsi
+	jne	.LBB0_4
+	jmp	.LBB0_15
+.Lfunc_end0:
+	.size	sum_uint64_avx2, .Lfunc_end0-sum_uint64_avx2
+
+
+	.ident	"Apple LLVM version 9.0.0 (clang-900.0.39.2)"
+	.section	".note.GNU-stack","",@progbits
diff --git a/go/arrow/math/_lib/uint64_sse4.s b/go/arrow/math/_lib/uint64_sse4.s
new file mode 100644
index 000000000..04b4cc853
--- /dev/null
+++ b/go/arrow/math/_lib/uint64_sse4.s
@@ -0,0 +1,108 @@
+	.text
+	.intel_syntax noprefix
+	.file	"_lib/uint64.c"
+	.globl	sum_uint64_sse4
+	.p2align	4, 0x90
+	.type	sum_uint64_sse4,@function
+sum_uint64_sse4:                        # @sum_uint64_sse4
+# BB#0:
+	push	rbp
+	mov	rbp, rsp
+	and	rsp, -8
+	test	rsi, rsi
+	je	.LBB0_1
+# BB#2:
+	cmp	rsi, 3
+	jbe	.LBB0_3
+# BB#6:
+	mov	r9, rsi
+	and	r9, -4
+	je	.LBB0_3
+# BB#7:
+	lea	r8, [r9 - 4]
+	mov	eax, r8d
+	shr	eax, 2
+	inc	eax
+	and	rax, 3
+	je	.LBB0_8
+# BB#9:
+	neg	rax
+	pxor	xmm0, xmm0
+	xor	ecx, ecx
+	pxor	xmm1, xmm1
+	.p2align	4, 0x90
+.LBB0_10:                               # =>This Inner Loop Header: Depth=1
+	movdqu	xmm2, xmmword ptr [rdi + 8*rcx]
+	movdqu	xmm3, xmmword ptr [rdi + 8*rcx + 16]
+	paddq	xmm0, xmm2
+	paddq	xmm1, xmm3
+	add	rcx, 4
+	inc	rax
+	jne	.LBB0_10
+	jmp	.LBB0_11
+.LBB0_3:
+	xor	r9d, r9d
+	xor	eax, eax
+.LBB0_4:
+	lea	rcx, [rdi + 8*r9]
+	sub	rsi, r9
+	.p2align	4, 0x90
+.LBB0_5:                                # =>This Inner Loop Header: Depth=1
+	add	rax, qword ptr [rcx]
+	add	rcx, 8
+	dec	rsi
+	jne	.LBB0_5
+	jmp	.LBB0_15
+.LBB0_1:
+	xor	eax, eax
+.LBB0_15:
+	mov	qword ptr [rdx], rax
+	mov	rsp, rbp
+	pop	rbp
+	ret
+.LBB0_8:
+	xor	ecx, ecx
+	pxor	xmm0, xmm0
+	pxor	xmm1, xmm1
+.LBB0_11:
+	cmp	r8, 12
+	jb	.LBB0_14
+# BB#12:
+	mov	rax, r9
+	sub	rax, rcx
+	lea	rcx, [rdi + 8*rcx + 112]
+	.p2align	4, 0x90
+.LBB0_13:                               # =>This Inner Loop Header: Depth=1
+	movdqu	xmm2, xmmword ptr [rcx - 112]
+	movdqu	xmm3, xmmword ptr [rcx - 96]
+	movdqu	xmm4, xmmword ptr [rcx - 80]
+	movdqu	xmm5, xmmword ptr [rcx - 64]
+	paddq	xmm2, xmm0
+	paddq	xmm3, xmm1
+	movdqu	xmm6, xmmword ptr [rcx - 48]
+	movdqu	xmm7, xmmword ptr [rcx - 32]
+	paddq	xmm6, xmm4
+	paddq	xmm6, xmm2
+	paddq	xmm7, xmm5
+	paddq	xmm7, xmm3
+	movdqu	xmm0, xmmword ptr [rcx - 16]
+	movdqu	xmm1, xmmword ptr [rcx]
+	paddq	xmm0, xmm6
+	paddq	xmm1, xmm7
+	sub	rcx, -128
+	add	rax, -16
+	jne	.LBB0_13
+.LBB0_14:
+	paddq	xmm0, xmm1
+	pshufd	xmm1, xmm0, 78          # xmm1 = xmm0[2,3,0,1]
+	paddq	xmm1, xmm0
+	movq	rax, xmm1
+	cmp	r9, rsi
+	jne	.LBB0_4
+	jmp	.LBB0_15
+.Lfunc_end0:
+	.size	sum_uint64_sse4, .Lfunc_end0-sum_uint64_sse4
+
+
+	.ident	"Apple LLVM version 9.0.0 (clang-900.0.39.2)"
+	.section	".note.GNU-stack","",@progbits
diff --git a/go/arrow/math/doc.go b/go/arrow/math/doc.go
new file mode 100644
index 000000000..30d50a2f1
--- /dev/null
+++ b/go/arrow/math/doc.go
@@ -0,0 +1,30 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*
+Package math provides optimized mathematical functions for processing Arrow arrays.
+*/
+package math
+
+//go:generate go run ../_tools/tmpl/main.go -i -data=float64.tmpldata type.go.tmpl=float64.go type_amd64.go.tmpl=float64_amd64.go type_test.go.tmpl=float64_test.go
+//go:generate go run ../_tools/tmpl/main.go -i -data=float64.tmpldata -d arch=avx2 type_simd_amd64.go.tmpl=float64_avx2_amd64.go
+//go:generate go run ../_tools/tmpl/main.go -i -data=float64.tmpldata -d arch=sse4 type_simd_amd64.go.tmpl=float64_sse4_amd64.go
+//go:generate go run ../_tools/tmpl/main.go -i -data=int64.tmpldata type.go.tmpl=int64.go type_amd64.go.tmpl=int64_amd64.go type_test.go.tmpl=int64_test.go
+//go:generate go run ../_tools/tmpl/main.go -i -data=int64.tmpldata -d arch=avx2 type_simd_amd64.go.tmpl=int64_avx2_amd64.go
+//go:generate go run ../_tools/tmpl/main.go -i -data=int64.tmpldata -d arch=sse4 type_simd_amd64.go.tmpl=int64_sse4_amd64.go
+//go:generate go run ../_tools/tmpl/main.go -i -data=uint64.tmpldata type.go.tmpl=uint64.go type_amd64.go.tmpl=uint64_amd64.go type_test.go.tmpl=uint64_test.go
+//go:generate go run ../_tools/tmpl/main.go -i -data=uint64.tmpldata -d arch=avx2 type_simd_amd64.go.tmpl=uint64_avx2_amd64.go
+//go:generate go run ../_tools/tmpl/main.go -i -data=uint64.tmpldata -d arch=sse4 type_simd_amd64.go.tmpl=uint64_sse4_amd64.go
diff --git a/go/arrow/math/float64.go b/go/arrow/math/float64.go
new file mode 100644
index 000000000..a9c54665e
--- /dev/null
+++ b/go/arrow/math/float64.go
@@ -0,0 +1,44 @@
+// Code generated by type.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package math
+
+import (
+	"github.com/apache/arrow/go/arrow/array"
+)
+
+type Float64Funcs struct {
+	sum func(a *array.Float64) float64
+}
+
+var (
+	Float64 Float64Funcs
+)
+
+// Sum returns the summation of all elements in a.
+func (f Float64Funcs) Sum(a *array.Float64) float64 {
+	return f.sum(a)
+}
+
+func sum_float64_go(a *array.Float64) float64 {
+	acc := float64(0)
+	for _, v := range a.Float64Values() {
+		acc += v
+	}
+	return acc
+}
diff --git a/go/arrow/math/float64.tmpldata b/go/arrow/math/float64.tmpldata
new file mode 100644
index 000000000..de54eea2a
--- /dev/null
+++ b/go/arrow/math/float64.tmpldata
@@ -0,0 +1,4 @@
+{
+  "Name": "Float64",
+  "Type": "float64"
+}
\ No newline at end of file
diff --git a/go/arrow/math/float64_amd64.go b/go/arrow/math/float64_amd64.go
new file mode 100644
index 000000000..87227d5fa
--- /dev/null
+++ b/go/arrow/math/float64_amd64.go
@@ -0,0 +1,33 @@
+// Code generated by type_amd64.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !noasm
+
+package math
+
+func initFloat64AVX2() {
+	Float64.sum = sum_float64_avx2
+}
+
+func initFloat64SSE4() {
+	Float64.sum = sum_float64_sse4
+}
+
+func initFloat64Go() {
+	Float64.sum = sum_float64_go
+}
diff --git a/go/arrow/math/float64_avx2_amd64.go b/go/arrow/math/float64_avx2_amd64.go
new file mode 100644
index 000000000..9301b3284
--- /dev/null
+++ b/go/arrow/math/float64_avx2_amd64.go
@@ -0,0 +1,41 @@
+// Code generated by type_simd_amd64.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !noasm
+
+package math
+
+import (
+	"unsafe"
+
+	"github.com/apache/arrow/go/arrow/array"
+)
+
+//go:noescape
+func _sum_float64_avx2(buf, len, res unsafe.Pointer)
+
+func sum_float64_avx2(a *array.Float64) float64 {
+	buf := a.Float64Values()
+	var (
+		p1  = unsafe.Pointer(&buf[0])
+		p2  = unsafe.Pointer(uintptr(len(buf)))
+		res float64
+	)
+	_sum_float64_avx2(p1, p2, unsafe.Pointer(&res))
+	return res
+}
diff --git a/go/arrow/math/float64_avx2_amd64.s b/go/arrow/math/float64_avx2_amd64.s
new file mode 100644
index 000000000..e5fe247ec
--- /dev/null
+++ b/go/arrow/math/float64_avx2_amd64.s
@@ -0,0 +1,167 @@
+//+build !noasm !appengine
+// AUTO-GENERATED BY C2GOASM -- DO NOT EDIT
+
+TEXT ·_sum_float64_avx2(SB), $0-24
+
+	MOVQ buf+0(FP), DI
+	MOVQ len+8(FP), SI
+	MOVQ res+16(FP), DX
+
+	LONG $0xc057f9c5         // vxorpd    xmm0, xmm0, xmm0
+	WORD $0x8548; BYTE $0xf6 // test    rsi, rsi
+	JE   LBB0_14
+	LONG $0x1ffe8348         // cmp    rsi, 31
+	JBE  LBB0_2
+	WORD $0x8949; BYTE $0xf1 // mov    r9, rsi
+	LONG $0xe0e18349         // and    r9, -32
+	JE   LBB0_2
+	LONG $0xe0418d4d         // lea    r8, [r9 - 32]
+	WORD $0x8944; BYTE $0xc0 // mov    eax, r8d
+	WORD $0xe8c1; BYTE $0x05 // shr    eax, 5
+	WORD $0xc0ff             // inc    eax
+	LONG $0x07e08348         // and    rax, 7
+	JE   LBB0_7
+	WORD $0xf748; BYTE $0xd8 // neg    rax
+	LONG $0xc057fdc5         // vxorpd    ymm0, ymm0, ymm0
+	WORD $0xc931             // xor    ecx, ecx
+	LONG $0xc957f5c5         // vxorpd    ymm1, ymm1, ymm1
+	LONG $0xd257edc5         // vxorpd    ymm2, ymm2, ymm2
+	LONG $0xdb57e5c5         // vxorpd    ymm3, ymm3, ymm3
+	LONG $0xe457ddc5         // vxorpd    ymm4, ymm4, ymm4
+	LONG $0xed57d5c5         // vxorpd    ymm5, ymm5, ymm5
+	LONG $0xf657cdc5         // vxorpd    ymm6, ymm6, ymm6
+	LONG $0xff57c5c5         // vxorpd    ymm7, ymm7, ymm7
+
+LBB0_9:
+	LONG $0x0458fdc5; BYTE $0xcf         // vaddpd    ymm0, ymm0, yword [rdi + 8*rcx]
+	LONG $0x4c58f5c5; WORD $0x20cf       // vaddpd    ymm1, ymm1, yword [rdi + 8*rcx + 32]
+	LONG $0x5458edc5; WORD $0x40cf       // vaddpd    ymm2, ymm2, yword [rdi + 8*rcx + 64]
+	LONG $0x5c58e5c5; WORD $0x60cf       // vaddpd    ymm3, ymm3, yword [rdi + 8*rcx + 96]
+	QUAD $0x000080cfa458ddc5; BYTE $0x00 // vaddpd    ymm4, ymm4, yword [rdi + 8*rcx + 128]
+	QUAD $0x0000a0cfac58d5c5; BYTE $0x00 // vaddpd    ymm5, ymm5, yword [rdi + 8*rcx + 160]
+	QUAD $0x0000c0cfb458cdc5; BYTE $0x00 // vaddpd    ymm6, ymm6, yword [rdi + 8*rcx + 192]
+	QUAD $0x0000e0cfbc58c5c5; BYTE $0x00 // vaddpd    ymm7, ymm7, yword [rdi + 8*rcx + 224]
+	LONG $0x20c18348                     // add    rcx, 32
+	WORD $0xff48; BYTE $0xc0             // inc    rax
+	JNE  LBB0_9
+	JMP  LBB0_10
+
+LBB0_2:
+	WORD $0x3145; BYTE $0xc9 // xor    r9d, r9d
+
+LBB0_3:
+	LONG $0xcf048d4a         // lea    rax, [rdi + 8*r9]
+	WORD $0x294c; BYTE $0xce // sub    rsi, r9
+
+LBB0_4:
+	LONG $0x0058fbc5         // vaddsd    xmm0, xmm0, qword [rax]
+	LONG $0x08c08348         // add    rax, 8
+	WORD $0xff48; BYTE $0xce // dec    rsi
+	JNE  LBB0_4
+
+LBB0_14:
+	LONG $0x0211fbc5 // vmovsd    qword [rdx], xmm0
+	VZEROUPPER
+	RET
+
+LBB0_7:
+	WORD $0xc931     // xor    ecx, ecx
+	LONG $0xc057fdc5 // vxorpd    ymm0, ymm0, ymm0
+	LONG $0xc957f5c5 // vxorpd    ymm1, ymm1, ymm1
+	LONG $0xd257edc5 // vxorpd    ymm2, ymm2, ymm2
+	LONG $0xdb57e5c5 // vxorpd    ymm3, ymm3, ymm3
+	LONG $0xe457ddc5 // vxorpd    ymm4, ymm4, ymm4
+	LONG $0xed57d5c5 // vxorpd    ymm5, ymm5, ymm5
+	LONG $0xf657cdc5 // vxorpd    ymm6, ymm6, ymm6
+	LONG $0xff57c5c5 // vxorpd    ymm7, ymm7, ymm7
+
+LBB0_10:
+	LONG $0xe0f88149; WORD $0x0000; BYTE $0x00 // cmp    r8, 224
+	JB   LBB0_13
+	WORD $0x894c; BYTE $0xc8                   // mov    rax, r9
+	WORD $0x2948; BYTE $0xc8                   // sub    rax, rcx
+	QUAD $0x00000700cf8c8d48                   // lea    rcx, [rdi + 8*rcx + 1792]
+
+LBB0_12:
+	QUAD $0xfffff9e0b958c5c5                   // vaddpd    ymm7, ymm7, yword [rcx - 1568]
+	QUAD $0xfffff9c0b158cdc5                   // vaddpd    ymm6, ymm6, yword [rcx - 1600]
+	QUAD $0xfffff9a0a958d5c5                   // vaddpd    ymm5, ymm5, yword [rcx - 1632]
+	QUAD $0xfffff980a158ddc5                   // vaddpd    ymm4, ymm4, yword [rcx - 1664]
+	QUAD $0xfffff9609958e5c5                   // vaddpd    ymm3, ymm3, yword [rcx - 1696]
+	QUAD $0xfffff9409158edc5                   // vaddpd    ymm2, ymm2, yword [rcx - 1728]
+	QUAD $0xfffff9208958f5c5                   // vaddpd    ymm1, ymm1, yword [rcx - 1760]
+	QUAD $0xfffff9008158fdc5                   // vaddpd    ymm0, ymm0, yword [rcx - 1792]
+	QUAD $0xfffffa008158fdc5                   // vaddpd    ymm0, ymm0, yword [rcx - 1536]
+	QUAD $0xfffffa208958f5c5                   // vaddpd    ymm1, ymm1, yword [rcx - 1504]
+	QUAD $0xfffffa409158edc5                   // vaddpd    ymm2, ymm2, yword [rcx - 1472]
+	QUAD $0xfffffa609958e5c5                   // vaddpd    ymm3, ymm3, yword [rcx - 1440]
+	QUAD $0xfffffa80a158ddc5                   // vaddpd    ymm4, ymm4, yword [rcx - 1408]
+	QUAD $0xfffffaa0a958d5c5                   // vaddpd    ymm5, ymm5, yword [rcx - 1376]
+	QUAD $0xfffffac0b158cdc5                   // vaddpd    ymm6, ymm6, yword [rcx - 1344]
+	QUAD $0xfffffae0b958c5c5                   // vaddpd    ymm7, ymm7, yword [rcx - 1312]
+	QUAD $0xfffffbe0b958c5c5                   // vaddpd    ymm7, ymm7, yword [rcx - 1056]
+	QUAD $0xfffffbc0b158cdc5                   // vaddpd    ymm6, ymm6, yword [rcx - 1088]
+	QUAD $0xfffffba0a958d5c5                   // vaddpd    ymm5, ymm5, yword [rcx - 1120]
+	QUAD $0xfffffb80a158ddc5                   // vaddpd    ymm4, ymm4, yword [rcx - 1152]
+	QUAD $0xfffffb609958e5c5                   // vaddpd    ymm3, ymm3, yword [rcx - 1184]
+	QUAD $0xfffffb409158edc5                   // vaddpd    ymm2, ymm2, yword [rcx - 1216]
+	QUAD $0xfffffb208958f5c5                   // vaddpd    ymm1, ymm1, yword [rcx - 1248]
+	QUAD $0xfffffb008158fdc5                   // vaddpd    ymm0, ymm0, yword [rcx - 1280]
+	QUAD $0xfffffc008158fdc5                   // vaddpd    ymm0, ymm0, yword [rcx - 1024]
+	QUAD $0xfffffc208958f5c5                   // vaddpd    ymm1, ymm1, yword [rcx - 992]
+	QUAD $0xfffffc409158edc5                   // vaddpd    ymm2, ymm2, yword [rcx - 960]
+	QUAD $0xfffffc609958e5c5                   // vaddpd    ymm3, ymm3, yword [rcx - 928]
+	QUAD $0xfffffc80a158ddc5                   // vaddpd    ymm4, ymm4, yword [rcx - 896]
+	QUAD $0xfffffca0a958d5c5                   // vaddpd    ymm5, ymm5, yword [rcx - 864]
+	QUAD $0xfffffcc0b158cdc5                   // vaddpd    ymm6, ymm6, yword [rcx - 832]
+	QUAD $0xfffffce0b958c5c5                   // vaddpd    ymm7, ymm7, yword [rcx - 800]
+	QUAD $0xfffffde0b958c5c5                   // vaddpd    ymm7, ymm7, yword [rcx - 544]
+	QUAD $0xfffffdc0b158cdc5                   // vaddpd    ymm6, ymm6, yword [rcx - 576]
+	QUAD $0xfffffda0a958d5c5                   // vaddpd    ymm5, ymm5, yword [rcx - 608]
+	QUAD $0xfffffd80a158ddc5                   // vaddpd    ymm4, ymm4, yword [rcx - 640]
+	QUAD $0xfffffd609958e5c5                   // vaddpd    ymm3, ymm3, yword [rcx - 672]
+	QUAD $0xfffffd409158edc5                   // vaddpd    ymm2, ymm2, yword [rcx - 704]
+	QUAD $0xfffffd208958f5c5                   // vaddpd    ymm1, ymm1, yword [rcx - 736]
+	QUAD $0xfffffd008158fdc5                   // vaddpd    ymm0, ymm0, yword [rcx - 768]
+	QUAD $0xfffffe008158fdc5                   // vaddpd    ymm0, ymm0, yword [rcx - 512]
+	QUAD $0xfffffe208958f5c5                   // vaddpd    ymm1, ymm1, yword [rcx - 480]
+	QUAD $0xfffffe409158edc5                   // vaddpd    ymm2, ymm2, yword [rcx - 448]
+	QUAD $0xfffffe609958e5c5                   // vaddpd    ymm3, ymm3, yword [rcx - 416]
+	QUAD $0xfffffe80a158ddc5                   // vaddpd    ymm4, ymm4, yword [rcx - 384]
+	QUAD $0xfffffea0a958d5c5                   // vaddpd    ymm5, ymm5, yword [rcx - 352]
+	QUAD $0xfffffec0b158cdc5                   // vaddpd    ymm6, ymm6, yword [rcx - 320]
+	QUAD $0xfffffee0b958c5c5                   // vaddpd    ymm7, ymm7, yword [rcx - 288]
+	LONG $0x7958c5c5; BYTE $0xe0               // vaddpd    ymm7, ymm7, yword [rcx - 32]
+	LONG $0x7158cdc5; BYTE $0xc0               // vaddpd    ymm6, ymm6, yword [rcx - 64]
+	LONG $0x6958d5c5; BYTE $0xa0               // vaddpd    ymm5, ymm5, yword [rcx - 96]
+	LONG $0x6158ddc5; BYTE $0x80               // vaddpd    ymm4, ymm4, yword [rcx - 128]
+	QUAD $0xffffff609958e5c5                   // vaddpd    ymm3, ymm3, yword [rcx - 160]
+	QUAD $0xffffff409158edc5                   // vaddpd    ymm2, ymm2, yword [rcx - 192]
+	QUAD $0xffffff208958f5c5                   // vaddpd    ymm1, ymm1, yword [rcx - 224]
+	QUAD $0xffffff008158fdc5                   // vaddpd    ymm0, ymm0, yword [rcx - 256]
+	LONG $0x0158fdc5                           // vaddpd    ymm0, ymm0, yword [rcx]
+	LONG $0x4958f5c5; BYTE $0x20               // vaddpd    ymm1, ymm1, yword [rcx + 32]
+	LONG $0x5158edc5; BYTE $0x40               // vaddpd    ymm2, ymm2, yword [rcx + 64]
+	LONG $0x5958e5c5; BYTE $0x60               // vaddpd    ymm3, ymm3, yword [rcx + 96]
+	QUAD $0x00000080a158ddc5                   // vaddpd    ymm4, ymm4, yword [rcx + 128]
+	QUAD $0x000000a0a958d5c5                   // vaddpd    ymm5, ymm5, yword [rcx + 160]
+	QUAD $0x000000c0b158cdc5                   // vaddpd    ymm6, ymm6, yword [rcx + 192]
+	QUAD $0x000000e0b958c5c5                   // vaddpd    ymm7, ymm7, yword [rcx + 224]
+	LONG $0x00c18148; WORD $0x0008; BYTE $0x00 // add    rcx, 2048
+	LONG $0xff000548; WORD $0xffff             // add    rax, -256
+	JNE  LBB0_12
+
+LBB0_13:
+	LONG $0xcd58f5c5               // vaddpd    ymm1, ymm1, ymm5
+	LONG $0xdf58e5c5               // vaddpd    ymm3, ymm3, ymm7
+	LONG $0xc458fdc5               // vaddpd    ymm0, ymm0, ymm4
+	LONG $0xd658edc5               // vaddpd    ymm2, ymm2, ymm6
+	LONG $0xc258fdc5               // vaddpd    ymm0, ymm0, ymm2
+	LONG $0xcb58f5c5               // vaddpd    ymm1, ymm1, ymm3
+	LONG $0xc158fdc5               // vaddpd    ymm0, ymm0, ymm1
+	LONG $0x197de3c4; WORD $0x01c1 // vextractf128    xmm1, ymm0, 1
+	LONG $0xc158fdc5               // vaddpd    ymm0, ymm0, ymm1
+	LONG $0xc07cfdc5               // vhaddpd    ymm0, ymm0, ymm0
+	WORD $0x3949; BYTE $0xf1       // cmp    r9, rsi
+	JNE  LBB0_3
+	JMP  LBB0_14
diff --git a/go/arrow/math/float64_noasm.go b/go/arrow/math/float64_noasm.go
new file mode 100644
index 000000000..b480ad34f
--- /dev/null
+++ b/go/arrow/math/float64_noasm.go
@@ -0,0 +1,25 @@
+// Code generated by type_noasm.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build noasm
+
+package math
+
+func initFloat64Go() {
+	Float64.sum = sum_float64_go
+}
diff --git a/go/arrow/math/float64_sse4_amd64.go b/go/arrow/math/float64_sse4_amd64.go
new file mode 100644
index 000000000..30a79f48a
--- /dev/null
+++ b/go/arrow/math/float64_sse4_amd64.go
@@ -0,0 +1,41 @@
+// Code generated by type_simd_amd64.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !noasm
+
+package math
+
+import (
+	"unsafe"
+
+	"github.com/apache/arrow/go/arrow/array"
+)
+
+//go:noescape
+func _sum_float64_sse4(buf, len, res unsafe.Pointer)
+
+func sum_float64_sse4(a *array.Float64) float64 {
+	buf := a.Float64Values()
+	var (
+		p1  = unsafe.Pointer(&buf[0])
+		p2  = unsafe.Pointer(uintptr(len(buf)))
+		res float64
+	)
+	_sum_float64_sse4(p1, p2, unsafe.Pointer(&res))
+	return res
+}
diff --git a/go/arrow/math/float64_sse4_amd64.s b/go/arrow/math/float64_sse4_amd64.s
new file mode 100644
index 000000000..957efa427
--- /dev/null
+++ b/go/arrow/math/float64_sse4_amd64.s
@@ -0,0 +1,94 @@
+//+build !noasm !appengine
+// AUTO-GENERATED BY C2GOASM -- DO NOT EDIT
+
+TEXT ·_sum_float64_sse4(SB), $0-24
+
+	MOVQ buf+0(FP), DI
+	MOVQ len+8(FP), SI
+	MOVQ res+16(FP), DX
+
+	LONG $0xc0570f66         // xorpd    xmm0, xmm0
+	WORD $0x8548; BYTE $0xf6 // test    rsi, rsi
+	JE   LBB0_14
+	LONG $0x03fe8348         // cmp    rsi, 3
+	JBE  LBB0_2
+	WORD $0x8949; BYTE $0xf1 // mov    r9, rsi
+	LONG $0xfce18349         // and    r9, -4
+	JE   LBB0_2
+	LONG $0xfc418d4d         // lea    r8, [r9 - 4]
+	WORD $0x8944; BYTE $0xc0 // mov    eax, r8d
+	WORD $0xe8c1; BYTE $0x02 // shr    eax, 2
+	WORD $0xc0ff             // inc    eax
+	LONG $0x03e08348         // and    rax, 3
+	JE   LBB0_7
+	WORD $0xf748; BYTE $0xd8 // neg    rax
+	LONG $0xc0570f66         // xorpd    xmm0, xmm0
+	WORD $0xc931             // xor    ecx, ecx
+	LONG $0xc9570f66         // xorpd    xmm1, xmm1
+
+LBB0_9:
+	LONG $0x14100f66; BYTE $0xcf   // movupd    xmm2, oword [rdi + 8*rcx]
+	LONG $0x5c100f66; WORD $0x10cf // movupd    xmm3, oword [rdi + 8*rcx + 16]
+	LONG $0xc2580f66               // addpd    xmm0, xmm2
+	LONG $0xcb580f66               // addpd    xmm1, xmm3
+	LONG $0x04c18348               // add    rcx, 4
+	WORD $0xff48; BYTE $0xc0       // inc    rax
+	JNE  LBB0_9
+	JMP  LBB0_10
+
+LBB0_2:
+	WORD $0x3145; BYTE $0xc9 // xor    r9d, r9d
+
+LBB0_3:
+	LONG $0xcf048d4a         // lea    rax, [rdi + 8*r9]
+	WORD $0x294c; BYTE $0xce // sub    rsi, r9
+
+LBB0_4:
+	LONG $0x00580ff2         // addsd    xmm0, qword [rax]
+	LONG $0x08c08348         // add    rax, 8
+	WORD $0xff48; BYTE $0xce // dec    rsi
+	JNE  LBB0_4
+
+LBB0_14:
+	LONG $0x02110ff2 // movsd    qword [rdx], xmm0
+	RET
+
+LBB0_7:
+	WORD $0xc931     // xor    ecx, ecx
+	LONG $0xc0570f66 // xorpd    xmm0, xmm0
+	LONG $0xc9570f66 // xorpd    xmm1, xmm1
+
+LBB0_10:
+	LONG $0x0cf88349             // cmp    r8, 12
+	JB   LBB0_13
+	WORD $0x894c; BYTE $0xc8     // mov    rax, r9
+	WORD $0x2948; BYTE $0xc8     // sub    rax, rcx
+	LONG $0xcf4c8d48; BYTE $0x70 // lea    rcx, [rdi + 8*rcx + 112]
+
+LBB0_12:
+	LONG $0x51100f66; BYTE $0x90 // movupd    xmm2, oword [rcx - 112]
+	LONG $0x59100f66; BYTE $0xa0 // movupd    xmm3, oword [rcx - 96]
+	LONG $0x61100f66; BYTE $0xb0 // movupd    xmm4, oword [rcx - 80]
+	LONG $0x69100f66; BYTE $0xc0 // movupd    xmm5, oword [rcx - 64]
+	LONG $0xd0580f66             // addpd    xmm2, xmm0
+	LONG $0xd9580f66             // addpd    xmm3, xmm1
+	LONG $0x71100f66; BYTE $0xd0 // movupd    xmm6, oword [rcx - 48]
+	LONG $0x79100f66; BYTE $0xe0 // movupd    xmm7, oword [rcx - 32]
+	LONG $0xf4580f66             // addpd    xmm6, xmm4
+	LONG $0xf2580f66             // addpd    xmm6, xmm2
+	LONG $0xfd580f66             // addpd    xmm7, xmm5
+	LONG $0xfb580f66             // addpd    xmm7, xmm3
+	LONG $0x41100f66; BYTE $0xf0 // movupd    xmm0, oword [rcx - 16]
+	LONG $0x09100f66             // movupd    xmm1, oword [rcx]
+	LONG $0xc6580f66             // addpd    xmm0, xmm6
+	LONG $0xcf580f66             // addpd    xmm1, xmm7
+	LONG $0x80e98348             // sub    rcx, -128
+	LONG $0xf0c08348             // add    rax, -16
+	JNE  LBB0_12
+
+LBB0_13:
+	LONG $0xc1580f66         // addpd    xmm0, xmm1
+	LONG $0xc07c0f66         // haddpd    xmm0, xmm0
+	WORD $0x3949; BYTE $0xf1 // cmp    r9, rsi
+	JNE  LBB0_3
+	JMP  LBB0_14
diff --git a/go/arrow/math/float64_test.go b/go/arrow/math/float64_test.go
new file mode 100644
index 000000000..ad33e0f77
--- /dev/null
+++ b/go/arrow/math/float64_test.go
@@ -0,0 +1,68 @@
+// Code generated by type_test.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package math_test
+
+import (
+	"testing"
+
+	"github.com/apache/arrow/go/arrow/array"
+	"github.com/apache/arrow/go/arrow/math"
+	"github.com/apache/arrow/go/arrow/memory"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestFloat64Funcs_Sum(t *testing.T) {
+	vec := makeArrayFloat64(10000)
+	res := math.Float64.Sum(vec)
+	assert.Equal(t, res, float64(49995000))
+}
+
+func makeArrayFloat64(l int) *array.Float64 {
+	fb := array.NewFloat64Builder(memory.NewGoAllocator())
+	fb.Reserve(l)
+	for i := 0; i < l; i++ {
+		fb.Append(float64(i))
+	}
+	return fb.NewFloat64Array()
+}
+
+func benchmarkFloat64Funcs_Sum(b *testing.B, n int) {
+	vec := makeArrayFloat64(n)
+	b.SetBytes(int64(vec.Len() * 8))
+	b.ResetTimer()
+	for i := 0; i < b.N; i++ {
+		math.Float64.Sum(vec)
+	}
+}
+
+func BenchmarkFloat64Funcs_Sum_256(b *testing.B) {
+	benchmarkFloat64Funcs_Sum(b, 256)
+}
+
+func BenchmarkFloat64Funcs_Sum_1024(b *testing.B) {
+	benchmarkFloat64Funcs_Sum(b, 1024)
+}
+
+func BenchmarkFloat64Funcs_Sum_8192(b *testing.B) {
+	benchmarkFloat64Funcs_Sum(b, 8192)
+}
+
+func BenchmarkFloat64Funcs_Sum_1000000(b *testing.B) {
+	benchmarkFloat64Funcs_Sum(b, 1e6)
+}
diff --git a/go/arrow/math/int64.go b/go/arrow/math/int64.go
new file mode 100644
index 000000000..4f70d2e32
--- /dev/null
+++ b/go/arrow/math/int64.go
@@ -0,0 +1,44 @@
+// Code generated by type.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package math
+
+import (
+	"github.com/apache/arrow/go/arrow/array"
+)
+
+type Int64Funcs struct {
+	sum func(a *array.Int64) int64
+}
+
+var (
+	Int64 Int64Funcs
+)
+
+// Sum returns the summation of all elements in a.
+func (f Int64Funcs) Sum(a *array.Int64) int64 {
+	return f.sum(a)
+}
+
+func sum_int64_go(a *array.Int64) int64 {
+	acc := int64(0)
+	for _, v := range a.Int64Values() {
+		acc += v
+	}
+	return acc
+}
diff --git a/go/arrow/math/int64.tmpldata b/go/arrow/math/int64.tmpldata
new file mode 100644
index 000000000..94669f9d3
--- /dev/null
+++ b/go/arrow/math/int64.tmpldata
@@ -0,0 +1,4 @@
+{
+  "Name": "Int64",
+  "Type": "int64"
+}
\ No newline at end of file
diff --git a/go/arrow/math/int64_amd64.go b/go/arrow/math/int64_amd64.go
new file mode 100644
index 000000000..2703bebd0
--- /dev/null
+++ b/go/arrow/math/int64_amd64.go
@@ -0,0 +1,33 @@
+// Code generated by type_amd64.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !noasm
+
+package math
+
+func initInt64AVX2() {
+	Int64.sum = sum_int64_avx2
+}
+
+func initInt64SSE4() {
+	Int64.sum = sum_int64_sse4
+}
+
+func initInt64Go() {
+	Int64.sum = sum_int64_go
+}
diff --git a/go/arrow/math/int64_avx2_amd64.go b/go/arrow/math/int64_avx2_amd64.go
new file mode 100644
index 000000000..55e03cd63
--- /dev/null
+++ b/go/arrow/math/int64_avx2_amd64.go
@@ -0,0 +1,41 @@
+// Code generated by type_simd_amd64.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !noasm
+
+package math
+
+import (
+	"unsafe"
+
+	"github.com/apache/arrow/go/arrow/array"
+)
+
+//go:noescape
+func _sum_int64_avx2(buf, len, res unsafe.Pointer)
+
+func sum_int64_avx2(a *array.Int64) int64 {
+	buf := a.Int64Values()
+	var (
+		p1  = unsafe.Pointer(&buf[0])
+		p2  = unsafe.Pointer(uintptr(len(buf)))
+		res int64
+	)
+	_sum_int64_avx2(p1, p2, unsafe.Pointer(&res))
+	return res
+}
diff --git a/go/arrow/math/int64_avx2_amd64.s b/go/arrow/math/int64_avx2_amd64.s
new file mode 100644
index 000000000..10d234cc4
--- /dev/null
+++ b/go/arrow/math/int64_avx2_amd64.s
@@ -0,0 +1,173 @@
+//+build !noasm !appengine
+// AUTO-GENERATED BY C2GOASM -- DO NOT EDIT
+
+TEXT ·_sum_int64_avx2(SB), $0-24
+
+	MOVQ buf+0(FP), DI
+	MOVQ len+8(FP), SI
+	MOVQ res+16(FP), DX
+
+	WORD $0x8548; BYTE $0xf6 // test    rsi, rsi
+	JE   LBB0_1
+	LONG $0x1ffe8348         // cmp    rsi, 31
+	JBE  LBB0_3
+	WORD $0x8949; BYTE $0xf1 // mov    r9, rsi
+	LONG $0xe0e18349         // and    r9, -32
+	JE   LBB0_3
+	LONG $0xe0418d4d         // lea    r8, [r9 - 32]
+	WORD $0x8944; BYTE $0xc0 // mov    eax, r8d
+	WORD $0xe8c1; BYTE $0x05 // shr    eax, 5
+	WORD $0xc0ff             // inc    eax
+	LONG $0x07e08348         // and    rax, 7
+	JE   LBB0_8
+	WORD $0xf748; BYTE $0xd8 // neg    rax
+	LONG $0xc0effdc5         // vpxor    ymm0, ymm0, ymm0
+	WORD $0xc931             // xor    ecx, ecx
+	LONG $0xc9eff5c5         // vpxor    ymm1, ymm1, ymm1
+	LONG $0xd2efedc5         // vpxor    ymm2, ymm2, ymm2
+	LONG $0xdbefe5c5         // vpxor    ymm3, ymm3, ymm3
+	LONG $0xe4efddc5         // vpxor    ymm4, ymm4, ymm4
+	LONG $0xedefd5c5         // vpxor    ymm5, ymm5, ymm5
+	LONG $0xf6efcdc5         // vpxor    ymm6, ymm6, ymm6
+	LONG $0xffefc5c5         // vpxor    ymm7, ymm7, ymm7
+
+LBB0_10:
+	LONG $0x04d4fdc5; BYTE $0xcf         // vpaddq    ymm0, ymm0, yword [rdi + 8*rcx]
+	LONG $0x4cd4f5c5; WORD $0x20cf       // vpaddq    ymm1, ymm1, yword [rdi + 8*rcx + 32]
+	LONG $0x54d4edc5; WORD $0x40cf       // vpaddq    ymm2, ymm2, yword [rdi + 8*rcx + 64]
+	LONG $0x5cd4e5c5; WORD $0x60cf       // vpaddq    ymm3, ymm3, yword [rdi + 8*rcx + 96]
+	QUAD $0x000080cfa4d4ddc5; BYTE $0x00 // vpaddq    ymm4, ymm4, yword [rdi + 8*rcx + 128]
+	QUAD $0x0000a0cfacd4d5c5; BYTE $0x00 // vpaddq    ymm5, ymm5, yword [rdi + 8*rcx + 160]
+	QUAD $0x0000c0cfb4d4cdc5; BYTE $0x00 // vpaddq    ymm6, ymm6, yword [rdi + 8*rcx + 192]
+	QUAD $0x0000e0cfbcd4c5c5; BYTE $0x00 // vpaddq    ymm7, ymm7, yword [rdi + 8*rcx + 224]
+	LONG $0x20c18348                     // add    rcx, 32
+	WORD $0xff48; BYTE $0xc0             // inc    rax
+	JNE  LBB0_10
+	JMP  LBB0_11
+
+LBB0_3:
+	WORD $0x3145; BYTE $0xc9 // xor    r9d, r9d
+	WORD $0xc031             // xor    eax, eax
+
+LBB0_4:
+	LONG $0xcf0c8d4a         // lea    rcx, [rdi + 8*r9]
+	WORD $0x294c; BYTE $0xce // sub    rsi, r9
+
+LBB0_5:
+	WORD $0x0348; BYTE $0x01 // add    rax, qword [rcx]
+	LONG $0x08c18348         // add    rcx, 8
+	WORD $0xff48; BYTE $0xce // dec    rsi
+	JNE  LBB0_5
+	JMP  LBB0_15
+
+LBB0_1:
+	WORD $0xc031 // xor    eax, eax
+
+LBB0_15:
+	WORD $0x8948; BYTE $0x02 // mov    qword [rdx], rax
+	VZEROUPPER
+	RET
+
+LBB0_8:
+	WORD $0xc931     // xor    ecx, ecx
+	LONG $0xc0effdc5 // vpxor    ymm0, ymm0, ymm0
+	LONG $0xc9eff5c5 // vpxor    ymm1, ymm1, ymm1
+	LONG $0xd2efedc5 // vpxor    ymm2, ymm2, ymm2
+	LONG $0xdbefe5c5 // vpxor    ymm3, ymm3, ymm3
+	LONG $0xe4efddc5 // vpxor    ymm4, ymm4, ymm4
+	LONG $0xedefd5c5 // vpxor    ymm5, ymm5, ymm5
+	LONG $0xf6efcdc5 // vpxor    ymm6, ymm6, ymm6
+	LONG $0xffefc5c5 // vpxor    ymm7, ymm7, ymm7
+
+LBB0_11:
+	LONG $0xe0f88149; WORD $0x0000; BYTE $0x00 // cmp    r8, 224
+	JB   LBB0_14
+	WORD $0x894c; BYTE $0xc8                   // mov    rax, r9
+	WORD $0x2948; BYTE $0xc8                   // sub    rax, rcx
+	QUAD $0x00000700cf8c8d48                   // lea    rcx, [rdi + 8*rcx + 1792]
+
+LBB0_13:
+	QUAD $0xfffff9e0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 1568]
+	QUAD $0xfffff9c0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 1600]
+	QUAD $0xfffff9a0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 1632]
+	QUAD $0xfffff980a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 1664]
+	QUAD $0xfffff96099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 1696]
+	QUAD $0xfffff94091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 1728]
+	QUAD $0xfffff92089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 1760]
+	QUAD $0xfffff90081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 1792]
+	QUAD $0xfffffa0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 1536]
+	QUAD $0xfffffa2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 1504]
+	QUAD $0xfffffa4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 1472]
+	QUAD $0xfffffa6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 1440]
+	QUAD $0xfffffa80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 1408]
+	QUAD $0xfffffaa0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 1376]
+	QUAD $0xfffffac0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 1344]
+	QUAD $0xfffffae0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 1312]
+	QUAD $0xfffffbe0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 1056]
+	QUAD $0xfffffbc0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 1088]
+	QUAD $0xfffffba0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 1120]
+	QUAD $0xfffffb80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 1152]
+	QUAD $0xfffffb6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 1184]
+	QUAD $0xfffffb4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 1216]
+	QUAD $0xfffffb2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 1248]
+	QUAD $0xfffffb0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 1280]
+	QUAD $0xfffffc0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 1024]
+	QUAD $0xfffffc2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 992]
+	QUAD $0xfffffc4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 960]
+	QUAD $0xfffffc6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 928]
+	QUAD $0xfffffc80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 896]
+	QUAD $0xfffffca0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 864]
+	QUAD $0xfffffcc0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 832]
+	QUAD $0xfffffce0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 800]
+	QUAD $0xfffffde0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 544]
+	QUAD $0xfffffdc0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 576]
+	QUAD $0xfffffda0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 608]
+	QUAD $0xfffffd80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 640]
+	QUAD $0xfffffd6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 672]
+	QUAD $0xfffffd4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 704]
+	QUAD $0xfffffd2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 736]
+	QUAD $0xfffffd0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 768]
+	QUAD $0xfffffe0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 512]
+	QUAD $0xfffffe2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 480]
+	QUAD $0xfffffe4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 448]
+	QUAD $0xfffffe6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 416]
+	QUAD $0xfffffe80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 384]
+	QUAD $0xfffffea0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 352]
+	QUAD $0xfffffec0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 320]
+	QUAD $0xfffffee0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 288]
+	LONG $0x79d4c5c5; BYTE $0xe0               // vpaddq    ymm7, ymm7, yword [rcx - 32]
+	LONG $0x71d4cdc5; BYTE $0xc0               // vpaddq    ymm6, ymm6, yword [rcx - 64]
+	LONG $0x69d4d5c5; BYTE $0xa0               // vpaddq    ymm5, ymm5, yword [rcx - 96]
+	LONG $0x61d4ddc5; BYTE $0x80               // vpaddq    ymm4, ymm4, yword [rcx - 128]
+	QUAD $0xffffff6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 160]
+	QUAD $0xffffff4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 192]
+	QUAD $0xffffff2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 224]
+	QUAD $0xffffff0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 256]
+	LONG $0x01d4fdc5                           // vpaddq    ymm0, ymm0, yword [rcx]
+	LONG $0x49d4f5c5; BYTE $0x20               // vpaddq    ymm1, ymm1, yword [rcx + 32]
+	LONG $0x51d4edc5; BYTE $0x40               // vpaddq    ymm2, ymm2, yword [rcx + 64]
+	LONG $0x59d4e5c5; BYTE $0x60               // vpaddq    ymm3, ymm3, yword [rcx + 96]
+	QUAD $0x00000080a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx + 128]
+	QUAD $0x000000a0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx + 160]
+	QUAD $0x000000c0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx + 192]
+	QUAD $0x000000e0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx + 224]
+	LONG $0x00c18148; WORD $0x0008; BYTE $0x00 // add    rcx, 2048
+	LONG $0xff000548; WORD $0xffff             // add    rax, -256
+	JNE  LBB0_13
+
+LBB0_14:
+	LONG $0xcdd4f5c5               // vpaddq    ymm1, ymm1, ymm5
+	LONG $0xdfd4e5c5               // vpaddq    ymm3, ymm3, ymm7
+	LONG $0xc4d4fdc5               // vpaddq    ymm0, ymm0, ymm4
+	LONG $0xd6d4edc5               // vpaddq    ymm2, ymm2, ymm6
+	LONG $0xc2d4fdc5               // vpaddq    ymm0, ymm0, ymm2
+	LONG $0xcbd4f5c5               // vpaddq    ymm1, ymm1, ymm3
+	LONG $0xc1d4fdc5               // vpaddq    ymm0, ymm0, ymm1
+	LONG $0x397de3c4; WORD $0x01c1 // vextracti128    xmm1, ymm0, 1
+	LONG $0xc1d4fdc5               // vpaddq    ymm0, ymm0, ymm1
+	LONG $0xc870f9c5; BYTE $0x4e   // vpshufd    xmm1, xmm0, 78
+	LONG $0xc1d4fdc5               // vpaddq    ymm0, ymm0, ymm1
+	LONG $0x7ef9e1c4; BYTE $0xc0   // vmovq    rax, xmm0
+	WORD $0x3949; BYTE $0xf1       // cmp    r9, rsi
+	JNE  LBB0_4
+	JMP  LBB0_15
diff --git a/go/arrow/math/int64_noasm.go b/go/arrow/math/int64_noasm.go
new file mode 100644
index 000000000..5a5efc31b
--- /dev/null
+++ b/go/arrow/math/int64_noasm.go
@@ -0,0 +1,25 @@
+// Code generated by type_noasm.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build noasm
+
+package math
+
+func initInt64Go() {
+	Int64.sum = sum_int64_go
+}
diff --git a/go/arrow/math/int64_sse4_amd64.go b/go/arrow/math/int64_sse4_amd64.go
new file mode 100644
index 000000000..c13c8de14
--- /dev/null
+++ b/go/arrow/math/int64_sse4_amd64.go
@@ -0,0 +1,41 @@
+// Code generated by type_simd_amd64.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !noasm
+
+package math
+
+import (
+	"unsafe"
+
+	"github.com/apache/arrow/go/arrow/array"
+)
+
+//go:noescape
+func _sum_int64_sse4(buf, len, res unsafe.Pointer)
+
+func sum_int64_sse4(a *array.Int64) int64 {
+	buf := a.Int64Values()
+	var (
+		p1  = unsafe.Pointer(&buf[0])
+		p2  = unsafe.Pointer(uintptr(len(buf)))
+		res int64
+	)
+	_sum_int64_sse4(p1, p2, unsafe.Pointer(&res))
+	return res
+}
diff --git a/go/arrow/math/int64_sse4_amd64.s b/go/arrow/math/int64_sse4_amd64.s
new file mode 100644
index 000000000..ef27eee16
--- /dev/null
+++ b/go/arrow/math/int64_sse4_amd64.s
@@ -0,0 +1,100 @@
+//+build !noasm !appengine
+// AUTO-GENERATED BY C2GOASM -- DO NOT EDIT
+
+TEXT ·_sum_int64_sse4(SB), $0-24
+
+	MOVQ buf+0(FP), DI
+	MOVQ len+8(FP), SI
+	MOVQ res+16(FP), DX
+
+	WORD $0x8548; BYTE $0xf6 // test    rsi, rsi
+	JE   LBB0_1
+	LONG $0x03fe8348         // cmp    rsi, 3
+	JBE  LBB0_3
+	WORD $0x8949; BYTE $0xf1 // mov    r9, rsi
+	LONG $0xfce18349         // and    r9, -4
+	JE   LBB0_3
+	LONG $0xfc418d4d         // lea    r8, [r9 - 4]
+	WORD $0x8944; BYTE $0xc0 // mov    eax, r8d
+	WORD $0xe8c1; BYTE $0x02 // shr    eax, 2
+	WORD $0xc0ff             // inc    eax
+	LONG $0x03e08348         // and    rax, 3
+	JE   LBB0_8
+	WORD $0xf748; BYTE $0xd8 // neg    rax
+	LONG $0xc0ef0f66         // pxor    xmm0, xmm0
+	WORD $0xc931             // xor    ecx, ecx
+	LONG $0xc9ef0f66         // pxor    xmm1, xmm1
+
+LBB0_10:
+	LONG $0x146f0ff3; BYTE $0xcf   // movdqu    xmm2, oword [rdi + 8*rcx]
+	LONG $0x5c6f0ff3; WORD $0x10cf // movdqu    xmm3, oword [rdi + 8*rcx + 16]
+	LONG $0xc2d40f66               // paddq    xmm0, xmm2
+	LONG $0xcbd40f66               // paddq    xmm1, xmm3
+	LONG $0x04c18348               // add    rcx, 4
+	WORD $0xff48; BYTE $0xc0       // inc    rax
+	JNE  LBB0_10
+	JMP  LBB0_11
+
+LBB0_3:
+	WORD $0x3145; BYTE $0xc9 // xor    r9d, r9d
+	WORD $0xc031             // xor    eax, eax
+
+LBB0_4:
+	LONG $0xcf0c8d4a         // lea    rcx, [rdi + 8*r9]
+	WORD $0x294c; BYTE $0xce // sub    rsi, r9
+
+LBB0_5:
+	WORD $0x0348; BYTE $0x01 // add    rax, qword [rcx]
+	LONG $0x08c18348         // add    rcx, 8
+	WORD $0xff48; BYTE $0xce // dec    rsi
+	JNE  LBB0_5
+	JMP  LBB0_15
+
+LBB0_1:
+	WORD $0xc031 // xor    eax, eax
+
+LBB0_15:
+	WORD $0x8948; BYTE $0x02 // mov    qword [rdx], rax
+	RET
+
+LBB0_8:
+	WORD $0xc931     // xor    ecx, ecx
+	LONG $0xc0ef0f66 // pxor    xmm0, xmm0
+	LONG $0xc9ef0f66 // pxor    xmm1, xmm1
+
+LBB0_11:
+	LONG $0x0cf88349             // cmp    r8, 12
+	JB   LBB0_14
+	WORD $0x894c; BYTE $0xc8     // mov    rax, r9
+	WORD $0x2948; BYTE $0xc8     // sub    rax, rcx
+	LONG $0xcf4c8d48; BYTE $0x70 // lea    rcx, [rdi + 8*rcx + 112]
+
+LBB0_13:
+	LONG $0x516f0ff3; BYTE $0x90 // movdqu    xmm2, oword [rcx - 112]
+	LONG $0x596f0ff3; BYTE $0xa0 // movdqu    xmm3, oword [rcx - 96]
+	LONG $0x616f0ff3; BYTE $0xb0 // movdqu    xmm4, oword [rcx - 80]
+	LONG $0x696f0ff3; BYTE $0xc0 // movdqu    xmm5, oword [rcx - 64]
+	LONG $0xd0d40f66             // paddq    xmm2, xmm0
+	LONG $0xd9d40f66             // paddq    xmm3, xmm1
+	LONG $0x716f0ff3; BYTE $0xd0 // movdqu    xmm6, oword [rcx - 48]
+	LONG $0x796f0ff3; BYTE $0xe0 // movdqu    xmm7, oword [rcx - 32]
+	LONG $0xf4d40f66             // paddq    xmm6, xmm4
+	LONG $0xf2d40f66             // paddq    xmm6, xmm2
+	LONG $0xfdd40f66             // paddq    xmm7, xmm5
+	LONG $0xfbd40f66             // paddq    xmm7, xmm3
+	LONG $0x416f0ff3; BYTE $0xf0 // movdqu    xmm0, oword [rcx - 16]
+	LONG $0x096f0ff3             // movdqu    xmm1, oword [rcx]
+	LONG $0xc6d40f66             // paddq    xmm0, xmm6
+	LONG $0xcfd40f66             // paddq    xmm1, xmm7
+	LONG $0x80e98348             // sub    rcx, -128
+	LONG $0xf0c08348             // add    rax, -16
+	JNE  LBB0_13
+
+LBB0_14:
+	LONG $0xc1d40f66             // paddq    xmm0, xmm1
+	LONG $0xc8700f66; BYTE $0x4e // pshufd    xmm1, xmm0, 78
+	LONG $0xc8d40f66             // paddq    xmm1, xmm0
+	LONG $0x7e0f4866; BYTE $0xc8 // movq    rax, xmm1
+	WORD $0x3949; BYTE $0xf1     // cmp    r9, rsi
+	JNE  LBB0_4
+	JMP  LBB0_15
diff --git a/go/arrow/math/int64_test.go b/go/arrow/math/int64_test.go
new file mode 100644
index 000000000..19722828e
--- /dev/null
+++ b/go/arrow/math/int64_test.go
@@ -0,0 +1,68 @@
+// Code generated by type_test.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package math_test
+
+import (
+	"testing"
+
+	"github.com/apache/arrow/go/arrow/array"
+	"github.com/apache/arrow/go/arrow/math"
+	"github.com/apache/arrow/go/arrow/memory"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestInt64Funcs_Sum(t *testing.T) {
+	vec := makeArrayInt64(10000)
+	res := math.Int64.Sum(vec)
+	assert.Equal(t, res, int64(49995000))
+}
+
+func makeArrayInt64(l int) *array.Int64 {
+	fb := array.NewInt64Builder(memory.NewGoAllocator())
+	fb.Reserve(l)
+	for i := 0; i < l; i++ {
+		fb.Append(int64(i))
+	}
+	return fb.NewInt64Array()
+}
+
+func benchmarkInt64Funcs_Sum(b *testing.B, n int) {
+	vec := makeArrayInt64(n)
+	b.SetBytes(int64(vec.Len() * 8))
+	b.ResetTimer()
+	for i := 0; i < b.N; i++ {
+		math.Int64.Sum(vec)
+	}
+}
+
+func BenchmarkInt64Funcs_Sum_256(b *testing.B) {
+	benchmarkInt64Funcs_Sum(b, 256)
+}
+
+func BenchmarkInt64Funcs_Sum_1024(b *testing.B) {
+	benchmarkInt64Funcs_Sum(b, 1024)
+}
+
+func BenchmarkInt64Funcs_Sum_8192(b *testing.B) {
+	benchmarkInt64Funcs_Sum(b, 8192)
+}
+
+func BenchmarkInt64Funcs_Sum_1000000(b *testing.B) {
+	benchmarkInt64Funcs_Sum(b, 1e6)
+}
diff --git a/go/arrow/math/math_amd64.go b/go/arrow/math/math_amd64.go
new file mode 100644
index 000000000..73789de6d
--- /dev/null
+++ b/go/arrow/math/math_amd64.go
@@ -0,0 +1,51 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !noasm
+
+package math
+
+import (
+	"github.com/apache/arrow/go/arrow/internal/cpu"
+)
+
+func init() {
+	if cpu.X86.HasAVX2 {
+		initAVX2()
+	} else if cpu.X86.HasSSE42 {
+		initSSE4()
+	} else {
+		initGo()
+	}
+}
+
+func initAVX2() {
+	initFloat64AVX2()
+	initInt64AVX2()
+	initUint64AVX2()
+}
+
+func initSSE4() {
+	initFloat64SSE4()
+	initInt64SSE4()
+	initUint64SSE4()
+}
+
+func initGo() {
+	initFloat64Go()
+	initInt64Go()
+	initUint64Go()
+}
diff --git a/go/arrow/math/math_noasm.go b/go/arrow/math/math_noasm.go
new file mode 100644
index 000000000..0fa924d90
--- /dev/null
+++ b/go/arrow/math/math_noasm.go
@@ -0,0 +1,29 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build noasm
+
+package math
+
+func init() {
+	initGo()
+}
+
+func initGo() {
+	initFloat64Go()
+	initInt64Go()
+	initUint64Go()
+}
diff --git a/go/arrow/math/type.go.tmpl b/go/arrow/math/type.go.tmpl
new file mode 100644
index 000000000..1b2dd6966
--- /dev/null
+++ b/go/arrow/math/type.go.tmpl
@@ -0,0 +1,45 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package math
+
+import (
+	"github.com/apache/arrow/go/arrow/array"
+)
+
+{{$def := .D}}
+{{with .In}}
+type {{.Name}}Funcs struct {
+	sum func(a *array.{{.Name}}) {{.Type}}
+}
+
+var (
+	{{.Name}} {{.Name}}Funcs
+)
+
+// Sum returns the summation of all elements in a.
+func (f {{.Name}}Funcs) Sum(a *array.{{.Name}}) {{.Type}} {
+	return f.sum(a)
+}
+
+func sum_{{.Type}}_go(a *array.{{.Name}}) {{.Type}} {
+	acc := {{.Type}}(0)
+	for _, v := range a.{{.Name}}Values() {
+		acc += v
+	}
+	return acc
+}
+{{end}}
\ No newline at end of file
diff --git a/go/arrow/math/type_amd64.go.tmpl b/go/arrow/math/type_amd64.go.tmpl
new file mode 100644
index 000000000..c3c27498b
--- /dev/null
+++ b/go/arrow/math/type_amd64.go.tmpl
@@ -0,0 +1,33 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !noasm
+
+package math
+
+{{with .In}}
+func init{{.Name}}AVX2() {
+	{{.Name}}.sum = sum_{{.Type}}_avx2
+}
+
+func init{{.Name}}SSE4() {
+	{{.Name}}.sum = sum_{{.Type}}_sse4
+}
+
+func init{{.Name}}Go() {
+	{{.Name}}.sum = sum_{{.Type}}_go
+}
+{{end}}
\ No newline at end of file
diff --git a/go/arrow/math/type_noasm.go.tmpl b/go/arrow/math/type_noasm.go.tmpl
new file mode 100644
index 000000000..66802f0fe
--- /dev/null
+++ b/go/arrow/math/type_noasm.go.tmpl
@@ -0,0 +1,25 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build noasm
+
+package math
+
+{{with .In}}
+func init{{.Name}}Go() {
+	{{.Name}}.sum = sum_{{.Type}}_go
+}
+{{end}}
\ No newline at end of file
diff --git a/go/arrow/math/type_simd_amd64.go.tmpl b/go/arrow/math/type_simd_amd64.go.tmpl
new file mode 100644
index 000000000..b572290cc
--- /dev/null
+++ b/go/arrow/math/type_simd_amd64.go.tmpl
@@ -0,0 +1,42 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !noasm
+
+package math
+
+import (
+	"unsafe"
+
+	"github.com/apache/arrow/go/arrow/array"
+)
+
+{{$name := printf "%s_%s" .In.Type .D.arch}}
+{{with .In}}
+//go:noescape
+func _sum_{{$name}}(buf, len, res unsafe.Pointer)
+
+func sum_{{$name}}(a *array.{{.Name}}) {{.Type}} {
+	buf := a.{{.Name}}Values()
+	var (
+		p1  = unsafe.Pointer(&buf[0])
+		p2  = unsafe.Pointer(uintptr(len(buf)))
+		res {{.Type}}
+	)
+	_sum_{{$name}}(p1, p2, unsafe.Pointer(&res))
+	return res
+}
+{{end}}
\ No newline at end of file
diff --git a/go/arrow/math/type_test.go.tmpl b/go/arrow/math/type_test.go.tmpl
new file mode 100644
index 000000000..f1b744ca4
--- /dev/null
+++ b/go/arrow/math/type_test.go.tmpl
@@ -0,0 +1,69 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package math_test
+
+import (
+	"testing"
+
+	"github.com/apache/arrow/go/arrow/array"
+	"github.com/apache/arrow/go/arrow/math"
+	"github.com/apache/arrow/go/arrow/memory"
+	"github.com/stretchr/testify/assert"
+)
+
+{{$name := printf "%s_%s" .In.Type .D.arch}}
+{{with .In}}
+func Test{{.Name}}Funcs_Sum(t *testing.T) {
+	vec := makeArray{{.Name}}(10000)
+	res := math.{{.Name}}.Sum(vec)
+	assert.Equal(t, res, {{.Type}}(49995000))
+}
+
+func makeArray{{.Name}}(l int) *array.{{.Name}} {
+	fb := array.New{{.Name}}Builder(memory.NewGoAllocator())
+	fb.Reserve(l)
+	for i := 0; i < l; i++ {
+		fb.Append({{.Type}}(i))
+	}
+	return fb.New{{.Name}}Array()
+}
+
+func benchmark{{.Name}}Funcs_Sum(b *testing.B, n int) {
+	vec := makeArray{{.Name}}(n)
+	b.SetBytes(int64(vec.Len() * 8))
+	b.ResetTimer()
+	for i := 0; i < b.N; i++ {
+		math.{{.Name}}.Sum(vec)
+	}
+}
+
+func Benchmark{{.Name}}Funcs_Sum_256(b *testing.B) {
+	benchmark{{.Name}}Funcs_Sum(b, 256)
+}
+
+func Benchmark{{.Name}}Funcs_Sum_1024(b *testing.B) {
+	benchmark{{.Name}}Funcs_Sum(b, 1024)
+}
+
+func Benchmark{{.Name}}Funcs_Sum_8192(b *testing.B) {
+	benchmark{{.Name}}Funcs_Sum(b, 8192)
+}
+
+func Benchmark{{.Name}}Funcs_Sum_1000000(b *testing.B) {
+	benchmark{{.Name}}Funcs_Sum(b, 1e6)
+}
+{{end}}
\ No newline at end of file
diff --git a/go/arrow/math/uint64.go b/go/arrow/math/uint64.go
new file mode 100644
index 000000000..875e82143
--- /dev/null
+++ b/go/arrow/math/uint64.go
@@ -0,0 +1,44 @@
+// Code generated by type.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package math
+
+import (
+	"github.com/apache/arrow/go/arrow/array"
+)
+
+type Uint64Funcs struct {
+	sum func(a *array.Uint64) uint64
+}
+
+var (
+	Uint64 Uint64Funcs
+)
+
+// Sum returns the summation of all elements in a.
+func (f Uint64Funcs) Sum(a *array.Uint64) uint64 {
+	return f.sum(a)
+}
+
+func sum_uint64_go(a *array.Uint64) uint64 {
+	acc := uint64(0)
+	for _, v := range a.Uint64Values() {
+		acc += v
+	}
+	return acc
+}
diff --git a/go/arrow/math/uint64.tmpldata b/go/arrow/math/uint64.tmpldata
new file mode 100644
index 000000000..22165eb1d
--- /dev/null
+++ b/go/arrow/math/uint64.tmpldata
@@ -0,0 +1,4 @@
+{
+  "Name": "Uint64",
+  "Type": "uint64"
+}
\ No newline at end of file
diff --git a/go/arrow/math/uint64_amd64.go b/go/arrow/math/uint64_amd64.go
new file mode 100644
index 000000000..c6bc29c4e
--- /dev/null
+++ b/go/arrow/math/uint64_amd64.go
@@ -0,0 +1,33 @@
+// Code generated by type_amd64.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !noasm
+
+package math
+
+func initUint64AVX2() {
+	Uint64.sum = sum_uint64_avx2
+}
+
+func initUint64SSE4() {
+	Uint64.sum = sum_uint64_sse4
+}
+
+func initUint64Go() {
+	Uint64.sum = sum_uint64_go
+}
diff --git a/go/arrow/math/uint64_avx2_amd64.go b/go/arrow/math/uint64_avx2_amd64.go
new file mode 100644
index 000000000..ff0500e7c
--- /dev/null
+++ b/go/arrow/math/uint64_avx2_amd64.go
@@ -0,0 +1,41 @@
+// Code generated by type_simd_amd64.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !noasm
+
+package math
+
+import (
+	"unsafe"
+
+	"github.com/apache/arrow/go/arrow/array"
+)
+
+//go:noescape
+func _sum_uint64_avx2(buf, len, res unsafe.Pointer)
+
+func sum_uint64_avx2(a *array.Uint64) uint64 {
+	buf := a.Uint64Values()
+	var (
+		p1  = unsafe.Pointer(&buf[0])
+		p2  = unsafe.Pointer(uintptr(len(buf)))
+		res uint64
+	)
+	_sum_uint64_avx2(p1, p2, unsafe.Pointer(&res))
+	return res
+}
diff --git a/go/arrow/math/uint64_avx2_amd64.s b/go/arrow/math/uint64_avx2_amd64.s
new file mode 100644
index 000000000..7edfd476a
--- /dev/null
+++ b/go/arrow/math/uint64_avx2_amd64.s
@@ -0,0 +1,173 @@
+//+build !noasm !appengine
+// AUTO-GENERATED BY C2GOASM -- DO NOT EDIT
+
+TEXT ·_sum_uint64_avx2(SB), $0-24
+
+	MOVQ buf+0(FP), DI
+	MOVQ len+8(FP), SI
+	MOVQ res+16(FP), DX
+
+	WORD $0x8548; BYTE $0xf6 // test    rsi, rsi
+	JE   LBB0_1
+	LONG $0x1ffe8348         // cmp    rsi, 31
+	JBE  LBB0_3
+	WORD $0x8949; BYTE $0xf1 // mov    r9, rsi
+	LONG $0xe0e18349         // and    r9, -32
+	JE   LBB0_3
+	LONG $0xe0418d4d         // lea    r8, [r9 - 32]
+	WORD $0x8944; BYTE $0xc0 // mov    eax, r8d
+	WORD $0xe8c1; BYTE $0x05 // shr    eax, 5
+	WORD $0xc0ff             // inc    eax
+	LONG $0x07e08348         // and    rax, 7
+	JE   LBB0_8
+	WORD $0xf748; BYTE $0xd8 // neg    rax
+	LONG $0xc0effdc5         // vpxor    ymm0, ymm0, ymm0
+	WORD $0xc931             // xor    ecx, ecx
+	LONG $0xc9eff5c5         // vpxor    ymm1, ymm1, ymm1
+	LONG $0xd2efedc5         // vpxor    ymm2, ymm2, ymm2
+	LONG $0xdbefe5c5         // vpxor    ymm3, ymm3, ymm3
+	LONG $0xe4efddc5         // vpxor    ymm4, ymm4, ymm4
+	LONG $0xedefd5c5         // vpxor    ymm5, ymm5, ymm5
+	LONG $0xf6efcdc5         // vpxor    ymm6, ymm6, ymm6
+	LONG $0xffefc5c5         // vpxor    ymm7, ymm7, ymm7
+
+LBB0_10:
+	LONG $0x04d4fdc5; BYTE $0xcf         // vpaddq    ymm0, ymm0, yword [rdi + 8*rcx]
+	LONG $0x4cd4f5c5; WORD $0x20cf       // vpaddq    ymm1, ymm1, yword [rdi + 8*rcx + 32]
+	LONG $0x54d4edc5; WORD $0x40cf       // vpaddq    ymm2, ymm2, yword [rdi + 8*rcx + 64]
+	LONG $0x5cd4e5c5; WORD $0x60cf       // vpaddq    ymm3, ymm3, yword [rdi + 8*rcx + 96]
+	QUAD $0x000080cfa4d4ddc5; BYTE $0x00 // vpaddq    ymm4, ymm4, yword [rdi + 8*rcx + 128]
+	QUAD $0x0000a0cfacd4d5c5; BYTE $0x00 // vpaddq    ymm5, ymm5, yword [rdi + 8*rcx + 160]
+	QUAD $0x0000c0cfb4d4cdc5; BYTE $0x00 // vpaddq    ymm6, ymm6, yword [rdi + 8*rcx + 192]
+	QUAD $0x0000e0cfbcd4c5c5; BYTE $0x00 // vpaddq    ymm7, ymm7, yword [rdi + 8*rcx + 224]
+	LONG $0x20c18348                     // add    rcx, 32
+	WORD $0xff48; BYTE $0xc0             // inc    rax
+	JNE  LBB0_10
+	JMP  LBB0_11
+
+LBB0_3:
+	WORD $0x3145; BYTE $0xc9 // xor    r9d, r9d
+	WORD $0xc031             // xor    eax, eax
+
+LBB0_4:
+	LONG $0xcf0c8d4a         // lea    rcx, [rdi + 8*r9]
+	WORD $0x294c; BYTE $0xce // sub    rsi, r9
+
+LBB0_5:
+	WORD $0x0348; BYTE $0x01 // add    rax, qword [rcx]
+	LONG $0x08c18348         // add    rcx, 8
+	WORD $0xff48; BYTE $0xce // dec    rsi
+	JNE  LBB0_5
+	JMP  LBB0_15
+
+LBB0_1:
+	WORD $0xc031 // xor    eax, eax
+
+LBB0_15:
+	WORD $0x8948; BYTE $0x02 // mov    qword [rdx], rax
+	VZEROUPPER
+	RET
+
+LBB0_8:
+	WORD $0xc931     // xor    ecx, ecx
+	LONG $0xc0effdc5 // vpxor    ymm0, ymm0, ymm0
+	LONG $0xc9eff5c5 // vpxor    ymm1, ymm1, ymm1
+	LONG $0xd2efedc5 // vpxor    ymm2, ymm2, ymm2
+	LONG $0xdbefe5c5 // vpxor    ymm3, ymm3, ymm3
+	LONG $0xe4efddc5 // vpxor    ymm4, ymm4, ymm4
+	LONG $0xedefd5c5 // vpxor    ymm5, ymm5, ymm5
+	LONG $0xf6efcdc5 // vpxor    ymm6, ymm6, ymm6
+	LONG $0xffefc5c5 // vpxor    ymm7, ymm7, ymm7
+
+LBB0_11:
+	LONG $0xe0f88149; WORD $0x0000; BYTE $0x00 // cmp    r8, 224
+	JB   LBB0_14
+	WORD $0x894c; BYTE $0xc8                   // mov    rax, r9
+	WORD $0x2948; BYTE $0xc8                   // sub    rax, rcx
+	QUAD $0x00000700cf8c8d48                   // lea    rcx, [rdi + 8*rcx + 1792]
+
+LBB0_13:
+	QUAD $0xfffff9e0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 1568]
+	QUAD $0xfffff9c0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 1600]
+	QUAD $0xfffff9a0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 1632]
+	QUAD $0xfffff980a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 1664]
+	QUAD $0xfffff96099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 1696]
+	QUAD $0xfffff94091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 1728]
+	QUAD $0xfffff92089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 1760]
+	QUAD $0xfffff90081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 1792]
+	QUAD $0xfffffa0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 1536]
+	QUAD $0xfffffa2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 1504]
+	QUAD $0xfffffa4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 1472]
+	QUAD $0xfffffa6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 1440]
+	QUAD $0xfffffa80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 1408]
+	QUAD $0xfffffaa0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 1376]
+	QUAD $0xfffffac0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 1344]
+	QUAD $0xfffffae0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 1312]
+	QUAD $0xfffffbe0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 1056]
+	QUAD $0xfffffbc0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 1088]
+	QUAD $0xfffffba0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 1120]
+	QUAD $0xfffffb80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 1152]
+	QUAD $0xfffffb6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 1184]
+	QUAD $0xfffffb4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 1216]
+	QUAD $0xfffffb2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 1248]
+	QUAD $0xfffffb0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 1280]
+	QUAD $0xfffffc0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 1024]
+	QUAD $0xfffffc2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 992]
+	QUAD $0xfffffc4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 960]
+	QUAD $0xfffffc6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 928]
+	QUAD $0xfffffc80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 896]
+	QUAD $0xfffffca0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 864]
+	QUAD $0xfffffcc0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 832]
+	QUAD $0xfffffce0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 800]
+	QUAD $0xfffffde0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 544]
+	QUAD $0xfffffdc0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 576]
+	QUAD $0xfffffda0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 608]
+	QUAD $0xfffffd80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 640]
+	QUAD $0xfffffd6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 672]
+	QUAD $0xfffffd4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 704]
+	QUAD $0xfffffd2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 736]
+	QUAD $0xfffffd0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 768]
+	QUAD $0xfffffe0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 512]
+	QUAD $0xfffffe2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 480]
+	QUAD $0xfffffe4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 448]
+	QUAD $0xfffffe6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 416]
+	QUAD $0xfffffe80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 384]
+	QUAD $0xfffffea0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 352]
+	QUAD $0xfffffec0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 320]
+	QUAD $0xfffffee0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 288]
+	LONG $0x79d4c5c5; BYTE $0xe0               // vpaddq    ymm7, ymm7, yword [rcx - 32]
+	LONG $0x71d4cdc5; BYTE $0xc0               // vpaddq    ymm6, ymm6, yword [rcx - 64]
+	LONG $0x69d4d5c5; BYTE $0xa0               // vpaddq    ymm5, ymm5, yword [rcx - 96]
+	LONG $0x61d4ddc5; BYTE $0x80               // vpaddq    ymm4, ymm4, yword [rcx - 128]
+	QUAD $0xffffff6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 160]
+	QUAD $0xffffff4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 192]
+	QUAD $0xffffff2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 224]
+	QUAD $0xffffff0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 256]
+	LONG $0x01d4fdc5                           // vpaddq    ymm0, ymm0, yword [rcx]
+	LONG $0x49d4f5c5; BYTE $0x20               // vpaddq    ymm1, ymm1, yword [rcx + 32]
+	LONG $0x51d4edc5; BYTE $0x40               // vpaddq    ymm2, ymm2, yword [rcx + 64]
+	LONG $0x59d4e5c5; BYTE $0x60               // vpaddq    ymm3, ymm3, yword [rcx + 96]
+	QUAD $0x00000080a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx + 128]
+	QUAD $0x000000a0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx + 160]
+	QUAD $0x000000c0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx + 192]
+	QUAD $0x000000e0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx + 224]
+	LONG $0x00c18148; WORD $0x0008; BYTE $0x00 // add    rcx, 2048
+	LONG $0xff000548; WORD $0xffff             // add    rax, -256
+	JNE  LBB0_13
+
+LBB0_14:
+	LONG $0xcdd4f5c5               // vpaddq    ymm1, ymm1, ymm5
+	LONG $0xdfd4e5c5               // vpaddq    ymm3, ymm3, ymm7
+	LONG $0xc4d4fdc5               // vpaddq    ymm0, ymm0, ymm4
+	LONG $0xd6d4edc5               // vpaddq    ymm2, ymm2, ymm6
+	LONG $0xc2d4fdc5               // vpaddq    ymm0, ymm0, ymm2
+	LONG $0xcbd4f5c5               // vpaddq    ymm1, ymm1, ymm3
+	LONG $0xc1d4fdc5               // vpaddq    ymm0, ymm0, ymm1
+	LONG $0x397de3c4; WORD $0x01c1 // vextracti128    xmm1, ymm0, 1
+	LONG $0xc1d4fdc5               // vpaddq    ymm0, ymm0, ymm1
+	LONG $0xc870f9c5; BYTE $0x4e   // vpshufd    xmm1, xmm0, 78
+	LONG $0xc1d4fdc5               // vpaddq    ymm0, ymm0, ymm1
+	LONG $0x7ef9e1c4; BYTE $0xc0   // vmovq    rax, xmm0
+	WORD $0x3949; BYTE $0xf1       // cmp    r9, rsi
+	JNE  LBB0_4
+	JMP  LBB0_15
diff --git a/go/arrow/math/uint64_noasm.go b/go/arrow/math/uint64_noasm.go
new file mode 100644
index 000000000..b7174b3d7
--- /dev/null
+++ b/go/arrow/math/uint64_noasm.go
@@ -0,0 +1,25 @@
+// Code generated by type_noasm.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build noasm
+
+package math
+
+func initUint64Go() {
+	Uint64.sum = sum_uint64_go
+}
diff --git a/go/arrow/math/uint64_sse4_amd64.go b/go/arrow/math/uint64_sse4_amd64.go
new file mode 100644
index 000000000..428bbe69f
--- /dev/null
+++ b/go/arrow/math/uint64_sse4_amd64.go
@@ -0,0 +1,41 @@
+// Code generated by type_simd_amd64.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !noasm
+
+package math
+
+import (
+	"unsafe"
+
+	"github.com/apache/arrow/go/arrow/array"
+)
+
+//go:noescape
+func _sum_uint64_sse4(buf, len, res unsafe.Pointer)
+
+func sum_uint64_sse4(a *array.Uint64) uint64 {
+	buf := a.Uint64Values()
+	var (
+		p1  = unsafe.Pointer(&buf[0])
+		p2  = unsafe.Pointer(uintptr(len(buf)))
+		res uint64
+	)
+	_sum_uint64_sse4(p1, p2, unsafe.Pointer(&res))
+	return res
+}
diff --git a/go/arrow/math/uint64_sse4_amd64.s b/go/arrow/math/uint64_sse4_amd64.s
new file mode 100644
index 000000000..1af9cfeb5
--- /dev/null
+++ b/go/arrow/math/uint64_sse4_amd64.s
@@ -0,0 +1,100 @@
+//+build !noasm !appengine
+// AUTO-GENERATED BY C2GOASM -- DO NOT EDIT
+
+TEXT ·_sum_uint64_sse4(SB), $0-24
+
+	MOVQ buf+0(FP), DI
+	MOVQ len+8(FP), SI
+	MOVQ res+16(FP), DX
+
+	WORD $0x8548; BYTE $0xf6 // test    rsi, rsi
+	JE   LBB0_1
+	LONG $0x03fe8348         // cmp    rsi, 3
+	JBE  LBB0_3
+	WORD $0x8949; BYTE $0xf1 // mov    r9, rsi
+	LONG $0xfce18349         // and    r9, -4
+	JE   LBB0_3
+	LONG $0xfc418d4d         // lea    r8, [r9 - 4]
+	WORD $0x8944; BYTE $0xc0 // mov    eax, r8d
+	WORD $0xe8c1; BYTE $0x02 // shr    eax, 2
+	WORD $0xc0ff             // inc    eax
+	LONG $0x03e08348         // and    rax, 3
+	JE   LBB0_8
+	WORD $0xf748; BYTE $0xd8 // neg    rax
+	LONG $0xc0ef0f66         // pxor    xmm0, xmm0
+	WORD $0xc931             // xor    ecx, ecx
+	LONG $0xc9ef0f66         // pxor    xmm1, xmm1
+
+LBB0_10:
+	LONG $0x146f0ff3; BYTE $0xcf   // movdqu    xmm2, oword [rdi + 8*rcx]
+	LONG $0x5c6f0ff3; WORD $0x10cf // movdqu    xmm3, oword [rdi + 8*rcx + 16]
+	LONG $0xc2d40f66               // paddq    xmm0, xmm2
+	LONG $0xcbd40f66               // paddq    xmm1, xmm3
+	LONG $0x04c18348               // add    rcx, 4
+	WORD $0xff48; BYTE $0xc0       // inc    rax
+	JNE  LBB0_10
+	JMP  LBB0_11
+
+LBB0_3:
+	WORD $0x3145; BYTE $0xc9 // xor    r9d, r9d
+	WORD $0xc031             // xor    eax, eax
+
+LBB0_4:
+	LONG $0xcf0c8d4a         // lea    rcx, [rdi + 8*r9]
+	WORD $0x294c; BYTE $0xce // sub    rsi, r9
+
+LBB0_5:
+	WORD $0x0348; BYTE $0x01 // add    rax, qword [rcx]
+	LONG $0x08c18348         // add    rcx, 8
+	WORD $0xff48; BYTE $0xce // dec    rsi
+	JNE  LBB0_5
+	JMP  LBB0_15
+
+LBB0_1:
+	WORD $0xc031 // xor    eax, eax
+
+LBB0_15:
+	WORD $0x8948; BYTE $0x02 // mov    qword [rdx], rax
+	RET
+
+LBB0_8:
+	WORD $0xc931     // xor    ecx, ecx
+	LONG $0xc0ef0f66 // pxor    xmm0, xmm0
+	LONG $0xc9ef0f66 // pxor    xmm1, xmm1
+
+LBB0_11:
+	LONG $0x0cf88349             // cmp    r8, 12
+	JB   LBB0_14
+	WORD $0x894c; BYTE $0xc8     // mov    rax, r9
+	WORD $0x2948; BYTE $0xc8     // sub    rax, rcx
+	LONG $0xcf4c8d48; BYTE $0x70 // lea    rcx, [rdi + 8*rcx + 112]
+
+LBB0_13:
+	LONG $0x516f0ff3; BYTE $0x90 // movdqu    xmm2, oword [rcx - 112]
+	LONG $0x596f0ff3; BYTE $0xa0 // movdqu    xmm3, oword [rcx - 96]
+	LONG $0x616f0ff3; BYTE $0xb0 // movdqu    xmm4, oword [rcx - 80]
+	LONG $0x696f0ff3; BYTE $0xc0 // movdqu    xmm5, oword [rcx - 64]
+	LONG $0xd0d40f66             // paddq    xmm2, xmm0
+	LONG $0xd9d40f66             // paddq    xmm3, xmm1
+	LONG $0x716f0ff3; BYTE $0xd0 // movdqu    xmm6, oword [rcx - 48]
+	LONG $0x796f0ff3; BYTE $0xe0 // movdqu    xmm7, oword [rcx - 32]
+	LONG $0xf4d40f66             // paddq    xmm6, xmm4
+	LONG $0xf2d40f66             // paddq    xmm6, xmm2
+	LONG $0xfdd40f66             // paddq    xmm7, xmm5
+	LONG $0xfbd40f66             // paddq    xmm7, xmm3
+	LONG $0x416f0ff3; BYTE $0xf0 // movdqu    xmm0, oword [rcx - 16]
+	LONG $0x096f0ff3             // movdqu    xmm1, oword [rcx]
+	LONG $0xc6d40f66             // paddq    xmm0, xmm6
+	LONG $0xcfd40f66             // paddq    xmm1, xmm7
+	LONG $0x80e98348             // sub    rcx, -128
+	LONG $0xf0c08348             // add    rax, -16
+	JNE  LBB0_13
+
+LBB0_14:
+	LONG $0xc1d40f66             // paddq    xmm0, xmm1
+	LONG $0xc8700f66; BYTE $0x4e // pshufd    xmm1, xmm0, 78
+	LONG $0xc8d40f66             // paddq    xmm1, xmm0
+	LONG $0x7e0f4866; BYTE $0xc8 // movq    rax, xmm1
+	WORD $0x3949; BYTE $0xf1     // cmp    r9, rsi
+	JNE  LBB0_4
+	JMP  LBB0_15
diff --git a/go/arrow/math/uint64_test.go b/go/arrow/math/uint64_test.go
new file mode 100644
index 000000000..7b8a16579
--- /dev/null
+++ b/go/arrow/math/uint64_test.go
@@ -0,0 +1,68 @@
+// Code generated by type_test.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package math_test
+
+import (
+	"testing"
+
+	"github.com/apache/arrow/go/arrow/array"
+	"github.com/apache/arrow/go/arrow/math"
+	"github.com/apache/arrow/go/arrow/memory"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestUint64Funcs_Sum(t *testing.T) {
+	vec := makeArrayUint64(10000)
+	res := math.Uint64.Sum(vec)
+	assert.Equal(t, res, uint64(49995000))
+}
+
+func makeArrayUint64(l int) *array.Uint64 {
+	fb := array.NewUint64Builder(memory.NewGoAllocator())
+	fb.Reserve(l)
+	for i := 0; i < l; i++ {
+		fb.Append(uint64(i))
+	}
+	return fb.NewUint64Array()
+}
+
+func benchmarkUint64Funcs_Sum(b *testing.B, n int) {
+	vec := makeArrayUint64(n)
+	b.SetBytes(int64(vec.Len() * 8))
+	b.ResetTimer()
+	for i := 0; i < b.N; i++ {
+		math.Uint64.Sum(vec)
+	}
+}
+
+func BenchmarkUint64Funcs_Sum_256(b *testing.B) {
+	benchmarkUint64Funcs_Sum(b, 256)
+}
+
+func BenchmarkUint64Funcs_Sum_1024(b *testing.B) {
+	benchmarkUint64Funcs_Sum(b, 1024)
+}
+
+func BenchmarkUint64Funcs_Sum_8192(b *testing.B) {
+	benchmarkUint64Funcs_Sum(b, 8192)
+}
+
+func BenchmarkUint64Funcs_Sum_1000000(b *testing.B) {
+	benchmarkUint64Funcs_Sum(b, 1e6)
+}
diff --git a/go/arrow/memory/Makefile b/go/arrow/memory/Makefile
new file mode 100644
index 000000000..e50d94e60
--- /dev/null
+++ b/go/arrow/memory/Makefile
@@ -0,0 +1,54 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+GO_BUILD=go build
+GO_GEN=go generate
+GO_TEST=go test
+GOPATH=$(realpath ../../../..)
+
+# this converts rotate instructions from "ro[lr] <reg>" -> "ro[lr] <reg>, 1" for yasm compatibility
+PERL_FIXUP_ROTATE=perl -i -pe 's/(ro[rl]\s+\w{2,3})$$/\1, 1/'
+
+C2GOASM=c2goasm -a -f
+CC=clang
+C_FLAGS=-target x86_64-unknown-none -masm=intel -mno-red-zone -mstackrealign -mllvm -inline-threshold=1000 -fno-asynchronous-unwind-tables \
+	-fno-exceptions -fno-rtti -O3 -fno-builtin -ffast-math -fno-jump-tables -I_lib
+ASM_FLAGS_AVX2=-mavx2 -mfma -mllvm -force-vector-width=32
+ASM_FLAGS_SSE3=-msse3
+ASM_FLAGS_SSE4=-msse4
+
+GO_SOURCES  := $(shell find . -path ./_lib -prune -o -name '*.go' -not -name '*_test.go')
+ALL_SOURCES := $(shell find . -path ./_lib -prune -o -name '*.go' -name '*.s' -not -name '*_test.go')
+
+INTEL_SOURCES := \
+	memory_avx2_amd64.s memory_sse4_amd64.s
+
+.PHONEY: assembly
+
+assembly: $(INTEL_SOURCES)
+
+_lib/memory_avx2.s: _lib/memory.c
+	$(CC) -S $(C_FLAGS) $(ASM_FLAGS_AVX2) $^ -o $@ ; $(PERL_FIXUP_ROTATE) $@
+
+_lib/memory_sse4.s: _lib/memory.c
+	$(CC) -S $(C_FLAGS) $(ASM_FLAGS_SSE4) $^ -o $@ ; $(PERL_FIXUP_ROTATE) $@
+
+memory_avx2_amd64.s: _lib/memory_avx2.s
+	$(C2GOASM) -a -f $^ $@
+
+memory_sse4_amd64.s: _lib/memory_sse4.s
+	$(C2GOASM) -a -f $^ $@
+
diff --git a/go/arrow/memory/_lib/.gitignore b/go/arrow/memory/_lib/.gitignore
new file mode 100644
index 000000000..72757d396
--- /dev/null
+++ b/go/arrow/memory/_lib/.gitignore
@@ -0,0 +1,18 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+.idea
+cmake-build-*
\ No newline at end of file
diff --git a/go/arrow/memory/_lib/CMakeLists.txt b/go/arrow/memory/_lib/CMakeLists.txt
new file mode 100644
index 000000000..f6815302d
--- /dev/null
+++ b/go/arrow/memory/_lib/CMakeLists.txt
@@ -0,0 +1,24 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+cmake_minimum_required(VERSION 3.6)
+
+project(memory-func)
+set(CMAKE_C_STANDARD 99)
+
+add_library(memory STATIC memory.c)
+
+
diff --git a/go/arrow/memory/_lib/arch.h b/go/arrow/memory/_lib/arch.h
new file mode 100644
index 000000000..d9c7d98bf
--- /dev/null
+++ b/go/arrow/memory/_lib/arch.h
@@ -0,0 +1,27 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#undef FULL_NAME
+
+#if  defined(__AVX2__)
+    #define FULL_NAME(x) x##_avx2
+#elif __SSE4_2__ == 1
+    #define FULL_NAME(x) x##_sse4
+#elif __SSE3__ == 1
+    #define FULL_NAME(x) x##_sse3
+#else
+    #define FULL_NAME(x) x##_x86
+#endif
\ No newline at end of file
diff --git a/go/arrow/memory/_lib/memory.c b/go/arrow/memory/_lib/memory.c
new file mode 100644
index 000000000..0e57237c3
--- /dev/null
+++ b/go/arrow/memory/_lib/memory.c
@@ -0,0 +1,27 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "arch.h"
+#include <memory.h>
+
+void FULL_NAME(memset)(void *buf, size_t len, int v) {
+    char *bytes = buf;
+    char *end   = buf+len;
+    const char val = v;
+    while (bytes < end) {
+        *bytes++ = val;
+    }
+}
\ No newline at end of file
diff --git a/go/arrow/memory/_lib/memory_avx2.s b/go/arrow/memory/_lib/memory_avx2.s
new file mode 100644
index 000000000..f53fa15c5
--- /dev/null
+++ b/go/arrow/memory/_lib/memory_avx2.s
@@ -0,0 +1,97 @@
+	.text
+	.intel_syntax noprefix
+	.file	"_lib/memory.c"
+	.globl	memset_avx2
+	.p2align	4, 0x90
+	.type	memset_avx2,@function
+memset_avx2:                            # @memset_avx2
+# BB#0:
+	push	rbp
+	mov	rbp, rsp
+	and	rsp, -8
+	lea	r11, [rdi + rsi]
+	cmp	r11, rdi
+	jbe	.LBB0_13
+# BB#1:
+	cmp	rsi, 128
+	jb	.LBB0_12
+# BB#2:
+	mov	r8, rsi
+	and	r8, -128
+	mov	r10, rsi
+	and	r10, -128
+	je	.LBB0_12
+# BB#3:
+	vmovd	xmm0, edx
+	vpbroadcastb	ymm0, xmm0
+	lea	r9, [r10 - 128]
+	mov	eax, r9d
+	shr	eax, 7
+	inc	eax
+	and	rax, 3
+	je	.LBB0_4
+# BB#5:
+	neg	rax
+	xor	ecx, ecx
+	.p2align	4, 0x90
+.LBB0_6:                                # =>This Inner Loop Header: Depth=1
+	vmovdqu	ymmword ptr [rdi + rcx], ymm0
+	vmovdqu	ymmword ptr [rdi + rcx + 32], ymm0
+	vmovdqu	ymmword ptr [rdi + rcx + 64], ymm0
+	vmovdqu	ymmword ptr [rdi + rcx + 96], ymm0
+	sub	rcx, -128
+	inc	rax
+	jne	.LBB0_6
+	jmp	.LBB0_7
+.LBB0_4:
+	xor	ecx, ecx
+.LBB0_7:
+	cmp	r9, 384
+	jb	.LBB0_10
+# BB#8:
+	mov	rax, r10
+	sub	rax, rcx
+	lea	rcx, [rdi + rcx + 480]
+	.p2align	4, 0x90
+.LBB0_9:                                # =>This Inner Loop Header: Depth=1
+	vmovdqu	ymmword ptr [rcx - 480], ymm0
+	vmovdqu	ymmword ptr [rcx - 448], ymm0
+	vmovdqu	ymmword ptr [rcx - 416], ymm0
+	vmovdqu	ymmword ptr [rcx - 384], ymm0
+	vmovdqu	ymmword ptr [rcx - 352], ymm0
+	vmovdqu	ymmword ptr [rcx - 320], ymm0
+	vmovdqu	ymmword ptr [rcx - 288], ymm0
+	vmovdqu	ymmword ptr [rcx - 256], ymm0
+	vmovdqu	ymmword ptr [rcx - 224], ymm0
+	vmovdqu	ymmword ptr [rcx - 192], ymm0
+	vmovdqu	ymmword ptr [rcx - 160], ymm0
+	vmovdqu	ymmword ptr [rcx - 128], ymm0
+	vmovdqu	ymmword ptr [rcx - 96], ymm0
+	vmovdqu	ymmword ptr [rcx - 64], ymm0
+	vmovdqu	ymmword ptr [rcx - 32], ymm0
+	vmovdqu	ymmword ptr [rcx], ymm0
+	add	rcx, 512
+	add	rax, -512
+	jne	.LBB0_9
+.LBB0_10:
+	cmp	r10, rsi
+	je	.LBB0_13
+# BB#11:
+	add	rdi, r8
+	.p2align	4, 0x90
+.LBB0_12:                               # =>This Inner Loop Header: Depth=1
+	mov	byte ptr [rdi], dl
+	inc	rdi
+	cmp	r11, rdi
+	jne	.LBB0_12
+.LBB0_13:
+	mov	rsp, rbp
+	pop	rbp
+	vzeroupper
+	ret
+.Lfunc_end0:
+	.size	memset_avx2, .Lfunc_end0-memset_avx2
+
+
+	.ident	"Apple LLVM version 9.0.0 (clang-900.0.39.2)"
+	.section	".note.GNU-stack","",@progbits
diff --git a/go/arrow/memory/_lib/memory_sse4.s b/go/arrow/memory/_lib/memory_sse4.s
new file mode 100644
index 000000000..4b44cd31c
--- /dev/null
+++ b/go/arrow/memory/_lib/memory_sse4.s
@@ -0,0 +1,96 @@
+	.text
+	.intel_syntax noprefix
+	.file	"_lib/memory.c"
+	.globl	memset_sse4
+	.p2align	4, 0x90
+	.type	memset_sse4,@function
+memset_sse4:                            # @memset_sse4
+# BB#0:
+	push	rbp
+	mov	rbp, rsp
+	and	rsp, -8
+	lea	r11, [rdi + rsi]
+	cmp	r11, rdi
+	jbe	.LBB0_13
+# BB#1:
+	cmp	rsi, 32
+	jb	.LBB0_12
+# BB#2:
+	mov	r8, rsi
+	and	r8, -32
+	mov	r10, rsi
+	and	r10, -32
+	je	.LBB0_12
+# BB#3:
+	movzx	eax, dl
+	movd	xmm0, eax
+	pxor	xmm1, xmm1
+	pshufb	xmm0, xmm1
+	lea	r9, [r10 - 32]
+	mov	ecx, r9d
+	shr	ecx, 5
+	inc	ecx
+	and	rcx, 7
+	je	.LBB0_4
+# BB#5:
+	neg	rcx
+	xor	eax, eax
+	.p2align	4, 0x90
+.LBB0_6:                                # =>This Inner Loop Header: Depth=1
+	movdqu	xmmword ptr [rdi + rax], xmm0
+	movdqu	xmmword ptr [rdi + rax + 16], xmm0
+	add	rax, 32
+	inc	rcx
+	jne	.LBB0_6
+	jmp	.LBB0_7
+.LBB0_4:
+	xor	eax, eax
+.LBB0_7:
+	cmp	r9, 224
+	jb	.LBB0_10
+# BB#8:
+	mov	rcx, r10
+	sub	rcx, rax
+	lea	rax, [rdi + rax + 240]
+	.p2align	4, 0x90
+.LBB0_9:                                # =>This Inner Loop Header: Depth=1
+	movdqu	xmmword ptr [rax - 240], xmm0
+	movdqu	xmmword ptr [rax - 224], xmm0
+	movdqu	xmmword ptr [rax - 208], xmm0
+	movdqu	xmmword ptr [rax - 192], xmm0
+	movdqu	xmmword ptr [rax - 176], xmm0
+	movdqu	xmmword ptr [rax - 160], xmm0
+	movdqu	xmmword ptr [rax - 144], xmm0
+	movdqu	xmmword ptr [rax - 128], xmm0
+	movdqu	xmmword ptr [rax - 112], xmm0
+	movdqu	xmmword ptr [rax - 96], xmm0
+	movdqu	xmmword ptr [rax - 80], xmm0
+	movdqu	xmmword ptr [rax - 64], xmm0
+	movdqu	xmmword ptr [rax - 48], xmm0
+	movdqu	xmmword ptr [rax - 32], xmm0
+	movdqu	xmmword ptr [rax - 16], xmm0
+	movdqu	xmmword ptr [rax], xmm0
+	add	rax, 256
+	add	rcx, -256
+	jne	.LBB0_9
+.LBB0_10:
+	cmp	r10, rsi
+	je	.LBB0_13
+# BB#11:
+	add	rdi, r8
+	.p2align	4, 0x90
+.LBB0_12:                               # =>This Inner Loop Header: Depth=1
+	mov	byte ptr [rdi], dl
+	inc	rdi
+	cmp	r11, rdi
+	jne	.LBB0_12
+.LBB0_13:
+	mov	rsp, rbp
+	pop	rbp
+	ret
+.Lfunc_end0:
+	.size	memset_sse4, .Lfunc_end0-memset_sse4
+
+
+	.ident	"Apple LLVM version 9.0.0 (clang-900.0.39.2)"
+	.section	".note.GNU-stack","",@progbits
diff --git a/go/arrow/memory/allocator.go b/go/arrow/memory/allocator.go
new file mode 100644
index 000000000..da6be44e3
--- /dev/null
+++ b/go/arrow/memory/allocator.go
@@ -0,0 +1,33 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package memory
+
+const (
+	alignment = 64
+)
+
+type Allocator interface {
+	Allocate(size int) []byte
+	Reallocate(size int, b []byte) []byte
+	Free(b []byte)
+}
+
+// DefaultAllocator is a default implementation of Allocator and can be used anywhere
+// an Allocator is required.
+//
+// DefaultAllocator is safe to use from multiple goroutines.
+var DefaultAllocator Allocator = NewGoAllocator()
diff --git a/go/arrow/memory/buffer.go b/go/arrow/memory/buffer.go
new file mode 100644
index 000000000..234f5d433
--- /dev/null
+++ b/go/arrow/memory/buffer.go
@@ -0,0 +1,108 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package memory
+
+import (
+	"sync/atomic"
+
+	"github.com/apache/arrow/go/arrow/internal/debug"
+)
+
+type Buffer struct {
+	refCount int64
+	buf      []byte
+	length   int
+	mutable  bool
+	mem      Allocator
+}
+
+// NewBufferBytes creates a fixed-size buffer from the specified data.
+func NewBufferBytes(data []byte) *Buffer {
+	return &Buffer{refCount: 0, buf: data, length: len(data)}
+}
+
+// NewBuffer creates a mutable, resizable buffer with an Allocator for managing memory.
+func NewResizableBuffer(mem Allocator) *Buffer {
+	return &Buffer{refCount: 1, mutable: true, mem: mem}
+}
+
+// Retain increases the reference count by 1.
+func (b *Buffer) Retain() {
+	if b.mem != nil {
+		atomic.AddInt64(&b.refCount, 1)
+	}
+}
+
+// Release decreases the reference count by 1.
+// When the reference count goes to zero, the memory is freed.
+func (b *Buffer) Release() {
+	if b.mem != nil {
+		debug.Assert(atomic.LoadInt64(&b.refCount) > 0, "too many releases")
+
+		if atomic.AddInt64(&b.refCount, -1) == 0 {
+			b.mem.Free(b.buf)
+			b.buf, b.length = nil, 0
+		}
+	}
+}
+
+// Buf returns the slice of memory allocated by the Buffer, which is adjusted by calling Reserve.
+func (b *Buffer) Buf() []byte { return b.buf }
+
+// Bytes returns a slice of size Len, which is adjusted by calling Resize.
+func (b *Buffer) Bytes() []byte { return b.buf[:b.length] }
+func (b *Buffer) Mutable() bool { return b.mutable }
+func (b *Buffer) Len() int      { return b.length }
+func (b *Buffer) Cap() int      { return len(b.buf) }
+
+func (b *Buffer) Reserve(capacity int) {
+	if capacity > len(b.buf) {
+		newCap := roundUpToMultipleOf64(capacity)
+		if len(b.buf) == 0 {
+			b.buf = b.mem.Allocate(newCap)
+		} else {
+			b.buf = b.mem.Reallocate(newCap, b.buf)
+		}
+	}
+}
+
+func (b *Buffer) Resize(newSize int) {
+	b.resize(newSize, true)
+}
+
+func (b *Buffer) ResizeNoShrink(newSize int) {
+	b.resize(newSize, false)
+}
+
+func (b *Buffer) resize(newSize int, shrink bool) {
+	if !shrink || newSize > b.length {
+		b.Reserve(newSize)
+	} else {
+		// Buffer is not growing, so shrink to the requested size without
+		// excess space.
+		newCap := roundUpToMultipleOf64(newSize)
+		if len(b.buf) != newCap {
+			if newSize == 0 {
+				b.mem.Free(b.buf)
+				b.buf = nil
+			} else {
+				b.buf = b.mem.Reallocate(newCap, b.buf)
+			}
+		}
+	}
+	b.length = newSize
+}
diff --git a/go/arrow/memory/buffer_test.go b/go/arrow/memory/buffer_test.go
new file mode 100644
index 000000000..918175cb6
--- /dev/null
+++ b/go/arrow/memory/buffer_test.go
@@ -0,0 +1,45 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package memory_test
+
+import (
+	"testing"
+
+	"github.com/apache/arrow/go/arrow/memory"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestNewResizableBuffer(t *testing.T) {
+	mem := memory.NewCheckedAllocator(memory.NewGoAllocator())
+	defer mem.AssertSize(t, 0)
+
+	buf := memory.NewResizableBuffer(mem)
+	buf.Retain() // refCount == 2
+
+	exp := 10
+	buf.Resize(exp)
+	assert.NotNil(t, buf.Bytes())
+	assert.Equal(t, exp, len(buf.Bytes()))
+	assert.Equal(t, exp, buf.Len())
+
+	buf.Release() // refCount == 1
+	assert.NotNil(t, buf.Bytes())
+
+	buf.Release() // refCount == 0
+	assert.Nil(t, buf.Bytes())
+	assert.Zero(t, buf.Len())
+}
diff --git a/go/arrow/memory/checked_allocator.go b/go/arrow/memory/checked_allocator.go
new file mode 100644
index 000000000..4cce89f24
--- /dev/null
+++ b/go/arrow/memory/checked_allocator.go
@@ -0,0 +1,70 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package memory
+
+type CheckedAllocator struct {
+	mem  Allocator
+	base int
+	sz   int
+}
+
+func NewCheckedAllocator(mem Allocator) *CheckedAllocator {
+	return &CheckedAllocator{mem: mem}
+}
+
+func (a *CheckedAllocator) Allocate(size int) []byte {
+	a.sz += size
+	return a.mem.Allocate(size)
+}
+
+func (a *CheckedAllocator) Reallocate(size int, b []byte) []byte {
+	a.sz += size - len(b)
+	return a.mem.Reallocate(size, b)
+}
+
+func (a *CheckedAllocator) Free(b []byte) {
+	a.sz -= len(b)
+	a.mem.Free(b)
+}
+
+type TestingT interface {
+	Errorf(format string, args ...interface{})
+	Helper()
+}
+
+func (a *CheckedAllocator) AssertSize(t TestingT, sz int) {
+	if a.sz != sz {
+		t.Helper()
+		t.Errorf("invalid memory size exp=%d, got=%d", sz, a.sz)
+	}
+}
+
+type CheckedAllocatorScope struct {
+	alloc *CheckedAllocator
+	sz    int
+}
+
+func NewCheckedAllocatorScope(alloc *CheckedAllocator) *CheckedAllocatorScope {
+	return &CheckedAllocatorScope{alloc: alloc, sz: alloc.sz}
+}
+
+func (c *CheckedAllocatorScope) CheckSize(t TestingT) {
+	if c.sz != c.alloc.sz {
+		t.Helper()
+		t.Errorf("invalid memory size exp=%d, got=%d", c.sz, c.alloc.sz)
+	}
+}
diff --git a/go/arrow/memory/doc.go b/go/arrow/memory/doc.go
new file mode 100644
index 000000000..959f88b4f
--- /dev/null
+++ b/go/arrow/memory/doc.go
@@ -0,0 +1,20 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/*
+Package memory provides support for allocating and manipulating memory at a low level.
+*/
+package memory
diff --git a/go/arrow/memory/go_allocator.go b/go/arrow/memory/go_allocator.go
new file mode 100644
index 000000000..a85baee71
--- /dev/null
+++ b/go/arrow/memory/go_allocator.go
@@ -0,0 +1,44 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package memory
+
+type GoAllocator struct{}
+
+func NewGoAllocator() *GoAllocator { return &GoAllocator{} }
+
+func (a *GoAllocator) Allocate(size int) []byte {
+	buf := make([]byte, size+alignment) // padding for 64-byte alignment
+	addr := int(addressOf(buf))
+	next := roundUpToMultipleOf64(addr)
+	if addr != next {
+		shift := next - addr
+		return buf[shift : size+shift : size+shift]
+	}
+	return buf[:size:size]
+}
+
+func (a *GoAllocator) Reallocate(size int, b []byte) []byte {
+	if size == len(b) {
+		return b
+	}
+
+	newBuf := a.Allocate(size)
+	copy(newBuf, b)
+	return newBuf
+}
+
+func (a *GoAllocator) Free(b []byte) {}
diff --git a/go/arrow/memory/go_allocator_test.go b/go/arrow/memory/go_allocator_test.go
new file mode 100644
index 000000000..d146e301a
--- /dev/null
+++ b/go/arrow/memory/go_allocator_test.go
@@ -0,0 +1,76 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package memory
+
+import (
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+)
+
+func isAlignedTo(addr, alignment int) bool {
+	return addr&(alignment-1) == 0
+}
+
+func TestGoAllocator_Allocate(t *testing.T) {
+	tests := []struct {
+		name string
+		sz   int
+	}{
+		{"lt alignment", 33},
+		{"gt alignment unaligned", 65},
+		{"eq alignment", 64},
+		{"large unaligned", 4097},
+		{"large aligned", 8192},
+	}
+	for _, test := range tests {
+		t.Run(test.name, func(t *testing.T) {
+			a := &GoAllocator{}
+			buf := a.Allocate(test.sz)
+			addr := addressOf(buf)
+			assert.True(t, isAlignedTo(int(addr), alignment))
+			assert.Equal(t, test.sz, len(buf), "invalid len")
+			assert.Equal(t, test.sz, cap(buf), "invalid cap")
+		})
+	}
+}
+
+func TestGoAllocator_Reallocate(t *testing.T) {
+	tests := []struct {
+		name     string
+		sz1, sz2 int
+	}{
+		{"smaller", 200, 100},
+		{"same", 200, 200},
+		{"larger", 200, 300},
+	}
+	for _, test := range tests {
+		t.Run(test.name, func(t *testing.T) {
+			a := &GoAllocator{}
+			buf := a.Allocate(test.sz1)
+			for i := range buf {
+				buf[i] = byte(i & 0xff)
+			}
+
+			exp := make([]byte, test.sz2)
+			copy(exp, buf)
+
+			newBuf := a.Reallocate(test.sz2, buf)
+			assert.Equal(t, exp, newBuf)
+		})
+	}
+}
diff --git a/go/arrow/memory/memory.go b/go/arrow/memory/memory.go
new file mode 100644
index 000000000..de2a3a663
--- /dev/null
+++ b/go/arrow/memory/memory.go
@@ -0,0 +1,33 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package memory
+
+var (
+	memset func(b []byte, c byte)
+)
+
+// Set assigns the value c to every element of the slice buf.
+func Set(buf []byte, c byte) {
+	memset(buf, c)
+}
+
+// memory_memset_go reference implementation
+func memory_memset_go(buf []byte, c byte) {
+	for i := 0; i < len(buf); i++ {
+		buf[i] = c
+	}
+}
diff --git a/go/arrow/memory/memory_amd64.go b/go/arrow/memory/memory_amd64.go
new file mode 100644
index 000000000..5ea4a3fe1
--- /dev/null
+++ b/go/arrow/memory/memory_amd64.go
@@ -0,0 +1,33 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !noasm
+
+package memory
+
+import (
+	"github.com/apache/arrow/go/arrow/internal/cpu"
+)
+
+func init() {
+	if cpu.X86.HasAVX2 {
+		memset = memory_memset_avx2
+	} else if cpu.X86.HasSSE42 {
+		memset = memory_memset_sse4
+	} else {
+		memset = memory_memset_go
+	}
+}
diff --git a/go/arrow/memory/memory_avx2_amd64.go b/go/arrow/memory/memory_avx2_amd64.go
new file mode 100644
index 000000000..1f9d176cc
--- /dev/null
+++ b/go/arrow/memory/memory_avx2_amd64.go
@@ -0,0 +1,41 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !noasm
+
+package memory
+
+import "unsafe"
+
+//go:noescape
+func _memset_avx2(buf, len, c unsafe.Pointer)
+
+func memory_memset_avx2(buf []byte, c byte) {
+	if len(buf) == 0 {
+		return
+	}
+
+	var (
+		p1 = unsafe.Pointer(&buf[0])
+		p2 = unsafe.Pointer(uintptr(len(buf)))
+		p3 = unsafe.Pointer(uintptr(c))
+	)
+	if len(buf) > 2000 || isMultipleOfPowerOf2(len(buf), 256) {
+		_memset_avx2(p1, p2, p3)
+	} else {
+		_memset_sse4(p1, p2, p3)
+	}
+}
diff --git a/go/arrow/memory/memory_avx2_amd64.s b/go/arrow/memory/memory_avx2_amd64.s
new file mode 100644
index 000000000..2a77807cb
--- /dev/null
+++ b/go/arrow/memory/memory_avx2_amd64.s
@@ -0,0 +1,85 @@
+//+build !noasm !appengine
+// AUTO-GENERATED BY C2GOASM -- DO NOT EDIT
+
+TEXT ·_memset_avx2(SB), $0-24
+
+	MOVQ buf+0(FP), DI
+	MOVQ len+8(FP), SI
+	MOVQ c+16(FP), DX
+
+	LONG $0x371c8d4c                           // lea    r11, [rdi + rsi]
+	WORD $0x3949; BYTE $0xfb                   // cmp    r11, rdi
+	JBE  LBB0_13
+	LONG $0x80fe8148; WORD $0x0000; BYTE $0x00 // cmp    rsi, 128
+	JB   LBB0_12
+	WORD $0x8949; BYTE $0xf0                   // mov    r8, rsi
+	LONG $0x80e08349                           // and    r8, -128
+	WORD $0x8949; BYTE $0xf2                   // mov    r10, rsi
+	LONG $0x80e28349                           // and    r10, -128
+	JE   LBB0_12
+	LONG $0xc26ef9c5                           // vmovd    xmm0, edx
+	LONG $0x787de2c4; BYTE $0xc0               // vpbroadcastb    ymm0, xmm0
+	LONG $0x804a8d4d                           // lea    r9, [r10 - 128]
+	WORD $0x8944; BYTE $0xc8                   // mov    eax, r9d
+	WORD $0xe8c1; BYTE $0x07                   // shr    eax, 7
+	WORD $0xc0ff                               // inc    eax
+	LONG $0x03e08348                           // and    rax, 3
+	JE   LBB0_4
+	WORD $0xf748; BYTE $0xd8                   // neg    rax
+	WORD $0xc931                               // xor    ecx, ecx
+
+LBB0_6:
+	LONG $0x047ffec5; BYTE $0x0f   // vmovdqu    yword [rdi + rcx], ymm0
+	LONG $0x447ffec5; WORD $0x200f // vmovdqu    yword [rdi + rcx + 32], ymm0
+	LONG $0x447ffec5; WORD $0x400f // vmovdqu    yword [rdi + rcx + 64], ymm0
+	LONG $0x447ffec5; WORD $0x600f // vmovdqu    yword [rdi + rcx + 96], ymm0
+	LONG $0x80e98348               // sub    rcx, -128
+	WORD $0xff48; BYTE $0xc0       // inc    rax
+	JNE  LBB0_6
+	JMP  LBB0_7
+
+LBB0_4:
+	WORD $0xc931 // xor    ecx, ecx
+
+LBB0_7:
+	LONG $0x80f98149; WORD $0x0001; BYTE $0x00 // cmp    r9, 384
+	JB   LBB0_10
+	WORD $0x894c; BYTE $0xd0                   // mov    rax, r10
+	WORD $0x2948; BYTE $0xc8                   // sub    rax, rcx
+	QUAD $0x000001e00f8c8d48                   // lea    rcx, [rdi + rcx + 480]
+
+LBB0_9:
+	QUAD $0xfffffe20817ffec5                   // vmovdqu    yword [rcx - 480], ymm0
+	QUAD $0xfffffe40817ffec5                   // vmovdqu    yword [rcx - 448], ymm0
+	QUAD $0xfffffe60817ffec5                   // vmovdqu    yword [rcx - 416], ymm0
+	QUAD $0xfffffe80817ffec5                   // vmovdqu    yword [rcx - 384], ymm0
+	QUAD $0xfffffea0817ffec5                   // vmovdqu    yword [rcx - 352], ymm0
+	QUAD $0xfffffec0817ffec5                   // vmovdqu    yword [rcx - 320], ymm0
+	QUAD $0xfffffee0817ffec5                   // vmovdqu    yword [rcx - 288], ymm0
+	QUAD $0xffffff00817ffec5                   // vmovdqu    yword [rcx - 256], ymm0
+	QUAD $0xffffff20817ffec5                   // vmovdqu    yword [rcx - 224], ymm0
+	QUAD $0xffffff40817ffec5                   // vmovdqu    yword [rcx - 192], ymm0
+	QUAD $0xffffff60817ffec5                   // vmovdqu    yword [rcx - 160], ymm0
+	LONG $0x417ffec5; BYTE $0x80               // vmovdqu    yword [rcx - 128], ymm0
+	LONG $0x417ffec5; BYTE $0xa0               // vmovdqu    yword [rcx - 96], ymm0
+	LONG $0x417ffec5; BYTE $0xc0               // vmovdqu    yword [rcx - 64], ymm0
+	LONG $0x417ffec5; BYTE $0xe0               // vmovdqu    yword [rcx - 32], ymm0
+	LONG $0x017ffec5                           // vmovdqu    yword [rcx], ymm0
+	LONG $0x00c18148; WORD $0x0002; BYTE $0x00 // add    rcx, 512
+	LONG $0xfe000548; WORD $0xffff             // add    rax, -512
+	JNE  LBB0_9
+
+LBB0_10:
+	WORD $0x3949; BYTE $0xf2 // cmp    r10, rsi
+	JE   LBB0_13
+	WORD $0x014c; BYTE $0xc7 // add    rdi, r8
+
+LBB0_12:
+	WORD $0x1788             // mov    byte [rdi], dl
+	WORD $0xff48; BYTE $0xc7 // inc    rdi
+	WORD $0x3949; BYTE $0xfb // cmp    r11, rdi
+	JNE  LBB0_12
+
+LBB0_13:
+	VZEROUPPER
+	RET
diff --git a/go/arrow/memory/memory_noasm.go b/go/arrow/memory/memory_noasm.go
new file mode 100644
index 000000000..bf8846fa2
--- /dev/null
+++ b/go/arrow/memory/memory_noasm.go
@@ -0,0 +1,23 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build noasm
+
+package memory
+
+func init() {
+	memset = memory_memset_go
+}
diff --git a/go/arrow/memory/memory_sse4_amd64.go b/go/arrow/memory/memory_sse4_amd64.go
new file mode 100644
index 000000000..61da4665a
--- /dev/null
+++ b/go/arrow/memory/memory_sse4_amd64.go
@@ -0,0 +1,31 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +build !noasm
+
+package memory
+
+import "unsafe"
+
+//go:noescape
+func _memset_sse4(buf, len, c unsafe.Pointer)
+
+func memory_memset_sse4(buf []byte, c byte) {
+	if len(buf) == 0 {
+		return
+	}
+	_memset_sse4(unsafe.Pointer(&buf[0]), unsafe.Pointer(uintptr(len(buf))), unsafe.Pointer(uintptr(c)))
+}
diff --git a/go/arrow/memory/memory_sse4_amd64.s b/go/arrow/memory/memory_sse4_amd64.s
new file mode 100644
index 000000000..b1906f99b
--- /dev/null
+++ b/go/arrow/memory/memory_sse4_amd64.s
@@ -0,0 +1,84 @@
+//+build !noasm !appengine
+// AUTO-GENERATED BY C2GOASM -- DO NOT EDIT
+
+TEXT ·_memset_sse4(SB), $0-24
+
+	MOVQ buf+0(FP), DI
+	MOVQ len+8(FP), SI
+	MOVQ c+16(FP), DX
+
+	LONG $0x371c8d4c             // lea    r11, [rdi + rsi]
+	WORD $0x3949; BYTE $0xfb     // cmp    r11, rdi
+	JBE  LBB0_13
+	LONG $0x20fe8348             // cmp    rsi, 32
+	JB   LBB0_12
+	WORD $0x8949; BYTE $0xf0     // mov    r8, rsi
+	LONG $0xe0e08349             // and    r8, -32
+	WORD $0x8949; BYTE $0xf2     // mov    r10, rsi
+	LONG $0xe0e28349             // and    r10, -32
+	JE   LBB0_12
+	WORD $0xb60f; BYTE $0xc2     // movzx    eax, dl
+	LONG $0xc06e0f66             // movd    xmm0, eax
+	LONG $0xc9ef0f66             // pxor    xmm1, xmm1
+	LONG $0x00380f66; BYTE $0xc1 // pshufb    xmm0, xmm1
+	LONG $0xe04a8d4d             // lea    r9, [r10 - 32]
+	WORD $0x8944; BYTE $0xc9     // mov    ecx, r9d
+	WORD $0xe9c1; BYTE $0x05     // shr    ecx, 5
+	WORD $0xc1ff                 // inc    ecx
+	LONG $0x07e18348             // and    rcx, 7
+	JE   LBB0_4
+	WORD $0xf748; BYTE $0xd9     // neg    rcx
+	WORD $0xc031                 // xor    eax, eax
+
+LBB0_6:
+	LONG $0x047f0ff3; BYTE $0x07   // movdqu    oword [rdi + rax], xmm0
+	LONG $0x447f0ff3; WORD $0x1007 // movdqu    oword [rdi + rax + 16], xmm0
+	LONG $0x20c08348               // add    rax, 32
+	WORD $0xff48; BYTE $0xc1       // inc    rcx
+	JNE  LBB0_6
+	JMP  LBB0_7
+
+LBB0_4:
+	WORD $0xc031 // xor    eax, eax
+
+LBB0_7:
+	LONG $0xe0f98149; WORD $0x0000; BYTE $0x00 // cmp    r9, 224
+	JB   LBB0_10
+	WORD $0x894c; BYTE $0xd1                   // mov    rcx, r10
+	WORD $0x2948; BYTE $0xc1                   // sub    rcx, rax
+	QUAD $0x000000f007848d48                   // lea    rax, [rdi + rax + 240]
+
+LBB0_9:
+	QUAD $0xffffff10807f0ff3                   // movdqu    oword [rax - 240], xmm0
+	QUAD $0xffffff20807f0ff3                   // movdqu    oword [rax - 224], xmm0
+	QUAD $0xffffff30807f0ff3                   // movdqu    oword [rax - 208], xmm0
+	QUAD $0xffffff40807f0ff3                   // movdqu    oword [rax - 192], xmm0
+	QUAD $0xffffff50807f0ff3                   // movdqu    oword [rax - 176], xmm0
+	QUAD $0xffffff60807f0ff3                   // movdqu    oword [rax - 160], xmm0
+	QUAD $0xffffff70807f0ff3                   // movdqu    oword [rax - 144], xmm0
+	LONG $0x407f0ff3; BYTE $0x80               // movdqu    oword [rax - 128], xmm0
+	LONG $0x407f0ff3; BYTE $0x90               // movdqu    oword [rax - 112], xmm0
+	LONG $0x407f0ff3; BYTE $0xa0               // movdqu    oword [rax - 96], xmm0
+	LONG $0x407f0ff3; BYTE $0xb0               // movdqu    oword [rax - 80], xmm0
+	LONG $0x407f0ff3; BYTE $0xc0               // movdqu    oword [rax - 64], xmm0
+	LONG $0x407f0ff3; BYTE $0xd0               // movdqu    oword [rax - 48], xmm0
+	LONG $0x407f0ff3; BYTE $0xe0               // movdqu    oword [rax - 32], xmm0
+	LONG $0x407f0ff3; BYTE $0xf0               // movdqu    oword [rax - 16], xmm0
+	LONG $0x007f0ff3                           // movdqu    oword [rax], xmm0
+	LONG $0x01000548; WORD $0x0000             // add    rax, 256
+	LONG $0x00c18148; WORD $0xffff; BYTE $0xff // add    rcx, -256
+	JNE  LBB0_9
+
+LBB0_10:
+	WORD $0x3949; BYTE $0xf2 // cmp    r10, rsi
+	JE   LBB0_13
+	WORD $0x014c; BYTE $0xc7 // add    rdi, r8
+
+LBB0_12:
+	WORD $0x1788             // mov    byte [rdi], dl
+	WORD $0xff48; BYTE $0xc7 // inc    rdi
+	WORD $0x3949; BYTE $0xfb // cmp    r11, rdi
+	JNE  LBB0_12
+
+LBB0_13:
+	RET
diff --git a/go/arrow/memory/memory_test.go b/go/arrow/memory/memory_test.go
new file mode 100644
index 000000000..2ee5bfbe8
--- /dev/null
+++ b/go/arrow/memory/memory_test.go
@@ -0,0 +1,125 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package memory_test
+
+import (
+	"testing"
+
+	"github.com/apache/arrow/go/arrow/memory"
+	"github.com/stretchr/testify/assert"
+)
+
+func makeExpectedBuf(sz, lo, hi int, c byte) []byte {
+	buf := make([]byte, sz)
+	for i := lo; i < hi; i++ {
+		buf[i] = c
+	}
+	return buf
+}
+
+func TestSet(t *testing.T) {
+	tests := []struct {
+		name   string
+		sz     int
+		lo, hi int
+		c      byte
+	}{
+		{"sz=0", 0, 0, 0, 0x00},
+		{"all,sz=7", 7, 0, 7, 0x1f},
+		{"part,sz=7", 7, 3, 4, 0x1f},
+		{"last,sz=7", 7, 6, 7, 0x1f},
+		{"all,sz=25", 25, 0, 25, 0x1f},
+		{"part,sz=25", 25, 13, 19, 0x1f},
+		{"last,sz=25", 25, 24, 25, 0x1f},
+		{"all,sz=4096", 4096, 0, 4096, 0x1f},
+		{"part,sz=4096", 4096, 1000, 3000, 0x1f},
+		{"last,sz=4096", 4096, 4095, 4096, 0x1f},
+		{"all,sz=16384", 16384, 0, 16384, 0x1f},
+		{"part,sz=16384", 16384, 3333, 10000, 0x1f},
+		{"last,sz=16384", 16384, 16383, 16384, 0x1f},
+	}
+	for _, test := range tests {
+		t.Run(test.name, func(t *testing.T) {
+			buf := make([]byte, test.sz)
+			memory.Set(buf[test.lo:test.hi], test.c)
+			exp := makeExpectedBuf(test.sz, test.lo, test.hi, test.c)
+			assert.Equal(t, exp, buf)
+		})
+	}
+}
+
+func benchmarkSet(b *testing.B, n int64) {
+	buf := make([]byte, n)
+	b.SetBytes(n)
+	b.ResetTimer()
+
+	for i := 0; i < b.N; i++ {
+		memory.Set(buf, 0x1f)
+	}
+}
+
+func BenchmarkSet_8(b *testing.B) {
+	benchmarkSet(b, 8)
+}
+
+func BenchmarkSet_32(b *testing.B) {
+	benchmarkSet(b, 32)
+}
+
+func BenchmarkSet_64(b *testing.B) {
+	benchmarkSet(b, 64)
+}
+
+func BenchmarkSet_500(b *testing.B) {
+	benchmarkSet(b, 500)
+}
+
+func BenchmarkSet_512(b *testing.B) {
+	benchmarkSet(b, 512)
+}
+
+func BenchmarkSet_1000(b *testing.B) {
+	benchmarkSet(b, 1000)
+}
+
+func BenchmarkSet_1024(b *testing.B) {
+	benchmarkSet(b, 1024)
+}
+
+func BenchmarkSet_2000(b *testing.B) {
+	benchmarkSet(b, 2000)
+}
+
+func BenchmarkSet_2048(b *testing.B) {
+	benchmarkSet(b, 2048)
+}
+
+func BenchmarkSet_4000(b *testing.B) {
+	benchmarkSet(b, 4000)
+}
+
+func BenchmarkSet_4096(b *testing.B) {
+	benchmarkSet(b, 4096)
+}
+
+func BenchmarkSet_8000(b *testing.B) {
+	benchmarkSet(b, 8000)
+}
+
+func BenchmarkSet_8192(b *testing.B) {
+	benchmarkSet(b, 8192)
+}
diff --git a/go/arrow/memory/util.go b/go/arrow/memory/util.go
new file mode 100644
index 000000000..3b0d3a5cb
--- /dev/null
+++ b/go/arrow/memory/util.go
@@ -0,0 +1,37 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package memory
+
+import "unsafe"
+
+func roundToPowerOf2(v, round int) int {
+	forceCarry := round - 1
+	truncateMask := ^forceCarry
+	return (v + forceCarry) & truncateMask
+}
+
+func roundUpToMultipleOf64(v int) int {
+	return roundToPowerOf2(v, 64)
+}
+
+func isMultipleOfPowerOf2(v int, d int) bool {
+	return (v & (d - 1)) == 0
+}
+
+func addressOf(b []byte) uintptr {
+	return uintptr(unsafe.Pointer(&b[0]))
+}
diff --git a/go/arrow/memory/util_test.go b/go/arrow/memory/util_test.go
new file mode 100644
index 000000000..d8afe80a0
--- /dev/null
+++ b/go/arrow/memory/util_test.go
@@ -0,0 +1,61 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package memory
+
+import (
+	"fmt"
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+)
+
+func TestRoundToPowerOf2(t *testing.T) {
+	tests := []struct {
+		v, round int
+		exp      int
+	}{
+		{60, 64, 64},
+		{122, 64, 128},
+		{16, 64, 64},
+		{64, 64, 64},
+		{13, 8, 16},
+	}
+	for _, test := range tests {
+		t.Run(fmt.Sprintf("v%d_r%d", test.v, test.round), func(t *testing.T) {
+			a := roundToPowerOf2(test.v, test.round)
+			assert.Equal(t, test.exp, a)
+		})
+	}
+}
+
+func TestIsMultipleOfPowerOf2(t *testing.T) {
+	tests := []struct {
+		v, d int
+		exp  bool
+	}{
+		{200, 256, false},
+		{256, 256, true},
+		{500, 256, false},
+		{512, 256, true},
+	}
+	for _, test := range tests {
+		t.Run(fmt.Sprintf("%d_%d_%t", test.v, test.d, test.exp), func(t *testing.T) {
+			got := isMultipleOfPowerOf2(test.v, test.d)
+			assert.Equal(t, test.exp, got)
+		})
+	}
+}
diff --git a/go/arrow/metadata/schema.go b/go/arrow/metadata/schema.go
new file mode 100644
index 000000000..021b6ee53
--- /dev/null
+++ b/go/arrow/metadata/schema.go
@@ -0,0 +1,37 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package metadata
+
+import "github.com/apache/arrow/go/arrow"
+
+type Schema struct {
+	fields      []Field
+	nameToIndex map[string]int
+	metadata    KeyValueMetadata
+}
+
+type Field struct {
+	name     string           // Field name
+	typ      arrow.DataType   // The field's data type
+	nullable bool             // Fields can be nullable
+	metadata KeyValueMetadata // The field's metadata, if any
+}
+
+type KeyValueMetadata struct {
+	keys   []string
+	values []string
+}
diff --git a/go/arrow/numeric.schema.json b/go/arrow/numeric.schema.json
new file mode 100644
index 000000000..7fa2800a5
--- /dev/null
+++ b/go/arrow/numeric.schema.json
@@ -0,0 +1,15 @@
+{
+  "title": "templates",
+  "type": "array",
+  "items": {
+    "title": "template",
+    "type": "object",
+    "properties": {
+      "Name": {
+        "type": "string",
+        "description": "The name of the template type"
+      }
+    },
+    "required": ["Name"]
+  }
+}
\ No newline at end of file
diff --git a/go/arrow/numeric.tmpldata b/go/arrow/numeric.tmpldata
new file mode 100644
index 000000000..ea08d8bde
--- /dev/null
+++ b/go/arrow/numeric.tmpldata
@@ -0,0 +1,87 @@
+[
+  {
+    "Name": "Int64",
+    "name": "int64",
+    "Type": "int64",
+    "Default": "0",
+    "Size": "8"
+  },
+  {
+    "Name": "Uint64",
+    "name": "uint64",
+    "Type": "uint64",
+    "Default": "0",
+    "Size": "8"
+  },
+  {
+    "Name": "Float64",
+    "name": "float64",
+    "Type": "float64",
+    "Default": "0",
+    "Size": "8"
+  },
+  {
+    "Name": "Int32",
+    "name": "int32",
+    "Type": "int32",
+    "Default": "0",
+    "Size": "4",
+    "Opt": {
+      "BufferBuilder": true
+    }
+  },
+  {
+    "Name": "Uint32",
+    "name": "uint32",
+    "Type": "uint32",
+    "Default": "0",
+    "Size": "4"
+  },
+  {
+    "Name": "Float32",
+    "name": "float32",
+    "Type": "float32",
+    "Default": "0",
+    "Size": "4"
+  },
+  {
+    "Name": "Int16",
+    "name": "int16",
+    "Type": "int16",
+    "Default": "0",
+    "Size": "2"
+  },
+  {
+    "Name": "Uint16",
+    "name": "uint16",
+    "Type": "uint16",
+    "Default": "0",
+    "Size": "2"
+  },
+  {
+    "Name": "Int8",
+    "name": "int8",
+    "Type": "int8",
+    "Default": "0",
+    "Size": "1"
+  },
+  {
+    "Name": "Uint8",
+    "name": "uint8",
+    "Type": "uint8",
+    "Default": "0",
+    "Size": "1"
+  },
+  {
+    "Name": "Timestamp",
+    "name": "timestamp",
+    "Type": "Timestamp",
+    "QualifiedType": "arrow.Timestamp",
+    "InternalType": "int64",
+    "Default": "0",
+    "Size": "8",
+    "Opt": {
+      "Parametric": true
+    }
+  }
+]
\ No newline at end of file
diff --git a/go/arrow/type_string.go b/go/arrow/type_string.go
new file mode 100644
index 000000000..9c82dbad4
--- /dev/null
+++ b/go/arrow/type_string.go
@@ -0,0 +1,16 @@
+// Code generated by "stringer -type=Type"; DO NOT EDIT.
+
+package arrow
+
+import "fmt"
+
+const _Type_name = "NULLBOOLUINT8INT8UINT16INT16UINT32INT32UINT64INT64HALF_FLOATFLOAT32FLOAT64STRINGBINARYFIXED_SIZE_BINARYDATE32DATE64TIMESTAMPTIME32TIME64INTERVALDECIMALLISTSTRUCTUNIONDICTIONARYMAP"
+
+var _Type_index = [...]uint8{0, 4, 8, 13, 17, 23, 28, 34, 39, 45, 50, 60, 67, 74, 80, 86, 103, 109, 115, 124, 130, 136, 144, 151, 155, 161, 166, 176, 179}
+
+func (i Type) String() string {
+	if i < 0 || i >= Type(len(_Type_index)-1) {
+		return fmt.Sprintf("Type(%d)", i)
+	}
+	return _Type_name[_Type_index[i]:_Type_index[i+1]]
+}
diff --git a/go/arrow/type_traits_boolean.go b/go/arrow/type_traits_boolean.go
new file mode 100644
index 000000000..c30ae0fec
--- /dev/null
+++ b/go/arrow/type_traits_boolean.go
@@ -0,0 +1,28 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package arrow
+
+import (
+	"github.com/apache/arrow/go/arrow/internal/bitutil"
+)
+
+type booleanTraits struct{}
+
+var BooleanTraits booleanTraits
+
+// BytesRequired returns the number of bytes required to store n elements in memory.
+func (booleanTraits) BytesRequired(n int) int { return bitutil.CeilByte(n) / 8 }
diff --git a/go/arrow/type_traits_numeric.gen.go b/go/arrow/type_traits_numeric.gen.go
new file mode 100644
index 000000000..b51960b6d
--- /dev/null
+++ b/go/arrow/type_traits_numeric.gen.go
@@ -0,0 +1,567 @@
+// Code generated by type_traits_numeric.gen.go.tmpl. DO NOT EDIT.
+
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package arrow
+
+import (
+	"encoding/binary"
+	"reflect"
+	"unsafe"
+)
+
+var (
+	Int64Traits     int64Traits
+	Uint64Traits    uint64Traits
+	Float64Traits   float64Traits
+	Int32Traits     int32Traits
+	Uint32Traits    uint32Traits
+	Float32Traits   float32Traits
+	Int16Traits     int16Traits
+	Uint16Traits    uint16Traits
+	Int8Traits      int8Traits
+	Uint8Traits     uint8Traits
+	TimestampTraits timestampTraits
+)
+
+// Int64 traits
+
+const (
+	// Int64SizeBytes specifies the number of bytes required to store a single int64 in memory
+	Int64SizeBytes = int(unsafe.Sizeof(int64(0)))
+)
+
+type int64Traits struct{}
+
+// BytesRequired returns the number of bytes required to store n elements in memory.
+func (int64Traits) BytesRequired(n int) int { return Int64SizeBytes * n }
+
+// PutValue
+func (int64Traits) PutValue(b []byte, v int64) {
+	binary.LittleEndian.PutUint64(b, uint64(v))
+}
+
+// CastFromBytes reinterprets the slice b to a slice of type int64.
+//
+// NOTE: len(b) must be a multiple of Int64SizeBytes.
+func (int64Traits) CastFromBytes(b []byte) []int64 {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []int64
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len / Int64SizeBytes
+	s.Cap = h.Cap / Int64SizeBytes
+
+	return res
+}
+
+// CastToBytes reinterprets the slice b to a slice of bytes.
+func (int64Traits) CastToBytes(b []int64) []byte {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []byte
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len * Int64SizeBytes
+	s.Cap = h.Cap * Int64SizeBytes
+
+	return res
+}
+
+// Copy copies src to dst.
+func (int64Traits) Copy(dst, src []int64) { copy(dst, src) }
+
+// Uint64 traits
+
+const (
+	// Uint64SizeBytes specifies the number of bytes required to store a single uint64 in memory
+	Uint64SizeBytes = int(unsafe.Sizeof(uint64(0)))
+)
+
+type uint64Traits struct{}
+
+// BytesRequired returns the number of bytes required to store n elements in memory.
+func (uint64Traits) BytesRequired(n int) int { return Uint64SizeBytes * n }
+
+// PutValue
+func (uint64Traits) PutValue(b []byte, v uint64) {
+	binary.LittleEndian.PutUint64(b, uint64(v))
+}
+
+// CastFromBytes reinterprets the slice b to a slice of type uint64.
+//
+// NOTE: len(b) must be a multiple of Uint64SizeBytes.
+func (uint64Traits) CastFromBytes(b []byte) []uint64 {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []uint64
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len / Uint64SizeBytes
+	s.Cap = h.Cap / Uint64SizeBytes
+
+	return res
+}
+
+// CastToBytes reinterprets the slice b to a slice of bytes.
+func (uint64Traits) CastToBytes(b []uint64) []byte {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []byte
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len * Uint64SizeBytes
+	s.Cap = h.Cap * Uint64SizeBytes
+
+	return res
+}
+
+// Copy copies src to dst.
+func (uint64Traits) Copy(dst, src []uint64) { copy(dst, src) }
+
+// Float64 traits
+
+const (
+	// Float64SizeBytes specifies the number of bytes required to store a single float64 in memory
+	Float64SizeBytes = int(unsafe.Sizeof(float64(0)))
+)
+
+type float64Traits struct{}
+
+// BytesRequired returns the number of bytes required to store n elements in memory.
+func (float64Traits) BytesRequired(n int) int { return Float64SizeBytes * n }
+
+// PutValue
+func (float64Traits) PutValue(b []byte, v float64) {
+	binary.LittleEndian.PutUint64(b, uint64(v))
+}
+
+// CastFromBytes reinterprets the slice b to a slice of type float64.
+//
+// NOTE: len(b) must be a multiple of Float64SizeBytes.
+func (float64Traits) CastFromBytes(b []byte) []float64 {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []float64
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len / Float64SizeBytes
+	s.Cap = h.Cap / Float64SizeBytes
+
+	return res
+}
+
+// CastToBytes reinterprets the slice b to a slice of bytes.
+func (float64Traits) CastToBytes(b []float64) []byte {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []byte
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len * Float64SizeBytes
+	s.Cap = h.Cap * Float64SizeBytes
+
+	return res
+}
+
+// Copy copies src to dst.
+func (float64Traits) Copy(dst, src []float64) { copy(dst, src) }
+
+// Int32 traits
+
+const (
+	// Int32SizeBytes specifies the number of bytes required to store a single int32 in memory
+	Int32SizeBytes = int(unsafe.Sizeof(int32(0)))
+)
+
+type int32Traits struct{}
+
+// BytesRequired returns the number of bytes required to store n elements in memory.
+func (int32Traits) BytesRequired(n int) int { return Int32SizeBytes * n }
+
+// PutValue
+func (int32Traits) PutValue(b []byte, v int32) {
+	binary.LittleEndian.PutUint32(b, uint32(v))
+}
+
+// CastFromBytes reinterprets the slice b to a slice of type int32.
+//
+// NOTE: len(b) must be a multiple of Int32SizeBytes.
+func (int32Traits) CastFromBytes(b []byte) []int32 {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []int32
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len / Int32SizeBytes
+	s.Cap = h.Cap / Int32SizeBytes
+
+	return res
+}
+
+// CastToBytes reinterprets the slice b to a slice of bytes.
+func (int32Traits) CastToBytes(b []int32) []byte {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []byte
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len * Int32SizeBytes
+	s.Cap = h.Cap * Int32SizeBytes
+
+	return res
+}
+
+// Copy copies src to dst.
+func (int32Traits) Copy(dst, src []int32) { copy(dst, src) }
+
+// Uint32 traits
+
+const (
+	// Uint32SizeBytes specifies the number of bytes required to store a single uint32 in memory
+	Uint32SizeBytes = int(unsafe.Sizeof(uint32(0)))
+)
+
+type uint32Traits struct{}
+
+// BytesRequired returns the number of bytes required to store n elements in memory.
+func (uint32Traits) BytesRequired(n int) int { return Uint32SizeBytes * n }
+
+// PutValue
+func (uint32Traits) PutValue(b []byte, v uint32) {
+	binary.LittleEndian.PutUint32(b, uint32(v))
+}
+
+// CastFromBytes reinterprets the slice b to a slice of type uint32.
+//
+// NOTE: len(b) must be a multiple of Uint32SizeBytes.
+func (uint32Traits) CastFromBytes(b []byte) []uint32 {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []uint32
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len / Uint32SizeBytes
+	s.Cap = h.Cap / Uint32SizeBytes
+
+	return res
+}
+
+// CastToBytes reinterprets the slice b to a slice of bytes.
+func (uint32Traits) CastToBytes(b []uint32) []byte {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []byte
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len * Uint32SizeBytes
+	s.Cap = h.Cap * Uint32SizeBytes
+
+	return res
+}
+
+// Copy copies src to dst.
+func (uint32Traits) Copy(dst, src []uint32) { copy(dst, src) }
+
+// Float32 traits
+
+const (
+	// Float32SizeBytes specifies the number of bytes required to store a single float32 in memory
+	Float32SizeBytes = int(unsafe.Sizeof(float32(0)))
+)
+
+type float32Traits struct{}
+
+// BytesRequired returns the number of bytes required to store n elements in memory.
+func (float32Traits) BytesRequired(n int) int { return Float32SizeBytes * n }
+
+// PutValue
+func (float32Traits) PutValue(b []byte, v float32) {
+	binary.LittleEndian.PutUint32(b, uint32(v))
+}
+
+// CastFromBytes reinterprets the slice b to a slice of type float32.
+//
+// NOTE: len(b) must be a multiple of Float32SizeBytes.
+func (float32Traits) CastFromBytes(b []byte) []float32 {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []float32
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len / Float32SizeBytes
+	s.Cap = h.Cap / Float32SizeBytes
+
+	return res
+}
+
+// CastToBytes reinterprets the slice b to a slice of bytes.
+func (float32Traits) CastToBytes(b []float32) []byte {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []byte
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len * Float32SizeBytes
+	s.Cap = h.Cap * Float32SizeBytes
+
+	return res
+}
+
+// Copy copies src to dst.
+func (float32Traits) Copy(dst, src []float32) { copy(dst, src) }
+
+// Int16 traits
+
+const (
+	// Int16SizeBytes specifies the number of bytes required to store a single int16 in memory
+	Int16SizeBytes = int(unsafe.Sizeof(int16(0)))
+)
+
+type int16Traits struct{}
+
+// BytesRequired returns the number of bytes required to store n elements in memory.
+func (int16Traits) BytesRequired(n int) int { return Int16SizeBytes * n }
+
+// PutValue
+func (int16Traits) PutValue(b []byte, v int16) {
+	binary.LittleEndian.PutUint16(b, uint16(v))
+}
+
+// CastFromBytes reinterprets the slice b to a slice of type int16.
+//
+// NOTE: len(b) must be a multiple of Int16SizeBytes.
+func (int16Traits) CastFromBytes(b []byte) []int16 {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []int16
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len / Int16SizeBytes
+	s.Cap = h.Cap / Int16SizeBytes
+
+	return res
+}
+
+// CastToBytes reinterprets the slice b to a slice of bytes.
+func (int16Traits) CastToBytes(b []int16) []byte {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []byte
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len * Int16SizeBytes
+	s.Cap = h.Cap * Int16SizeBytes
+
+	return res
+}
+
+// Copy copies src to dst.
+func (int16Traits) Copy(dst, src []int16) { copy(dst, src) }
+
+// Uint16 traits
+
+const (
+	// Uint16SizeBytes specifies the number of bytes required to store a single uint16 in memory
+	Uint16SizeBytes = int(unsafe.Sizeof(uint16(0)))
+)
+
+type uint16Traits struct{}
+
+// BytesRequired returns the number of bytes required to store n elements in memory.
+func (uint16Traits) BytesRequired(n int) int { return Uint16SizeBytes * n }
+
+// PutValue
+func (uint16Traits) PutValue(b []byte, v uint16) {
+	binary.LittleEndian.PutUint16(b, uint16(v))
+}
+
+// CastFromBytes reinterprets the slice b to a slice of type uint16.
+//
+// NOTE: len(b) must be a multiple of Uint16SizeBytes.
+func (uint16Traits) CastFromBytes(b []byte) []uint16 {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []uint16
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len / Uint16SizeBytes
+	s.Cap = h.Cap / Uint16SizeBytes
+
+	return res
+}
+
+// CastToBytes reinterprets the slice b to a slice of bytes.
+func (uint16Traits) CastToBytes(b []uint16) []byte {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []byte
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len * Uint16SizeBytes
+	s.Cap = h.Cap * Uint16SizeBytes
+
+	return res
+}
+
+// Copy copies src to dst.
+func (uint16Traits) Copy(dst, src []uint16) { copy(dst, src) }
+
+// Int8 traits
+
+const (
+	// Int8SizeBytes specifies the number of bytes required to store a single int8 in memory
+	Int8SizeBytes = int(unsafe.Sizeof(int8(0)))
+)
+
+type int8Traits struct{}
+
+// BytesRequired returns the number of bytes required to store n elements in memory.
+func (int8Traits) BytesRequired(n int) int { return Int8SizeBytes * n }
+
+// PutValue
+func (int8Traits) PutValue(b []byte, v int8) {
+	b[0] = byte(v)
+}
+
+// CastFromBytes reinterprets the slice b to a slice of type int8.
+//
+// NOTE: len(b) must be a multiple of Int8SizeBytes.
+func (int8Traits) CastFromBytes(b []byte) []int8 {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []int8
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len / Int8SizeBytes
+	s.Cap = h.Cap / Int8SizeBytes
+
+	return res
+}
+
+// CastToBytes reinterprets the slice b to a slice of bytes.
+func (int8Traits) CastToBytes(b []int8) []byte {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []byte
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len * Int8SizeBytes
+	s.Cap = h.Cap * Int8SizeBytes
+
+	return res
+}
+
+// Copy copies src to dst.
+func (int8Traits) Copy(dst, src []int8) { copy(dst, src) }
+
+// Uint8 traits
+
+const (
+	// Uint8SizeBytes specifies the number of bytes required to store a single uint8 in memory
+	Uint8SizeBytes = int(unsafe.Sizeof(uint8(0)))
+)
+
+type uint8Traits struct{}
+
+// BytesRequired returns the number of bytes required to store n elements in memory.
+func (uint8Traits) BytesRequired(n int) int { return Uint8SizeBytes * n }
+
+// PutValue
+func (uint8Traits) PutValue(b []byte, v uint8) {
+	b[0] = byte(v)
+}
+
+// CastFromBytes reinterprets the slice b to a slice of type uint8.
+//
+// NOTE: len(b) must be a multiple of Uint8SizeBytes.
+func (uint8Traits) CastFromBytes(b []byte) []uint8 {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []uint8
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len / Uint8SizeBytes
+	s.Cap = h.Cap / Uint8SizeBytes
+
+	return res
+}
+
+// CastToBytes reinterprets the slice b to a slice of bytes.
+func (uint8Traits) CastToBytes(b []uint8) []byte {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []byte
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len * Uint8SizeBytes
+	s.Cap = h.Cap * Uint8SizeBytes
+
+	return res
+}
+
+// Copy copies src to dst.
+func (uint8Traits) Copy(dst, src []uint8) { copy(dst, src) }
+
+// Timestamp traits
+
+const (
+	// TimestampSizeBytes specifies the number of bytes required to store a single Timestamp in memory
+	TimestampSizeBytes = int(unsafe.Sizeof(Timestamp(0)))
+)
+
+type timestampTraits struct{}
+
+// BytesRequired returns the number of bytes required to store n elements in memory.
+func (timestampTraits) BytesRequired(n int) int { return TimestampSizeBytes * n }
+
+// PutValue
+func (timestampTraits) PutValue(b []byte, v Timestamp) {
+	binary.LittleEndian.PutUint64(b, uint64(v))
+}
+
+// CastFromBytes reinterprets the slice b to a slice of type Timestamp.
+//
+// NOTE: len(b) must be a multiple of TimestampSizeBytes.
+func (timestampTraits) CastFromBytes(b []byte) []Timestamp {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []Timestamp
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len / TimestampSizeBytes
+	s.Cap = h.Cap / TimestampSizeBytes
+
+	return res
+}
+
+// CastToBytes reinterprets the slice b to a slice of bytes.
+func (timestampTraits) CastToBytes(b []Timestamp) []byte {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []byte
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len * TimestampSizeBytes
+	s.Cap = h.Cap * TimestampSizeBytes
+
+	return res
+}
+
+// Copy copies src to dst.
+func (timestampTraits) Copy(dst, src []Timestamp) { copy(dst, src) }
diff --git a/go/arrow/type_traits_numeric.gen.go.tmpl b/go/arrow/type_traits_numeric.gen.go.tmpl
new file mode 100644
index 000000000..362d2d850
--- /dev/null
+++ b/go/arrow/type_traits_numeric.gen.go.tmpl
@@ -0,0 +1,89 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package arrow
+
+import (
+	"encoding/binary"
+	"reflect"
+	"unsafe"
+)
+
+var (
+{{range .In}}
+	{{.Name}}Traits {{.name}}Traits
+{{- end}}
+)
+
+{{range .In}}
+// {{.Name}} traits
+
+const (
+	// {{.Name}}SizeBytes specifies the number of bytes required to store a single {{.Type}} in memory
+	{{.Name}}SizeBytes = int(unsafe.Sizeof({{.Type}}({{.Default}})))
+)
+
+type {{.name}}Traits struct{}
+
+// BytesRequired returns the number of bytes required to store n elements in memory.
+func ({{.name}}Traits) BytesRequired(n int) int { return {{.Name}}SizeBytes * n }
+
+// PutValue
+func ({{.name}}Traits) PutValue(b []byte, v {{.Type}}) {
+{{- if eq .Size "1" -}}
+	b[0] = byte(v)
+{{- else if eq .Size "2" -}}
+	binary.LittleEndian.PutUint16(b, uint16(v))
+{{- else if eq .Size "4" -}}
+	binary.LittleEndian.PutUint32(b, uint32(v))
+{{- else if eq .Size "8" -}}
+	binary.LittleEndian.PutUint64(b, uint64(v))
+{{- else -}}
+	panic("invalid type {{.Type}}")
+{{end}}
+}
+
+// CastFromBytes reinterprets the slice b to a slice of type {{.Type}}.
+//
+// NOTE: len(b) must be a multiple of {{.Name}}SizeBytes.
+func ({{.name}}Traits) CastFromBytes(b []byte) []{{.Type}} {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []{{.Type}}
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len/{{.Name}}SizeBytes
+	s.Cap = h.Cap/{{.Name}}SizeBytes
+
+	return res
+}
+
+// CastToBytes reinterprets the slice b to a slice of bytes.
+func ({{.name}}Traits) CastToBytes(b []{{.Type}}) []byte {
+	h := (*reflect.SliceHeader)(unsafe.Pointer(&b))
+
+	var res []byte
+	s := (*reflect.SliceHeader)(unsafe.Pointer(&res))
+	s.Data = h.Data
+	s.Len = h.Len*{{.Name}}SizeBytes
+	s.Cap = h.Cap*{{.Name}}SizeBytes
+
+	return res
+}
+
+// Copy copies src to dst.
+func ({{.name}}Traits) Copy(dst, src []{{.Type}}) { copy(dst, src) }
+{{end}}
\ No newline at end of file
diff --git a/java/format/pom.xml b/java/format/pom.xml
index 3e6582d3f..4ff5a4ee7 100644
--- a/java/format/pom.xml
+++ b/java/format/pom.xml
@@ -15,7 +15,7 @@
 <parent>
   <artifactId>arrow-java-root</artifactId>
   <groupId>org.apache.arrow</groupId>
-  <version>0.9.0-SNAPSHOT</version>
+  <version>0.10.0-SNAPSHOT</version>
 </parent>
 
 <artifactId>arrow-format</artifactId>
diff --git a/java/memory/pom.xml b/java/memory/pom.xml
index 74ec45c1d..59c14d4af 100644
--- a/java/memory/pom.xml
+++ b/java/memory/pom.xml
@@ -14,7 +14,7 @@
   <parent>
     <groupId>org.apache.arrow</groupId>
     <artifactId>arrow-java-root</artifactId>
-    <version>0.9.0-SNAPSHOT</version>
+    <version>0.10.0-SNAPSHOT</version>
   </parent>
   <artifactId>arrow-memory</artifactId>
   <name>Arrow Memory</name>
diff --git a/java/pom.xml b/java/pom.xml
index 152deaa9c..6bb807f43 100644
--- a/java/pom.xml
+++ b/java/pom.xml
@@ -20,7 +20,7 @@
 
   <groupId>org.apache.arrow</groupId>
   <artifactId>arrow-java-root</artifactId>
-  <version>0.9.0-SNAPSHOT</version>
+  <version>0.10.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>Apache Arrow Java Root POM</name>
diff --git a/java/tools/pom.xml b/java/tools/pom.xml
index 246f264a6..964f0c85b 100644
--- a/java/tools/pom.xml
+++ b/java/tools/pom.xml
@@ -14,7 +14,7 @@
     <parent>
         <groupId>org.apache.arrow</groupId>
         <artifactId>arrow-java-root</artifactId>
-        <version>0.9.0-SNAPSHOT</version>
+        <version>0.10.0-SNAPSHOT</version>
     </parent>
     <artifactId>arrow-tools</artifactId>
     <name>Arrow Tools</name>
diff --git a/java/vector/pom.xml b/java/vector/pom.xml
index 0f3e03e69..5a8915a90 100644
--- a/java/vector/pom.xml
+++ b/java/vector/pom.xml
@@ -14,7 +14,7 @@
   <parent>
     <groupId>org.apache.arrow</groupId>
     <artifactId>arrow-java-root</artifactId>
-    <version>0.9.0-SNAPSHOT</version>
+    <version>0.10.0-SNAPSHOT</version>
   </parent>
   <artifactId>arrow-vector</artifactId>
   <name>Arrow Vectors</name>
diff --git a/python/doc/source/conf.py b/python/doc/source/conf.py
index 25e6d5e2d..1e35ef935 100644
--- a/python/doc/source/conf.py
+++ b/python/doc/source/conf.py
@@ -165,7 +165,9 @@
 # further.  For a list of options available for each theme, see the
 # documentation.
 #
-# html_theme_options = {}
+html_theme_options = {
+    'nosidebar': True
+}
 
 # Add any paths that contain custom themes here, relative to this directory.
 html_theme_path = sphinx_bootstrap_theme.get_html_theme_path()
diff --git a/python/manylinux1/scripts/build_boost.sh b/python/manylinux1/scripts/build_boost.sh
index 47d826251..80b79ab80 100755
--- a/python/manylinux1/scripts/build_boost.sh
+++ b/python/manylinux1/scripts/build_boost.sh
@@ -16,7 +16,7 @@
 # specific language governing permissions and limitations
 # under the License.
 
-BOOST_VERSION=1.65.1
+BOOST_VERSION=1.66.0
 BOOST_VERSION_UNDERSCORE=${BOOST_VERSION//\./_}
 
 wget --no-check-certificate https://dl.bintray.com/boostorg/release/${BOOST_VERSION}/source/boost_${BOOST_VERSION_UNDERSCORE}.tar.gz -O /boost_${BOOST_VERSION_UNDERSCORE}.tar.gz
diff --git a/python/pyarrow/array.pxi b/python/pyarrow/array.pxi
index 8dac57d18..afb68a2fb 100644
--- a/python/pyarrow/array.pxi
+++ b/python/pyarrow/array.pxi
@@ -344,7 +344,7 @@ cdef class Array:
         """
         Convert pandas.Series to an Arrow Array, using pandas's semantics about
         what values indicate nulls. See pyarrow.array for more general
-        conversion from arrays or sequences to Arrow arrays
+        conversion from arrays or sequences to Arrow arrays.
 
         Parameters
         ----------
@@ -372,6 +372,41 @@ cdef class Array:
         return array(obj, mask=mask, type=type, memory_pool=memory_pool,
                      from_pandas=True)
 
+    @staticmethod
+    def from_buffers(DataType type, length, buffers, null_count=-1, offset=0):
+        """
+        Construct an Array from a sequence of buffers.  The concrete type
+        returned depends on the datatype.
+
+        Parameters
+        ----------
+        type : DataType
+            The value type of the array
+        length : int
+            The number of values in the array
+        buffers: List[Buffer]
+            The buffers backing this array
+        null_count : int, default -1
+        offset : int, default 0
+            The array's logical offset (in values, not in bytes) from the
+            start of each buffer
+
+        Returns
+        -------
+        array : Array
+        """
+        cdef:
+            Buffer buf
+            vector[shared_ptr[CBuffer]] c_buffers
+            shared_ptr[CArrayData] ad
+
+        for buf in buffers:
+            # None will produce a null buffer pointer
+            c_buffers.push_back(pyarrow_unwrap_buffer(buf))
+        ad = CArrayData.Make(type.sp_type, length, c_buffers,
+                             null_count, offset)
+        return pyarrow_wrap_array(MakeArray(ad))
+
     property null_count:
 
         def __get__(self):
@@ -787,6 +822,7 @@ cdef class UnionArray(Array):
             check_status(CUnionArray.MakeSparse(deref(types.ap), c, &out))
         return pyarrow_wrap_array(out)
 
+
 cdef class StringArray(Array):
 
     @staticmethod
@@ -824,6 +860,7 @@ cdef class StringArray(Array):
             null_count, offset))
         return pyarrow_wrap_array(out)
 
+
 cdef class BinaryArray(Array):
     pass
 
diff --git a/python/pyarrow/includes/libarrow.pxd b/python/pyarrow/includes/libarrow.pxd
index 589103635..f1032495e 100644
--- a/python/pyarrow/includes/libarrow.pxd
+++ b/python/pyarrow/includes/libarrow.pxd
@@ -98,6 +98,13 @@ cdef extern from "arrow/api.h" namespace "arrow" nogil:
         vector[shared_ptr[CBuffer]] buffers
         vector[shared_ptr[CArrayData]] child_data
 
+        @staticmethod
+        shared_ptr[CArrayData] Make(const shared_ptr[CDataType]& type,
+                                    int64_t length,
+                                    vector[shared_ptr[CBuffer]]& buffers,
+                                    int64_t null_count,
+                                    int64_t offset)
+
     cdef cppclass CArray" arrow::Array":
         shared_ptr[CDataType] type()
 
diff --git a/python/pyarrow/lib.pxd b/python/pyarrow/lib.pxd
index e4d574f18..be103b354 100644
--- a/python/pyarrow/lib.pxd
+++ b/python/pyarrow/lib.pxd
@@ -56,11 +56,6 @@ cdef class DictionaryType(DataType):
         const CDictionaryType* dict_type
 
 
-cdef class UnionType(DataType):
-    cdef:
-        list child_types
-
-
 cdef class TimestampType(DataType):
     cdef:
         const CTimestampType* ts_type
diff --git a/python/pyarrow/scalar.pxi b/python/pyarrow/scalar.pxi
index 2692ace40..a0f8480db 100644
--- a/python/pyarrow/scalar.pxi
+++ b/python/pyarrow/scalar.pxi
@@ -334,9 +334,9 @@ cdef class UnionValue(ArrayValue):
         cdef int8_t type_id = self.ap.raw_type_ids()[i]
         cdef shared_ptr[CArray] child = self.ap.child(type_id)
         if self.ap.mode() == _UnionMode_SPARSE:
-            return box_scalar(self.type[type_id], child, i)
+            return box_scalar(self.type[type_id].type, child, i)
         else:
-            return box_scalar(self.type[type_id], child,
+            return box_scalar(self.type[type_id].type, child,
                               self.ap.value_offset(i))
 
     def as_py(self):
diff --git a/python/pyarrow/tests/test_array.py b/python/pyarrow/tests/test_array.py
index 6faf4566b..d126db373 100644
--- a/python/pyarrow/tests/test_array.py
+++ b/python/pyarrow/tests/test_array.py
@@ -178,6 +178,26 @@ def test_array_eq_raises():
         arr1 == arr2
 
 
+def test_array_from_buffers():
+    values_buf = pa.py_buffer(np.int16([4, 5, 6, 7]))
+    nulls_buf = pa.py_buffer(np.uint8([0b00001101]))
+    arr = pa.Array.from_buffers(pa.int16(), 4, [nulls_buf, values_buf])
+    assert arr.type == pa.int16()
+    assert arr.to_pylist() == [4, None, 6, 7]
+
+    arr = pa.Array.from_buffers(pa.int16(), 4, [None, values_buf])
+    assert arr.type == pa.int16()
+    assert arr.to_pylist() == [4, 5, 6, 7]
+
+    arr = pa.Array.from_buffers(pa.int16(), 3, [nulls_buf, values_buf],
+                                offset=1)
+    assert arr.type == pa.int16()
+    assert arr.to_pylist() == [None, 6, 7]
+
+    with pytest.raises(TypeError):
+        pa.Array.from_buffers(pa.int16(), 3, [u'', u''], offset=1)
+
+
 def test_dictionary_from_numpy():
     indices = np.repeat([0, 1, 2], 2)
     dictionary = np.array(['foo', 'bar', 'baz'], dtype=object)
diff --git a/python/pyarrow/tests/test_types.py b/python/pyarrow/tests/test_types.py
index ad683e9a2..b5170203c 100644
--- a/python/pyarrow/tests/test_types.py
+++ b/python/pyarrow/tests/test_types.py
@@ -15,12 +15,44 @@
 # specific language governing permissions and limitations
 # under the License.
 
+import pickle
+
 import pytest
 
 import pyarrow as pa
 import pyarrow.types as types
 
 
+MANY_TYPES = [
+    pa.null(),
+    pa.bool_(),
+    pa.int32(),
+    pa.time32('s'),
+    pa.time64('us'),
+    pa.date32(),
+    pa.timestamp('us'),
+    pa.timestamp('us', tz='UTC'),
+    pa.timestamp('us', tz='Europe/Paris'),
+    pa.float16(),
+    pa.float32(),
+    pa.float64(),
+    pa.decimal128(19, 4),
+    pa.string(),
+    pa.binary(),
+    pa.binary(10),
+    pa.list_(pa.int32()),
+    pa.struct([pa.field('a', pa.int32()),
+               pa.field('b', pa.int8()),
+               pa.field('c', pa.string())]),
+    pa.union([pa.field('a', pa.binary(10)),
+              pa.field('b', pa.string())], mode=pa.lib.UnionMode_DENSE),
+    pa.union([pa.field('a', pa.binary(10)),
+              pa.field('b', pa.string())], mode=pa.lib.UnionMode_SPARSE),
+    # XXX Needs array pickling
+    # pa.dictionary(pa.int32(), pa.array(['a', 'b', 'c'])),
+]
+
+
 def test_is_boolean():
     assert types.is_boolean(pa.bool_())
     assert not types.is_boolean(pa.int8())
@@ -88,10 +120,11 @@ def test_is_nested_or_struct():
 
 
 def test_is_union():
-    assert types.is_union(pa.union([pa.field('a', pa.int32()),
-                                    pa.field('b', pa.int8()),
-                                    pa.field('c', pa.string())],
-                                   pa.lib.UnionMode_SPARSE))
+    for mode in [pa.lib.UnionMode_SPARSE, pa.lib.UnionMode_DENSE]:
+        assert types.is_union(pa.union([pa.field('a', pa.int32()),
+                                        pa.field('b', pa.int8()),
+                                        pa.field('c', pa.string())],
+                                       mode=mode))
     assert not types.is_union(pa.list_(pa.int32()))
 
 
@@ -141,28 +174,39 @@ def test_timestamp_type():
     assert isinstance(pa.timestamp('ns'), pa.TimestampType)
 
 
-def test_types_hashable():
-    types = [
-        pa.null(),
-        pa.int32(),
-        pa.time32('s'),
-        pa.time64('us'),
-        pa.date32(),
-        pa.timestamp('us'),
-        pa.string(),
-        pa.binary(),
-        pa.binary(10),
-        pa.list_(pa.int32()),
-        pa.struct([pa.field('a', pa.int32()),
-                   pa.field('b', pa.int8()),
-                   pa.field('c', pa.string())])
-    ]
+def test_union_type():
+    def check_fields(ty, fields):
+        assert ty.num_children == len(fields)
+        assert [ty[i] for i in range(ty.num_children)] == fields
+
+    fields = [pa.field('x', pa.list_(pa.int32())),
+              pa.field('y', pa.binary())]
+    for mode in ('sparse', pa.lib.UnionMode_SPARSE):
+        ty = pa.union(fields, mode=mode)
+        assert ty.mode == 'sparse'
+        check_fields(ty, fields)
+    for mode in ('dense', pa.lib.UnionMode_DENSE):
+        ty = pa.union(fields, mode=mode)
+        assert ty.mode == 'dense'
+        check_fields(ty, fields)
+    for mode in ('unknown', 2):
+        with pytest.raises(ValueError, match='Invalid union mode'):
+            pa.union(fields, mode=mode)
 
+
+def test_types_hashable():
     in_dict = {}
-    for i, type_ in enumerate(types):
+    for i, type_ in enumerate(MANY_TYPES):
         assert hash(type_) == hash(type_)
         in_dict[type_] = i
         assert in_dict[type_] == i
+    assert len(in_dict) == len(MANY_TYPES)
+
+
+def test_types_picklable():
+    for ty in MANY_TYPES:
+        data = pickle.dumps(ty)
+        assert pickle.loads(data) == ty
 
 
 @pytest.mark.parametrize('t,check_func', [
diff --git a/python/pyarrow/types.pxi b/python/pyarrow/types.pxi
index 5f962901c..a4391c7f9 100644
--- a/python/pyarrow/types.pxi
+++ b/python/pyarrow/types.pxi
@@ -189,9 +189,6 @@ cdef class UnionType(DataType):
 
     cdef void init(self, const shared_ptr[CDataType]& type):
         DataType.init(self, type)
-        self.child_types = [
-            pyarrow_wrap_data_type(type.get().child(i).get().type())
-            for i in range(self.num_children)]
 
     property num_children:
 
@@ -202,20 +199,25 @@ cdef class UnionType(DataType):
 
         def __get__(self):
             cdef CUnionType* type = <CUnionType*> self.sp_type.get()
-            return type.mode()
+            cdef int mode = type.mode()
+            if mode == _UnionMode_DENSE:
+                return 'dense'
+            if mode == _UnionMode_SPARSE:
+                return 'sparse'
+            assert 0
 
     def __getitem__(self, i):
-        return self.child_types[i]
+        return pyarrow_wrap_field(self.type.child(i))
 
     def __getstate__(self):
-        children = [pyarrow_wrap_field(self.type.child(i))
-                    for i in range(self.num_children)]
+        children = [self[i] for i in range(self.num_children)]
         return children, self.mode
 
     def __setstate__(self, state):
         cdef DataType reconstituted = union(*state)
         self.init(reconstituted.sp_type)
 
+
 cdef class TimestampType(DataType):
 
     cdef void init(self, const shared_ptr[CDataType]& type):
@@ -245,6 +247,13 @@ cdef class TimestampType(DataType):
             # Return DatetimeTZ
             return pdcompat.make_datetimetz(self.tz)
 
+    def __getstate__(self):
+        return self.unit, self.tz
+
+    def __setstate__(self, state):
+        cdef DataType reconstituted = timestamp(*state)
+        self.init(reconstituted.sp_type)
+
 
 cdef class Time32Type(DataType):
 
@@ -1145,6 +1154,16 @@ def struct(fields):
 def union(children_fields, mode):
     """
     Create UnionType from children fields.
+
+    Parameters
+    ----------
+    fields : sequence of Field values
+    mode : str
+        'dense' or 'sparse'
+
+    Returns
+    -------
+    type : DataType
     """
     cdef:
         Field child_field
@@ -1153,22 +1172,34 @@ def union(children_fields, mode):
         shared_ptr[CDataType] union_type
         int i
 
+    if isinstance(mode, int):
+        if mode not in (_UnionMode_SPARSE, _UnionMode_DENSE):
+            raise ValueError("Invalid union mode {0!r}".format(mode))
+    else:
+        if mode == 'sparse':
+            mode = _UnionMode_SPARSE
+        elif mode == 'dense':
+            mode = _UnionMode_DENSE
+        else:
+            raise ValueError("Invalid union mode {0!r}".format(mode))
+
     for i, child_field in enumerate(children_fields):
         type_codes.push_back(i)
         c_fields.push_back(child_field.sp_field)
 
-        if mode == UnionMode_SPARSE:
-            union_type.reset(new CUnionType(c_fields, type_codes,
-                                            _UnionMode_SPARSE))
-        else:
-            union_type.reset(new CUnionType(c_fields, type_codes,
-                                            _UnionMode_DENSE))
+    if mode == UnionMode_SPARSE:
+        union_type.reset(new CUnionType(c_fields, type_codes,
+                                        _UnionMode_SPARSE))
+    else:
+        union_type.reset(new CUnionType(c_fields, type_codes,
+                                        _UnionMode_DENSE))
 
     return pyarrow_wrap_data_type(union_type)
 
 
 cdef dict _type_aliases = {
     'null': null,
+    'bool': bool_,
     'i1': int8,
     'int8': int8,
     'i2': int16,
@@ -1185,9 +1216,14 @@ cdef dict _type_aliases = {
     'uint32': uint32,
     'u8': uint64,
     'uint64': uint64,
+    'f2': float16,
+    'halffloat': float16,
+    'float16': float16,
     'f4': float32,
+    'float': float32,
     'float32': float32,
     'f8': float64,
+    'double': float64,
     'float64': float64,
     'string': string,
     'str': string,
diff --git a/python/setup.py b/python/setup.py
index 453626020..cf44b1e43 100644
--- a/python/setup.py
+++ b/python/setup.py
@@ -111,7 +111,7 @@ def initialize_options(self):
         _build_ext.initialize_options(self)
         self.extra_cmake_args = os.environ.get('PYARROW_CMAKE_OPTIONS', '')
         self.build_type = os.environ.get('PYARROW_BUILD_TYPE', 'debug').lower()
-        self.boost_namespace = os.environ.get('PYARROW_BOOST_NAMESPACE')
+        self.boost_namespace = os.environ.get('PYARROW_BOOST_NAMESPACE', 'boost')
 
         self.cmake_cxxflags = os.environ.get('PYARROW_CXXFLAGS', '')
 
@@ -208,7 +208,7 @@ def _run_cmake(self):
             cmake_options.append('-DCMAKE_BUILD_TYPE={0}'
                                  .format(self.build_type.lower()))
 
-            if self.boost_namespace is not None:
+            if self.boost_namespace != 'boost':
                 cmake_options.append('-DBoost_NAMESPACE={}'
                                      .format(self.boost_namespace))
 
diff --git a/site/_data/contributors.yml b/site/_data/contributors.yml
index 19ca53ad4..9289542fd 100644
--- a/site/_data/contributors.yml
+++ b/site/_data/contributors.yml
@@ -35,4 +35,7 @@
 - name: Siddharth Teotia
   apacheId: siddharthteotia
   githubId: siddharthteotia
+- name: The Apache Arrow PMC
+  apacheId: pmc
+  githubId: pmc
 # End contributors.yml
diff --git a/site/_data/versions.yml b/site/_data/versions.yml
index 0d0418386..461480fe5 100644
--- a/site/_data/versions.yml
+++ b/site/_data/versions.yml
@@ -17,13 +17,13 @@
 # Blogs and other pages use this data
 #
 current:
-  number: '0.8.0'
-  date: '18 December 2017'
-  git-tag: '1d689e5'
-  github-tag-link: 'https://github.com/apache/arrow/releases/tag/apache-arrow-0.8.0'
-  release-notes: 'http://arrow.apache.org/release/0.8.0.html'
-  mirrors: 'https://www.apache.org/dyn/closer.cgi/arrow/arrow-0.8.0/'
-  mirrors-tar: 'https://www.apache.org/dyn/closer.cgi/arrow/arrow-0.8.0/apache-arrow-0.8.0.tar.gz'
-  java-artifacts: 'http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.apache.arrow%22%20AND%20v%3A%220.8.0%22'
-  asc: 'https://www.apache.org/dist/arrow/arrow-0.8.0/apache-arrow-0.8.0.tar.gz.asc'
-  sha512: 'https://www.apache.org/dist/arrow/arrow-0.8.0/apache-arrow-0.8.0.tar.gz.sha512'
\ No newline at end of file
+  number: '0.9.0'
+  date: '21 March 2018'
+  git-tag: 'c695a5d'
+  github-tag-link: 'https://github.com/apache/arrow/releases/tag/apache-arrow-0.9.0'
+  release-notes: 'http://arrow.apache.org/release/0.9.0.html'
+  mirrors: 'https://www.apache.org/dyn/closer.cgi/arrow/arrow-0.9.0/'
+  mirrors-tar: 'https://www.apache.org/dyn/closer.cgi/arrow/arrow-0.9.0/apache-arrow-0.9.0.tar.gz'
+  java-artifacts: 'http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.apache.arrow%22%20AND%20v%3A%220.9.0%22'
+  asc: 'https://www.apache.org/dist/arrow/arrow-0.9.0/apache-arrow-0.9.0.tar.gz.asc'
+  sha512: 'https://www.apache.org/dist/arrow/arrow-0.9.0/apache-arrow-0.9.0.tar.gz.sha512'
diff --git a/site/_posts/2017-12-19-0.8.0-release.md b/site/_posts/2017-12-19-0.8.0-release.md
index 8c1f464ed..1ecc93999 100644
--- a/site/_posts/2017-12-19-0.8.0-release.md
+++ b/site/_posts/2017-12-19-0.8.0-release.md
@@ -25,7 +25,7 @@ limitations under the License.
 -->
 
 The Apache Arrow team is pleased to announce the 0.8.0 release. It is the
-product of 10 weeks of development andincludes [**286 resolved JIRAs**][1] with
+product of 10 weeks of development and includes [**286 resolved JIRAs**][1] with
 many new features and bug fixes to the various language implementations. This
 is the largest release since 0.3.0 earlier this year.
 
diff --git a/site/_posts/2018-03-22-0.9.0-release.md b/site/_posts/2018-03-22-0.9.0-release.md
new file mode 100644
index 000000000..e8778d55e
--- /dev/null
+++ b/site/_posts/2018-03-22-0.9.0-release.md
@@ -0,0 +1,100 @@
+---
+layout: post
+title: "Apache Arrow 0.9.0 Release"
+date: "2018-03-22 00:00:00 -0400"
+author: wesm
+categories: [release]
+---
+<!--
+{% comment %}
+Licensed to the Apache Software Foundation (ASF) under one or more
+contributor license agreements.  See the NOTICE file distributed with
+this work for additional information regarding copyright ownership.
+The ASF licenses this file to you under the Apache License, Version 2.0
+(the "License"); you may not use this file except in compliance with
+the License.  You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+{% endcomment %}
+-->
+
+The Apache Arrow team is pleased to announce the 0.9.0 release. It is the
+product of over 3 months of development and includes [**260 resolved
+JIRAs**][1].
+
+While we made some of backwards-incompatible columnar binary format changes in
+last December's 0.8.0 release, the 0.9.0 release is backwards-compatible with
+0.8.0. We will be working toward a 1.0.0 release this year, which will mark
+longer-term binary stability for the Arrow columnar format and metadata.
+
+See the [Install Page][2] to learn how to get the libraries for your
+platform. The [complete changelog][3] is also available.
+
+We discuss some highlights from the release and other project news in this
+post. This release has been overall focused more on bug fixes, compatibility,
+and stability compared with previous releases which have pushed more on new and
+expanded features.
+
+## New Arrow committers and PMC members
+
+Since the last release, we have added 2 new Arrow committers: [Brian
+Hulette][4] and [Robert Nishihara][5]. Additionally, [Phillip Cloud][6] and
+[Philipp Moritz][7] have been promoted from committer to PMC
+member. Congratulations and thank you for your contributions!
+
+## Plasma Object Store Improvements
+
+The Plasma Object Store now supports managing interprocess shared memory on
+CUDA-enabled GPUs. We are excited to see more GPU-related functionality develop
+in Apache Arrow, as this has become a key computing environment for scalable
+machine learning.
+
+## Python Improvements
+
+[Antoine Pitrou][8] has joined the Python development efforts and helped
+significantly this release with interoperability with built-in CPython data
+structures and NumPy structured data types.
+
+* New experimental support for reading Apache ORC files
+* `pyarrow.array` now accepts lists of tuples or Python dicts for creating
+  Arrow struct type arrays.
+* NumPy structured dtypes (which are row/record-oriented) can be directly
+  converted to Arrow struct (column-oriented) arrays
+* Python 3.6 `pathlib` objects for file paths are now accepted in many file
+  APIs, including for Parquet files
+* Arrow integer arrays with nulls can now be converted to NumPy object arrays
+  with `None` values
+* New `pyarrow.foreign_buffer` API for interacting with memory blocks located
+  at particular memory addresses
+
+## Java Improvements
+
+Java now fully supports the `FixedSizeBinary` data type.
+
+## JavaScript Improvements
+
+The JavaScript library has been significantly refactored and expanded. We are
+making separate Apache releases (most recently `JS-0.3.1`) for JavaScript,
+which are being [published to NPM][9].
+
+## Upcoming Roadmap
+
+In the coming months, we will be working to move Apache Arrow closer to a 1.0.0
+release. We will also be discussing plans to develop native Arrow-based
+computational libraries within the project.
+
+[1]: https://issues.apache.org/jira/issues/?jql=project%20%3D%20ARROW%20AND%20status%20in%20(Resolved%2C%20Closed)%20AND%20fixVersion%20%3D%200.9.0
+[2]: https://arrow.apache.org/install
+[3]: https://arrow.apache.org/release/0.8.0.html
+[4]: https://github.com/theneuralbit
+[5]: https://github.com/robertnishihara
+[6]: https://github.com/cpcloud
+[7]: https://github.com/pcmoritz
+[8]: https://github.com/pitrou
+[9]: https://www.npmjs.com/package/apache-arrow
\ No newline at end of file
diff --git a/site/_posts/2018-03-22-go-code-donation.md b/site/_posts/2018-03-22-go-code-donation.md
new file mode 100644
index 000000000..41ddace9e
--- /dev/null
+++ b/site/_posts/2018-03-22-go-code-donation.md
@@ -0,0 +1,82 @@
+---
+layout: post
+title: "A Native Go Library for Apache Arrow"
+date: "2018-03-22 00:00:00 -0400"
+author: pmc
+categories: [application]
+---
+<!--
+{% comment %}
+Licensed to the Apache Software Foundation (ASF) under one or more
+contributor license agreements.  See the NOTICE file distributed with
+this work for additional information regarding copyright ownership.
+The ASF licenses this file to you under the Apache License, Version 2.0
+(the "License"); you may not use this file except in compliance with
+the License.  You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+{% endcomment %}
+-->
+
+Since launching in early 2016, Apache Arrow has been growing fast. We have made
+nine major releases through the efforts of over 120 distinct contributors. The
+project’s scope has also expanded. We began by focusing on the development of
+the standardized in-memory columnar data format, which now serves as a pillar
+of the project. Since then, we have been growing into a more general
+cross-language platform for in-memory data analysis through new additions to
+the project like the [Plasma shared memory object store][1]. A primary goal of
+the project is to enable data system developers to process and move data fast.
+
+So far, we officially have developed native Arrow implementations in C++, Java,
+and JavaScript. We have created binding layers for the C++ libraries in C
+(using the GLib libraries) and Python. We have also seen efforts to develop
+interfaces to the Arrow C++ libraries in Go, Lua, Ruby, and Rust. While binding
+layers serve many purposes, there can be benefits to native implementations,
+and so we’ve been keen to see future work on native implementations in growing
+systems languages like Go and Rust.
+
+This past October, engineers [Stuart Carnie][2], [Nathaniel Cook][3], and
+[Chris Goller][4], employees of [InfluxData][5], began developing a native [Go
+language implementation of the [Apache Arrow][6] in-memory columnar format for
+use in Go-based database systems like InfluxDB. We are excited to announce that
+InfluxData has [donated this native Go implementation to the Apache Arrow
+project][10], where it will continue to be developed. This work features
+low-level integration with the Go runtime and native support for SIMD
+instruction sets. We are looking forward to working more closely with the Go
+community on solving in-memory analytics and data interoperability problems.
+
+<div align="center">
+<img src="{{ site.base-url }}/img/native_go_implementation.png"
+     alt="Apache Arrow implementations and bindings"
+     width="60%" class="img-responsive">
+</div>
+
+One of the mantras in [The Apache Software Foundation][7] is "Community over
+Code". By building an open and collaborative development community across many
+programming language ecosystems, we will be able to development better and
+longer-lived solutions to the systems problems faced by data developers.
+
+We are excited for what the future holds for the Apache Arrow project. Adding
+first-class support for a popular systems programming language like Go is an
+important step along the way. We welcome others from the Go community to get
+involved in the project. We also welcome others who wish to explore building
+Arrow support for other programming languages not yet represented. Learn more
+at [https://arrow.apache.org][9] and join the mailing list
+[dev@arrow.apache.org][8].
+
+[1]: http://arrow.apache.org/blog/2017/08/16/0.6.0-release/
+[2]: https://github.com/stuartcarnie
+[3]: https://github.com/nathanielc
+[4]: https://github.com/goller
+[5]: https://influxdata.com
+[6]: https://github.com/influxdata/arrow
+[7]: https://www.apache.org
+[8]: https://lists.apache.org/list.html?dev@arrow.apache.org
+[9]: https://arrow.apache.org
+[10]: https://www.businesswire.com/news/home/20180322005393/en/InfluxData-Announces-Language-Implementation-Contribution-Apache-Arrow
\ No newline at end of file
diff --git a/site/_release/0.9.0.md b/site/_release/0.9.0.md
new file mode 100644
index 000000000..1c8f5444d
--- /dev/null
+++ b/site/_release/0.9.0.md
@@ -0,0 +1,334 @@
+---
+layout: default
+title: Apache Arrow 0.9.0 Release
+permalink: /release/0.9.0.html
+---
+<!--
+{% comment %}
+Licensed to the Apache Software Foundation (ASF) under one or more
+contributor license agreements.  See the NOTICE file distributed with
+this work for additional information regarding copyright ownership.
+The ASF licenses this file to you under the Apache License, Version 2.0
+(the "License"); you may not use this file except in compliance with
+the License.  You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+{% endcomment %}
+-->
+
+# Apache Arrow 0.9.0 (21 March 2018)
+
+This is a major release.
+
+## Download
+
+* [**Source Artifacts**][2]
+* [Git tag][1]
+
+## Contributors
+
+```shell
+$ git shortlog -sn apache-arrow-0.8.0..apache-arrow-0.9.0
+    52  Wes McKinney
+    52  Antoine Pitrou
+    25  Uwe L. Korn
+    14  Paul Taylor
+    13  Kouhei Sutou
+    13  Phillip Cloud
+     9  Robert Nishihara
+     9  Korn, Uwe
+     9  Jim Crist
+     8  Brian Hulette
+     7  Philipp Moritz
+     6  Panchen Xue
+     6  yosuke shiro
+     5  Mitar
+     5  Bryan Cutler
+     4  siddharth
+     3  Adam Seibert
+     3  Licht-T
+     3  moriyoshi
+     2  rvernica
+     2  Sidd
+     2  Albert Shieh
+     1  Marco Neumann
+     1  Max Risuhin
+     1  Jin Hai
+     1  Jeffrey Heer
+     1  Jacques Nadeau
+     1  Ehsan Totoni
+     1  Dimitri Vorona
+     1  Chris Bartak
+     1  Simbarashe Nyatsanga
+     1  Cheng Lian
+     1  Viktor Gal
+     1  Andy Grove
+     1  William Paul
+     1  devin-petersohn
+```
+
+# Changelog
+
+## New Features and Improvements
+
+* [ARROW-1021](https://issues.apache.org/jira/browse/ARROW-1021) - [Python] Add documentation about using pyarrow from other Cython and C++ projects
+* [ARROW-1035](https://issues.apache.org/jira/browse/ARROW-1035) - [Python] Add ASV benchmarks for streaming columnar deserialization
+* [ARROW-1394](https://issues.apache.org/jira/browse/ARROW-1394) - [Plasma] Add optional extension for allocating memory on GPUs
+* [ARROW-1463](https://issues.apache.org/jira/browse/ARROW-1463) - [JAVA] Restructure ValueVector hierarchy to minimize compile-time generated code
+* [ARROW-1579](https://issues.apache.org/jira/browse/ARROW-1579) - [Java] Add dockerized test setup to validate Spark integration
+* [ARROW-1580](https://issues.apache.org/jira/browse/ARROW-1580) - [Python] Instructions for setting up nightly builds on Linux
+* [ARROW-1623](https://issues.apache.org/jira/browse/ARROW-1623) - [C++] Add convenience method to construct Buffer from a string that owns its memory
+* [ARROW-1632](https://issues.apache.org/jira/browse/ARROW-1632) - [Python] Permit categorical conversions in Table.to_pandas on a per-column basis
+* [ARROW-1643](https://issues.apache.org/jira/browse/ARROW-1643) - [Python] Accept hdfs:// prefixes in parquet.read_table and attempt to connect to HDFS
+* [ARROW-1705](https://issues.apache.org/jira/browse/ARROW-1705) - [Python] Create StructArray from sequence of dicts given a known data type
+* [ARROW-1706](https://issues.apache.org/jira/browse/ARROW-1706) - [Python] StructArray.from_arrays should handle sequences that are coercible to arrays
+* [ARROW-1712](https://issues.apache.org/jira/browse/ARROW-1712) - [C++] Add method to BinaryBuilder to reserve space for value data
+* [ARROW-1757](https://issues.apache.org/jira/browse/ARROW-1757) - [C++] Add DictionaryArray::FromArrays alternate ctor that can check or sanitized "untrusted" indices
+* [ARROW-1815](https://issues.apache.org/jira/browse/ARROW-1815) - [Java] Rename MapVector to StructVector
+* [ARROW-1832](https://issues.apache.org/jira/browse/ARROW-1832) - [JS] Implement JSON reader for integration tests
+* [ARROW-1835](https://issues.apache.org/jira/browse/ARROW-1835) - [C++] Create Arrow schema from std::tuple types
+* [ARROW-1861](https://issues.apache.org/jira/browse/ARROW-1861) - [Python] Fix up ASV setup, add developer instructions for writing new benchmarks and running benchmark suite locally
+* [ARROW-1872](https://issues.apache.org/jira/browse/ARROW-1872) - [Website] Populate hard-coded fields for current release from a YAML file
+* [ARROW-1920](https://issues.apache.org/jira/browse/ARROW-1920) - Add support for reading ORC files
+* [ARROW-1926](https://issues.apache.org/jira/browse/ARROW-1926) - [GLib] Add garrow_timestamp_data_type_get_unit()
+* [ARROW-1927](https://issues.apache.org/jira/browse/ARROW-1927) - [Plasma] Implement delete function
+* [ARROW-1929](https://issues.apache.org/jira/browse/ARROW-1929) - [C++] Move various Arrow testing utility code from Parquet to Arrow codebase
+* [ARROW-1930](https://issues.apache.org/jira/browse/ARROW-1930) - [C++] Implement Slice for ChunkedArray and Column
+* [ARROW-1931](https://issues.apache.org/jira/browse/ARROW-1931) - [C++] w4996 warning due to std::tr1 failing builds on Visual Studio 2017
+* [ARROW-1937](https://issues.apache.org/jira/browse/ARROW-1937) - [Python] Add documentation for different forms of constructing nested arrays from Python data structures 
+* [ARROW-1942](https://issues.apache.org/jira/browse/ARROW-1942) - [C++] Hash table specializations for small integers
+* [ARROW-1947](https://issues.apache.org/jira/browse/ARROW-1947) - [Plasma] Change Client Create and Get to use Buffers
+* [ARROW-1951](https://issues.apache.org/jira/browse/ARROW-1951) - Add memcopy_threads to serialization context
+* [ARROW-1962](https://issues.apache.org/jira/browse/ARROW-1962) - [Java] Add reset() to ValueVector interface
+* [ARROW-1965](https://issues.apache.org/jira/browse/ARROW-1965) - [GLib] Add garrow_array_builder_get_value_data_type() and garrow_array_builder_get_value_type()
+* [ARROW-1969](https://issues.apache.org/jira/browse/ARROW-1969) - [C++] Do not build ORC adapter by default
+* [ARROW-1970](https://issues.apache.org/jira/browse/ARROW-1970) - [GLib] Add garrow_chunked_array_get_value_data_type() and garrow_chunked_array_get_value_type()
+* [ARROW-1977](https://issues.apache.org/jira/browse/ARROW-1977) - [C++] Update windows dev docs
+* [ARROW-1978](https://issues.apache.org/jira/browse/ARROW-1978) - [Website] Add more visible link to "Powered By" page to front page, simplify Powered By
+* [ARROW-2004](https://issues.apache.org/jira/browse/ARROW-2004) - [C++] Add shrink_to_fit option in BufferBuilder::Resize
+* [ARROW-2007](https://issues.apache.org/jira/browse/ARROW-2007) - [Python] Sequence converter for float32 not implemented
+* [ARROW-2011](https://issues.apache.org/jira/browse/ARROW-2011) - Allow setting the pickler to use in pyarrow serialization.
+* [ARROW-2012](https://issues.apache.org/jira/browse/ARROW-2012) - [GLib] Support "make distclean"
+* [ARROW-2018](https://issues.apache.org/jira/browse/ARROW-2018) - [C++] Build instruction on macOS and Homebrew is incomplete
+* [ARROW-2019](https://issues.apache.org/jira/browse/ARROW-2019) - Control the memory allocated for inner vector in LIST
+* [ARROW-2024](https://issues.apache.org/jira/browse/ARROW-2024) - [Python] Remove global SerializationContext variables
+* [ARROW-2028](https://issues.apache.org/jira/browse/ARROW-2028) - [Python] extra_cmake_args needs to be passed through shlex.split
+* [ARROW-2031](https://issues.apache.org/jira/browse/ARROW-2031) - HadoopFileSystem isn't pickleable
+* [ARROW-2035](https://issues.apache.org/jira/browse/ARROW-2035) - [C++] Update vendored cpplint.py to a Py3-compatible one
+* [ARROW-2036](https://issues.apache.org/jira/browse/ARROW-2036) - NativeFile should support standard IOBase methods
+* [ARROW-2042](https://issues.apache.org/jira/browse/ARROW-2042) - [Plasma] Revert API change of plasma::Create to output a MutableBuffer
+* [ARROW-2043](https://issues.apache.org/jira/browse/ARROW-2043) - [C++] Change description from OS X to macOS
+* [ARROW-2046](https://issues.apache.org/jira/browse/ARROW-2046) - [Python] Add support for PEP519 - pathlib and similar objects
+* [ARROW-2048](https://issues.apache.org/jira/browse/ARROW-2048) - [Python/C++] Upate Thrift pin to 0.11
+* [ARROW-2050](https://issues.apache.org/jira/browse/ARROW-2050) - Support `setup.py pytest` to automatically fetch the test dependencies
+* [ARROW-2052](https://issues.apache.org/jira/browse/ARROW-2052) - Unify OwnedRef and ScopedRef
+* [ARROW-2054](https://issues.apache.org/jira/browse/ARROW-2054) - Compilation warnings
+* [ARROW-2064](https://issues.apache.org/jira/browse/ARROW-2064) - [GLib] Add common build problems link to the install section
+* [ARROW-2065](https://issues.apache.org/jira/browse/ARROW-2065) - Fix bug in SerializationContext.clone().
+* [ARROW-2068](https://issues.apache.org/jira/browse/ARROW-2068) - [Python] Expose Array's buffers to Python users
+* [ARROW-2069](https://issues.apache.org/jira/browse/ARROW-2069) - [Python] Document that Plasma is not (yet) supported on Windows
+* [ARROW-2071](https://issues.apache.org/jira/browse/ARROW-2071) - [Python] Reduce runtime of builds in Travis CI
+* [ARROW-2073](https://issues.apache.org/jira/browse/ARROW-2073) - [Python] Create StructArray from sequence of tuples given a known data type
+* [ARROW-2076](https://issues.apache.org/jira/browse/ARROW-2076) - [Python] Display slowest test durations
+* [ARROW-2083](https://issues.apache.org/jira/browse/ARROW-2083) - Support skipping builds
+* [ARROW-2084](https://issues.apache.org/jira/browse/ARROW-2084) - [C++] Support newer Brotli static library names
+* [ARROW-2086](https://issues.apache.org/jira/browse/ARROW-2086) - [Python] Shrink size of arrow_manylinux1_x86_64_base docker image
+* [ARROW-2087](https://issues.apache.org/jira/browse/ARROW-2087) - [Python] Binaries of 3rdparty are not stripped in manylinux1 base image
+* [ARROW-2088](https://issues.apache.org/jira/browse/ARROW-2088) - [GLib] Add GArrowNumericArray
+* [ARROW-2089](https://issues.apache.org/jira/browse/ARROW-2089) - [GLib] Rename to GARROW_TYPE_BOOLEAN for consistency
+* [ARROW-2090](https://issues.apache.org/jira/browse/ARROW-2090) - [Python] Add context manager methods to ParquetWriter
+* [ARROW-2093](https://issues.apache.org/jira/browse/ARROW-2093) - [Python] Possibly do not test pytorch serialization in Travis CI
+* [ARROW-2094](https://issues.apache.org/jira/browse/ARROW-2094) - [Python] Use toolchain libraries and PROTOBUF_HOME for protocol buffers
+* [ARROW-2095](https://issues.apache.org/jira/browse/ARROW-2095) - [C++] Suppress ORC EP build logging by default
+* [ARROW-2096](https://issues.apache.org/jira/browse/ARROW-2096) - [C++] Turn off Boost_DEBUG to trim build output
+* [ARROW-2099](https://issues.apache.org/jira/browse/ARROW-2099) - [Python] Support DictionaryArray::FromArrays in Python bindings
+* [ARROW-2107](https://issues.apache.org/jira/browse/ARROW-2107) - [GLib] Follow arrow::gpu::CudaIpcMemHandle API change
+* [ARROW-2108](https://issues.apache.org/jira/browse/ARROW-2108) - [Python] Update instructions for ASV
+* [ARROW-2110](https://issues.apache.org/jira/browse/ARROW-2110) - [Python] Only require pytest-runner on test commands
+* [ARROW-2111](https://issues.apache.org/jira/browse/ARROW-2111) - [C++] Linting could be faster
+* [ARROW-2114](https://issues.apache.org/jira/browse/ARROW-2114) - [Python] Pull latest docker manylinux1 image
+* [ARROW-2117](https://issues.apache.org/jira/browse/ARROW-2117) - [C++] Pin clang to version 5.0
+* [ARROW-2118](https://issues.apache.org/jira/browse/ARROW-2118) - [Python] Improve error message when calling parquet.read_table on an empty file
+* [ARROW-2120](https://issues.apache.org/jira/browse/ARROW-2120) - Add possibility to use empty _MSVC_STATIC_LIB_SUFFIX for Thirdparties
+* [ARROW-2121](https://issues.apache.org/jira/browse/ARROW-2121) - [Python] Consider special casing object arrays in pandas serializers.
+* [ARROW-2123](https://issues.apache.org/jira/browse/ARROW-2123) - [JS] Upgrade to TS 2.7.1
+* [ARROW-2132](https://issues.apache.org/jira/browse/ARROW-2132) - [Doc] Add links / mentions of Plasma store to main README
+* [ARROW-2134](https://issues.apache.org/jira/browse/ARROW-2134) - [CI] Make Travis commit inspection more robust
+* [ARROW-2137](https://issues.apache.org/jira/browse/ARROW-2137) - [Python] Don't print paths that are ignored when reading Parquet files
+* [ARROW-2138](https://issues.apache.org/jira/browse/ARROW-2138) - [C++] Have FatalLog abort instead of exiting
+* [ARROW-2142](https://issues.apache.org/jira/browse/ARROW-2142) - [Python] Conversion from Numpy struct array unimplemented
+* [ARROW-2143](https://issues.apache.org/jira/browse/ARROW-2143) - [Python] Provide a manylinux1 wheel for cp27m
+* [ARROW-2146](https://issues.apache.org/jira/browse/ARROW-2146) - [GLib] Implement Slice for ChunkedArray
+* [ARROW-2149](https://issues.apache.org/jira/browse/ARROW-2149) - [Python] reorganize test_convert_pandas.py
+* [ARROW-2154](https://issues.apache.org/jira/browse/ARROW-2154) - [Python] __eq__ unimplemented on Buffer
+* [ARROW-2155](https://issues.apache.org/jira/browse/ARROW-2155) - [Python] pa.frombuffer(bytearray) returns immutable Buffer
+* [ARROW-2156](https://issues.apache.org/jira/browse/ARROW-2156) - [CI] Isolate Sphinx dependencies
+* [ARROW-2163](https://issues.apache.org/jira/browse/ARROW-2163) - Install apt dependencies separate from built-in Travis commands, retry on flakiness
+* [ARROW-2166](https://issues.apache.org/jira/browse/ARROW-2166) - [GLib] Implement Slice for Column
+* [ARROW-2168](https://issues.apache.org/jira/browse/ARROW-2168) - [C++] Build toolchain builds with jemalloc
+* [ARROW-2169](https://issues.apache.org/jira/browse/ARROW-2169) - [C++] MSVC is complaining about uncaptured variables
+* [ARROW-2174](https://issues.apache.org/jira/browse/ARROW-2174) - [JS] Export format and schema enums
+* [ARROW-2176](https://issues.apache.org/jira/browse/ARROW-2176) - [C++] Extend DictionaryBuilder to support delta dictionaries
+* [ARROW-2177](https://issues.apache.org/jira/browse/ARROW-2177) - [C++] Remove support for specifying negative scale values in DecimalType
+* [ARROW-2180](https://issues.apache.org/jira/browse/ARROW-2180) - [C++] Remove APIs deprecated in 0.8.0 release
+* [ARROW-2181](https://issues.apache.org/jira/browse/ARROW-2181) - [Python] Add concat_tables to API reference, add documentation on use
+* [ARROW-2184](https://issues.apache.org/jira/browse/ARROW-2184) - [C++] Add static constructor for FileOutputStream returning shared_ptr to base OutputStream
+* [ARROW-2185](https://issues.apache.org/jira/browse/ARROW-2185) - Remove CI directives from squashed commit messages
+* [ARROW-2190](https://issues.apache.org/jira/browse/ARROW-2190) - [GLib] Add add/remove field functions for RecordBatch.
+* [ARROW-2191](https://issues.apache.org/jira/browse/ARROW-2191) - [C++] Only use specific version of jemalloc
+* [ARROW-2197](https://issues.apache.org/jira/browse/ARROW-2197) - Document "undefined symbol" issue and workaround
+* [ARROW-2198](https://issues.apache.org/jira/browse/ARROW-2198) - [Python] Docstring for parquet.read_table is misleading or incorrect
+* [ARROW-2199](https://issues.apache.org/jira/browse/ARROW-2199) - [JAVA] Follow up fixes for ARROW-2019. Ensure density driven capacity is never less than 1 and propagate density throughout the vector tree
+* [ARROW-2203](https://issues.apache.org/jira/browse/ARROW-2203) - [C++] StderrStream class
+* [ARROW-2204](https://issues.apache.org/jira/browse/ARROW-2204) - [C++] Build fails with TLS error on parquet-cpp clone
+* [ARROW-2205](https://issues.apache.org/jira/browse/ARROW-2205) - [Python] Option for integer object nulls
+* [ARROW-2206](https://issues.apache.org/jira/browse/ARROW-2206) - [JS] Add Perspective as a community project
+* [ARROW-2218](https://issues.apache.org/jira/browse/ARROW-2218) - [Python] PythonFile should infer mode when not given
+* [ARROW-2231](https://issues.apache.org/jira/browse/ARROW-2231) - [CI] Use clcache on AppVeyor
+* [ARROW-2238](https://issues.apache.org/jira/browse/ARROW-2238) - [C++] Detect clcache in cmake configuration
+* [ARROW-2239](https://issues.apache.org/jira/browse/ARROW-2239) - [C++] Update build docs for Windows
+* [ARROW-2250](https://issues.apache.org/jira/browse/ARROW-2250) - plasma_store process should cleanup on INT and TERM signals
+* [ARROW-2252](https://issues.apache.org/jira/browse/ARROW-2252) - [Python] Create buffer from address, size and base
+* [ARROW-2253](https://issues.apache.org/jira/browse/ARROW-2253) - [Python] Support __eq__ on scalar values
+* [ARROW-2261](https://issues.apache.org/jira/browse/ARROW-2261) - [GLib] Can't share the same memory in GArrowBuffer safely
+* [ARROW-2262](https://issues.apache.org/jira/browse/ARROW-2262) - [Python] Support slicing on pyarrow.ChunkedArray
+* [ARROW-2279](https://issues.apache.org/jira/browse/ARROW-2279) - [Python] Better error message if lib cannot be found
+* [ARROW-2282](https://issues.apache.org/jira/browse/ARROW-2282) - [Python] Create StringArray from buffers
+* [ARROW-2283](https://issues.apache.org/jira/browse/ARROW-2283) - [C++] Support Arrow C++ installed in /usr detection by pkg-config
+* [ARROW-2289](https://issues.apache.org/jira/browse/ARROW-2289) - [GLib] Add  Numeric, Integer and FloatingPoint data types
+* [ARROW-2291](https://issues.apache.org/jira/browse/ARROW-2291) - [C++] README missing instructions for libboost-regex-dev
+* [ARROW-2292](https://issues.apache.org/jira/browse/ARROW-2292) - [Python] More consistent / intuitive name for pyarrow.frombuffer
+* [ARROW-2309](https://issues.apache.org/jira/browse/ARROW-2309) - [C++] Use std::make_unsigned
+* [ARROW-232](https://issues.apache.org/jira/browse/ARROW-232) - C++/Parquet: Support writing chunked arrays as part of a table 
+* [ARROW-2321](https://issues.apache.org/jira/browse/ARROW-2321) - [C++] Release verification script fails with if CMAKE_INSTALL_LIBDIR is not $ARROW_HOME/lib
+* [ARROW-633](https://issues.apache.org/jira/browse/ARROW-633) - [Java] Add support for FixedSizeBinary type
+* [ARROW-634](https://issues.apache.org/jira/browse/ARROW-634) - Add integration tests for FixedSizeBinary
+* [ARROW-764](https://issues.apache.org/jira/browse/ARROW-764) - [C++] Improve performance of CopyBitmap, add benchmarks
+* [ARROW-969](https://issues.apache.org/jira/browse/ARROW-969) - [C++/Python] Add add/remove field functions for RecordBatch
+
+## Bug Fixes
+
+* [ARROW-1345](https://issues.apache.org/jira/browse/ARROW-1345) - [Python] Conversion from nested NumPy arrays fails on integers other than int64, float32
+* [ARROW-1589](https://issues.apache.org/jira/browse/ARROW-1589) - [C++] Fuzzing for certain input formats
+* [ARROW-1646](https://issues.apache.org/jira/browse/ARROW-1646) - [Python] pyarrow.array cannot handle NumPy scalar types
+* [ARROW-1856](https://issues.apache.org/jira/browse/ARROW-1856) - [Python] Auto-detect Parquet ABI version when using PARQUET_HOME
+* [ARROW-1909](https://issues.apache.org/jira/browse/ARROW-1909) - [C++] Bug: Build fails on windows with "-DARROW_BUILD_BENCHMARKS=ON"
+* [ARROW-1912](https://issues.apache.org/jira/browse/ARROW-1912) - [Website] Add org affiliations to committers.html
+* [ARROW-1919](https://issues.apache.org/jira/browse/ARROW-1919) - Plasma hanging if object id is not 20 bytes
+* [ARROW-1924](https://issues.apache.org/jira/browse/ARROW-1924) - [Python] Bring back pickle=True option for serialization
+* [ARROW-1933](https://issues.apache.org/jira/browse/ARROW-1933) - [GLib] Build failure with --with-arrow-cpp-build-dir and GPU enabled Arrow C++
+* [ARROW-1940](https://issues.apache.org/jira/browse/ARROW-1940) - [Python] Extra metadata gets added after multiple conversions between pd.DataFrame and pa.Table
+* [ARROW-1941](https://issues.apache.org/jira/browse/ARROW-1941) - Table <–> DataFrame roundtrip failing
+* [ARROW-1943](https://issues.apache.org/jira/browse/ARROW-1943) - Handle setInitialCapacity() for deeply nested lists of lists
+* [ARROW-1944](https://issues.apache.org/jira/browse/ARROW-1944) - FindArrow has wrong ARROW_STATIC_LIB
+* [ARROW-1945](https://issues.apache.org/jira/browse/ARROW-1945) - [C++] Fix doxygen documentation of array.h
+* [ARROW-1946](https://issues.apache.org/jira/browse/ARROW-1946) - Add APIs to decimal vector for writing big endian data
+* [ARROW-1948](https://issues.apache.org/jira/browse/ARROW-1948) - [Java] ListVector does not handle ipc with all non-null values with none set
+* [ARROW-1950](https://issues.apache.org/jira/browse/ARROW-1950) - [Python] pandas_type in pandas metadata incorrect for List types
+* [ARROW-1953](https://issues.apache.org/jira/browse/ARROW-1953) - [JS] JavaScript builds broken on master
+* [ARROW-1958](https://issues.apache.org/jira/browse/ARROW-1958) - [Python] Error in pandas conversion for datetimetz row index
+* [ARROW-1961](https://issues.apache.org/jira/browse/ARROW-1961) - [Python] Writing Parquet file with flavor='spark' loses pandas schema metadata
+* [ARROW-1966](https://issues.apache.org/jira/browse/ARROW-1966) - [C++] Support JAVA_HOME paths in HDFS libjvm loading that include the jre directory
+* [ARROW-1971](https://issues.apache.org/jira/browse/ARROW-1971) - [Python] Add pandas serialization to the default
+* [ARROW-1972](https://issues.apache.org/jira/browse/ARROW-1972) - Deserialization of buffer objects (and pandas dataframes) segfaults on different processes.
+* [ARROW-1973](https://issues.apache.org/jira/browse/ARROW-1973) - [Python] Memory leak when converting Arrow tables with array columns to Pandas dataframes.
+* [ARROW-1976](https://issues.apache.org/jira/browse/ARROW-1976) - [Python] Handling unicode pandas columns on parquet.read_table
+* [ARROW-1979](https://issues.apache.org/jira/browse/ARROW-1979) - [JS] JS builds handing in es2015:umd tests
+* [ARROW-1980](https://issues.apache.org/jira/browse/ARROW-1980) - [Python] Race condition in `write_to_dataset`
+* [ARROW-1982](https://issues.apache.org/jira/browse/ARROW-1982) - [Python] Return parquet statistics min/max as values instead of strings
+* [ARROW-1991](https://issues.apache.org/jira/browse/ARROW-1991) - [GLib] Docker-based documentation build is broken
+* [ARROW-1992](https://issues.apache.org/jira/browse/ARROW-1992) - [Python] to_pandas crashes when using strings_to_categoricals on empty string cols on 0.8.0
+* [ARROW-1997](https://issues.apache.org/jira/browse/ARROW-1997) - [Python] to_pandas with strings_to_categorical fails
+* [ARROW-1998](https://issues.apache.org/jira/browse/ARROW-1998) - [Python] Table.from_pandas crashes when data frame is empty
+* [ARROW-1999](https://issues.apache.org/jira/browse/ARROW-1999) - [Python] from_numpy_dtype returns wrong types
+* [ARROW-2000](https://issues.apache.org/jira/browse/ARROW-2000) - Deduplicate file descriptors when plasma store replies to get request.
+* [ARROW-2002](https://issues.apache.org/jira/browse/ARROW-2002) - use pyarrow download file will raise queue.Full exceptions sometimes
+* [ARROW-2003](https://issues.apache.org/jira/browse/ARROW-2003) - [Python] Do not use deprecated kwarg in pandas.core.internals.make_block
+* [ARROW-2005](https://issues.apache.org/jira/browse/ARROW-2005) - [Python] pyflakes warnings on Cython files not failing build
+* [ARROW-2008](https://issues.apache.org/jira/browse/ARROW-2008) - [Python] Type inference for int32 NumPy arrays (expecting list<int32>) returns int64 and then conversion fails
+* [ARROW-2010](https://issues.apache.org/jira/browse/ARROW-2010) - [C++] Compiler warnings with CHECKIN warning level in ORC adapter
+* [ARROW-2017](https://issues.apache.org/jira/browse/ARROW-2017) - Array initialization with  large (>2**31-1) uint64 values fails
+* [ARROW-2023](https://issues.apache.org/jira/browse/ARROW-2023) - [C++] Test opening IPC stream reader or file reader on an empty InputStream
+* [ARROW-2025](https://issues.apache.org/jira/browse/ARROW-2025) - [Python/C++] HDFS Client disconnect closes all open clients
+* [ARROW-2029](https://issues.apache.org/jira/browse/ARROW-2029) - [Python] Program crash on `HdfsFile.tell` if file is closed
+* [ARROW-2032](https://issues.apache.org/jira/browse/ARROW-2032) - [C++] ORC ep installs on each call to ninja build (even if no work to do)
+* [ARROW-2033](https://issues.apache.org/jira/browse/ARROW-2033) - pa.array() doesn't work with iterators
+* [ARROW-2039](https://issues.apache.org/jira/browse/ARROW-2039) - [Python] pyarrow.Buffer().to_pybytes() segfaults
+* [ARROW-2040](https://issues.apache.org/jira/browse/ARROW-2040) - [Python] Deserialized Numpy array must keep ref to underlying tensor
+* [ARROW-2047](https://issues.apache.org/jira/browse/ARROW-2047) - [Python] test_serialization.py uses a python executable in PATH rather than that used for a test run
+* [ARROW-2049](https://issues.apache.org/jira/browse/ARROW-2049) - ARROW-2049: [Python] Use python -m cython to run Cython, instead of CYTHON_EXECUTABLE
+* [ARROW-2062](https://issues.apache.org/jira/browse/ARROW-2062) - [C++] Stalled builds in test_serialization.py in Travis CI
+* [ARROW-2070](https://issues.apache.org/jira/browse/ARROW-2070) - [Python] chdir logic in setup.py buggy
+* [ARROW-2072](https://issues.apache.org/jira/browse/ARROW-2072) - [Python] decimal128.byte_width crashes
+* [ARROW-2080](https://issues.apache.org/jira/browse/ARROW-2080) - [Python] Update documentation after ARROW-2024
+* [ARROW-2085](https://issues.apache.org/jira/browse/ARROW-2085) - HadoopFileSystem.isdir and .isfile should return False if the path doesn't exist 
+* [ARROW-2106](https://issues.apache.org/jira/browse/ARROW-2106) - [Python] pyarrow.array can't take a pandas Series of python datetime objects.
+* [ARROW-2109](https://issues.apache.org/jira/browse/ARROW-2109) - [C++] Boost 1.66 compilation fails on Windows on linkage stage
+* [ARROW-2124](https://issues.apache.org/jira/browse/ARROW-2124) - [Python] ArrowInvalid raised if the first item of a nested list of numpy arrays is empty
+* [ARROW-2128](https://issues.apache.org/jira/browse/ARROW-2128) - [Python] Cannot serialize array of empty lists
+* [ARROW-2129](https://issues.apache.org/jira/browse/ARROW-2129) - [Python] Segmentation fault on conversion of empty array to Pandas
+* [ARROW-2131](https://issues.apache.org/jira/browse/ARROW-2131) - [Python] Serialization test fails on Windows when library has been built in place / not installed
+* [ARROW-2133](https://issues.apache.org/jira/browse/ARROW-2133) - [Python] Segmentation fault on conversion of empty nested arrays to Pandas
+* [ARROW-2135](https://issues.apache.org/jira/browse/ARROW-2135) - [Python] NaN values silently casted to int64 when passing explicit schema for conversion in Table.from_pandas
+* [ARROW-2145](https://issues.apache.org/jira/browse/ARROW-2145) - [Python] Decimal conversion not working for NaN values
+* [ARROW-2150](https://issues.apache.org/jira/browse/ARROW-2150) - [Python] array equality defaults to identity
+* [ARROW-2151](https://issues.apache.org/jira/browse/ARROW-2151) - [Python] Error when converting from list of uint64 arrays
+* [ARROW-2153](https://issues.apache.org/jira/browse/ARROW-2153) - [C++/Python] Decimal conversion not working for exponential notation
+* [ARROW-2157](https://issues.apache.org/jira/browse/ARROW-2157) - [Python] Decimal arrays cannot be constructed from Python lists
+* [ARROW-2160](https://issues.apache.org/jira/browse/ARROW-2160) - [C++/Python] Fix decimal precision inference
+* [ARROW-2161](https://issues.apache.org/jira/browse/ARROW-2161) - [Python] Skip test_cython_api if ARROW_HOME isn't defined
+* [ARROW-2162](https://issues.apache.org/jira/browse/ARROW-2162) - [Python/C++] Decimal Values with too-high precision are multiplied by 100
+* [ARROW-2167](https://issues.apache.org/jira/browse/ARROW-2167) - [C++] Building Orc extensions fails with the default BUILD_WARNING_LEVEL=Production
+* [ARROW-2170](https://issues.apache.org/jira/browse/ARROW-2170) - [Python] construct_metadata fails on reading files where no index was preserved
+* [ARROW-2171](https://issues.apache.org/jira/browse/ARROW-2171) - [Python] OwnedRef is fragile
+* [ARROW-2172](https://issues.apache.org/jira/browse/ARROW-2172) - [Python] Incorrect conversion from Numpy array when stride % itemsize != 0
+* [ARROW-2173](https://issues.apache.org/jira/browse/ARROW-2173) - [Python] NumPyBuffer destructor should hold the GIL
+* [ARROW-2175](https://issues.apache.org/jira/browse/ARROW-2175) - [Python] arrow_ep build is triggering during parquet-cpp build in Travis CI
+* [ARROW-2178](https://issues.apache.org/jira/browse/ARROW-2178) -  [JS] Fix JS html FileReader example
+* [ARROW-2179](https://issues.apache.org/jira/browse/ARROW-2179) - [C++] arrow/util/io-util.h missing from libarrow-dev
+* [ARROW-2192](https://issues.apache.org/jira/browse/ARROW-2192) - Commits to master should run all builds in CI matrix
+* [ARROW-2209](https://issues.apache.org/jira/browse/ARROW-2209) - [Python] Partition columns are not correctly loaded in schema of ParquetDataset
+* [ARROW-2210](https://issues.apache.org/jira/browse/ARROW-2210) - [C++] TestBuffer_ResizeOOM has a memory leak with jemalloc
+* [ARROW-2212](https://issues.apache.org/jira/browse/ARROW-2212) - [C++/Python] Build Protobuf in base manylinux 1 docker image
+* [ARROW-2223](https://issues.apache.org/jira/browse/ARROW-2223) - [JS] installing umd release throws an error
+* [ARROW-2227](https://issues.apache.org/jira/browse/ARROW-2227) - [Python] Table.from_pandas does not create chunked_arrays.
+* [ARROW-2230](https://issues.apache.org/jira/browse/ARROW-2230) - [Python] JS version number is sometimes picked up
+* [ARROW-2232](https://issues.apache.org/jira/browse/ARROW-2232) - [Python] pyarrow.Tensor constructor segfaults
+* [ARROW-2234](https://issues.apache.org/jira/browse/ARROW-2234) - [JS] Read timestamp low bits as Uint32s
+* [ARROW-2240](https://issues.apache.org/jira/browse/ARROW-2240) - [Python] Array initialization with leading numpy nan fails with exception
+* [ARROW-2244](https://issues.apache.org/jira/browse/ARROW-2244) - [C++] Slicing NullArray should not cause the null count on the internal data to be unknown
+* [ARROW-2245](https://issues.apache.org/jira/browse/ARROW-2245) - [Python] Revert static linkage of parquet-cpp in manylinux1 wheel
+* [ARROW-2246](https://issues.apache.org/jira/browse/ARROW-2246) - [Python] Use namespaced boost in manylinux1 package
+* [ARROW-2251](https://issues.apache.org/jira/browse/ARROW-2251) - [GLib] Destroying GArrowBuffer while GArrowTensor that uses the buffer causes a crash
+* [ARROW-2254](https://issues.apache.org/jira/browse/ARROW-2254) - [Python] Local in-place dev versions picking up JS tags
+* [ARROW-2258](https://issues.apache.org/jira/browse/ARROW-2258) - [C++] Appveyor builds failing on master
+* [ARROW-2263](https://issues.apache.org/jira/browse/ARROW-2263) - [Python] test_cython.py fails if pyarrow is not in import path (e.g. with inplace builds)
+* [ARROW-2265](https://issues.apache.org/jira/browse/ARROW-2265) - [Python] Serializing subclasses of np.ndarray returns a np.ndarray.
+* [ARROW-2268](https://issues.apache.org/jira/browse/ARROW-2268) - Remove MD5 checksums from release process
+* [ARROW-2269](https://issues.apache.org/jira/browse/ARROW-2269) - [Python] Cannot build bdist_wheel for Python
+* [ARROW-2270](https://issues.apache.org/jira/browse/ARROW-2270) - [Python] ForeignBuffer doesn't tie Python object lifetime to C++ buffer lifetime
+* [ARROW-2272](https://issues.apache.org/jira/browse/ARROW-2272) - [Python] test_plasma spams /tmp
+* [ARROW-2275](https://issues.apache.org/jira/browse/ARROW-2275) - [C++] Buffer::mutable_data_ member uninitialized
+* [ARROW-2280](https://issues.apache.org/jira/browse/ARROW-2280) - [Python] pyarrow.Array.buffers should also include the offsets
+* [ARROW-2284](https://issues.apache.org/jira/browse/ARROW-2284) - [Python] test_plasma error on plasma_store error
+* [ARROW-2288](https://issues.apache.org/jira/browse/ARROW-2288) - [Python] slicing logic defective
+* [ARROW-2297](https://issues.apache.org/jira/browse/ARROW-2297) - [JS] babel-jest is not listed as a dev dependency
+* [ARROW-2304](https://issues.apache.org/jira/browse/ARROW-2304) - [C++] MultipleClients test in io-hdfs-test fails on trunk
+* [ARROW-2306](https://issues.apache.org/jira/browse/ARROW-2306) - [Python] HDFS test failures
+* [ARROW-2307](https://issues.apache.org/jira/browse/ARROW-2307) - [Python] Unable to read arrow stream containing 0 record batches
+* [ARROW-2311](https://issues.apache.org/jira/browse/ARROW-2311) - [Python] Struct array slicing defective
+* [ARROW-2312](https://issues.apache.org/jira/browse/ARROW-2312) - [JS] verify-release-candidate-sh must be updated to include JS in integration tests
+* [ARROW-2313](https://issues.apache.org/jira/browse/ARROW-2313) - [GLib] Release builds must define NDEBUG
+* [ARROW-2316](https://issues.apache.org/jira/browse/ARROW-2316) - [C++] Revert Buffer::mutable_data member to always inline
+* [ARROW-2318](https://issues.apache.org/jira/browse/ARROW-2318) - [C++] TestPlasmaStore.MultipleClientTest is flaky (hangs) in release builds
+* [ARROW-2320](https://issues.apache.org/jira/browse/ARROW-2320) - [C++] Vendored Boost build does not build regex library
+
+
+[1]: https://github.com/apache/arrow/releases/tag/apache-arrow-0.9.0
+[2]: https://www.apache.org/dyn/closer.cgi/arrow/arrow-0.9.0/
diff --git a/site/_release/index.md b/site/_release/index.md
index e22df92b6..adf54f12d 100644
--- a/site/_release/index.md
+++ b/site/_release/index.md
@@ -26,6 +26,7 @@ limitations under the License.
 
 Navigate to the release page for downloads and the changelog.
 
+* [0.9.0 (21 March 2018)][11]
 * [0.8.0 (18 December 2017)][10]
 * [0.7.1 (1 October 2017)][9]
 * [0.7.0 (17 September 2017)][8]
@@ -47,3 +48,5 @@ Navigate to the release page for downloads and the changelog.
 [8]: {{ site.baseurl }}/release/0.7.0.html
 [9]: {{ site.baseurl }}/release/0.7.1.html
 [10]: {{ site.baseurl }}/release/0.8.0.html
+[11]: {{ site.baseurl }}/release/0.9.0.html
+
diff --git a/site/img/native_go_implementation.png b/site/img/native_go_implementation.png
new file mode 100644
index 000000000..39f095243
Binary files /dev/null and b/site/img/native_go_implementation.png differ
diff --git a/site/install.md b/site/install.md
index f79529967..2d47e210b 100644
--- a/site/install.md
+++ b/site/install.md
@@ -28,7 +28,7 @@ See the [release notes][10] for more about what's new.
 
 ### Source release
 
-* **Source Release**: [apache-arrow-0.8.0.tar.gz][6]
+* **Source Release**: [apache-arrow-0.9.0.tar.gz][6]
 * **Verification**: [sha512][3], [asc][7] ([verification instructions][12])
 * [Git tag {{site.data.versions['current'].git-tag}}][2]
 * [PGP keys for release signatures][11]
@@ -53,8 +53,8 @@ Install them with:
 
 
 ```shell
-conda install arrow-cpp=0.8.* -c conda-forge
-conda install pyarrow=0.8.* -c conda-forge
+conda install arrow-cpp=0.9.* -c conda-forge
+conda install pyarrow=0.9.* -c conda-forge
 ```
 
 ### Python Wheels on PyPI (Unofficial)
@@ -62,10 +62,10 @@ conda install pyarrow=0.8.* -c conda-forge
 We have provided binary wheels on PyPI for Linux, macOS, and Windows:
 
 ```shell
-pip install pyarrow==0.8.*
+pip install pyarrow==0.9.*
 ```
 
-We recommend pinning `0.8.*` in `requirements.txt` to install the latest patch
+We recommend pinning `0.9.*` in `requirements.txt` to install the latest patch
 release.
 
 These include the Apache Arrow and Apache Parquet C++ binary libraries bundled


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


wesm commented on issue #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#issuecomment-375699243
 
 
   I will review this when I can, it has been a very busy week

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


wesm commented on issue #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#issuecomment-375939284
 
 
   BTW, feel no need to put these "ARROW-2328: [C++]" messages in your commits. The only one that matters is in the PR title
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on issue #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#issuecomment-375958714
 
 
   Will do, thanks.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pitrou commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179477752
 
 

 ##########
 File path: cpp/src/arrow/ipc/test-common.h
 ##########
 @@ -223,15 +223,17 @@ Status MakeRandomBinaryArray(int64_t length, bool include_nulls, MemoryPool* poo
     if (include_nulls && values_index == 0) {
       RETURN_NOT_OK(builder.AppendNull());
     } else {
-      const std::string& value = values[values_index];
+      const std::string value =
+          i < int64_t(values.size()) ? values[values_index] : std::to_string(i);
       RETURN_NOT_OK(builder.Append(reinterpret_cast<const RawType*>(value.data()),
                                    static_cast<int32_t>(value.size())));
     }
   }
   return builder.Finish(out);
 }
 
-Status MakeStringTypesRecordBatch(std::shared_ptr<RecordBatch>* out) {
+Status MakeStringTypesRecordBatchWithNulls(std::shared_ptr<RecordBatch>* out,
 
 Review comment:
   Style note: if it's called `MakeStringTypesRecordBatchWithNulls`, it shouldn't take an argument indicating whether you want to include nulls. Consider renaming or using a private helper function.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pitrou commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179478300
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather-test.cc
 ##########
 @@ -406,6 +406,125 @@ TEST_F(TestTableWriter, PrimitiveNullRoundTrip) {
   }
 }
 
+TEST_F(TestTableWriter, SliceRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeIntBatchSized(300, &batch));
+  batch = batch->Slice(100, 100);
 
 Review comment:
   It would be nice if you could iterate over a couple of different slice starts / lengths, especially non-multiples of 8.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pitrou commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179478878
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather-test.cc
 ##########
 @@ -406,6 +406,125 @@ TEST_F(TestTableWriter, PrimitiveNullRoundTrip) {
   }
 }
 
+TEST_F(TestTableWriter, SliceRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeIntBatchSized(300, &batch));
+  batch = batch->Slice(100, 100);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_F(TestTableWriter, SliceStringsRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeStringTypesRecordBatchWithNulls(&batch, false));
+  batch = batch->Slice(320, 30);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
 
 Review comment:
   There's a lot of duplicate here with `SliceRoundTrip`.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pitrou commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179478971
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather-test.cc
 ##########
 @@ -406,6 +406,125 @@ TEST_F(TestTableWriter, PrimitiveNullRoundTrip) {
   }
 }
 
+TEST_F(TestTableWriter, SliceRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeIntBatchSized(300, &batch));
+  batch = batch->Slice(100, 100);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_F(TestTableWriter, SliceStringsRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeStringTypesRecordBatchWithNulls(&batch, false));
+  batch = batch->Slice(320, 30);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  SCOPED_TRACE(col->data()->chunk(0)->ToString() + "\n" + batch->column(0)->ToString());
 
 Review comment:
   Is this required?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pitrou commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179478878
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather-test.cc
 ##########
 @@ -406,6 +406,125 @@ TEST_F(TestTableWriter, PrimitiveNullRoundTrip) {
   }
 }
 
+TEST_F(TestTableWriter, SliceRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeIntBatchSized(300, &batch));
+  batch = batch->Slice(100, 100);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_F(TestTableWriter, SliceStringsRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeStringTypesRecordBatchWithNulls(&batch, false));
+  batch = batch->Slice(320, 30);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
 
 Review comment:
   There's a lot of duplicate code here with `SliceRoundTrip`.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pitrou commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179479281
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather-test.cc
 ##########
 @@ -406,6 +406,125 @@ TEST_F(TestTableWriter, PrimitiveNullRoundTrip) {
   }
 }
 
+TEST_F(TestTableWriter, SliceRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeIntBatchSized(300, &batch));
+  batch = batch->Slice(100, 100);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_F(TestTableWriter, SliceStringsRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeStringTypesRecordBatchWithNulls(&batch, false));
+  batch = batch->Slice(320, 30);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  SCOPED_TRACE(col->data()->chunk(0)->ToString() + "\n" + batch->column(0)->ToString());
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_F(TestTableWriter, SliceStringsWithNullsRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeStringTypesRecordBatchWithNulls(&batch, true));
+  batch = batch->Slice(320, 30);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  SCOPED_TRACE(col->data()->chunk(0)->ToString() + "\n" + batch->column(0)->ToString());
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_F(TestTableWriter, SliceAtNonEightOffsetStringsWithNullsRoundTrip) {
 
 Review comment:
   There's no need writing independent methods here, just iterate over different slice starts / lengths.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pitrou commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179479896
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather.cc
 ##########
 @@ -75,6 +75,43 @@ static Status WritePadded(io::OutputStream* stream, const uint8_t* data, int64_t
   return Status::OK();
 }
 
+static Status WritePaddedWithOffset(io::OutputStream* stream, const uint8_t* data,
+                                    int64_t bit_offset, const int64_t length,
+                                    int64_t* bytes_written) {
+  data = data + bit_offset / 8;
+  uint8_t bit_shift = static_cast<uint8_t>(bit_offset % 8);
 
 Review comment:
   Is the cast to int8 necessary here? (for performance perhaps?)

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pitrou commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179481731
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather.cc
 ##########
 @@ -558,15 +595,18 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {
       // byte boundary, and we write this much data into the stream
 
 Review comment:
   This comment needs updating.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pitrou commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179482956
 
 

 ##########
 File path: cpp/src/arrow/ipc/test-common.h
 ##########
 @@ -223,15 +223,17 @@ Status MakeRandomBinaryArray(int64_t length, bool include_nulls, MemoryPool* poo
     if (include_nulls && values_index == 0) {
       RETURN_NOT_OK(builder.AppendNull());
     } else {
-      const std::string& value = values[values_index];
+      const std::string value =
+          i < int64_t(values.size()) ? values[values_index] : std::to_string(i);
       RETURN_NOT_OK(builder.Append(reinterpret_cast<const RawType*>(value.data()),
                                    static_cast<int32_t>(value.size())));
     }
   }
   return builder.Finish(out);
 }
 
-Status MakeStringTypesRecordBatch(std::shared_ptr<RecordBatch>* out) {
+Status MakeStringTypesRecordBatchWithNulls(std::shared_ptr<RecordBatch>* out,
 
 Review comment:
   Or simply add a `bool with_nulls = true` optional argument to `MakeStringTypesRecordBatch`.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179814300
 
 

 ##########
 File path: cpp/src/arrow/ipc/test-common.h
 ##########
 @@ -223,15 +223,17 @@ Status MakeRandomBinaryArray(int64_t length, bool include_nulls, MemoryPool* poo
     if (include_nulls && values_index == 0) {
       RETURN_NOT_OK(builder.AppendNull());
     } else {
-      const std::string& value = values[values_index];
+      const std::string value =
+          i < int64_t(values.size()) ? values[values_index] : std::to_string(i);
       RETURN_NOT_OK(builder.Append(reinterpret_cast<const RawType*>(value.data()),
                                    static_cast<int32_t>(value.size())));
     }
   }
   return builder.Finish(out);
 }
 
-Status MakeStringTypesRecordBatch(std::shared_ptr<RecordBatch>* out) {
+Status MakeStringTypesRecordBatchWithNulls(std::shared_ptr<RecordBatch>* out,
 
 Review comment:
   Adding the default argument didn't work, because MakeStringTypesRecordBatch is used as a function pointer in other tests. I'll rename is to MakeStringTypesRecordBatchWithoutNulls abd this one to MakeStringTypesRecordBatch.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179814535
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather-test.cc
 ##########
 @@ -406,6 +406,125 @@ TEST_F(TestTableWriter, PrimitiveNullRoundTrip) {
   }
 }
 
+TEST_F(TestTableWriter, SliceRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeIntBatchSized(300, &batch));
+  batch = batch->Slice(100, 100);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_F(TestTableWriter, SliceStringsRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeStringTypesRecordBatchWithNulls(&batch, false));
+  batch = batch->Slice(320, 30);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  SCOPED_TRACE(col->data()->chunk(0)->ToString() + "\n" + batch->column(0)->ToString());
 
 Review comment:
   Yes(ish) It helps give a helpfull message when the test fails.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179815275
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather-test.cc
 ##########
 @@ -406,6 +406,125 @@ TEST_F(TestTableWriter, PrimitiveNullRoundTrip) {
   }
 }
 
+TEST_F(TestTableWriter, SliceRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeIntBatchSized(300, &batch));
+  batch = batch->Slice(100, 100);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_F(TestTableWriter, SliceStringsRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeStringTypesRecordBatchWithNulls(&batch, false));
+  batch = batch->Slice(320, 30);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  SCOPED_TRACE(col->data()->chunk(0)->ToString() + "\n" + batch->column(0)->ToString());
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_F(TestTableWriter, SliceStringsWithNullsRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeStringTypesRecordBatchWithNulls(&batch, true));
+  batch = batch->Slice(320, 30);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  SCOPED_TRACE(col->data()->chunk(0)->ToString() + "\n" + batch->column(0)->ToString());
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_F(TestTableWriter, SliceAtNonEightOffsetStringsWithNullsRoundTrip) {
 
 Review comment:
   I think the problem with loops in unit tests is that you only see the first failure. That said I should be able to convert these tests to one parameterised test, which hopefully also answers the above concerns..

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179816648
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather.cc
 ##########
 @@ -75,6 +75,43 @@ static Status WritePadded(io::OutputStream* stream, const uint8_t* data, int64_t
   return Status::OK();
 }
 
+static Status WritePaddedWithOffset(io::OutputStream* stream, const uint8_t* data,
+                                    int64_t bit_offset, const int64_t length,
+                                    int64_t* bytes_written) {
+  data = data + bit_offset / 8;
+  uint8_t bit_shift = static_cast<uint8_t>(bit_offset % 8);
 
 Review comment:
   Not really, but I think I got some warning, maybe with clang.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179817501
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather.cc
 ##########
 @@ -558,15 +595,18 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {
       // byte boundary, and we write this much data into the stream
 
 Review comment:
   will do.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pitrou commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179819483
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather-test.cc
 ##########
 @@ -406,6 +406,125 @@ TEST_F(TestTableWriter, PrimitiveNullRoundTrip) {
   }
 }
 
+TEST_F(TestTableWriter, SliceRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeIntBatchSized(300, &batch));
+  batch = batch->Slice(100, 100);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_F(TestTableWriter, SliceStringsRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeStringTypesRecordBatchWithNulls(&batch, false));
+  batch = batch->Slice(320, 30);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  SCOPED_TRACE(col->data()->chunk(0)->ToString() + "\n" + batch->column(0)->ToString());
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_F(TestTableWriter, SliceStringsWithNullsRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeStringTypesRecordBatchWithNulls(&batch, true));
+  batch = batch->Slice(320, 30);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  SCOPED_TRACE(col->data()->chunk(0)->ToString() + "\n" + batch->column(0)->ToString());
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_F(TestTableWriter, SliceAtNonEightOffsetStringsWithNullsRoundTrip) {
 
 Review comment:
   Cool :-) Though I don't think using a loop is a big deal either...

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on issue #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#issuecomment-379329455
 
 
   Thanks for the review comments. I’ve rewritten the tests as parameter unit tests and did most of the rest. 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pitrou commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179913230
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather-test.cc
 ##########
 @@ -406,6 +406,89 @@ TEST_F(TestTableWriter, PrimitiveNullRoundTrip) {
   }
 }
 
+class TestTableWriterSlice : public TestTableWriter,
+                             public ::testing::WithParamInterface<std::tuple<int, int>> {
+};
+
+TEST_P(TestTableWriterSlice, SliceRoundTrip) {
+  auto p = GetParam();
+  auto start = std::get<0>(p);
+  auto size = std::get<1>(p);
+
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeIntBatchSized(start * 2, &batch));
+  batch = batch->Slice(start, size);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_P(TestTableWriterSlice, SliceStringsRoundTrip) {
+  auto p = GetParam();
+  auto start = std::get<0>(p);
+  auto size = std::get<1>(p);
+  auto with_nulls = start % 2 == 0;
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeStringTypesRecordBatch(&batch, with_nulls));
+  batch = batch->Slice(start, size);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  SCOPED_TRACE(col->data()->chunk(0)->ToString() + "\n" + batch->column(0)->ToString());
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_P(TestTableWriterSlice, SliceBooleanRoundTrip) {
+  auto p = GetParam();
+  auto start = std::get<0>(p);
+  auto size = std::get<1>(p);
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeBooleanBatchSized(600, &batch));
+  batch = batch->Slice(start, size);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  SCOPED_TRACE(col->data()->chunk(0)->ToString() + "\n" + batch->column(0)->ToString());
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+INSTANTIATE_TEST_CASE_P(
+    TestTableWriterSliceOffsets, TestTableWriterSlice,
+    ::testing::Values(std::make_tuple(300, 30), std::make_tuple(301, 30),
 
 Review comment:
   Hmm... Does gtest allow making a Cartesian product here?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pitrou commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179913262
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather-test.cc
 ##########
 @@ -406,6 +406,89 @@ TEST_F(TestTableWriter, PrimitiveNullRoundTrip) {
   }
 }
 
+class TestTableWriterSlice : public TestTableWriter,
+                             public ::testing::WithParamInterface<std::tuple<int, int>> {
+};
+
+TEST_P(TestTableWriterSlice, SliceRoundTrip) {
+  auto p = GetParam();
+  auto start = std::get<0>(p);
+  auto size = std::get<1>(p);
+
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeIntBatchSized(start * 2, &batch));
+  batch = batch->Slice(start, size);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
 
 Review comment:
   This part and below is still duplicated in the other two test cases. Do you think you can factor that out, for example as a template function?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pitrou commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179913300
 
 

 ##########
 File path: cpp/src/arrow/ipc/test-common.h
 ##########
 @@ -244,18 +246,22 @@ Status MakeStringTypesRecordBatch(std::shared_ptr<RecordBatch>* out) {
 
   // Quirk with RETURN_NOT_OK macro and templated functions
   {
-    auto s = MakeRandomBinaryArray<StringBuilder, char>(length, true, pool, &a0);
+    auto s = MakeRandomBinaryArray<StringBuilder, char>(length, with_nulls, pool, &a0);
     RETURN_NOT_OK(s);
   }
 
   {
-    auto s = MakeRandomBinaryArray<BinaryBuilder, uint8_t>(length, true, pool, &a1);
+    auto s = MakeRandomBinaryArray<BinaryBuilder, uint8_t>(length, with_nulls, pool, &a1);
     RETURN_NOT_OK(s);
   }
   *out = RecordBatch::Make(schema, length, {a0, a1});
   return Status::OK();
 }
 
+Status MakeStringTypesRecordBatchWithoutNulls(std::shared_ptr<RecordBatch>* out) {
 
 Review comment:
   Why is it called "...WithoutNulls" if it passes `with_nulls = true`?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179913956
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather-test.cc
 ##########
 @@ -406,6 +406,89 @@ TEST_F(TestTableWriter, PrimitiveNullRoundTrip) {
   }
 }
 
+class TestTableWriterSlice : public TestTableWriter,
+                             public ::testing::WithParamInterface<std::tuple<int, int>> {
+};
+
+TEST_P(TestTableWriterSlice, SliceRoundTrip) {
+  auto p = GetParam();
+  auto start = std::get<0>(p);
+  auto size = std::get<1>(p);
+
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeIntBatchSized(start * 2, &batch));
+  batch = batch->Slice(start, size);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
 
 Review comment:
   You are right the duplication can be removed without adding any complexity.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179914007
 
 

 ##########
 File path: cpp/src/arrow/ipc/test-common.h
 ##########
 @@ -244,18 +246,22 @@ Status MakeStringTypesRecordBatch(std::shared_ptr<RecordBatch>* out) {
 
   // Quirk with RETURN_NOT_OK macro and templated functions
   {
-    auto s = MakeRandomBinaryArray<StringBuilder, char>(length, true, pool, &a0);
+    auto s = MakeRandomBinaryArray<StringBuilder, char>(length, with_nulls, pool, &a0);
     RETURN_NOT_OK(s);
   }
 
   {
-    auto s = MakeRandomBinaryArray<BinaryBuilder, uint8_t>(length, true, pool, &a1);
+    auto s = MakeRandomBinaryArray<BinaryBuilder, uint8_t>(length, with_nulls, pool, &a1);
     RETURN_NOT_OK(s);
   }
   *out = RecordBatch::Make(schema, length, {a0, a1});
   return Status::OK();
 }
 
+Status MakeStringTypesRecordBatchWithoutNulls(std::shared_ptr<RecordBatch>* out) {
 
 Review comment:
   Oops.. I'll rename it.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r179914221
 
 

 ##########
 File path: cpp/src/arrow/ipc/feather-test.cc
 ##########
 @@ -406,6 +406,89 @@ TEST_F(TestTableWriter, PrimitiveNullRoundTrip) {
   }
 }
 
+class TestTableWriterSlice : public TestTableWriter,
+                             public ::testing::WithParamInterface<std::tuple<int, int>> {
+};
+
+TEST_P(TestTableWriterSlice, SliceRoundTrip) {
+  auto p = GetParam();
+  auto start = std::get<0>(p);
+  auto size = std::get<1>(p);
+
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeIntBatchSized(start * 2, &batch));
+  batch = batch->Slice(start, size);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_P(TestTableWriterSlice, SliceStringsRoundTrip) {
+  auto p = GetParam();
+  auto start = std::get<0>(p);
+  auto size = std::get<1>(p);
+  auto with_nulls = start % 2 == 0;
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeStringTypesRecordBatch(&batch, with_nulls));
+  batch = batch->Slice(start, size);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  SCOPED_TRACE(col->data()->chunk(0)->ToString() + "\n" + batch->column(0)->ToString());
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+TEST_P(TestTableWriterSlice, SliceBooleanRoundTrip) {
+  auto p = GetParam();
+  auto start = std::get<0>(p);
+  auto size = std::get<1>(p);
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeBooleanBatchSized(600, &batch));
+  batch = batch->Slice(start, size);
+
+  ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+  ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+  Finish();
+
+  std::shared_ptr<Column> col;
+  ASSERT_OK(reader_->GetColumn(0, &col));
+  SCOPED_TRACE(col->data()->chunk(0)->ToString() + "\n" + batch->column(0)->ToString());
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+  ASSERT_EQ("f0", col->name());
+
+  ASSERT_OK(reader_->GetColumn(1, &col));
+  ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+  ASSERT_EQ("f1", col->name());
+}
+
+INSTANTIATE_TEST_CASE_P(
+    TestTableWriterSliceOffsets, TestTableWriterSlice,
+    ::testing::Values(std::make_tuple(300, 30), std::make_tuple(301, 30),
 
 Review comment:
   Yes it does, yesterday I was just too lazy to find out how.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pitrou commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r180016562
 
 

 ##########
 File path: cpp/src/arrow/ipc/test-common.h
 ##########
 @@ -223,15 +223,17 @@ Status MakeRandomBinaryArray(int64_t length, bool include_nulls, MemoryPool* poo
     if (include_nulls && values_index == 0) {
       RETURN_NOT_OK(builder.AppendNull());
     } else {
-      const std::string& value = values[values_index];
+      const std::string value =
+          i < int64_t(values.size()) ? values[values_index] : std::to_string(i);
 
 Review comment:
   Why did you need this change? Is this just a debugging leftover?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r180032970
 
 

 ##########
 File path: cpp/src/arrow/ipc/test-common.h
 ##########
 @@ -223,15 +223,17 @@ Status MakeRandomBinaryArray(int64_t length, bool include_nulls, MemoryPool* poo
     if (include_nulls && values_index == 0) {
       RETURN_NOT_OK(builder.AppendNull());
     } else {
-      const std::string& value = values[values_index];
+      const std::string value =
+          i < int64_t(values.size()) ? values[values_index] : std::to_string(i);
 
 Review comment:
   The original random strings were not very random, just a repetition of the same few strings. I admit the new ones aren't very random either, in particular there are no repetitions which you would expect in a in real data. I probably should have added a new method (MakeRangeBinaryArray?).
   Of course you don't want true random data either in a test.
   If I revert the change I wouldn't be confident that my tests are still testing anything, the repetition might just align in a lucky pattern.
   You ok with leaving it, I think it is better than the previous code?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pitrou commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r180034330
 
 

 ##########
 File path: cpp/src/arrow/ipc/test-common.h
 ##########
 @@ -223,15 +223,17 @@ Status MakeRandomBinaryArray(int64_t length, bool include_nulls, MemoryPool* poo
     if (include_nulls && values_index == 0) {
       RETURN_NOT_OK(builder.AppendNull());
     } else {
-      const std::string& value = values[values_index];
+      const std::string value =
+          i < int64_t(values.size()) ? values[values_index] : std::to_string(i);
 
 Review comment:
   I'd rather revert this change. If we want better random generation of binary arrays we should do it more thoroughly.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Adriandorr commented on a change in pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#discussion_r180093019
 
 

 ##########
 File path: cpp/src/arrow/ipc/test-common.h
 ##########
 @@ -223,15 +223,17 @@ Status MakeRandomBinaryArray(int64_t length, bool include_nulls, MemoryPool* poo
     if (include_nulls && values_index == 0) {
       RETURN_NOT_OK(builder.AppendNull());
     } else {
-      const std::string& value = values[values_index];
+      const std::string value =
+          i < int64_t(values.size()) ? values[values_index] : std::to_string(i);
 
 Review comment:
   Not knowing the history of this particular function, I don't know what would be "better" in there. For my test I pretty much just want the consecutive numbers, otherwise it is very difficult to see what has gone wrong (I like the tests to give me the answer to that question if possible). I made a change to add a second function that implements that, but turns out this function is only used from MakeStringTypesRecordBatch, so we can't really have two implementations.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pitrou commented on issue #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784#issuecomment-379806635
 
 
   Thank you! I will merge once the AppVeyor build passes (the Travis-CI failures in the Rust and glib builds are unrelated).

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pitrou closed pull request #1784: ARROW-2328: [C++] Fixed and unit tested feather writing with slice
URL: https://github.com/apache/arrow/pull/1784
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/cpp/src/arrow/ipc/feather-test.cc b/cpp/src/arrow/ipc/feather-test.cc
index 8ec3b0e4a..ae1489aa3 100644
--- a/cpp/src/arrow/ipc/feather-test.cc
+++ b/cpp/src/arrow/ipc/feather-test.cc
@@ -406,6 +406,57 @@ TEST_F(TestTableWriter, PrimitiveNullRoundTrip) {
   }
 }
 
+class TestTableWriterSlice : public TestTableWriter,
+                             public ::testing::WithParamInterface<std::tuple<int, int>> {
+ public:
+  void CheckSlice(std::shared_ptr<RecordBatch> batch) {
+    auto p = GetParam();
+    auto start = std::get<0>(p);
+    auto size = std::get<1>(p);
+
+    batch = batch->Slice(start, size);
+
+    ASSERT_OK(writer_->Append("f0", *batch->column(0)));
+    ASSERT_OK(writer_->Append("f1", *batch->column(1)));
+    Finish();
+
+    std::shared_ptr<Column> col;
+    ASSERT_OK(reader_->GetColumn(0, &col));
+    ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(0)));
+    ASSERT_EQ("f0", col->name());
+
+    ASSERT_OK(reader_->GetColumn(1, &col));
+    ASSERT_TRUE(col->data()->chunk(0)->Equals(batch->column(1)));
+    ASSERT_EQ("f1", col->name());
+  }
+};
+
+TEST_P(TestTableWriterSlice, SliceRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeIntBatchSized(600, &batch));
+  CheckSlice(batch);
+}
+
+TEST_P(TestTableWriterSlice, SliceStringsRoundTrip) {
+  auto p = GetParam();
+  auto start = std::get<0>(p);
+  auto with_nulls = start % 2 == 0;
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeStringTypesRecordBatch(&batch, with_nulls));
+  CheckSlice(batch);
+}
+
+TEST_P(TestTableWriterSlice, SliceBooleanRoundTrip) {
+  std::shared_ptr<RecordBatch> batch;
+  ASSERT_OK(MakeBooleanBatchSized(600, &batch));
+  CheckSlice(batch);
+}
+
+INSTANTIATE_TEST_CASE_P(TestTableWriterSliceOffsets, TestTableWriterSlice,
+                        ::testing::Combine(::testing::Values(0, 1, 300, 301, 302, 303,
+                                                             304, 305, 306, 307),
+                                           ::testing::Values(0, 1, 7, 8, 30, 32, 100)));
+
 }  // namespace feather
 }  // namespace ipc
 }  // namespace arrow
diff --git a/cpp/src/arrow/ipc/feather.cc b/cpp/src/arrow/ipc/feather.cc
index faf6a08df..df5c7993e 100644
--- a/cpp/src/arrow/ipc/feather.cc
+++ b/cpp/src/arrow/ipc/feather.cc
@@ -75,6 +75,43 @@ static Status WritePadded(io::OutputStream* stream, const uint8_t* data, int64_t
   return Status::OK();
 }
 
+static Status WritePaddedWithOffset(io::OutputStream* stream, const uint8_t* data,
+                                    int64_t bit_offset, const int64_t length,
+                                    int64_t* bytes_written) {
+  data = data + bit_offset / 8;
+  uint8_t bit_shift = static_cast<uint8_t>(bit_offset % 8);
+  if (bit_offset == 0) {
+    RETURN_NOT_OK(stream->Write(data, length));
+  } else {
+    constexpr int64_t buffersize = 256;
+    uint8_t buffer[buffersize];
+    const uint8_t lshift = static_cast<uint8_t>(8 - bit_shift);
+    const uint8_t* buffer_end = buffer + buffersize;
+    uint8_t* buffer_it = buffer;
+
+    for (const uint8_t* end = data + length; data != end;) {
+      uint8_t r = static_cast<uint8_t>(*data++ >> bit_shift);
+      uint8_t l = static_cast<uint8_t>(*data << lshift);
+      uint8_t value = l | r;
+      *buffer_it++ = value;
+      if (buffer_it == buffer_end) {
+        RETURN_NOT_OK(stream->Write(buffer, buffersize));
+        buffer_it = buffer;
+      }
+    }
+    if (buffer_it != buffer) {
+      RETURN_NOT_OK(stream->Write(buffer, buffer_it - buffer));
+    }
+  }
+
+  int64_t remainder = PaddedLength(length) - length;
+  if (remainder != 0) {
+    RETURN_NOT_OK(stream->Write(kPaddingBytes, remainder));
+  }
+  *bytes_written = length + remainder;
+  return Status::OK();
+}
+
 /// For compability, we need to write any data sometimes just to keep producing
 /// files that can be read with an older reader.
 static Status WritePaddedBlank(io::OutputStream* stream, int64_t length,
@@ -554,12 +591,14 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {
 
     // Write the null bitmask
     if (values.null_count() > 0) {
-      // We assume there is one bit for each value in values.nulls, aligned on a
-      // byte boundary, and we write this much data into the stream
+      // We assume there is one bit for each value in values.nulls,
+      // starting at the zero offset.
       int64_t null_bitmap_size = GetOutputLength(BitUtil::BytesForBits(values.length()));
       if (values.null_bitmap()) {
-        RETURN_NOT_OK(WritePadded(stream_.get(), values.null_bitmap()->data(),
-                                  null_bitmap_size, &bytes_written));
+        auto null_bitmap = values.null_bitmap();
+        RETURN_NOT_OK(WritePaddedWithOffset(stream_.get(), null_bitmap->data(),
+                                            values.offset(), null_bitmap_size,
+                                            &bytes_written));
       } else {
         RETURN_NOT_OK(WritePaddedBlank(stream_.get(), null_bitmap_size, &bytes_written));
       }
@@ -567,6 +606,7 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {
     }
 
     int64_t values_bytes = 0;
+    int64_t bit_offset = 0;
 
     const uint8_t* values_buffer = nullptr;
 
@@ -595,20 +635,17 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {
       const auto& prim_values = static_cast<const PrimitiveArray&>(values);
       const auto& fw_type = static_cast<const FixedWidthType&>(*values.type());
 
-      if (values.type_id() == Type::BOOL) {
-        // Booleans are bit-packed
-        values_bytes = BitUtil::BytesForBits(values.length());
-      } else {
-        values_bytes = values.length() * fw_type.bit_width() / 8;
-      }
+      values_bytes = BitUtil::BytesForBits(values.length() * fw_type.bit_width());
 
       if (prim_values.values()) {
-        values_buffer = prim_values.values()->data();
+        values_buffer = prim_values.values()->data() +
+                        (prim_values.offset() * fw_type.bit_width() / 8);
+        bit_offset = (prim_values.offset() * fw_type.bit_width()) % 8;
       }
     }
     if (values_buffer) {
-      RETURN_NOT_OK(
-          WritePadded(stream_.get(), values_buffer, values_bytes, &bytes_written));
+      RETURN_NOT_OK(WritePaddedWithOffset(stream_.get(), values_buffer, bit_offset,
+                                          values_bytes, &bytes_written));
     } else {
       RETURN_NOT_OK(WritePaddedBlank(stream_.get(), values_bytes, &bytes_written));
     }
diff --git a/cpp/src/arrow/ipc/ipc-json-test.cc b/cpp/src/arrow/ipc/ipc-json-test.cc
index 12fa4bf3e..adf83c33e 100644
--- a/cpp/src/arrow/ipc/ipc-json-test.cc
+++ b/cpp/src/arrow/ipc/ipc-json-test.cc
@@ -375,9 +375,9 @@ TEST(TestJsonFileReadWrite, MinimalFormatExample) {
 #define BATCH_CASES()                                                                   \
   ::testing::Values(&MakeIntRecordBatch, &MakeListRecordBatch, &MakeNonNullRecordBatch, \
                     &MakeZeroLengthRecordBatch, &MakeDeeplyNestedList,                  \
-                    &MakeStringTypesRecordBatch, &MakeStruct, &MakeUnion, &MakeDates,   \
-                    &MakeTimestamps, &MakeTimes, &MakeFWBinary, &MakeDecimal,           \
-                    &MakeDictionary);
+                    &MakeStringTypesRecordBatchWithNulls, &MakeStruct, &MakeUnion,      \
+                    &MakeDates, &MakeTimestamps, &MakeTimes, &MakeFWBinary,             \
+                    &MakeDecimal, &MakeDictionary);
 
 class TestJsonRoundTrip : public ::testing::TestWithParam<MakeRecordBatch*> {
  public:
diff --git a/cpp/src/arrow/ipc/ipc-read-write-test.cc b/cpp/src/arrow/ipc/ipc-read-write-test.cc
index c1ff8a448..437585fa0 100644
--- a/cpp/src/arrow/ipc/ipc-read-write-test.cc
+++ b/cpp/src/arrow/ipc/ipc-read-write-test.cc
@@ -119,7 +119,7 @@ TEST_F(TestSchemaMetadata, NestedFields) {
 #define BATCH_CASES()                                                                   \
   ::testing::Values(&MakeIntRecordBatch, &MakeListRecordBatch, &MakeNonNullRecordBatch, \
                     &MakeZeroLengthRecordBatch, &MakeDeeplyNestedList,                  \
-                    &MakeStringTypesRecordBatch, &MakeStruct, &MakeUnion,               \
+                    &MakeStringTypesRecordBatchWithNulls, &MakeStruct, &MakeUnion,      \
                     &MakeDictionary, &MakeDates, &MakeTimestamps, &MakeTimes,           \
                     &MakeFWBinary, &MakeNull, &MakeDecimal, &MakeBooleanBatch);
 
diff --git a/cpp/src/arrow/ipc/test-common.h b/cpp/src/arrow/ipc/test-common.h
index 6f8a0dcc6..fb7792e0f 100644
--- a/cpp/src/arrow/ipc/test-common.h
+++ b/cpp/src/arrow/ipc/test-common.h
@@ -231,7 +231,24 @@ Status MakeRandomBinaryArray(int64_t length, bool include_nulls, MemoryPool* poo
   return builder.Finish(out);
 }
 
-Status MakeStringTypesRecordBatch(std::shared_ptr<RecordBatch>* out) {
+template <class Builder, class RawType>
+Status MakeBinaryArrayWithUniqueValues(int64_t length, bool include_nulls,
+                                       MemoryPool* pool, std::shared_ptr<Array>* out) {
+  Builder builder(pool);
+  for (int64_t i = 0; i < length; ++i) {
+    if (include_nulls && (i % 7 == 0)) {
+      RETURN_NOT_OK(builder.AppendNull());
+    } else {
+      const std::string value = std::to_string(i);
+      RETURN_NOT_OK(builder.Append(reinterpret_cast<const RawType*>(value.data()),
+                                   static_cast<int32_t>(value.size())));
+    }
+  }
+  return builder.Finish(out);
+}
+
+Status MakeStringTypesRecordBatch(std::shared_ptr<RecordBatch>* out,
+                                  bool with_nulls = true) {
   const int64_t length = 500;
   auto string_type = utf8();
   auto binary_type = binary();
@@ -244,18 +261,24 @@ Status MakeStringTypesRecordBatch(std::shared_ptr<RecordBatch>* out) {
 
   // Quirk with RETURN_NOT_OK macro and templated functions
   {
-    auto s = MakeRandomBinaryArray<StringBuilder, char>(length, true, pool, &a0);
+    auto s = MakeBinaryArrayWithUniqueValues<StringBuilder, char>(length, with_nulls,
+                                                                  pool, &a0);
     RETURN_NOT_OK(s);
   }
 
   {
-    auto s = MakeRandomBinaryArray<BinaryBuilder, uint8_t>(length, true, pool, &a1);
+    auto s = MakeBinaryArrayWithUniqueValues<BinaryBuilder, uint8_t>(length, with_nulls,
+                                                                     pool, &a1);
     RETURN_NOT_OK(s);
   }
   *out = RecordBatch::Make(schema, length, {a0, a1});
   return Status::OK();
 }
 
+Status MakeStringTypesRecordBatchWithNulls(std::shared_ptr<RecordBatch>* out) {
+  return MakeStringTypesRecordBatch(out, true);
+}
+
 Status MakeNullRecordBatch(std::shared_ptr<RecordBatch>* out) {
   const int64_t length = 500;
   auto f0 = field("f0", null());


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Issue resolved by pull request 1784
[https://github.com/apache/arrow/pull/1784]

This issue has been migrated to [issue #18278|https://github.com/apache/arrow/issues/18278] on GitHub. Please see the [migration documentation|https://github.com/apache/arrow/issues/14542] for further details.

