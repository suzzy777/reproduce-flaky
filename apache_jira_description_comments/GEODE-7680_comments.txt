agingade commented on a change in pull request #5095:
URL: https://github.com/apache/geode/pull/5095#discussion_r424694699



##########
File path: geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithRebalanceDUnitTest.java
##########
@@ -0,0 +1,376 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import static org.apache.geode.cache.PartitionAttributesFactory.GLOBAL_MAX_BUCKETS_DEFAULT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT_PERSISTENT;
+import static org.apache.geode.internal.util.ArrayUtils.asList;
+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;
+import static org.apache.geode.test.dunit.VM.getVM;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.Matchers.greaterThan;
+import static org.junit.Assert.assertThat;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.IntStream;
+
+import junitparams.JUnitParamsRunner;
+import junitparams.Parameters;
+import junitparams.naming.TestCaseName;
+import org.assertj.core.api.Assertions;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.apache.geode.cache.CacheWriterException;
+import org.apache.geode.cache.PartitionAttributes;
+import org.apache.geode.cache.PartitionAttributesFactory;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionEvent;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.cache.control.RebalanceOperation;
+import org.apache.geode.cache.control.RebalanceResults;
+import org.apache.geode.cache.partition.PartitionRegionHelper;
+import org.apache.geode.cache.util.CacheWriterAdapter;
+import org.apache.geode.distributed.internal.DMStats;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;
+import org.apache.geode.test.awaitility.GeodeAwaitility;
+import org.apache.geode.test.dunit.AsyncInvocation;
+import org.apache.geode.test.dunit.DUnitBlackboard;
+import org.apache.geode.test.dunit.VM;
+import org.apache.geode.test.dunit.rules.CacheRule;
+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;
+import org.apache.geode.test.dunit.rules.DistributedRule;
+
+@RunWith(JUnitParamsRunner.class)
+public class PartitionedRegionClearWithRebalanceDUnitTest implements Serializable {
+  private static final long serialVersionUID = -7183993832801073933L;
+
+  private static final Integer BUCKETS = GLOBAL_MAX_BUCKETS_DEFAULT;
+  private static final String REGION_NAME = "PartitionedRegion";
+  public static final String DISK_STORE_NAME = "diskStore";
+  public static final String BEGIN_CLEAR = "begin-clear";
+  private static final int ENTRIES = 10000;
+
+  @Rule
+  public DistributedRule distributedRule = new DistributedRule(3);
+
+  @Rule
+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();
+
+  @Rule
+  public DistributedDiskDirRule distributedDiskDirRule = new DistributedDiskDirRule();
+
+  private static transient DUnitBlackboard blackboard;
+
+  private VM accessor;
+  private VM server1;
+  private VM server2;
+
+  private enum TestVM {
+    ACCESSOR(0), SERVER1(1), SERVER2(2);
+
+    final int vmNumber;
+
+    TestVM(int vmNumber) {
+      this.vmNumber = vmNumber;
+    }
+  }
+
+  @SuppressWarnings("unused")
+  static RegionShortcut[] regionTypes() {
+    return new RegionShortcut[] {
+        PARTITION_REDUNDANT,
+        PARTITION_REDUNDANT_PERSISTENT,
+    };
+  }
+
+  @SuppressWarnings("unused")
+  static Object[] vmsAndRegionTypes() {
+    ArrayList<Object[]> parameters = new ArrayList<>();
+    RegionShortcut[] regionShortcuts = regionTypes();
+
+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {
+      // {ClearCoordinatorVM, RebalanceVM, regionShortcut}
+      parameters.add(new Object[] {TestVM.SERVER1, TestVM.SERVER1, regionShortcut});
+      parameters.add(new Object[] {TestVM.SERVER1, TestVM.ACCESSOR, regionShortcut});
+      parameters.add(new Object[] {TestVM.ACCESSOR, TestVM.SERVER1, regionShortcut});
+      parameters.add(new Object[] {TestVM.ACCESSOR, TestVM.ACCESSOR, regionShortcut});
+    });
+
+    return parameters.toArray();
+  }
+
+  @Before
+  public void setUp() throws Exception {
+    getBlackboard().initBlackboard();
+    server1 = getVM(TestVM.SERVER1.vmNumber);
+    server2 = getVM(TestVM.SERVER2.vmNumber);
+    accessor = getVM(TestVM.ACCESSOR.vmNumber);
+  }
+
+  private static DUnitBlackboard getBlackboard() {
+    if (blackboard == null) {
+      blackboard = new DUnitBlackboard();
+    }
+    return blackboard;
+  }
+
+  private RegionShortcut getRegionAccessorShortcut(RegionShortcut dataStoreRegionShortcut) {
+    if (dataStoreRegionShortcut.isPersistent()) {
+      switch (dataStoreRegionShortcut) {
+        case PARTITION_PERSISTENT:
+          return PARTITION;
+        case PARTITION_REDUNDANT_PERSISTENT:
+          return PARTITION_REDUNDANT;
+      }
+    }
+
+    return dataStoreRegionShortcut;
+  }
+
+  private void initAccessor(RegionShortcut regionShortcut) {
+    RegionShortcut accessorShortcut = getRegionAccessorShortcut(regionShortcut);
+    // StartupRecoveryDelay is set to infinite to prevent automatic rebalancing when creating the
+    // region on other members
+    PartitionAttributes<String, String> attributes =
+        new PartitionAttributesFactory<String, String>()
+            .setTotalNumBuckets(BUCKETS)
+            .setStartupRecoveryDelay(-1)
+            .setLocalMaxMemory(0)
+            .create();
+
+    cacheRule.getCache()
+        .<String, String>createRegionFactory(accessorShortcut)
+        .setPartitionAttributes(attributes)
+        .create(REGION_NAME);
+  }
+
+  private void initDataStore(RegionShortcut regionShortcut) {
+    // StartupRecoveryDelay is set to infinite to prevent automatic rebalancing when creating the
+    // region on other members
+    PartitionAttributes<String, String> attributes =
+        new PartitionAttributesFactory<String, String>()
+            .setTotalNumBuckets(BUCKETS)
+            .setStartupRecoveryDelay(-1)
+            .create();
+
+    RegionFactory<String, String> factory = cacheRule.getCache()
+        .<String, String>createRegionFactory(regionShortcut)
+        .setPartitionAttributes(attributes);
+
+    if (regionShortcut.isPersistent()) {
+      factory.setDiskStoreName(
+          cacheRule.getCache().createDiskStoreFactory().create(DISK_STORE_NAME).getName());
+    }
+
+    factory.create(REGION_NAME);
+  }
+
+  private void parametrizedSetup(RegionShortcut regionShortcut) {
+    // Create and populate the region on server1 first, to create an unbalanced distribution of data
+    server1.invoke(() -> {
+      initDataStore(regionShortcut);
+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);
+      IntStream.range(0, ENTRIES).forEach(i -> region.put("key" + i, "value" + i));
+    });
+    server2.invoke(() -> initDataStore(regionShortcut));
+    accessor.invoke(() -> initAccessor(regionShortcut));
+  }
+
+  private AsyncInvocation<Object> setupAndPrepareClear(TestVM clearCoordinatorVM,
+      RegionShortcut regionType) {
+    parametrizedSetup(regionType);
+
+    return getVM(clearCoordinatorVM.vmNumber).invokeAsync(() -> {
+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);
+      // Wait for the signal from the blackboard before triggering the clear to start
+      getBlackboard().waitForGate(BEGIN_CLEAR, GeodeAwaitility.getTimeout().toMillis(),
+          TimeUnit.MILLISECONDS);
+      region.clear();
+    });
+  }
+
+  private RebalanceResults startRebalanceAndGetResults() throws InterruptedException {
+    // Start a rebalance and wait until bucket creation for redundancy recovery (the first stage of
+    // a rebalance operation) has started before signalling the blackboard
+    RebalanceOperation rebalanceOp =
+        cacheRule.getCache().getResourceManager().createRebalanceFactory().start();
+    await().untilAsserted(() -> assertThat(cacheRule.getCache().getInternalResourceManager()
+        .getStats().getRebalanceBucketCreatesCompleted(), greaterThan(0)));

Review comment:
       There could be possibility that, by the time the "wait" here and "wait" in before the clear call (the sleep after first unsuccessful check); and with thread scheduling, the rebalance of buckets may be completed, before the clear start. Very less likely, but may be.

##########
File path: geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithRebalanceDUnitTest.java
##########
@@ -0,0 +1,376 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import static org.apache.geode.cache.PartitionAttributesFactory.GLOBAL_MAX_BUCKETS_DEFAULT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT_PERSISTENT;
+import static org.apache.geode.internal.util.ArrayUtils.asList;
+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;
+import static org.apache.geode.test.dunit.VM.getVM;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.Matchers.greaterThan;
+import static org.junit.Assert.assertThat;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.IntStream;
+
+import junitparams.JUnitParamsRunner;
+import junitparams.Parameters;
+import junitparams.naming.TestCaseName;
+import org.assertj.core.api.Assertions;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.apache.geode.cache.CacheWriterException;
+import org.apache.geode.cache.PartitionAttributes;
+import org.apache.geode.cache.PartitionAttributesFactory;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionEvent;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.cache.control.RebalanceOperation;
+import org.apache.geode.cache.control.RebalanceResults;
+import org.apache.geode.cache.partition.PartitionRegionHelper;
+import org.apache.geode.cache.util.CacheWriterAdapter;
+import org.apache.geode.distributed.internal.DMStats;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;
+import org.apache.geode.test.awaitility.GeodeAwaitility;
+import org.apache.geode.test.dunit.AsyncInvocation;
+import org.apache.geode.test.dunit.DUnitBlackboard;
+import org.apache.geode.test.dunit.VM;
+import org.apache.geode.test.dunit.rules.CacheRule;
+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;
+import org.apache.geode.test.dunit.rules.DistributedRule;
+
+@RunWith(JUnitParamsRunner.class)
+public class PartitionedRegionClearWithRebalanceDUnitTest implements Serializable {
+  private static final long serialVersionUID = -7183993832801073933L;
+
+  private static final Integer BUCKETS = GLOBAL_MAX_BUCKETS_DEFAULT;
+  private static final String REGION_NAME = "PartitionedRegion";
+  public static final String DISK_STORE_NAME = "diskStore";
+  public static final String BEGIN_CLEAR = "begin-clear";
+  private static final int ENTRIES = 10000;
+
+  @Rule
+  public DistributedRule distributedRule = new DistributedRule(3);
+
+  @Rule
+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();
+
+  @Rule
+  public DistributedDiskDirRule distributedDiskDirRule = new DistributedDiskDirRule();
+
+  private static transient DUnitBlackboard blackboard;
+
+  private VM accessor;
+  private VM server1;
+  private VM server2;
+
+  private enum TestVM {
+    ACCESSOR(0), SERVER1(1), SERVER2(2);
+
+    final int vmNumber;
+
+    TestVM(int vmNumber) {
+      this.vmNumber = vmNumber;
+    }
+  }
+
+  @SuppressWarnings("unused")
+  static RegionShortcut[] regionTypes() {
+    return new RegionShortcut[] {
+        PARTITION_REDUNDANT,
+        PARTITION_REDUNDANT_PERSISTENT,
+    };
+  }
+
+  @SuppressWarnings("unused")
+  static Object[] vmsAndRegionTypes() {
+    ArrayList<Object[]> parameters = new ArrayList<>();
+    RegionShortcut[] regionShortcuts = regionTypes();
+
+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {
+      // {ClearCoordinatorVM, RebalanceVM, regionShortcut}
+      parameters.add(new Object[] {TestVM.SERVER1, TestVM.SERVER1, regionShortcut});
+      parameters.add(new Object[] {TestVM.SERVER1, TestVM.ACCESSOR, regionShortcut});
+      parameters.add(new Object[] {TestVM.ACCESSOR, TestVM.SERVER1, regionShortcut});
+      parameters.add(new Object[] {TestVM.ACCESSOR, TestVM.ACCESSOR, regionShortcut});
+    });
+
+    return parameters.toArray();
+  }
+
+  @Before
+  public void setUp() throws Exception {
+    getBlackboard().initBlackboard();
+    server1 = getVM(TestVM.SERVER1.vmNumber);
+    server2 = getVM(TestVM.SERVER2.vmNumber);
+    accessor = getVM(TestVM.ACCESSOR.vmNumber);
+  }
+
+  private static DUnitBlackboard getBlackboard() {
+    if (blackboard == null) {
+      blackboard = new DUnitBlackboard();
+    }
+    return blackboard;
+  }
+
+  private RegionShortcut getRegionAccessorShortcut(RegionShortcut dataStoreRegionShortcut) {
+    if (dataStoreRegionShortcut.isPersistent()) {
+      switch (dataStoreRegionShortcut) {
+        case PARTITION_PERSISTENT:
+          return PARTITION;
+        case PARTITION_REDUNDANT_PERSISTENT:
+          return PARTITION_REDUNDANT;
+      }
+    }
+
+    return dataStoreRegionShortcut;
+  }
+
+  private void initAccessor(RegionShortcut regionShortcut) {
+    RegionShortcut accessorShortcut = getRegionAccessorShortcut(regionShortcut);
+    // StartupRecoveryDelay is set to infinite to prevent automatic rebalancing when creating the
+    // region on other members
+    PartitionAttributes<String, String> attributes =
+        new PartitionAttributesFactory<String, String>()
+            .setTotalNumBuckets(BUCKETS)
+            .setStartupRecoveryDelay(-1)
+            .setLocalMaxMemory(0)
+            .create();
+
+    cacheRule.getCache()
+        .<String, String>createRegionFactory(accessorShortcut)
+        .setPartitionAttributes(attributes)
+        .create(REGION_NAME);
+  }
+
+  private void initDataStore(RegionShortcut regionShortcut) {
+    // StartupRecoveryDelay is set to infinite to prevent automatic rebalancing when creating the
+    // region on other members
+    PartitionAttributes<String, String> attributes =
+        new PartitionAttributesFactory<String, String>()
+            .setTotalNumBuckets(BUCKETS)
+            .setStartupRecoveryDelay(-1)
+            .create();
+
+    RegionFactory<String, String> factory = cacheRule.getCache()
+        .<String, String>createRegionFactory(regionShortcut)
+        .setPartitionAttributes(attributes);
+
+    if (regionShortcut.isPersistent()) {
+      factory.setDiskStoreName(
+          cacheRule.getCache().createDiskStoreFactory().create(DISK_STORE_NAME).getName());
+    }
+
+    factory.create(REGION_NAME);
+  }
+
+  private void parametrizedSetup(RegionShortcut regionShortcut) {
+    // Create and populate the region on server1 first, to create an unbalanced distribution of data
+    server1.invoke(() -> {
+      initDataStore(regionShortcut);
+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);
+      IntStream.range(0, ENTRIES).forEach(i -> region.put("key" + i, "value" + i));
+    });
+    server2.invoke(() -> initDataStore(regionShortcut));
+    accessor.invoke(() -> initAccessor(regionShortcut));
+  }
+
+  private AsyncInvocation<Object> setupAndPrepareClear(TestVM clearCoordinatorVM,
+      RegionShortcut regionType) {
+    parametrizedSetup(regionType);
+
+    return getVM(clearCoordinatorVM.vmNumber).invokeAsync(() -> {
+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);
+      // Wait for the signal from the blackboard before triggering the clear to start
+      getBlackboard().waitForGate(BEGIN_CLEAR, GeodeAwaitility.getTimeout().toMillis(),
+          TimeUnit.MILLISECONDS);
+      region.clear();
+    });
+  }
+
+  private RebalanceResults startRebalanceAndGetResults() throws InterruptedException {
+    // Start a rebalance and wait until bucket creation for redundancy recovery (the first stage of
+    // a rebalance operation) has started before signalling the blackboard
+    RebalanceOperation rebalanceOp =
+        cacheRule.getCache().getResourceManager().createRebalanceFactory().start();
+    await().untilAsserted(() -> assertThat(cacheRule.getCache().getInternalResourceManager()
+        .getStats().getRebalanceBucketCreatesCompleted(), greaterThan(0)));
+    getBlackboard().signalGate(BEGIN_CLEAR);
+
+    return rebalanceOp.getResults();
+  }
+
+  private void waitForSilence() {
+    DMStats dmStats = cacheRule.getSystem().getDistributionManager().getStats();
+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);
+    PartitionedRegionStats partitionedRegionStats = region.getPrStats();
+
+    await().untilAsserted(() -> {
+      Assertions.assertThat(dmStats.getReplyWaitsInProgress()).isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getVolunteeringInProgress()).isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getBucketCreatesInProgress()).isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getPrimaryTransfersInProgress()).isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getRebalanceBucketCreatesInProgress())
+          .isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getRebalancePrimaryTransfersInProgress())
+          .isEqualTo(0);
+    });
+  }
+
+  private void assertRegionIsEmpty(List<VM> vms) {
+    vms.forEach(vm -> vm.invoke(() -> {
+      waitForSilence();
+      PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);
+
+      Assertions.assertThat(region.getLocalSize()).isEqualTo(0);
+    }));
+  }
+
+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {
+    vmsToBounce.forEach(vm -> vm.invoke(() -> {
+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);
+      region.getAttributesMutator().setCacheWriter(new MemberKiller());
+    }));
+  }
+
+  @Test
+  @Parameters(method = "vmsAndRegionTypes")
+  @TestCaseName("[{index}] {method}(ClearCoordinator:{0}, RebalanceCoordinator:{1}, RegionType:{2})")
+  public void clearRegionDuringRebalanceClearsRegion(TestVM clearCoordinatorVM,
+      TestVM rebalanceVM, RegionShortcut regionType) throws InterruptedException {
+    AsyncInvocation<?> clearInvocation = setupAndPrepareClear(clearCoordinatorVM, regionType);
+
+    getVM(rebalanceVM.vmNumber).invoke(() -> {
+      RebalanceResults results = startRebalanceAndGetResults();
+
+      // Verify that rebalance did some work
+      int combinedResults = results.getTotalBucketTransfersCompleted()
+          + results.getTotalBucketCreatesCompleted() + results.getTotalPrimaryTransfersCompleted();
+      assertThat(combinedResults, greaterThan(0));
+
+      // Verify that no bucket creates failed during the rebalance
+      assertThat(cacheRule.getCache().getInternalResourceManager().getStats()
+          .getRebalanceBucketCreatesFailed(), is(0));
+    });
+
+    clearInvocation.await();
+
+    // Assert that the region is empty
+    assertRegionIsEmpty(asList(accessor, server1, server2));
+  }
+
+  @Test
+  @Parameters(method = "vmsAndRegionTypes")
+  @TestCaseName("[{index}] {method}(ClearCoordinator:{0}, RebalanceCoordinator:{1}, RegionType:{2})")
+  public void clearRegionDuringRebalancePrimaryReassignmentClearsRegion(TestVM clearCoordinatorVM,
+      TestVM rebalanceVM, RegionShortcut regionType) throws InterruptedException {
+    AsyncInvocation<?> clearInvocation = setupAndPrepareClear(clearCoordinatorVM, regionType);
+
+    getVM(rebalanceVM.vmNumber).invoke(() -> {
+      // Start a rebalance and wait until primary reassignment has started before signalling the
+      // blackboard
+      RebalanceOperation rebalanceOp =

Review comment:
       Its same as "startRebalanceAndGetResults()"; can it be called here as done in previous test. 

##########
File path: geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithRebalanceDUnitTest.java
##########
@@ -0,0 +1,376 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import static org.apache.geode.cache.PartitionAttributesFactory.GLOBAL_MAX_BUCKETS_DEFAULT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT_PERSISTENT;
+import static org.apache.geode.internal.util.ArrayUtils.asList;
+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;
+import static org.apache.geode.test.dunit.VM.getVM;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.Matchers.greaterThan;
+import static org.junit.Assert.assertThat;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.IntStream;
+
+import junitparams.JUnitParamsRunner;
+import junitparams.Parameters;
+import junitparams.naming.TestCaseName;
+import org.assertj.core.api.Assertions;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.apache.geode.cache.CacheWriterException;
+import org.apache.geode.cache.PartitionAttributes;
+import org.apache.geode.cache.PartitionAttributesFactory;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionEvent;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.cache.control.RebalanceOperation;
+import org.apache.geode.cache.control.RebalanceResults;
+import org.apache.geode.cache.partition.PartitionRegionHelper;
+import org.apache.geode.cache.util.CacheWriterAdapter;
+import org.apache.geode.distributed.internal.DMStats;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;
+import org.apache.geode.test.awaitility.GeodeAwaitility;
+import org.apache.geode.test.dunit.AsyncInvocation;
+import org.apache.geode.test.dunit.DUnitBlackboard;
+import org.apache.geode.test.dunit.VM;
+import org.apache.geode.test.dunit.rules.CacheRule;
+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;
+import org.apache.geode.test.dunit.rules.DistributedRule;
+
+@RunWith(JUnitParamsRunner.class)
+public class PartitionedRegionClearWithRebalanceDUnitTest implements Serializable {
+  private static final long serialVersionUID = -7183993832801073933L;
+
+  private static final Integer BUCKETS = GLOBAL_MAX_BUCKETS_DEFAULT;
+  private static final String REGION_NAME = "PartitionedRegion";
+  public static final String DISK_STORE_NAME = "diskStore";
+  public static final String BEGIN_CLEAR = "begin-clear";
+  private static final int ENTRIES = 10000;
+
+  @Rule
+  public DistributedRule distributedRule = new DistributedRule(3);
+
+  @Rule
+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();
+
+  @Rule
+  public DistributedDiskDirRule distributedDiskDirRule = new DistributedDiskDirRule();
+
+  private static transient DUnitBlackboard blackboard;
+
+  private VM accessor;
+  private VM server1;
+  private VM server2;
+
+  private enum TestVM {
+    ACCESSOR(0), SERVER1(1), SERVER2(2);
+
+    final int vmNumber;
+
+    TestVM(int vmNumber) {
+      this.vmNumber = vmNumber;
+    }
+  }
+
+  @SuppressWarnings("unused")
+  static RegionShortcut[] regionTypes() {
+    return new RegionShortcut[] {
+        PARTITION_REDUNDANT,
+        PARTITION_REDUNDANT_PERSISTENT,
+    };
+  }
+
+  @SuppressWarnings("unused")
+  static Object[] vmsAndRegionTypes() {
+    ArrayList<Object[]> parameters = new ArrayList<>();
+    RegionShortcut[] regionShortcuts = regionTypes();
+
+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {
+      // {ClearCoordinatorVM, RebalanceVM, regionShortcut}
+      parameters.add(new Object[] {TestVM.SERVER1, TestVM.SERVER1, regionShortcut});
+      parameters.add(new Object[] {TestVM.SERVER1, TestVM.ACCESSOR, regionShortcut});
+      parameters.add(new Object[] {TestVM.ACCESSOR, TestVM.SERVER1, regionShortcut});
+      parameters.add(new Object[] {TestVM.ACCESSOR, TestVM.ACCESSOR, regionShortcut});
+    });
+
+    return parameters.toArray();
+  }
+
+  @Before
+  public void setUp() throws Exception {
+    getBlackboard().initBlackboard();
+    server1 = getVM(TestVM.SERVER1.vmNumber);
+    server2 = getVM(TestVM.SERVER2.vmNumber);
+    accessor = getVM(TestVM.ACCESSOR.vmNumber);
+  }
+
+  private static DUnitBlackboard getBlackboard() {
+    if (blackboard == null) {
+      blackboard = new DUnitBlackboard();
+    }
+    return blackboard;
+  }
+
+  private RegionShortcut getRegionAccessorShortcut(RegionShortcut dataStoreRegionShortcut) {
+    if (dataStoreRegionShortcut.isPersistent()) {
+      switch (dataStoreRegionShortcut) {
+        case PARTITION_PERSISTENT:
+          return PARTITION;
+        case PARTITION_REDUNDANT_PERSISTENT:
+          return PARTITION_REDUNDANT;
+      }
+    }
+
+    return dataStoreRegionShortcut;
+  }
+
+  private void initAccessor(RegionShortcut regionShortcut) {
+    RegionShortcut accessorShortcut = getRegionAccessorShortcut(regionShortcut);
+    // StartupRecoveryDelay is set to infinite to prevent automatic rebalancing when creating the
+    // region on other members
+    PartitionAttributes<String, String> attributes =
+        new PartitionAttributesFactory<String, String>()
+            .setTotalNumBuckets(BUCKETS)
+            .setStartupRecoveryDelay(-1)
+            .setLocalMaxMemory(0)
+            .create();
+
+    cacheRule.getCache()
+        .<String, String>createRegionFactory(accessorShortcut)
+        .setPartitionAttributes(attributes)
+        .create(REGION_NAME);
+  }
+
+  private void initDataStore(RegionShortcut regionShortcut) {
+    // StartupRecoveryDelay is set to infinite to prevent automatic rebalancing when creating the
+    // region on other members
+    PartitionAttributes<String, String> attributes =
+        new PartitionAttributesFactory<String, String>()
+            .setTotalNumBuckets(BUCKETS)
+            .setStartupRecoveryDelay(-1)
+            .create();
+
+    RegionFactory<String, String> factory = cacheRule.getCache()
+        .<String, String>createRegionFactory(regionShortcut)
+        .setPartitionAttributes(attributes);
+
+    if (regionShortcut.isPersistent()) {
+      factory.setDiskStoreName(
+          cacheRule.getCache().createDiskStoreFactory().create(DISK_STORE_NAME).getName());
+    }
+
+    factory.create(REGION_NAME);
+  }
+
+  private void parametrizedSetup(RegionShortcut regionShortcut) {
+    // Create and populate the region on server1 first, to create an unbalanced distribution of data
+    server1.invoke(() -> {
+      initDataStore(regionShortcut);
+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);
+      IntStream.range(0, ENTRIES).forEach(i -> region.put("key" + i, "value" + i));
+    });
+    server2.invoke(() -> initDataStore(regionShortcut));
+    accessor.invoke(() -> initAccessor(regionShortcut));
+  }
+
+  private AsyncInvocation<Object> setupAndPrepareClear(TestVM clearCoordinatorVM,
+      RegionShortcut regionType) {
+    parametrizedSetup(regionType);
+
+    return getVM(clearCoordinatorVM.vmNumber).invokeAsync(() -> {
+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);
+      // Wait for the signal from the blackboard before triggering the clear to start
+      getBlackboard().waitForGate(BEGIN_CLEAR, GeodeAwaitility.getTimeout().toMillis(),
+          TimeUnit.MILLISECONDS);
+      region.clear();
+    });
+  }
+
+  private RebalanceResults startRebalanceAndGetResults() throws InterruptedException {
+    // Start a rebalance and wait until bucket creation for redundancy recovery (the first stage of
+    // a rebalance operation) has started before signalling the blackboard
+    RebalanceOperation rebalanceOp =
+        cacheRule.getCache().getResourceManager().createRebalanceFactory().start();
+    await().untilAsserted(() -> assertThat(cacheRule.getCache().getInternalResourceManager()
+        .getStats().getRebalanceBucketCreatesCompleted(), greaterThan(0)));
+    getBlackboard().signalGate(BEGIN_CLEAR);
+
+    return rebalanceOp.getResults();
+  }
+
+  private void waitForSilence() {
+    DMStats dmStats = cacheRule.getSystem().getDistributionManager().getStats();
+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);
+    PartitionedRegionStats partitionedRegionStats = region.getPrStats();
+
+    await().untilAsserted(() -> {
+      Assertions.assertThat(dmStats.getReplyWaitsInProgress()).isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getVolunteeringInProgress()).isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getBucketCreatesInProgress()).isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getPrimaryTransfersInProgress()).isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getRebalanceBucketCreatesInProgress())
+          .isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getRebalancePrimaryTransfersInProgress())
+          .isEqualTo(0);
+    });
+  }
+
+  private void assertRegionIsEmpty(List<VM> vms) {
+    vms.forEach(vm -> vm.invoke(() -> {
+      waitForSilence();
+      PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);
+
+      Assertions.assertThat(region.getLocalSize()).isEqualTo(0);
+    }));
+  }
+
+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {
+    vmsToBounce.forEach(vm -> vm.invoke(() -> {
+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);
+      region.getAttributesMutator().setCacheWriter(new MemberKiller());
+    }));
+  }
+
+  @Test
+  @Parameters(method = "vmsAndRegionTypes")
+  @TestCaseName("[{index}] {method}(ClearCoordinator:{0}, RebalanceCoordinator:{1}, RegionType:{2})")
+  public void clearRegionDuringRebalanceClearsRegion(TestVM clearCoordinatorVM,
+      TestVM rebalanceVM, RegionShortcut regionType) throws InterruptedException {
+    AsyncInvocation<?> clearInvocation = setupAndPrepareClear(clearCoordinatorVM, regionType);
+
+    getVM(rebalanceVM.vmNumber).invoke(() -> {
+      RebalanceResults results = startRebalanceAndGetResults();
+
+      // Verify that rebalance did some work
+      int combinedResults = results.getTotalBucketTransfersCompleted()
+          + results.getTotalBucketCreatesCompleted() + results.getTotalPrimaryTransfersCompleted();
+      assertThat(combinedResults, greaterThan(0));
+
+      // Verify that no bucket creates failed during the rebalance
+      assertThat(cacheRule.getCache().getInternalResourceManager().getStats()
+          .getRebalanceBucketCreatesFailed(), is(0));
+    });
+
+    clearInvocation.await();
+
+    // Assert that the region is empty
+    assertRegionIsEmpty(asList(accessor, server1, server2));
+  }
+
+  @Test
+  @Parameters(method = "vmsAndRegionTypes")
+  @TestCaseName("[{index}] {method}(ClearCoordinator:{0}, RebalanceCoordinator:{1}, RegionType:{2})")
+  public void clearRegionDuringRebalancePrimaryReassignmentClearsRegion(TestVM clearCoordinatorVM,
+      TestVM rebalanceVM, RegionShortcut regionType) throws InterruptedException {
+    AsyncInvocation<?> clearInvocation = setupAndPrepareClear(clearCoordinatorVM, regionType);
+
+    getVM(rebalanceVM.vmNumber).invoke(() -> {
+      // Start a rebalance and wait until primary reassignment has started before signalling the
+      // blackboard
+      RebalanceOperation rebalanceOp =
+          cacheRule.getCache().getResourceManager().createRebalanceFactory().start();
+      await().untilAsserted(() -> assertThat(cacheRule.getCache().getInternalResourceManager()
+          .getStats().getRebalancePrimaryTransfersCompleted(), greaterThan(0)));
+      getBlackboard().signalGate(BEGIN_CLEAR);
+
+      // Verify that rebalance did some work
+      RebalanceResults results = rebalanceOp.getResults();
+      int combinedResults = results.getTotalBucketTransfersCompleted()
+          + results.getTotalBucketCreatesCompleted() + results.getTotalPrimaryTransfersCompleted();
+      assertThat(combinedResults, greaterThan(0));
+
+      // Verify that no primary transfers failed during the rebalance
+      assertThat(cacheRule.getCache().getInternalResourceManager().getStats()
+          .getRebalancePrimaryTransfersFailed(), is(0));
+    });
+
+    clearInvocation.await();
+
+    // Assert that the region is empty
+    assertRegionIsEmpty(asList(accessor, server1, server2));
+  }
+
+  @Test
+  @Parameters(method = "vmsAndRegionTypes")
+  @TestCaseName("[{index}] {method}(ClearCoordinator:{0}, RebalanceCoordinator:{1}, RegionType:{2})")
+  public void clearRegionDuringRebalanceClearsRegionWhenNonCoordinatorIsBounced(
+      TestVM clearCoordinatorVM, TestVM rebalanceVM, RegionShortcut regionType)
+      throws InterruptedException {
+    AsyncInvocation<?> clearInvocation = setupAndPrepareClear(clearCoordinatorVM, regionType);
+
+    // Server 2 is never the clear coordinator
+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));
+
+    getVM(rebalanceVM.vmNumber).invoke(() -> {
+      // Start a rebalance and wait until bucket creation for redundancy recovery has started before
+      // signalling the blackboard
+      RebalanceResults results = startRebalanceAndGetResults();
+
+      // Verify that rebalance did some work
+      int combinedResults = results.getTotalBucketTransfersCompleted()
+          + results.getTotalBucketCreatesCompleted() + results.getTotalPrimaryTransfersCompleted();
+      assertThat(combinedResults, greaterThan(0));
+    });
+
+    clearInvocation.await();
+
+    // Bring server 2 back online and assign buckets
+    server2.invoke(() -> {
+      cacheRule.createCache();
+      initDataStore(regionType);
+      await().untilAsserted(
+          () -> Assertions.assertThat(InternalDistributedSystem.getConnectedInstance())
+              .isNotNull());
+      PartitionRegionHelper.assignBucketsToPartitions(cacheRule.getCache().getRegion(REGION_NAME));
+    });
+
+    // Assert that the region is empty
+    assertRegionIsEmpty(asList(accessor, server1, server2));
+  }
+
+  /**
+   * Shutdowns a member while the clear operation is in progress.
+   * The writer is only installed on the member the test wants to shutdown, doesn't matter whether
+   * it's the clear coordinator or another member holding primary buckets.
+   */
+  public static class MemberKiller extends CacheWriterAdapter<String, String> {
+
+    @Override
+    public synchronized void beforeRegionClear(RegionEvent<String, String> event)
+        throws CacheWriterException {
+      InternalDistributedSystem.getConnectedInstance().stopReconnectingNoDisconnect();
+      MembershipManagerHelper.crashDistributedSystem(
+          InternalDistributedSystem.getConnectedInstance());
+      await().untilAsserted(
+          () -> Assertions.assertThat(InternalDistributedSystem.getConnectedInstance()).isNull());

Review comment:
       Do we need additional check to see cache is closed...When this vm is restarted, it creates the cache again.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


DonalEvans commented on a change in pull request #5095:
URL: https://github.com/apache/geode/pull/5095#discussion_r424764533



##########
File path: geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithRebalanceDUnitTest.java
##########
@@ -0,0 +1,376 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import static org.apache.geode.cache.PartitionAttributesFactory.GLOBAL_MAX_BUCKETS_DEFAULT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT_PERSISTENT;
+import static org.apache.geode.internal.util.ArrayUtils.asList;
+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;
+import static org.apache.geode.test.dunit.VM.getVM;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.Matchers.greaterThan;
+import static org.junit.Assert.assertThat;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.IntStream;
+
+import junitparams.JUnitParamsRunner;
+import junitparams.Parameters;
+import junitparams.naming.TestCaseName;
+import org.assertj.core.api.Assertions;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.apache.geode.cache.CacheWriterException;
+import org.apache.geode.cache.PartitionAttributes;
+import org.apache.geode.cache.PartitionAttributesFactory;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionEvent;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.cache.control.RebalanceOperation;
+import org.apache.geode.cache.control.RebalanceResults;
+import org.apache.geode.cache.partition.PartitionRegionHelper;
+import org.apache.geode.cache.util.CacheWriterAdapter;
+import org.apache.geode.distributed.internal.DMStats;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;
+import org.apache.geode.test.awaitility.GeodeAwaitility;
+import org.apache.geode.test.dunit.AsyncInvocation;
+import org.apache.geode.test.dunit.DUnitBlackboard;
+import org.apache.geode.test.dunit.VM;
+import org.apache.geode.test.dunit.rules.CacheRule;
+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;
+import org.apache.geode.test.dunit.rules.DistributedRule;
+
+@RunWith(JUnitParamsRunner.class)
+public class PartitionedRegionClearWithRebalanceDUnitTest implements Serializable {
+  private static final long serialVersionUID = -7183993832801073933L;
+
+  private static final Integer BUCKETS = GLOBAL_MAX_BUCKETS_DEFAULT;
+  private static final String REGION_NAME = "PartitionedRegion";
+  public static final String DISK_STORE_NAME = "diskStore";
+  public static final String BEGIN_CLEAR = "begin-clear";
+  private static final int ENTRIES = 10000;
+
+  @Rule
+  public DistributedRule distributedRule = new DistributedRule(3);
+
+  @Rule
+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();
+
+  @Rule
+  public DistributedDiskDirRule distributedDiskDirRule = new DistributedDiskDirRule();
+
+  private static transient DUnitBlackboard blackboard;
+
+  private VM accessor;
+  private VM server1;
+  private VM server2;
+
+  private enum TestVM {
+    ACCESSOR(0), SERVER1(1), SERVER2(2);
+
+    final int vmNumber;
+
+    TestVM(int vmNumber) {
+      this.vmNumber = vmNumber;
+    }
+  }
+
+  @SuppressWarnings("unused")
+  static RegionShortcut[] regionTypes() {
+    return new RegionShortcut[] {
+        PARTITION_REDUNDANT,
+        PARTITION_REDUNDANT_PERSISTENT,
+    };
+  }
+
+  @SuppressWarnings("unused")
+  static Object[] vmsAndRegionTypes() {
+    ArrayList<Object[]> parameters = new ArrayList<>();
+    RegionShortcut[] regionShortcuts = regionTypes();
+
+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {
+      // {ClearCoordinatorVM, RebalanceVM, regionShortcut}
+      parameters.add(new Object[] {TestVM.SERVER1, TestVM.SERVER1, regionShortcut});
+      parameters.add(new Object[] {TestVM.SERVER1, TestVM.ACCESSOR, regionShortcut});
+      parameters.add(new Object[] {TestVM.ACCESSOR, TestVM.SERVER1, regionShortcut});
+      parameters.add(new Object[] {TestVM.ACCESSOR, TestVM.ACCESSOR, regionShortcut});
+    });
+
+    return parameters.toArray();
+  }
+
+  @Before
+  public void setUp() throws Exception {
+    getBlackboard().initBlackboard();
+    server1 = getVM(TestVM.SERVER1.vmNumber);
+    server2 = getVM(TestVM.SERVER2.vmNumber);
+    accessor = getVM(TestVM.ACCESSOR.vmNumber);
+  }
+
+  private static DUnitBlackboard getBlackboard() {
+    if (blackboard == null) {
+      blackboard = new DUnitBlackboard();
+    }
+    return blackboard;
+  }
+
+  private RegionShortcut getRegionAccessorShortcut(RegionShortcut dataStoreRegionShortcut) {
+    if (dataStoreRegionShortcut.isPersistent()) {
+      switch (dataStoreRegionShortcut) {
+        case PARTITION_PERSISTENT:
+          return PARTITION;
+        case PARTITION_REDUNDANT_PERSISTENT:
+          return PARTITION_REDUNDANT;
+      }
+    }
+
+    return dataStoreRegionShortcut;
+  }
+
+  private void initAccessor(RegionShortcut regionShortcut) {
+    RegionShortcut accessorShortcut = getRegionAccessorShortcut(regionShortcut);
+    // StartupRecoveryDelay is set to infinite to prevent automatic rebalancing when creating the
+    // region on other members
+    PartitionAttributes<String, String> attributes =
+        new PartitionAttributesFactory<String, String>()
+            .setTotalNumBuckets(BUCKETS)
+            .setStartupRecoveryDelay(-1)
+            .setLocalMaxMemory(0)
+            .create();
+
+    cacheRule.getCache()
+        .<String, String>createRegionFactory(accessorShortcut)
+        .setPartitionAttributes(attributes)
+        .create(REGION_NAME);
+  }
+
+  private void initDataStore(RegionShortcut regionShortcut) {
+    // StartupRecoveryDelay is set to infinite to prevent automatic rebalancing when creating the
+    // region on other members
+    PartitionAttributes<String, String> attributes =
+        new PartitionAttributesFactory<String, String>()
+            .setTotalNumBuckets(BUCKETS)
+            .setStartupRecoveryDelay(-1)
+            .create();
+
+    RegionFactory<String, String> factory = cacheRule.getCache()
+        .<String, String>createRegionFactory(regionShortcut)
+        .setPartitionAttributes(attributes);
+
+    if (regionShortcut.isPersistent()) {
+      factory.setDiskStoreName(
+          cacheRule.getCache().createDiskStoreFactory().create(DISK_STORE_NAME).getName());
+    }
+
+    factory.create(REGION_NAME);
+  }
+
+  private void parametrizedSetup(RegionShortcut regionShortcut) {
+    // Create and populate the region on server1 first, to create an unbalanced distribution of data
+    server1.invoke(() -> {
+      initDataStore(regionShortcut);
+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);
+      IntStream.range(0, ENTRIES).forEach(i -> region.put("key" + i, "value" + i));
+    });
+    server2.invoke(() -> initDataStore(regionShortcut));
+    accessor.invoke(() -> initAccessor(regionShortcut));
+  }
+
+  private AsyncInvocation<Object> setupAndPrepareClear(TestVM clearCoordinatorVM,
+      RegionShortcut regionType) {
+    parametrizedSetup(regionType);
+
+    return getVM(clearCoordinatorVM.vmNumber).invokeAsync(() -> {
+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);
+      // Wait for the signal from the blackboard before triggering the clear to start
+      getBlackboard().waitForGate(BEGIN_CLEAR, GeodeAwaitility.getTimeout().toMillis(),
+          TimeUnit.MILLISECONDS);
+      region.clear();
+    });
+  }
+
+  private RebalanceResults startRebalanceAndGetResults() throws InterruptedException {
+    // Start a rebalance and wait until bucket creation for redundancy recovery (the first stage of
+    // a rebalance operation) has started before signalling the blackboard
+    RebalanceOperation rebalanceOp =
+        cacheRule.getCache().getResourceManager().createRebalanceFactory().start();
+    await().untilAsserted(() -> assertThat(cacheRule.getCache().getInternalResourceManager()
+        .getStats().getRebalanceBucketCreatesCompleted(), greaterThan(0)));
+    getBlackboard().signalGate(BEGIN_CLEAR);
+
+    return rebalanceOp.getResults();
+  }
+
+  private void waitForSilence() {
+    DMStats dmStats = cacheRule.getSystem().getDistributionManager().getStats();
+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);
+    PartitionedRegionStats partitionedRegionStats = region.getPrStats();
+
+    await().untilAsserted(() -> {
+      Assertions.assertThat(dmStats.getReplyWaitsInProgress()).isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getVolunteeringInProgress()).isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getBucketCreatesInProgress()).isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getPrimaryTransfersInProgress()).isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getRebalanceBucketCreatesInProgress())
+          .isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getRebalancePrimaryTransfersInProgress())
+          .isEqualTo(0);
+    });
+  }
+
+  private void assertRegionIsEmpty(List<VM> vms) {
+    vms.forEach(vm -> vm.invoke(() -> {
+      waitForSilence();
+      PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);
+
+      Assertions.assertThat(region.getLocalSize()).isEqualTo(0);
+    }));
+  }
+
+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {
+    vmsToBounce.forEach(vm -> vm.invoke(() -> {
+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);
+      region.getAttributesMutator().setCacheWriter(new MemberKiller());
+    }));
+  }
+
+  @Test
+  @Parameters(method = "vmsAndRegionTypes")
+  @TestCaseName("[{index}] {method}(ClearCoordinator:{0}, RebalanceCoordinator:{1}, RegionType:{2})")
+  public void clearRegionDuringRebalanceClearsRegion(TestVM clearCoordinatorVM,
+      TestVM rebalanceVM, RegionShortcut regionType) throws InterruptedException {
+    AsyncInvocation<?> clearInvocation = setupAndPrepareClear(clearCoordinatorVM, regionType);
+
+    getVM(rebalanceVM.vmNumber).invoke(() -> {
+      RebalanceResults results = startRebalanceAndGetResults();
+
+      // Verify that rebalance did some work
+      int combinedResults = results.getTotalBucketTransfersCompleted()
+          + results.getTotalBucketCreatesCompleted() + results.getTotalPrimaryTransfersCompleted();
+      assertThat(combinedResults, greaterThan(0));
+
+      // Verify that no bucket creates failed during the rebalance
+      assertThat(cacheRule.getCache().getInternalResourceManager().getStats()
+          .getRebalanceBucketCreatesFailed(), is(0));
+    });
+
+    clearInvocation.await();
+
+    // Assert that the region is empty
+    assertRegionIsEmpty(asList(accessor, server1, server2));
+  }
+
+  @Test
+  @Parameters(method = "vmsAndRegionTypes")
+  @TestCaseName("[{index}] {method}(ClearCoordinator:{0}, RebalanceCoordinator:{1}, RegionType:{2})")
+  public void clearRegionDuringRebalancePrimaryReassignmentClearsRegion(TestVM clearCoordinatorVM,
+      TestVM rebalanceVM, RegionShortcut regionType) throws InterruptedException {
+    AsyncInvocation<?> clearInvocation = setupAndPrepareClear(clearCoordinatorVM, regionType);
+
+    getVM(rebalanceVM.vmNumber).invoke(() -> {
+      // Start a rebalance and wait until primary reassignment has started before signalling the
+      // blackboard
+      RebalanceOperation rebalanceOp =

Review comment:
       This case is actually slightly different; it waits for `getRebalance**PrimaryTransfers**Completed()` to be greater than zero instead of `getRebalance**BucketCreates**Completed()`. This case is intended to test the behaviour of clear when rebalance is doing the reassigning primaries step specifically.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


DonalEvans commented on a change in pull request #5095:
URL: https://github.com/apache/geode/pull/5095#discussion_r424767889



##########
File path: geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithRebalanceDUnitTest.java
##########
@@ -0,0 +1,376 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import static org.apache.geode.cache.PartitionAttributesFactory.GLOBAL_MAX_BUCKETS_DEFAULT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT_PERSISTENT;
+import static org.apache.geode.internal.util.ArrayUtils.asList;
+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;
+import static org.apache.geode.test.dunit.VM.getVM;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.Matchers.greaterThan;
+import static org.junit.Assert.assertThat;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.IntStream;
+
+import junitparams.JUnitParamsRunner;
+import junitparams.Parameters;
+import junitparams.naming.TestCaseName;
+import org.assertj.core.api.Assertions;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.apache.geode.cache.CacheWriterException;
+import org.apache.geode.cache.PartitionAttributes;
+import org.apache.geode.cache.PartitionAttributesFactory;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionEvent;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.cache.control.RebalanceOperation;
+import org.apache.geode.cache.control.RebalanceResults;
+import org.apache.geode.cache.partition.PartitionRegionHelper;
+import org.apache.geode.cache.util.CacheWriterAdapter;
+import org.apache.geode.distributed.internal.DMStats;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;
+import org.apache.geode.test.awaitility.GeodeAwaitility;
+import org.apache.geode.test.dunit.AsyncInvocation;
+import org.apache.geode.test.dunit.DUnitBlackboard;
+import org.apache.geode.test.dunit.VM;
+import org.apache.geode.test.dunit.rules.CacheRule;
+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;
+import org.apache.geode.test.dunit.rules.DistributedRule;
+
+@RunWith(JUnitParamsRunner.class)
+public class PartitionedRegionClearWithRebalanceDUnitTest implements Serializable {
+  private static final long serialVersionUID = -7183993832801073933L;
+
+  private static final Integer BUCKETS = GLOBAL_MAX_BUCKETS_DEFAULT;
+  private static final String REGION_NAME = "PartitionedRegion";
+  public static final String DISK_STORE_NAME = "diskStore";
+  public static final String BEGIN_CLEAR = "begin-clear";
+  private static final int ENTRIES = 10000;
+
+  @Rule
+  public DistributedRule distributedRule = new DistributedRule(3);
+
+  @Rule
+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();
+
+  @Rule
+  public DistributedDiskDirRule distributedDiskDirRule = new DistributedDiskDirRule();
+
+  private static transient DUnitBlackboard blackboard;
+
+  private VM accessor;
+  private VM server1;
+  private VM server2;
+
+  private enum TestVM {
+    ACCESSOR(0), SERVER1(1), SERVER2(2);
+
+    final int vmNumber;
+
+    TestVM(int vmNumber) {
+      this.vmNumber = vmNumber;
+    }
+  }
+
+  @SuppressWarnings("unused")
+  static RegionShortcut[] regionTypes() {
+    return new RegionShortcut[] {
+        PARTITION_REDUNDANT,
+        PARTITION_REDUNDANT_PERSISTENT,
+    };
+  }
+
+  @SuppressWarnings("unused")
+  static Object[] vmsAndRegionTypes() {
+    ArrayList<Object[]> parameters = new ArrayList<>();
+    RegionShortcut[] regionShortcuts = regionTypes();
+
+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {
+      // {ClearCoordinatorVM, RebalanceVM, regionShortcut}
+      parameters.add(new Object[] {TestVM.SERVER1, TestVM.SERVER1, regionShortcut});
+      parameters.add(new Object[] {TestVM.SERVER1, TestVM.ACCESSOR, regionShortcut});
+      parameters.add(new Object[] {TestVM.ACCESSOR, TestVM.SERVER1, regionShortcut});
+      parameters.add(new Object[] {TestVM.ACCESSOR, TestVM.ACCESSOR, regionShortcut});
+    });
+
+    return parameters.toArray();
+  }
+
+  @Before
+  public void setUp() throws Exception {
+    getBlackboard().initBlackboard();
+    server1 = getVM(TestVM.SERVER1.vmNumber);
+    server2 = getVM(TestVM.SERVER2.vmNumber);
+    accessor = getVM(TestVM.ACCESSOR.vmNumber);
+  }
+
+  private static DUnitBlackboard getBlackboard() {
+    if (blackboard == null) {
+      blackboard = new DUnitBlackboard();
+    }
+    return blackboard;
+  }
+
+  private RegionShortcut getRegionAccessorShortcut(RegionShortcut dataStoreRegionShortcut) {
+    if (dataStoreRegionShortcut.isPersistent()) {
+      switch (dataStoreRegionShortcut) {
+        case PARTITION_PERSISTENT:
+          return PARTITION;
+        case PARTITION_REDUNDANT_PERSISTENT:
+          return PARTITION_REDUNDANT;
+      }
+    }
+
+    return dataStoreRegionShortcut;
+  }
+
+  private void initAccessor(RegionShortcut regionShortcut) {
+    RegionShortcut accessorShortcut = getRegionAccessorShortcut(regionShortcut);
+    // StartupRecoveryDelay is set to infinite to prevent automatic rebalancing when creating the
+    // region on other members
+    PartitionAttributes<String, String> attributes =
+        new PartitionAttributesFactory<String, String>()
+            .setTotalNumBuckets(BUCKETS)
+            .setStartupRecoveryDelay(-1)
+            .setLocalMaxMemory(0)
+            .create();
+
+    cacheRule.getCache()
+        .<String, String>createRegionFactory(accessorShortcut)
+        .setPartitionAttributes(attributes)
+        .create(REGION_NAME);
+  }
+
+  private void initDataStore(RegionShortcut regionShortcut) {
+    // StartupRecoveryDelay is set to infinite to prevent automatic rebalancing when creating the
+    // region on other members
+    PartitionAttributes<String, String> attributes =
+        new PartitionAttributesFactory<String, String>()
+            .setTotalNumBuckets(BUCKETS)
+            .setStartupRecoveryDelay(-1)
+            .create();
+
+    RegionFactory<String, String> factory = cacheRule.getCache()
+        .<String, String>createRegionFactory(regionShortcut)
+        .setPartitionAttributes(attributes);
+
+    if (regionShortcut.isPersistent()) {
+      factory.setDiskStoreName(
+          cacheRule.getCache().createDiskStoreFactory().create(DISK_STORE_NAME).getName());
+    }
+
+    factory.create(REGION_NAME);
+  }
+
+  private void parametrizedSetup(RegionShortcut regionShortcut) {
+    // Create and populate the region on server1 first, to create an unbalanced distribution of data
+    server1.invoke(() -> {
+      initDataStore(regionShortcut);
+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);
+      IntStream.range(0, ENTRIES).forEach(i -> region.put("key" + i, "value" + i));
+    });
+    server2.invoke(() -> initDataStore(regionShortcut));
+    accessor.invoke(() -> initAccessor(regionShortcut));
+  }
+
+  private AsyncInvocation<Object> setupAndPrepareClear(TestVM clearCoordinatorVM,
+      RegionShortcut regionType) {
+    parametrizedSetup(regionType);
+
+    return getVM(clearCoordinatorVM.vmNumber).invokeAsync(() -> {
+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);
+      // Wait for the signal from the blackboard before triggering the clear to start
+      getBlackboard().waitForGate(BEGIN_CLEAR, GeodeAwaitility.getTimeout().toMillis(),
+          TimeUnit.MILLISECONDS);
+      region.clear();
+    });
+  }
+
+  private RebalanceResults startRebalanceAndGetResults() throws InterruptedException {
+    // Start a rebalance and wait until bucket creation for redundancy recovery (the first stage of
+    // a rebalance operation) has started before signalling the blackboard
+    RebalanceOperation rebalanceOp =
+        cacheRule.getCache().getResourceManager().createRebalanceFactory().start();
+    await().untilAsserted(() -> assertThat(cacheRule.getCache().getInternalResourceManager()
+        .getStats().getRebalanceBucketCreatesCompleted(), greaterThan(0)));

Review comment:
       There are 10,000 entries in the region, so the rebalance process takes some time. The clear should always start before the rebalance finishes, unless the rebalance manages to finish in only a few milliseconds. Is there a solution to this timing issue other than just making sure the rebalance takes longer? The `clear()` call will always have some possible delay in starting due to the `waitForGate()` call.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


DonalEvans commented on a change in pull request #5095:
URL: https://github.com/apache/geode/pull/5095#discussion_r424775709



##########
File path: geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithRebalanceDUnitTest.java
##########
@@ -0,0 +1,376 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import static org.apache.geode.cache.PartitionAttributesFactory.GLOBAL_MAX_BUCKETS_DEFAULT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT_PERSISTENT;
+import static org.apache.geode.internal.util.ArrayUtils.asList;
+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;
+import static org.apache.geode.test.dunit.VM.getVM;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.Matchers.greaterThan;
+import static org.junit.Assert.assertThat;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.IntStream;
+
+import junitparams.JUnitParamsRunner;
+import junitparams.Parameters;
+import junitparams.naming.TestCaseName;
+import org.assertj.core.api.Assertions;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.apache.geode.cache.CacheWriterException;
+import org.apache.geode.cache.PartitionAttributes;
+import org.apache.geode.cache.PartitionAttributesFactory;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionEvent;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.cache.control.RebalanceOperation;
+import org.apache.geode.cache.control.RebalanceResults;
+import org.apache.geode.cache.partition.PartitionRegionHelper;
+import org.apache.geode.cache.util.CacheWriterAdapter;
+import org.apache.geode.distributed.internal.DMStats;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.distributed.internal.membership.api.MembershipManagerHelper;
+import org.apache.geode.test.awaitility.GeodeAwaitility;
+import org.apache.geode.test.dunit.AsyncInvocation;
+import org.apache.geode.test.dunit.DUnitBlackboard;
+import org.apache.geode.test.dunit.VM;
+import org.apache.geode.test.dunit.rules.CacheRule;
+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;
+import org.apache.geode.test.dunit.rules.DistributedRule;
+
+@RunWith(JUnitParamsRunner.class)
+public class PartitionedRegionClearWithRebalanceDUnitTest implements Serializable {
+  private static final long serialVersionUID = -7183993832801073933L;
+
+  private static final Integer BUCKETS = GLOBAL_MAX_BUCKETS_DEFAULT;
+  private static final String REGION_NAME = "PartitionedRegion";
+  public static final String DISK_STORE_NAME = "diskStore";
+  public static final String BEGIN_CLEAR = "begin-clear";
+  private static final int ENTRIES = 10000;
+
+  @Rule
+  public DistributedRule distributedRule = new DistributedRule(3);
+
+  @Rule
+  public CacheRule cacheRule = CacheRule.builder().createCacheInAll().build();
+
+  @Rule
+  public DistributedDiskDirRule distributedDiskDirRule = new DistributedDiskDirRule();
+
+  private static transient DUnitBlackboard blackboard;
+
+  private VM accessor;
+  private VM server1;
+  private VM server2;
+
+  private enum TestVM {
+    ACCESSOR(0), SERVER1(1), SERVER2(2);
+
+    final int vmNumber;
+
+    TestVM(int vmNumber) {
+      this.vmNumber = vmNumber;
+    }
+  }
+
+  @SuppressWarnings("unused")
+  static RegionShortcut[] regionTypes() {
+    return new RegionShortcut[] {
+        PARTITION_REDUNDANT,
+        PARTITION_REDUNDANT_PERSISTENT,
+    };
+  }
+
+  @SuppressWarnings("unused")
+  static Object[] vmsAndRegionTypes() {
+    ArrayList<Object[]> parameters = new ArrayList<>();
+    RegionShortcut[] regionShortcuts = regionTypes();
+
+    Arrays.stream(regionShortcuts).forEach(regionShortcut -> {
+      // {ClearCoordinatorVM, RebalanceVM, regionShortcut}
+      parameters.add(new Object[] {TestVM.SERVER1, TestVM.SERVER1, regionShortcut});
+      parameters.add(new Object[] {TestVM.SERVER1, TestVM.ACCESSOR, regionShortcut});
+      parameters.add(new Object[] {TestVM.ACCESSOR, TestVM.SERVER1, regionShortcut});
+      parameters.add(new Object[] {TestVM.ACCESSOR, TestVM.ACCESSOR, regionShortcut});
+    });
+
+    return parameters.toArray();
+  }
+
+  @Before
+  public void setUp() throws Exception {
+    getBlackboard().initBlackboard();
+    server1 = getVM(TestVM.SERVER1.vmNumber);
+    server2 = getVM(TestVM.SERVER2.vmNumber);
+    accessor = getVM(TestVM.ACCESSOR.vmNumber);
+  }
+
+  private static DUnitBlackboard getBlackboard() {
+    if (blackboard == null) {
+      blackboard = new DUnitBlackboard();
+    }
+    return blackboard;
+  }
+
+  private RegionShortcut getRegionAccessorShortcut(RegionShortcut dataStoreRegionShortcut) {
+    if (dataStoreRegionShortcut.isPersistent()) {
+      switch (dataStoreRegionShortcut) {
+        case PARTITION_PERSISTENT:
+          return PARTITION;
+        case PARTITION_REDUNDANT_PERSISTENT:
+          return PARTITION_REDUNDANT;
+      }
+    }
+
+    return dataStoreRegionShortcut;
+  }
+
+  private void initAccessor(RegionShortcut regionShortcut) {
+    RegionShortcut accessorShortcut = getRegionAccessorShortcut(regionShortcut);
+    // StartupRecoveryDelay is set to infinite to prevent automatic rebalancing when creating the
+    // region on other members
+    PartitionAttributes<String, String> attributes =
+        new PartitionAttributesFactory<String, String>()
+            .setTotalNumBuckets(BUCKETS)
+            .setStartupRecoveryDelay(-1)
+            .setLocalMaxMemory(0)
+            .create();
+
+    cacheRule.getCache()
+        .<String, String>createRegionFactory(accessorShortcut)
+        .setPartitionAttributes(attributes)
+        .create(REGION_NAME);
+  }
+
+  private void initDataStore(RegionShortcut regionShortcut) {
+    // StartupRecoveryDelay is set to infinite to prevent automatic rebalancing when creating the
+    // region on other members
+    PartitionAttributes<String, String> attributes =
+        new PartitionAttributesFactory<String, String>()
+            .setTotalNumBuckets(BUCKETS)
+            .setStartupRecoveryDelay(-1)
+            .create();
+
+    RegionFactory<String, String> factory = cacheRule.getCache()
+        .<String, String>createRegionFactory(regionShortcut)
+        .setPartitionAttributes(attributes);
+
+    if (regionShortcut.isPersistent()) {
+      factory.setDiskStoreName(
+          cacheRule.getCache().createDiskStoreFactory().create(DISK_STORE_NAME).getName());
+    }
+
+    factory.create(REGION_NAME);
+  }
+
+  private void parametrizedSetup(RegionShortcut regionShortcut) {
+    // Create and populate the region on server1 first, to create an unbalanced distribution of data
+    server1.invoke(() -> {
+      initDataStore(regionShortcut);
+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);
+      IntStream.range(0, ENTRIES).forEach(i -> region.put("key" + i, "value" + i));
+    });
+    server2.invoke(() -> initDataStore(regionShortcut));
+    accessor.invoke(() -> initAccessor(regionShortcut));
+  }
+
+  private AsyncInvocation<Object> setupAndPrepareClear(TestVM clearCoordinatorVM,
+      RegionShortcut regionType) {
+    parametrizedSetup(regionType);
+
+    return getVM(clearCoordinatorVM.vmNumber).invokeAsync(() -> {
+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);
+      // Wait for the signal from the blackboard before triggering the clear to start
+      getBlackboard().waitForGate(BEGIN_CLEAR, GeodeAwaitility.getTimeout().toMillis(),
+          TimeUnit.MILLISECONDS);
+      region.clear();
+    });
+  }
+
+  private RebalanceResults startRebalanceAndGetResults() throws InterruptedException {
+    // Start a rebalance and wait until bucket creation for redundancy recovery (the first stage of
+    // a rebalance operation) has started before signalling the blackboard
+    RebalanceOperation rebalanceOp =
+        cacheRule.getCache().getResourceManager().createRebalanceFactory().start();
+    await().untilAsserted(() -> assertThat(cacheRule.getCache().getInternalResourceManager()
+        .getStats().getRebalanceBucketCreatesCompleted(), greaterThan(0)));
+    getBlackboard().signalGate(BEGIN_CLEAR);
+
+    return rebalanceOp.getResults();
+  }
+
+  private void waitForSilence() {
+    DMStats dmStats = cacheRule.getSystem().getDistributionManager().getStats();
+    PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);
+    PartitionedRegionStats partitionedRegionStats = region.getPrStats();
+
+    await().untilAsserted(() -> {
+      Assertions.assertThat(dmStats.getReplyWaitsInProgress()).isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getVolunteeringInProgress()).isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getBucketCreatesInProgress()).isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getPrimaryTransfersInProgress()).isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getRebalanceBucketCreatesInProgress())
+          .isEqualTo(0);
+      Assertions.assertThat(partitionedRegionStats.getRebalancePrimaryTransfersInProgress())
+          .isEqualTo(0);
+    });
+  }
+
+  private void assertRegionIsEmpty(List<VM> vms) {
+    vms.forEach(vm -> vm.invoke(() -> {
+      waitForSilence();
+      PartitionedRegion region = (PartitionedRegion) cacheRule.getCache().getRegion(REGION_NAME);
+
+      Assertions.assertThat(region.getLocalSize()).isEqualTo(0);
+    }));
+  }
+
+  private void registerVMKillerAsCacheWriter(List<VM> vmsToBounce) {
+    vmsToBounce.forEach(vm -> vm.invoke(() -> {
+      Region<String, String> region = cacheRule.getCache().getRegion(REGION_NAME);
+      region.getAttributesMutator().setCacheWriter(new MemberKiller());
+    }));
+  }
+
+  @Test
+  @Parameters(method = "vmsAndRegionTypes")
+  @TestCaseName("[{index}] {method}(ClearCoordinator:{0}, RebalanceCoordinator:{1}, RegionType:{2})")
+  public void clearRegionDuringRebalanceClearsRegion(TestVM clearCoordinatorVM,
+      TestVM rebalanceVM, RegionShortcut regionType) throws InterruptedException {
+    AsyncInvocation<?> clearInvocation = setupAndPrepareClear(clearCoordinatorVM, regionType);
+
+    getVM(rebalanceVM.vmNumber).invoke(() -> {
+      RebalanceResults results = startRebalanceAndGetResults();
+
+      // Verify that rebalance did some work
+      int combinedResults = results.getTotalBucketTransfersCompleted()
+          + results.getTotalBucketCreatesCompleted() + results.getTotalPrimaryTransfersCompleted();
+      assertThat(combinedResults, greaterThan(0));
+
+      // Verify that no bucket creates failed during the rebalance
+      assertThat(cacheRule.getCache().getInternalResourceManager().getStats()
+          .getRebalanceBucketCreatesFailed(), is(0));
+    });
+
+    clearInvocation.await();
+
+    // Assert that the region is empty
+    assertRegionIsEmpty(asList(accessor, server1, server2));
+  }
+
+  @Test
+  @Parameters(method = "vmsAndRegionTypes")
+  @TestCaseName("[{index}] {method}(ClearCoordinator:{0}, RebalanceCoordinator:{1}, RegionType:{2})")
+  public void clearRegionDuringRebalancePrimaryReassignmentClearsRegion(TestVM clearCoordinatorVM,
+      TestVM rebalanceVM, RegionShortcut regionType) throws InterruptedException {
+    AsyncInvocation<?> clearInvocation = setupAndPrepareClear(clearCoordinatorVM, regionType);
+
+    getVM(rebalanceVM.vmNumber).invoke(() -> {
+      // Start a rebalance and wait until primary reassignment has started before signalling the
+      // blackboard
+      RebalanceOperation rebalanceOp =
+          cacheRule.getCache().getResourceManager().createRebalanceFactory().start();
+      await().untilAsserted(() -> assertThat(cacheRule.getCache().getInternalResourceManager()
+          .getStats().getRebalancePrimaryTransfersCompleted(), greaterThan(0)));
+      getBlackboard().signalGate(BEGIN_CLEAR);
+
+      // Verify that rebalance did some work
+      RebalanceResults results = rebalanceOp.getResults();
+      int combinedResults = results.getTotalBucketTransfersCompleted()
+          + results.getTotalBucketCreatesCompleted() + results.getTotalPrimaryTransfersCompleted();
+      assertThat(combinedResults, greaterThan(0));
+
+      // Verify that no primary transfers failed during the rebalance
+      assertThat(cacheRule.getCache().getInternalResourceManager().getStats()
+          .getRebalancePrimaryTransfersFailed(), is(0));
+    });
+
+    clearInvocation.await();
+
+    // Assert that the region is empty
+    assertRegionIsEmpty(asList(accessor, server1, server2));
+  }
+
+  @Test
+  @Parameters(method = "vmsAndRegionTypes")
+  @TestCaseName("[{index}] {method}(ClearCoordinator:{0}, RebalanceCoordinator:{1}, RegionType:{2})")
+  public void clearRegionDuringRebalanceClearsRegionWhenNonCoordinatorIsBounced(
+      TestVM clearCoordinatorVM, TestVM rebalanceVM, RegionShortcut regionType)
+      throws InterruptedException {
+    AsyncInvocation<?> clearInvocation = setupAndPrepareClear(clearCoordinatorVM, regionType);
+
+    // Server 2 is never the clear coordinator
+    registerVMKillerAsCacheWriter(Collections.singletonList(server2));
+
+    getVM(rebalanceVM.vmNumber).invoke(() -> {
+      // Start a rebalance and wait until bucket creation for redundancy recovery has started before
+      // signalling the blackboard
+      RebalanceResults results = startRebalanceAndGetResults();
+
+      // Verify that rebalance did some work
+      int combinedResults = results.getTotalBucketTransfersCompleted()
+          + results.getTotalBucketCreatesCompleted() + results.getTotalPrimaryTransfersCompleted();
+      assertThat(combinedResults, greaterThan(0));
+    });
+
+    clearInvocation.await();
+
+    // Bring server 2 back online and assign buckets
+    server2.invoke(() -> {
+      cacheRule.createCache();
+      initDataStore(regionType);
+      await().untilAsserted(
+          () -> Assertions.assertThat(InternalDistributedSystem.getConnectedInstance())
+              .isNotNull());
+      PartitionRegionHelper.assignBucketsToPartitions(cacheRule.getCache().getRegion(REGION_NAME));
+    });
+
+    // Assert that the region is empty
+    assertRegionIsEmpty(asList(accessor, server1, server2));
+  }
+
+  /**
+   * Shutdowns a member while the clear operation is in progress.
+   * The writer is only installed on the member the test wants to shutdown, doesn't matter whether
+   * it's the clear coordinator or another member holding primary buckets.
+   */
+  public static class MemberKiller extends CacheWriterAdapter<String, String> {
+
+    @Override
+    public synchronized void beforeRegionClear(RegionEvent<String, String> event)
+        throws CacheWriterException {
+      InternalDistributedSystem.getConnectedInstance().stopReconnectingNoDisconnect();
+      MembershipManagerHelper.crashDistributedSystem(
+          InternalDistributedSystem.getConnectedInstance());
+      await().untilAsserted(
+          () -> Assertions.assertThat(InternalDistributedSystem.getConnectedInstance()).isNull());

Review comment:
       I can add a check.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


mhansonp closed pull request #5095:
URL: https://github.com/apache/geode/pull/5095


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


mhansonp commented on pull request #5095:
URL: https://github.com/apache/geode/pull/5095#issuecomment-629416047


   Sorry all, I don't know how I closed this! I didn't intend to.
   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


DonalEvans opened a new pull request #5095:
URL: https://github.com/apache/geode/pull/5095


   - Added DUnit tests to confirm that clear does not interfere with
   rebalance or vice versa
   - Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
   - Fixed typo in PartitionedRegion
   
   Authored-by: Donal Evans <doevans@pivotal.io>
   
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [x] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [x] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [x] Is your initial contribution a single, squashed commit?
   
   - [x] Does `gradlew build` run cleanly?
   
   - [x] Have you written or updated unit tests to verify your changes?
   
   - [N/A] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, check Concourse for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


agingade commented on a change in pull request #5095:
URL: https://github.com/apache/geode/pull/5095#discussion_r430713290



##########
File path: geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithRebalanceDUnitTest.java
##########
@@ -0,0 +1,386 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import static org.apache.geode.cache.PartitionAttributesFactory.GLOBAL_MAX_BUCKETS_DEFAULT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT_PERSISTENT;
+import static org.apache.geode.internal.util.ArrayUtils.asList;
+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;
+import static org.apache.geode.test.dunit.VM.getVM;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.Matchers.greaterThan;
+import static org.junit.Assert.assertThat;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.IntStream;
+
+import junitparams.JUnitParamsRunner;
+import junitparams.Parameters;
+import junitparams.naming.TestCaseName;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.apache.geode.cache.PartitionAttributes;
+import org.apache.geode.cache.PartitionAttributesFactory;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.cache.control.RebalanceOperation;
+import org.apache.geode.cache.control.RebalanceResults;
+import org.apache.geode.distributed.internal.DMStats;
+import org.apache.geode.test.awaitility.GeodeAwaitility;
+import org.apache.geode.test.dunit.AsyncInvocation;
+import org.apache.geode.test.dunit.DUnitBlackboard;
+import org.apache.geode.test.dunit.SerializableRunnableIF;
+import org.apache.geode.test.dunit.VM;
+import org.apache.geode.test.dunit.rules.CacheRule;
+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;
+import org.apache.geode.test.dunit.rules.DistributedRule;
+
+@RunWith(JUnitParamsRunner.class)
+public class PartitionedRegionClearWithRebalanceDUnitTest implements Serializable {

Review comment:
       Looks good. If it is fine with you, can you add one more scenario, where there are 3 data nodes/servers and one of the server is brought down (case 1) and brought up (case 2); during clear, rebalance in progress....

##########
File path: geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithRebalanceDUnitTest.java
##########
@@ -0,0 +1,386 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import static org.apache.geode.cache.PartitionAttributesFactory.GLOBAL_MAX_BUCKETS_DEFAULT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT_PERSISTENT;
+import static org.apache.geode.internal.util.ArrayUtils.asList;
+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;
+import static org.apache.geode.test.dunit.VM.getVM;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.Matchers.greaterThan;
+import static org.junit.Assert.assertThat;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.IntStream;
+
+import junitparams.JUnitParamsRunner;
+import junitparams.Parameters;
+import junitparams.naming.TestCaseName;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.apache.geode.cache.PartitionAttributes;
+import org.apache.geode.cache.PartitionAttributesFactory;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.cache.control.RebalanceOperation;
+import org.apache.geode.cache.control.RebalanceResults;
+import org.apache.geode.distributed.internal.DMStats;
+import org.apache.geode.test.awaitility.GeodeAwaitility;
+import org.apache.geode.test.dunit.AsyncInvocation;
+import org.apache.geode.test.dunit.DUnitBlackboard;
+import org.apache.geode.test.dunit.SerializableRunnableIF;
+import org.apache.geode.test.dunit.VM;
+import org.apache.geode.test.dunit.rules.CacheRule;
+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;
+import org.apache.geode.test.dunit.rules.DistributedRule;
+
+@RunWith(JUnitParamsRunner.class)
+public class PartitionedRegionClearWithRebalanceDUnitTest implements Serializable {

Review comment:
       Based on the redundant copies available; the clear should finish successfully, even with server down. The clear operation waits certain time for secondary to become primary, if it is unable to find the primary in given time, then it will throw Partial Clear exception.   




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


DonalEvans commented on a change in pull request #5095:
URL: https://github.com/apache/geode/pull/5095#discussion_r430716253



##########
File path: geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithRebalanceDUnitTest.java
##########
@@ -0,0 +1,386 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import static org.apache.geode.cache.PartitionAttributesFactory.GLOBAL_MAX_BUCKETS_DEFAULT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT_PERSISTENT;
+import static org.apache.geode.internal.util.ArrayUtils.asList;
+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;
+import static org.apache.geode.test.dunit.VM.getVM;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.Matchers.greaterThan;
+import static org.junit.Assert.assertThat;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.IntStream;
+
+import junitparams.JUnitParamsRunner;
+import junitparams.Parameters;
+import junitparams.naming.TestCaseName;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.apache.geode.cache.PartitionAttributes;
+import org.apache.geode.cache.PartitionAttributesFactory;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.cache.control.RebalanceOperation;
+import org.apache.geode.cache.control.RebalanceResults;
+import org.apache.geode.distributed.internal.DMStats;
+import org.apache.geode.test.awaitility.GeodeAwaitility;
+import org.apache.geode.test.dunit.AsyncInvocation;
+import org.apache.geode.test.dunit.DUnitBlackboard;
+import org.apache.geode.test.dunit.SerializableRunnableIF;
+import org.apache.geode.test.dunit.VM;
+import org.apache.geode.test.dunit.rules.CacheRule;
+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;
+import org.apache.geode.test.dunit.rules.DistributedRule;
+
+@RunWith(JUnitParamsRunner.class)
+public class PartitionedRegionClearWithRebalanceDUnitTest implements Serializable {

Review comment:
       In the first scenario, would we expect clear to succeed? If a member departs during clear, we get `PartitionedRegionPartialClearException`, right? I can definitely add the second scenario though.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


DonalEvans commented on a change in pull request #5095:
URL: https://github.com/apache/geode/pull/5095#discussion_r432000642



##########
File path: geode-core/src/distributedTest/java/org/apache/geode/internal/cache/PartitionedRegionClearWithRebalanceDUnitTest.java
##########
@@ -0,0 +1,386 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import static org.apache.geode.cache.PartitionAttributesFactory.GLOBAL_MAX_BUCKETS_DEFAULT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT;
+import static org.apache.geode.cache.RegionShortcut.PARTITION_REDUNDANT_PERSISTENT;
+import static org.apache.geode.internal.util.ArrayUtils.asList;
+import static org.apache.geode.test.awaitility.GeodeAwaitility.await;
+import static org.apache.geode.test.dunit.VM.getVM;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.Matchers.greaterThan;
+import static org.junit.Assert.assertThat;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.IntStream;
+
+import junitparams.JUnitParamsRunner;
+import junitparams.Parameters;
+import junitparams.naming.TestCaseName;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import org.apache.geode.cache.PartitionAttributes;
+import org.apache.geode.cache.PartitionAttributesFactory;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionFactory;
+import org.apache.geode.cache.RegionShortcut;
+import org.apache.geode.cache.control.RebalanceOperation;
+import org.apache.geode.cache.control.RebalanceResults;
+import org.apache.geode.distributed.internal.DMStats;
+import org.apache.geode.test.awaitility.GeodeAwaitility;
+import org.apache.geode.test.dunit.AsyncInvocation;
+import org.apache.geode.test.dunit.DUnitBlackboard;
+import org.apache.geode.test.dunit.SerializableRunnableIF;
+import org.apache.geode.test.dunit.VM;
+import org.apache.geode.test.dunit.rules.CacheRule;
+import org.apache.geode.test.dunit.rules.DistributedDiskDirRule;
+import org.apache.geode.test.dunit.rules.DistributedRule;
+
+@RunWith(JUnitParamsRunner.class)
+public class PartitionedRegionClearWithRebalanceDUnitTest implements Serializable {

Review comment:
       Using three servers, with a PartitionedRegion with one redundant copy, and killing the non-coordinator server when the clear operation starts, I am still seeing a PartialClearException some of the time. It seems to be flaky whether the clear operation has enough time to find the new primary in the case that a server goes down. This happens even if there is no rebalance happening at the time; as long as some data is hosted on the member that is killed, there is a chance of a PartialClearException, it seems. I don't know if it will be possible to write a useful test in this scenario, since we have to either assert that the clear succeeds, or that it fails, but it doesn't do either reliably.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


DonalEvans merged pull request #5095:
URL: https://github.com/apache/geode/pull/5095


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit b941d7fe7fb0df69636fbb7847899d10cf281dea in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=b941d7f ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 0cb20cb322000661a466f9f63cb2c107ca1eb5d4 in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=0cb20cb ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 0cb20cb322000661a466f9f63cb2c107ca1eb5d4 in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=0cb20cb ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 0cb20cb322000661a466f9f63cb2c107ca1eb5d4 in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=0cb20cb ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 0cb20cb322000661a466f9f63cb2c107ca1eb5d4 in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=0cb20cb ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 0cb20cb322000661a466f9f63cb2c107ca1eb5d4 in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=0cb20cb ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 605f5b25493f4223e7fa30cc0c0b946e33e6c199 in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=605f5b2 ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 605f5b25493f4223e7fa30cc0c0b946e33e6c199 in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=605f5b2 ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 605f5b25493f4223e7fa30cc0c0b946e33e6c199 in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=605f5b2 ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 605f5b25493f4223e7fa30cc0c0b946e33e6c199 in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=605f5b2 ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 605f5b25493f4223e7fa30cc0c0b946e33e6c199 in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=605f5b2 ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 7ce8d101d803e10eb3fa2af0c3e795e5bed793cd in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=7ce8d10 ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 7ce8d101d803e10eb3fa2af0c3e795e5bed793cd in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=7ce8d10 ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 7ce8d101d803e10eb3fa2af0c3e795e5bed793cd in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=7ce8d10 ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 7ce8d101d803e10eb3fa2af0c3e795e5bed793cd in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=7ce8d10 ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 7ce8d101d803e10eb3fa2af0c3e795e5bed793cd in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=7ce8d10 ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 62701f9c5a22a10dc6d3c0d89ef8ad795999fa0e in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=62701f9 ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 62701f9c5a22a10dc6d3c0d89ef8ad795999fa0e in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=62701f9 ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 62701f9c5a22a10dc6d3c0d89ef8ad795999fa0e in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=62701f9 ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 62701f9c5a22a10dc6d3c0d89ef8ad795999fa0e in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=62701f9 ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 62701f9c5a22a10dc6d3c0d89ef8ad795999fa0e in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=62701f9 ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 02336cdcd9cfb734c7f3abff97a65f51bec0e727 in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=02336cd ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 02336cdcd9cfb734c7f3abff97a65f51bec0e727 in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=02336cd ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 02336cdcd9cfb734c7f3abff97a65f51bec0e727 in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=02336cd ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 02336cdcd9cfb734c7f3abff97a65f51bec0e727 in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=02336cd ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 02336cdcd9cfb734c7f3abff97a65f51bec0e727 in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=02336cd ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 0f756eb6a431e3005be850cc8509e47b1daf5728 in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=0f756eb ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 0f756eb6a431e3005be850cc8509e47b1daf5728 in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=0f756eb ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit f0afbea3b67eadbd623402866a72057720f54c1d in geode's branch refs/heads/feature/GEODE-7665 from Donal Evans
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=f0afbea ]

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

Commit 248a56aefcf72e0c60e197b377adc6542662bdc2 in geode's branch refs/heads/feature/GEODE-7665 from zhouxh
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=248a56a ]

GEODE-7683: introduce BR.cmnClearRegion

Co-authored-by: Xiaojian Zhou <gzhou@pivotal.io>

GEODE-7684: Create messaging class for PR Clear (#4689)

* Added new message class and test

Co-authored-by: Benjamin Ross <bross@pivotal.io>
Co-authored-by: Donal Evans <doevans@pivotal.io>

GEODE-7682: add PR.clear  API (#4755)

* GEODE-7683: introduce BR.cmnClearRegion

Co-authored-by: Xiaojian Zhou <gzhou@pivotal.io>

PR.clear's event id should be created and used in BR (#4805)

* GEODE-7857: PR.clear's event id should be created and used in BR

GEODE-7912: cacheWriter should be triggered when PR.clear (#4882)

        Co-authored-by: Anil <agingade@pivotal.io>
        Co-authored-by: Xiaojian Zhou <gzhou@pivotal.io>

GEODE-7983: Clear region writer callbacks should not be invoked for bucket regions (#4954)

GEODE-7676: Add PR clear with expiration tests (#4970)

Added distributed tests to verify the clear operation on Partitioned
Regions works as expected when expiration is configured.

- Added unit and distributed tests.
- Fixed LocalRegion class to clear the entryExpiryTasks Map whenever
  the cancelAllEntryExpiryTasks method is invoked.

GEODE-7667: Add a 'clear' gfsh command for PR and RR clear (#4818)

* Added clear command and modified remove functionality to clear PR

Authored-by: Benjamin Ross <bross@pivotal.io>

GEODE-7676: Conversion of duration to seconds.

GEODE-7894: Moving expiry tasks to AbstractRegion.

GEODE-7667: Fixing test to include PR clear help text.

GEODE-7678 (2nd PR) - Support for cache-listener and client-notification for Partitioned Region Clear operation  (#5124)

* GEODE-7678: Add support for cache listener and client notification for PR clear

The changes are made to PR clear messaging and locking mechanism to preserve
cache-listener and client-events ordering during concurrent cache operation
while clear in progress.

GEODE-7669 Test coverage for Partitioned Region clear with Overflow enabled (#5189)

Authored-by: Jianxia Chen <jchen21@apache.org>

GEODE-8173: Add unit test (coverage) for PartitionedRegionClear class. (#5208)

* GEODE-8173: Add unit test (coverage) for PartitionedRegionClear class.
Co-authored-by: anilkumar gingade <anil@anilg.local>

GEODE-8334: PR.clear should sync with putAll or removeAll on rvvLock (#5365)

    Co-authored-by: Xiaojian Zhou <zhouxh@vmware.com>
    Co-authored-by: Anil Gingade <agingade@vmware.com>

GEODE-8361: Use Set instead of List to track cleared buckets (#5379)

- Refactor PartitionRegionClear to use Set instead of List
- Some other changes to remove warnings/alerts from PartitionedRegionClear and PartitionedRegionClearMessage

Authored-by: Donal Evans <doevans@vmware.com>

GEODE-7670: PR Clear with Concurrent Ops DUnitTests (#4848)

Added distributed tests to verify that the clear operation on
Partitioned Regions works as expected when there are other
concurrent operations happening on the cache (put, putAll, get,
remove, removeAll, members added and members removed).

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

GEODE-7846: Adding Stats for Partitioned Region Clear (#5391)

Added stats to CachePerfStats for PR Clear
- Changed clears to 'regionClears' and 'bucketClears' to differentiate between the number of times the region was cleared and the number of times a bucket was cleared in a PartitionedRegion
- Added Local and Total duration stats to record how long clear has been running for a specific region, as well as how long it was spent clearing any specific member

GEODE-7672: add dunit test to verify OQL index after PR clear. (#5436)

* require rvv lock when create index

fix rebase compiling error

GEODE-7845 blocking PR region clear if one or more server versions are too old (#5577)

- if a server is running an old version when a PR clear is invoked
by the client, the client will receive a ServerOperationException
with a cause of ServerVersionMismatchException.

GEODE-7845: Adding a cleaner simpler test. (#5622)

- Changed the test for ServerVersionMismatchException to be more readable.

GEODE-7845: Now behaving with clients of various versions. (#5645)

- added functionality that would allow the tests to be run using various versions of the clients against and and new versions of the server.

GEODE-7858: PR.clear notify client should let the queue holder member to notify (#5677)

GEODE-7679 Partitioned Region clear is successful while region is being altered (#5516)

GEODE-7675: Partitioned Region clear should be successful when clients are present with subscription enabled (#5727)

GEODE-8771: invalidate should acquire the lock before initIndex (#5823)

GEODE-8878: PR clear should also send a lock message to the secondary members. (#5950)

GEODE-9132: Minor cleanup of PartitionedRegionClearTest


Commit 28d31d89de607d8947fe17890b5a951dfc895299 in geode's branch refs/heads/feature/GEODE-7665 from zhouxh
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=28d31d89de ]

GEODE-7683: introduce BR.cmnClearRegion

Co-authored-by: Xiaojian Zhou <gzhou@pivotal.io>

GEODE-7684: Create messaging class for PR Clear (#4689)

* Added new message class and test

Co-authored-by: Benjamin Ross <bross@pivotal.io>
Co-authored-by: Donal Evans <doevans@pivotal.io>

GEODE-7682: add PR.clear  API (#4755)

* GEODE-7683: introduce BR.cmnClearRegion

Co-authored-by: Xiaojian Zhou <gzhou@pivotal.io>

PR.clear's event id should be created and used in BR (#4805)

* GEODE-7857: PR.clear's event id should be created and used in BR

GEODE-7912: cacheWriter should be triggered when PR.clear (#4882)

        Co-authored-by: Anil <agingade@pivotal.io>
        Co-authored-by: Xiaojian Zhou <gzhou@pivotal.io>

GEODE-7983: Clear region writer callbacks should not be invoked for bucket regions (#4954)

GEODE-7676: Add PR clear with expiration tests (#4970)

Added distributed tests to verify the clear operation on Partitioned
Regions works as expected when expiration is configured.

- Added unit and distributed tests.
- Fixed LocalRegion class to clear the entryExpiryTasks Map whenever
  the cancelAllEntryExpiryTasks method is invoked.

GEODE-7667: Add a 'clear' gfsh command for PR and RR clear (#4818)

* Added clear command and modified remove functionality to clear PR

Authored-by: Benjamin Ross <bross@pivotal.io>

GEODE-7676: Conversion of duration to seconds.

GEODE-7894: Moving expiry tasks to AbstractRegion.

GEODE-7667: Fixing test to include PR clear help text.

GEODE-7678 (2nd PR) - Support for cache-listener and client-notification for Partitioned Region Clear operation  (#5124)

* GEODE-7678: Add support for cache listener and client notification for PR clear

The changes are made to PR clear messaging and locking mechanism to preserve
cache-listener and client-events ordering during concurrent cache operation
while clear in progress.

GEODE-7669 Test coverage for Partitioned Region clear with Overflow enabled (#5189)

Authored-by: Jianxia Chen <jchen21@apache.org>

GEODE-8173: Add unit test (coverage) for PartitionedRegionClear class. (#5208)

* GEODE-8173: Add unit test (coverage) for PartitionedRegionClear class.
Co-authored-by: anilkumar gingade <anil@anilg.local>

GEODE-8334: PR.clear should sync with putAll or removeAll on rvvLock (#5365)

    Co-authored-by: Xiaojian Zhou <zhouxh@vmware.com>
    Co-authored-by: Anil Gingade <agingade@vmware.com>

GEODE-8361: Use Set instead of List to track cleared buckets (#5379)

- Refactor PartitionRegionClear to use Set instead of List
- Some other changes to remove warnings/alerts from PartitionedRegionClear and PartitionedRegionClearMessage

Authored-by: Donal Evans <doevans@vmware.com>

GEODE-7670: PR Clear with Concurrent Ops DUnitTests (#4848)

Added distributed tests to verify that the clear operation on
Partitioned Regions works as expected when there are other
concurrent operations happening on the cache (put, putAll, get,
remove, removeAll, members added and members removed).

GEODE-7680: PR.clear must be successful when interacting with rebalance (#5095)

- Added DUnit tests to confirm that clear does not interfere with
rebalance or vice versa
- Test when member departs during clear/rebalance
- Test when member joins during clear/rebalance
- Fixed typo in PartitionedRegionClearWithExpirationDUnitTest
- Fixed typo in PartitionedRegion
- Call assignBucketsToPartitions() on leader colocated region during clear
instead of target region

Authored-by: Donal Evans <doevans@pivotal.io>

GEODE-7846: Adding Stats for Partitioned Region Clear (#5391)

Added stats to CachePerfStats for PR Clear
- Changed clears to 'regionClears' and 'bucketClears' to differentiate between the number of times the region was cleared and the number of times a bucket was cleared in a PartitionedRegion
- Added Local and Total duration stats to record how long clear has been running for a specific region, as well as how long it was spent clearing any specific member

GEODE-7672: add dunit test to verify OQL index after PR clear. (#5436)

* require rvv lock when create index

fix rebase compiling error

GEODE-7845 blocking PR region clear if one or more server versions are too old (#5577)

- if a server is running an old version when a PR clear is invoked
by the client, the client will receive a ServerOperationException
with a cause of ServerVersionMismatchException.

GEODE-7845: Adding a cleaner simpler test. (#5622)

- Changed the test for ServerVersionMismatchException to be more readable.

GEODE-7845: Now behaving with clients of various versions. (#5645)

- added functionality that would allow the tests to be run using various versions of the clients against and and new versions of the server.

GEODE-7858: PR.clear notify client should let the queue holder member to notify (#5677)

GEODE-7679 Partitioned Region clear is successful while region is being altered (#5516)

GEODE-7675: Partitioned Region clear should be successful when clients are present with subscription enabled (#5727)

GEODE-8771: invalidate should acquire the lock before initIndex (#5823)

GEODE-8878: PR clear should also send a lock message to the secondary members. (#5950)

GEODE-9132: Minor cleanup of PartitionedRegionClearTest


