We gonna work on the PR.

GitHub user ArnaudFnr opened a pull request:

    https://github.com/apache/beam/pull/3686

    [BEAM-2728] Extension for sketch-based statistics

    Follow this checklist to help us incorporate your contribution quickly and easily:
    
     - [ ] Make sure there is a [JIRA issue](https://issues.apache.org/jira/projects/BEAM/issues/) filed for the change (usually before you start working on it).  Trivial changes like typos do not require a JIRA issue.  Your pull request should address just this issue, without pulling in other changes.
     - [ ] Each commit in the pull request should have a meaningful subject line and body.
     - [ ] Format the pull request title like `[BEAM-XXX] Fixes bug in ApproximateQuantiles`, where you replace `BEAM-XXX` with the appropriate JIRA issue.
     - [ ] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.
     - [ ] Run `mvn clean verify` to make sure basic checks pass. A more thorough check will be performed on your pull request automatically.
     - [ ] If this contribution is large, please file an Apache [Individual Contributor License Agreement](https://www.apache.org/licenses/icla.pdf).
    
    ---
    
    Extension to compute approximate statistics with the use of probabilistic data structure, or sketches.
    
    For now, 4 sketches are supported :
    - HyperLogLog (ApproximateDistinct) for stream's cardinality
    - Count-min Sketch (SketchFrequencies) for computing frequency by element
    - Stream Summary (KMostFrequent) for computing a top k of most frequent elements
    - T-Digest (TDigestQuantiles) for computing quantiles in the stream
    
    The sketches are implemented as Beam Combiners, allowing a user to build the sketch dynamically in the Pipeline and then make some dynamic queries and/or store it in a database.
     

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/ArnaudFnr/beam sketching

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/beam/pull/3686.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #3686
    
----
commit 6bf51fdf6afe6f389415792f335dd08adf9fa85a
Author: Arnaud Fournier <arnaudfournier921@gmail.com>
Date:   2017-07-20T14:57:38Z

    [BEAM-2728] Extension for sketch-based statistics

----


GitHub user ArnaudFnr opened a pull request:

    https://github.com/apache/beam/pull/3991

    [BEAM-2728] Extension for sketch-based statistics : HyperLogLog

    Extension for computing approximate statistics with the use of probabilistic data structures aka sketches.
    
    For now the extension is composed of one sketch, HyperLogLog+ for computing the approximate number of distinct elements in a stream.
    It takes the form of a Combiner with the CombineFn exposed directly so it can be used as a state cell in stateful ParDos.
    
    Follow this checklist to help us incorporate your contribution quickly and easily:
    
     - [ ] Make sure there is a [JIRA issue](https://issues.apache.org/jira/projects/BEAM/issues/) filed for the change (usually before you start working on it).  Trivial changes like typos do not require a JIRA issue.  Your pull request should address just this issue, without pulling in other changes.
     - [ ] Each commit in the pull request should have a meaningful subject line and body.
     - [ ] Format the pull request title like `[BEAM-XXX] Fixes bug in ApproximateQuantiles`, where you replace `BEAM-XXX` with the appropriate JIRA issue.
     - [ ] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.
     - [ ] Run `mvn clean verify` to make sure basic checks pass. A more thorough check will be performed on your pull request automatically.
     - [ ] If this contribution is large, please file an Apache [Individual Contributor License Agreement](https://www.apache.org/licenses/icla.pdf).
    
    ---


You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/ArnaudFnr/beam HyperLogLog_sketch

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/beam/pull/3991.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #3991
    
----
commit 40c9b06c219e995b8b065ea69486edd5a33ed953
Author: Arnaud Fournier <arnaudfournier921@gmail.com>
Date:   2017-07-20T14:57:38Z

    [BEAM-2728] Extension for sketch-based statistics : HyperLogLog

----


Github user asfgit closed the pull request at:

    https://github.com/apache/beam/pull/3991


ArnaudFnr commented on a change in pull request #3686: [BEAM-2728] Extension for sketch-based statistics
URL: https://github.com/apache/beam/pull/3686#discussion_r154037195
 
 

 ##########
 File path: sdks/java/extensions/sketching/src/main/java/org/apache/beam/sdk/extensions/sketching/frequency/SketchFrequencies.java
 ##########
 @@ -0,0 +1,357 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.sdk.extensions.sketching.frequency;
+
+import com.clearspring.analytics.stream.frequency.CountMinSketch;
+import com.clearspring.analytics.stream.frequency.FrequencyMergeException;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Iterator;
+
+import org.apache.beam.sdk.coders.ByteArrayCoder;
+import org.apache.beam.sdk.coders.CannotProvideCoderException;
+import org.apache.beam.sdk.coders.Coder;
+import org.apache.beam.sdk.coders.CoderException;
+import org.apache.beam.sdk.coders.CoderRegistry;
+import org.apache.beam.sdk.coders.CustomCoder;
+import org.apache.beam.sdk.transforms.Combine;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * {@code PTransform}s that records an estimation of the frequency of each element in a
+ * {@code PCollection}, or the occurrences of values associated with each key in a
+ * {@code PCollection} of {@code KV}s.
+ *
+ * <p>This class uses the Count-min Sketch structure. The papers and other useful information
+ * about it is available on this website : <a>https://sites.google.com/site/countminsketch/</a>
+ * <br>The implementation comes from Apache Spark :
+ * <a>https://github.com/apache/spark/tree/master/common/sketch</a>
+ */
+public class SketchFrequencies {
+
+  private static final Logger LOG = LoggerFactory.getLogger(SketchFrequencies.class);
+
+  // do not instantiate
+  private SketchFrequencies() {
+  }
+
+  /**
+   * A {@code PTransform} that takes an input {@code PCollection<String>} and returns a
+   * {@code PCollection<CountMinSketch>} whose contents is a Count-min sketch that allows to query
+   * the number of hits for a specific element in the input {@code PCollection}.
+   *
+   * <p>The {@code seed} parameters will be used to randomly generate different hash functions.
+   * Thus, the result can be different for the same stream in different seeds are used.
+   * The {@code seed} parameter will be used to generate a and b for each hash function.
+   * <br>The Count-min sketch size is constant through the process so the memory use is fixed.
+   * However, the dimensions are directly linked to the accuracy.
+   * <br>By default, the relative error is set to 1% with 1% probability that the estimation
+   * breaks this limit.
+   * <br>Also keep in mind that this algorithm works well on highly skewed data but gives poor
+   * results if the elements are evenly distributed.
+   *
+   * <p>See {@link CountMinSketchFn#withAccuracy(double, double)} in order to tune the parameters.
+   * <br>Also see {@link CountMinSketchFn} for more details about the algorithm's principle.
+   *
+   * <p>Example of use:
+   * <pre>{@code
+   * PCollection<String> pc = ...;
+   * PCollection<CountMinSketch> countMinSketch =
+   *     pc.apply(SketchFrequencies.<String>globally(1234));
+   * }</pre>
+   *
+   * <p>Also see {@link CountMinSketchFn} for more details about the algorithm's principle.
+   *
+   * @param seed        the seed used for generating randomly different hash functions
+   */
+  public static Combine.Globally<String, CountMinSketch> globally(int seed) {
+    return Combine.<String, CountMinSketch>globally(CountMinSketchFn
+            .create(seed).withAccuracy(0.001, 0.99));
+  }
+
+  /**
+   * A {@code PTransform} that takes an input {@code PCollection<KV<K, InputT>>} and
+   * returns a {@code PCollection<KV<K, CountMinSketch>>} that contains an output element mapping
+   * each distinct key in the input {@code PCollection} to a structure that allows to query the
+   * count of a specific element associated with that key in the input {@code PCollection}.
+   *
+   * <p>The {@code seed} parameters will be used to randomly generate different hash functions.
+   * Thus, the result can be different for the same stream in different seeds are used.
+   * The {@code seed} parameter will be used to generate a and b for each hash function.
+   * <br>The Count-min sketch size is constant through the process so the memory use is fixed.
+   * However, the dimensions are directly linked to the accuracy.
+   * <br>By default, the relative error is set to 1% with 1% probability that the estimation
+   * breaks this limit.
+   * <br>also keep in mind that this algorithm works well on highly skewed data but gives poor
+   * results if the elements are evenly distributed.
+   *
+   * <p>See {@link CountMinSketchFn#withAccuracy(double, double)} in order to tune the parameters.
+   * <br>Also see {@link CountMinSketchFn} for more details about the algorithm's principle.
+   *
+   * <p>Example of use:
+   * <pre>{@code
+   * PCollection<KV<Integer, String>> pc = ...;
+   * PCollection<KV<Integer, CountMinSketch>> countMinSketch =
+   *     pc.apply(SketchFrequencies.<Integer, String>perKey(1234));
+   * }</pre>
+   *
+   * @param seed        the seed used for generating different hash functions
+   * @param <K>         the type of the keys in the input and output {@code PCollection}s
+   */
+  public static <K> Combine.PerKey<K, String, CountMinSketch> perKey(int seed) {
+    return Combine.<K, String, CountMinSketch>perKey(CountMinSketchFn
+            .create(seed).withAccuracy(0.001, 0.99));
+  }
+
+  /**
+   * A {@code Combine.CombineFn} that computes the {@link CountMinSketch} Structure
+   * of an {@code Iterable} of Strings, useful as an argument to {@link Combine#globally} or
+   * {@link Combine#perKey}.
+   *
+   * <p>When an element is added to the Count-min sketch, it is mapped to one column in each
+   * row using different hash functions, and a counter is updated in each column.
+   * <br>Collisions will happen as far as the number of distinct elements in the stream is greater
+   * than the width of the sketch. Each counter might be associated to many items so the frequency
+   * of an element is always overestimated. On average the relative error on a counter is bounded,
+   * but some counters can be very inaccurate.
+   * <br>That's why different hash functions are used to map the same element to different
+   * counters. Thus, the overestimation for each counter will differ as there will be different
+   * collisions, and one will probably be less inaccurate than the average.
+   *
+   * <p>Both the average relative error and the probability to have an estimation overcoming this
+   * error can be computed by knowing the dimensions of the sketch, and vice-versa.
+   * Thus, for Count-min sketch with 10 000 columns and 7 rows, the relative error should not be no
+   * more than 0.02% in 99% of the cases.
+   *
+   */
+  public static class CountMinSketchFn
+          extends Combine.CombineFn<String, CountMinSketch, CountMinSketch> {
+
+    private final int depth;
+
+    private final int width;
+
+    private final int seed;
+
+    private CountMinSketchFn(double eps, double confidence, int seed) {
+      this.width = (int) Math.ceil(2 / eps);
+      this.depth = (int) Math.ceil(-Math.log(1 - confidence) / Math.log(2));
+      this.seed = seed;
+    }
+
+    private CountMinSketchFn(int width, int depth, int seed) {
+      this.width = width;
+      this.depth = depth;
+      this.seed = seed;
+    }
+
+    /**
+     * Returns an {@code CountMinSketchFn} combiner that will have a Count-min sketch
+     * which will estimate the frequencies with about 1% of error guaranteed at 99%.
+     * the resulting dimensions are 2000 x 7. It will stay constant during all the aggregation.
+     *
+     * <p>the {@code seed} parameters is used to generate different hash functions of the form :
+     * <pre>a * i + b % p % width ,</pre>
+     * where a, b are chosen randomly and p is a prime number larger than the maximum i value.
+     *
+     * <p>Example of use:
+     * <br>1) Globally :
+     * <pre>{@code
+     * PCollection<String> pc = ...;
+     * PCollection<CountMinSketch> countMinSketch =
+     *     pc.apply(Combine.globally(CountMinSketchFn.<String>create(1234));
+     * }</pre>
+     * <br>2) Per key :
+     * <pre>{@code
+     * PCollection<KV<Integer, String>> pc = ...;
+     * PCollection<KV<Integer, CountMinSketch>> countMinSketch =
+     *     pc.apply(Combine.perKey(CountMinSketchFn.<String>create(1234));
+     * }</pre>
+     *
+     * @param seed        the seed used for generating different hash functions
+     */
+    public static CountMinSketchFn create(int seed) {
+      return new CountMinSketchFn(0.001, 0.99, seed);
+    }
+
+    /**
+     * Returns an {@code CountMinSketchFn} combiner that will have a Count-min sketch of
+     * dimensions {@code width x depth}, that will stay constant during all the aggregation.
+     * This method can only be applied from a {@link CountMinSketchFn} already created with the
+     * method {@link CountMinSketchFn#create(int)}.
+     *
+     * <p>The greater the {@code width}, the lower the expected relative error {@code epsilon} :
+     * <pre>{@code epsilon = 2 / width}</pre>
+     *
+     * <p>The greater the {@code depth}, the lower the probability to actually have
+     * a greater relative error than expected.
+     * <pre>{@code confidence = 1 - 2^-depth}</pre>
+     *
+     * <p>Example of use:
+     * <br>1) Globally :
+     * <pre> {@code
+     * PCollection<String> pc = ...;
+     * PCollection<CountMinSketch> countMinSketch =
+     *     pc.apply(Combine.globally(CountMinSketchFn.<String>create(1234)
+     *                  withDimensions(10000, 7));
+     * } </pre>
+     * <br>2) Per key :
+     * <pre> {@code
+     * PCollection<KV<Integer, String>> pc = ...;
+     * PCollection<KV<Integer, CountMinSketch>> countMinSketch =
+     *     pc.apply(Combine.perKey(CountMinSketchFn.<String>create(1234)
+     *                  withDimensions(10000, 7)););
+     * } </pre>
+     *
+     * @param width Number of columns, i.e. number of counters for the stream.
+     * @param depth Number of lines, i.e. number of hash functions
+     */
+    public CountMinSketchFn withDimensions(int width, int depth) {
+      if (width <= 0 || depth <= 0) {
+          throw new IllegalArgumentException("depth and width must be positive.");
+      }
+      return new CountMinSketchFn(width, depth, this.seed);
+    }
+
+    /**
+     * Returns an {@code CountMinSketchFn} combiner that will be as accurate as specified. The
+     * relative error {@code epsilon} can be guaranteed only with a certain {@code confidence},
+     * which has to be between 0 and 1 (1 being of course impossible). Those parameters will
+     * determine the size of the Count-min sketch in which the elements will be aggregated.
+     * This method can only be applied to a {@link CountMinSketchFn} already created with the
+     * method {@link CountMinSketchFn#create(int)}.
+     *
+     * <p>The lower the {@code epsilon} value, the greater the width.
+     * <pre>{@code width = (int) 2 / epsilon)}</pre>
+     *
+     * <p>The greater the confidence, the greater the depth.
+     * <pre>{@code depth = (int) -log2(1 - confidence)}</pre>
+     *
+     * <p>Example of use:
+     * <br>1) Globally :
+     * <pre>{@code
+     * PCollection<String> pc = ...;
+     * PCollection<CountMinSketch> countMinSketch =
+     *     pc.apply(Combine.globally(CountMinSketchFn.<String>create(1234)
+     *                  withDimensions(0.001, 0.99));
+     * }</pre>
+     * <br>2) Per key :
+     * <pre>{@code
+     * PCollection<KV<Integer, String>> pc = ...;
+     * PCollection<KV<Integer, CountMinSketch>> countMinSketch =
+     *     pc.apply(Combine.perKey(CountMinSketchFn.<String>create(1234)
+     *                  withAccuracy(0.001, 0.99)););
+     * }</pre>
+     *
+     *
+     * @param epsilon the relative error of the result
+     * @param confidence the confidence in the result to not overcome the relative error
+     */
+    public CountMinSketchFn withAccuracy(double epsilon, double confidence) {
+      return new CountMinSketchFn(epsilon, confidence, this.seed);
+    }
+
+    @Override public CountMinSketch createAccumulator() {
+      return new CountMinSketch(this.depth, this.width, this.seed);
+    }
+
+    @Override public CountMinSketch addInput(CountMinSketch accumulator, String element) {
+      accumulator.add(element, 1);
+      return accumulator;
+    }
+
+    @Override public CountMinSketch mergeAccumulators(Iterable<CountMinSketch> accumulators) {
+      Iterator<CountMinSketch> it = accumulators.iterator();
+      if (!it.hasNext()) {
+        return new CountMinSketch(seed, width, depth);
+      }
+      CountMinSketch merged = it.next();
+      try {
+        while (it.hasNext()) {
+          merged = CountMinSketch.merge(merged, it.next());
+        }
+      } catch (FrequencyMergeException e) {
+        // Should never happen because all the accumulators created are of the same type.
+        LOG.error(e.getMessage(), e);
+      }
+      return merged;
+    }
+
+    @Override public CountMinSketch extractOutput(CountMinSketch accumulator) {
+      return accumulator;
+    }
+
+    @Override public Coder<CountMinSketch> getAccumulatorCoder(CoderRegistry registry,
+        Coder inputCoder) {
+      return new CountMinSketchCoder();
+    }
+
+    @Override public Coder<CountMinSketch> getDefaultOutputCoder(CoderRegistry registry,
+        Coder inputCoder) throws CannotProvideCoderException {
+      return new CountMinSketchCoder();
+    }
+
+    @Override public CountMinSketch defaultValue() {
+      return new CountMinSketch(1, 1, 1);
+    }
+  }
+
+  static class CountMinSketchCoder extends CustomCoder<CountMinSketch> {
+
+    private static final ByteArrayCoder BYTE_ARRAY_CODER = ByteArrayCoder.of();
+
+    @Override public void encode(CountMinSketch value, OutputStream outStream) throws IOException {
+        if (value == null) {
+          throw new CoderException("cannot encode a null Count-min Sketch");
+        }
+        BYTE_ARRAY_CODER.encode(CountMinSketch.serialize(value), outStream);
+    }
+
+    @Override public CountMinSketch decode(InputStream inStream) throws IOException {
+      return CountMinSketch.deserialize(BYTE_ARRAY_CODER.decode(inStream));
+    }
+
+    @Override public boolean consistentWithEquals() {
+      return false;
+    }
+
+    @Override public boolean isRegisterByteSizeObserverCheap(CountMinSketch value) {
+      return true;
+    }
+
+    @Override protected long getEncodedElementByteSize(CountMinSketch value) throws IOException {
+      if (value == null) {
+        throw new CoderException("cannot encode a null Count-min Sketch");
+      } else {
+        // depth and width as computed in the CountMinSketch constructor from the relative error and
+        // confidence.
+        int width = (int) Math.ceil(2 / value.getRelativeError());
 
 Review comment:
   I don't understand why this is wonky? I compute depth and width exactly the same way as in Count-Min Sketch constructors. I can still create a PR for that though.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


lukecwik commented on a change in pull request #3686: [BEAM-2728] Extension for sketch-based statistics
URL: https://github.com/apache/beam/pull/3686#discussion_r154448029
 
 

 ##########
 File path: sdks/java/extensions/sketching/src/main/java/org/apache/beam/sdk/extensions/sketching/frequency/SketchFrequencies.java
 ##########
 @@ -0,0 +1,357 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.sdk.extensions.sketching.frequency;
+
+import com.clearspring.analytics.stream.frequency.CountMinSketch;
+import com.clearspring.analytics.stream.frequency.FrequencyMergeException;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Iterator;
+
+import org.apache.beam.sdk.coders.ByteArrayCoder;
+import org.apache.beam.sdk.coders.CannotProvideCoderException;
+import org.apache.beam.sdk.coders.Coder;
+import org.apache.beam.sdk.coders.CoderException;
+import org.apache.beam.sdk.coders.CoderRegistry;
+import org.apache.beam.sdk.coders.CustomCoder;
+import org.apache.beam.sdk.transforms.Combine;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * {@code PTransform}s that records an estimation of the frequency of each element in a
+ * {@code PCollection}, or the occurrences of values associated with each key in a
+ * {@code PCollection} of {@code KV}s.
+ *
+ * <p>This class uses the Count-min Sketch structure. The papers and other useful information
+ * about it is available on this website : <a>https://sites.google.com/site/countminsketch/</a>
+ * <br>The implementation comes from Apache Spark :
+ * <a>https://github.com/apache/spark/tree/master/common/sketch</a>
+ */
+public class SketchFrequencies {
+
+  private static final Logger LOG = LoggerFactory.getLogger(SketchFrequencies.class);
+
+  // do not instantiate
+  private SketchFrequencies() {
+  }
+
+  /**
+   * A {@code PTransform} that takes an input {@code PCollection<String>} and returns a
+   * {@code PCollection<CountMinSketch>} whose contents is a Count-min sketch that allows to query
+   * the number of hits for a specific element in the input {@code PCollection}.
+   *
+   * <p>The {@code seed} parameters will be used to randomly generate different hash functions.
+   * Thus, the result can be different for the same stream in different seeds are used.
+   * The {@code seed} parameter will be used to generate a and b for each hash function.
+   * <br>The Count-min sketch size is constant through the process so the memory use is fixed.
+   * However, the dimensions are directly linked to the accuracy.
+   * <br>By default, the relative error is set to 1% with 1% probability that the estimation
+   * breaks this limit.
+   * <br>Also keep in mind that this algorithm works well on highly skewed data but gives poor
+   * results if the elements are evenly distributed.
+   *
+   * <p>See {@link CountMinSketchFn#withAccuracy(double, double)} in order to tune the parameters.
+   * <br>Also see {@link CountMinSketchFn} for more details about the algorithm's principle.
+   *
+   * <p>Example of use:
+   * <pre>{@code
+   * PCollection<String> pc = ...;
+   * PCollection<CountMinSketch> countMinSketch =
+   *     pc.apply(SketchFrequencies.<String>globally(1234));
+   * }</pre>
+   *
+   * <p>Also see {@link CountMinSketchFn} for more details about the algorithm's principle.
+   *
+   * @param seed        the seed used for generating randomly different hash functions
+   */
+  public static Combine.Globally<String, CountMinSketch> globally(int seed) {
+    return Combine.<String, CountMinSketch>globally(CountMinSketchFn
+            .create(seed).withAccuracy(0.001, 0.99));
+  }
+
+  /**
+   * A {@code PTransform} that takes an input {@code PCollection<KV<K, InputT>>} and
+   * returns a {@code PCollection<KV<K, CountMinSketch>>} that contains an output element mapping
+   * each distinct key in the input {@code PCollection} to a structure that allows to query the
+   * count of a specific element associated with that key in the input {@code PCollection}.
+   *
+   * <p>The {@code seed} parameters will be used to randomly generate different hash functions.
+   * Thus, the result can be different for the same stream in different seeds are used.
+   * The {@code seed} parameter will be used to generate a and b for each hash function.
+   * <br>The Count-min sketch size is constant through the process so the memory use is fixed.
+   * However, the dimensions are directly linked to the accuracy.
+   * <br>By default, the relative error is set to 1% with 1% probability that the estimation
+   * breaks this limit.
+   * <br>also keep in mind that this algorithm works well on highly skewed data but gives poor
+   * results if the elements are evenly distributed.
+   *
+   * <p>See {@link CountMinSketchFn#withAccuracy(double, double)} in order to tune the parameters.
+   * <br>Also see {@link CountMinSketchFn} for more details about the algorithm's principle.
+   *
+   * <p>Example of use:
+   * <pre>{@code
+   * PCollection<KV<Integer, String>> pc = ...;
+   * PCollection<KV<Integer, CountMinSketch>> countMinSketch =
+   *     pc.apply(SketchFrequencies.<Integer, String>perKey(1234));
+   * }</pre>
+   *
+   * @param seed        the seed used for generating different hash functions
+   * @param <K>         the type of the keys in the input and output {@code PCollection}s
+   */
+  public static <K> Combine.PerKey<K, String, CountMinSketch> perKey(int seed) {
+    return Combine.<K, String, CountMinSketch>perKey(CountMinSketchFn
+            .create(seed).withAccuracy(0.001, 0.99));
+  }
+
+  /**
+   * A {@code Combine.CombineFn} that computes the {@link CountMinSketch} Structure
+   * of an {@code Iterable} of Strings, useful as an argument to {@link Combine#globally} or
+   * {@link Combine#perKey}.
+   *
+   * <p>When an element is added to the Count-min sketch, it is mapped to one column in each
+   * row using different hash functions, and a counter is updated in each column.
+   * <br>Collisions will happen as far as the number of distinct elements in the stream is greater
+   * than the width of the sketch. Each counter might be associated to many items so the frequency
+   * of an element is always overestimated. On average the relative error on a counter is bounded,
+   * but some counters can be very inaccurate.
+   * <br>That's why different hash functions are used to map the same element to different
+   * counters. Thus, the overestimation for each counter will differ as there will be different
+   * collisions, and one will probably be less inaccurate than the average.
+   *
+   * <p>Both the average relative error and the probability to have an estimation overcoming this
+   * error can be computed by knowing the dimensions of the sketch, and vice-versa.
+   * Thus, for Count-min sketch with 10 000 columns and 7 rows, the relative error should not be no
+   * more than 0.02% in 99% of the cases.
+   *
+   */
+  public static class CountMinSketchFn
+          extends Combine.CombineFn<String, CountMinSketch, CountMinSketch> {
+
+    private final int depth;
+
+    private final int width;
+
+    private final int seed;
+
+    private CountMinSketchFn(double eps, double confidence, int seed) {
+      this.width = (int) Math.ceil(2 / eps);
+      this.depth = (int) Math.ceil(-Math.log(1 - confidence) / Math.log(2));
+      this.seed = seed;
+    }
+
+    private CountMinSketchFn(int width, int depth, int seed) {
+      this.width = width;
+      this.depth = depth;
+      this.seed = seed;
+    }
+
+    /**
+     * Returns an {@code CountMinSketchFn} combiner that will have a Count-min sketch
+     * which will estimate the frequencies with about 1% of error guaranteed at 99%.
+     * the resulting dimensions are 2000 x 7. It will stay constant during all the aggregation.
+     *
+     * <p>the {@code seed} parameters is used to generate different hash functions of the form :
+     * <pre>a * i + b % p % width ,</pre>
+     * where a, b are chosen randomly and p is a prime number larger than the maximum i value.
+     *
+     * <p>Example of use:
+     * <br>1) Globally :
+     * <pre>{@code
+     * PCollection<String> pc = ...;
+     * PCollection<CountMinSketch> countMinSketch =
+     *     pc.apply(Combine.globally(CountMinSketchFn.<String>create(1234));
+     * }</pre>
+     * <br>2) Per key :
+     * <pre>{@code
+     * PCollection<KV<Integer, String>> pc = ...;
+     * PCollection<KV<Integer, CountMinSketch>> countMinSketch =
+     *     pc.apply(Combine.perKey(CountMinSketchFn.<String>create(1234));
+     * }</pre>
+     *
+     * @param seed        the seed used for generating different hash functions
+     */
+    public static CountMinSketchFn create(int seed) {
+      return new CountMinSketchFn(0.001, 0.99, seed);
+    }
+
+    /**
+     * Returns an {@code CountMinSketchFn} combiner that will have a Count-min sketch of
+     * dimensions {@code width x depth}, that will stay constant during all the aggregation.
+     * This method can only be applied from a {@link CountMinSketchFn} already created with the
+     * method {@link CountMinSketchFn#create(int)}.
+     *
+     * <p>The greater the {@code width}, the lower the expected relative error {@code epsilon} :
+     * <pre>{@code epsilon = 2 / width}</pre>
+     *
+     * <p>The greater the {@code depth}, the lower the probability to actually have
+     * a greater relative error than expected.
+     * <pre>{@code confidence = 1 - 2^-depth}</pre>
+     *
+     * <p>Example of use:
+     * <br>1) Globally :
+     * <pre> {@code
+     * PCollection<String> pc = ...;
+     * PCollection<CountMinSketch> countMinSketch =
+     *     pc.apply(Combine.globally(CountMinSketchFn.<String>create(1234)
+     *                  withDimensions(10000, 7));
+     * } </pre>
+     * <br>2) Per key :
+     * <pre> {@code
+     * PCollection<KV<Integer, String>> pc = ...;
+     * PCollection<KV<Integer, CountMinSketch>> countMinSketch =
+     *     pc.apply(Combine.perKey(CountMinSketchFn.<String>create(1234)
+     *                  withDimensions(10000, 7)););
+     * } </pre>
+     *
+     * @param width Number of columns, i.e. number of counters for the stream.
+     * @param depth Number of lines, i.e. number of hash functions
+     */
+    public CountMinSketchFn withDimensions(int width, int depth) {
+      if (width <= 0 || depth <= 0) {
+          throw new IllegalArgumentException("depth and width must be positive.");
+      }
+      return new CountMinSketchFn(width, depth, this.seed);
+    }
+
+    /**
+     * Returns an {@code CountMinSketchFn} combiner that will be as accurate as specified. The
+     * relative error {@code epsilon} can be guaranteed only with a certain {@code confidence},
+     * which has to be between 0 and 1 (1 being of course impossible). Those parameters will
+     * determine the size of the Count-min sketch in which the elements will be aggregated.
+     * This method can only be applied to a {@link CountMinSketchFn} already created with the
+     * method {@link CountMinSketchFn#create(int)}.
+     *
+     * <p>The lower the {@code epsilon} value, the greater the width.
+     * <pre>{@code width = (int) 2 / epsilon)}</pre>
+     *
+     * <p>The greater the confidence, the greater the depth.
+     * <pre>{@code depth = (int) -log2(1 - confidence)}</pre>
+     *
+     * <p>Example of use:
+     * <br>1) Globally :
+     * <pre>{@code
+     * PCollection<String> pc = ...;
+     * PCollection<CountMinSketch> countMinSketch =
+     *     pc.apply(Combine.globally(CountMinSketchFn.<String>create(1234)
+     *                  withDimensions(0.001, 0.99));
+     * }</pre>
+     * <br>2) Per key :
+     * <pre>{@code
+     * PCollection<KV<Integer, String>> pc = ...;
+     * PCollection<KV<Integer, CountMinSketch>> countMinSketch =
+     *     pc.apply(Combine.perKey(CountMinSketchFn.<String>create(1234)
+     *                  withAccuracy(0.001, 0.99)););
+     * }</pre>
+     *
+     *
+     * @param epsilon the relative error of the result
+     * @param confidence the confidence in the result to not overcome the relative error
+     */
+    public CountMinSketchFn withAccuracy(double epsilon, double confidence) {
+      return new CountMinSketchFn(epsilon, confidence, this.seed);
+    }
+
+    @Override public CountMinSketch createAccumulator() {
+      return new CountMinSketch(this.depth, this.width, this.seed);
+    }
+
+    @Override public CountMinSketch addInput(CountMinSketch accumulator, String element) {
+      accumulator.add(element, 1);
+      return accumulator;
+    }
+
+    @Override public CountMinSketch mergeAccumulators(Iterable<CountMinSketch> accumulators) {
+      Iterator<CountMinSketch> it = accumulators.iterator();
+      if (!it.hasNext()) {
+        return new CountMinSketch(seed, width, depth);
+      }
+      CountMinSketch merged = it.next();
+      try {
+        while (it.hasNext()) {
+          merged = CountMinSketch.merge(merged, it.next());
+        }
+      } catch (FrequencyMergeException e) {
+        // Should never happen because all the accumulators created are of the same type.
+        LOG.error(e.getMessage(), e);
+      }
+      return merged;
+    }
+
+    @Override public CountMinSketch extractOutput(CountMinSketch accumulator) {
+      return accumulator;
+    }
+
+    @Override public Coder<CountMinSketch> getAccumulatorCoder(CoderRegistry registry,
+        Coder inputCoder) {
+      return new CountMinSketchCoder();
+    }
+
+    @Override public Coder<CountMinSketch> getDefaultOutputCoder(CoderRegistry registry,
+        Coder inputCoder) throws CannotProvideCoderException {
+      return new CountMinSketchCoder();
+    }
+
+    @Override public CountMinSketch defaultValue() {
+      return new CountMinSketch(1, 1, 1);
+    }
+  }
+
+  static class CountMinSketchCoder extends CustomCoder<CountMinSketch> {
+
+    private static final ByteArrayCoder BYTE_ARRAY_CODER = ByteArrayCoder.of();
+
+    @Override public void encode(CountMinSketch value, OutputStream outStream) throws IOException {
+        if (value == null) {
+          throw new CoderException("cannot encode a null Count-min Sketch");
+        }
+        BYTE_ARRAY_CODER.encode(CountMinSketch.serialize(value), outStream);
+    }
+
+    @Override public CountMinSketch decode(InputStream inStream) throws IOException {
+      return CountMinSketch.deserialize(BYTE_ARRAY_CODER.decode(inStream));
+    }
+
+    @Override public boolean consistentWithEquals() {
+      return false;
+    }
+
+    @Override public boolean isRegisterByteSizeObserverCheap(CountMinSketch value) {
+      return true;
+    }
+
+    @Override protected long getEncodedElementByteSize(CountMinSketch value) throws IOException {
+      if (value == null) {
+        throw new CoderException("cannot encode a null Count-min Sketch");
+      } else {
+        // depth and width as computed in the CountMinSketch constructor from the relative error and
+        // confidence.
+        int width = (int) Math.ceil(2 / value.getRelativeError());
 
 Review comment:
   I think @jkff is pointing out that it would be best if we didn't duplicate the internal details of StreamLib and instead asked them to expose this functionality.
   
   I wouldn't block merging this in and instead add a TODO to replace it by calling StreamLib's implementation directly when available and link to a JIRA or PR against StreamLib which exposes it.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


ArnaudFnr commented on a change in pull request #3686: [BEAM-2728] Extension for sketch-based statistics
URL: https://github.com/apache/beam/pull/3686#discussion_r154449334
 
 

 ##########
 File path: sdks/java/extensions/sketching/src/main/java/org/apache/beam/sdk/extensions/sketching/frequency/SketchFrequencies.java
 ##########
 @@ -0,0 +1,357 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.sdk.extensions.sketching.frequency;
+
+import com.clearspring.analytics.stream.frequency.CountMinSketch;
+import com.clearspring.analytics.stream.frequency.FrequencyMergeException;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Iterator;
+
+import org.apache.beam.sdk.coders.ByteArrayCoder;
+import org.apache.beam.sdk.coders.CannotProvideCoderException;
+import org.apache.beam.sdk.coders.Coder;
+import org.apache.beam.sdk.coders.CoderException;
+import org.apache.beam.sdk.coders.CoderRegistry;
+import org.apache.beam.sdk.coders.CustomCoder;
+import org.apache.beam.sdk.transforms.Combine;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * {@code PTransform}s that records an estimation of the frequency of each element in a
+ * {@code PCollection}, or the occurrences of values associated with each key in a
+ * {@code PCollection} of {@code KV}s.
+ *
+ * <p>This class uses the Count-min Sketch structure. The papers and other useful information
+ * about it is available on this website : <a>https://sites.google.com/site/countminsketch/</a>
+ * <br>The implementation comes from Apache Spark :
+ * <a>https://github.com/apache/spark/tree/master/common/sketch</a>
+ */
+public class SketchFrequencies {
+
+  private static final Logger LOG = LoggerFactory.getLogger(SketchFrequencies.class);
+
+  // do not instantiate
+  private SketchFrequencies() {
+  }
+
+  /**
+   * A {@code PTransform} that takes an input {@code PCollection<String>} and returns a
+   * {@code PCollection<CountMinSketch>} whose contents is a Count-min sketch that allows to query
+   * the number of hits for a specific element in the input {@code PCollection}.
+   *
+   * <p>The {@code seed} parameters will be used to randomly generate different hash functions.
+   * Thus, the result can be different for the same stream in different seeds are used.
+   * The {@code seed} parameter will be used to generate a and b for each hash function.
+   * <br>The Count-min sketch size is constant through the process so the memory use is fixed.
+   * However, the dimensions are directly linked to the accuracy.
+   * <br>By default, the relative error is set to 1% with 1% probability that the estimation
+   * breaks this limit.
+   * <br>Also keep in mind that this algorithm works well on highly skewed data but gives poor
+   * results if the elements are evenly distributed.
+   *
+   * <p>See {@link CountMinSketchFn#withAccuracy(double, double)} in order to tune the parameters.
+   * <br>Also see {@link CountMinSketchFn} for more details about the algorithm's principle.
+   *
+   * <p>Example of use:
+   * <pre>{@code
+   * PCollection<String> pc = ...;
+   * PCollection<CountMinSketch> countMinSketch =
+   *     pc.apply(SketchFrequencies.<String>globally(1234));
+   * }</pre>
+   *
+   * <p>Also see {@link CountMinSketchFn} for more details about the algorithm's principle.
+   *
+   * @param seed        the seed used for generating randomly different hash functions
+   */
+  public static Combine.Globally<String, CountMinSketch> globally(int seed) {
+    return Combine.<String, CountMinSketch>globally(CountMinSketchFn
+            .create(seed).withAccuracy(0.001, 0.99));
+  }
+
+  /**
+   * A {@code PTransform} that takes an input {@code PCollection<KV<K, InputT>>} and
+   * returns a {@code PCollection<KV<K, CountMinSketch>>} that contains an output element mapping
+   * each distinct key in the input {@code PCollection} to a structure that allows to query the
+   * count of a specific element associated with that key in the input {@code PCollection}.
+   *
+   * <p>The {@code seed} parameters will be used to randomly generate different hash functions.
+   * Thus, the result can be different for the same stream in different seeds are used.
+   * The {@code seed} parameter will be used to generate a and b for each hash function.
+   * <br>The Count-min sketch size is constant through the process so the memory use is fixed.
+   * However, the dimensions are directly linked to the accuracy.
+   * <br>By default, the relative error is set to 1% with 1% probability that the estimation
+   * breaks this limit.
+   * <br>also keep in mind that this algorithm works well on highly skewed data but gives poor
+   * results if the elements are evenly distributed.
+   *
+   * <p>See {@link CountMinSketchFn#withAccuracy(double, double)} in order to tune the parameters.
+   * <br>Also see {@link CountMinSketchFn} for more details about the algorithm's principle.
+   *
+   * <p>Example of use:
+   * <pre>{@code
+   * PCollection<KV<Integer, String>> pc = ...;
+   * PCollection<KV<Integer, CountMinSketch>> countMinSketch =
+   *     pc.apply(SketchFrequencies.<Integer, String>perKey(1234));
+   * }</pre>
+   *
+   * @param seed        the seed used for generating different hash functions
+   * @param <K>         the type of the keys in the input and output {@code PCollection}s
+   */
+  public static <K> Combine.PerKey<K, String, CountMinSketch> perKey(int seed) {
+    return Combine.<K, String, CountMinSketch>perKey(CountMinSketchFn
+            .create(seed).withAccuracy(0.001, 0.99));
+  }
+
+  /**
+   * A {@code Combine.CombineFn} that computes the {@link CountMinSketch} Structure
+   * of an {@code Iterable} of Strings, useful as an argument to {@link Combine#globally} or
+   * {@link Combine#perKey}.
+   *
+   * <p>When an element is added to the Count-min sketch, it is mapped to one column in each
+   * row using different hash functions, and a counter is updated in each column.
+   * <br>Collisions will happen as far as the number of distinct elements in the stream is greater
+   * than the width of the sketch. Each counter might be associated to many items so the frequency
+   * of an element is always overestimated. On average the relative error on a counter is bounded,
+   * but some counters can be very inaccurate.
+   * <br>That's why different hash functions are used to map the same element to different
+   * counters. Thus, the overestimation for each counter will differ as there will be different
+   * collisions, and one will probably be less inaccurate than the average.
+   *
+   * <p>Both the average relative error and the probability to have an estimation overcoming this
+   * error can be computed by knowing the dimensions of the sketch, and vice-versa.
+   * Thus, for Count-min sketch with 10 000 columns and 7 rows, the relative error should not be no
+   * more than 0.02% in 99% of the cases.
+   *
+   */
+  public static class CountMinSketchFn
+          extends Combine.CombineFn<String, CountMinSketch, CountMinSketch> {
+
+    private final int depth;
+
+    private final int width;
+
+    private final int seed;
+
+    private CountMinSketchFn(double eps, double confidence, int seed) {
+      this.width = (int) Math.ceil(2 / eps);
+      this.depth = (int) Math.ceil(-Math.log(1 - confidence) / Math.log(2));
+      this.seed = seed;
+    }
+
+    private CountMinSketchFn(int width, int depth, int seed) {
+      this.width = width;
+      this.depth = depth;
+      this.seed = seed;
+    }
+
+    /**
+     * Returns an {@code CountMinSketchFn} combiner that will have a Count-min sketch
+     * which will estimate the frequencies with about 1% of error guaranteed at 99%.
+     * the resulting dimensions are 2000 x 7. It will stay constant during all the aggregation.
+     *
+     * <p>the {@code seed} parameters is used to generate different hash functions of the form :
+     * <pre>a * i + b % p % width ,</pre>
+     * where a, b are chosen randomly and p is a prime number larger than the maximum i value.
+     *
+     * <p>Example of use:
+     * <br>1) Globally :
+     * <pre>{@code
+     * PCollection<String> pc = ...;
+     * PCollection<CountMinSketch> countMinSketch =
+     *     pc.apply(Combine.globally(CountMinSketchFn.<String>create(1234));
+     * }</pre>
+     * <br>2) Per key :
+     * <pre>{@code
+     * PCollection<KV<Integer, String>> pc = ...;
+     * PCollection<KV<Integer, CountMinSketch>> countMinSketch =
+     *     pc.apply(Combine.perKey(CountMinSketchFn.<String>create(1234));
+     * }</pre>
+     *
+     * @param seed        the seed used for generating different hash functions
+     */
+    public static CountMinSketchFn create(int seed) {
+      return new CountMinSketchFn(0.001, 0.99, seed);
+    }
+
+    /**
+     * Returns an {@code CountMinSketchFn} combiner that will have a Count-min sketch of
+     * dimensions {@code width x depth}, that will stay constant during all the aggregation.
+     * This method can only be applied from a {@link CountMinSketchFn} already created with the
+     * method {@link CountMinSketchFn#create(int)}.
+     *
+     * <p>The greater the {@code width}, the lower the expected relative error {@code epsilon} :
+     * <pre>{@code epsilon = 2 / width}</pre>
+     *
+     * <p>The greater the {@code depth}, the lower the probability to actually have
+     * a greater relative error than expected.
+     * <pre>{@code confidence = 1 - 2^-depth}</pre>
+     *
+     * <p>Example of use:
+     * <br>1) Globally :
+     * <pre> {@code
+     * PCollection<String> pc = ...;
+     * PCollection<CountMinSketch> countMinSketch =
+     *     pc.apply(Combine.globally(CountMinSketchFn.<String>create(1234)
+     *                  withDimensions(10000, 7));
+     * } </pre>
+     * <br>2) Per key :
+     * <pre> {@code
+     * PCollection<KV<Integer, String>> pc = ...;
+     * PCollection<KV<Integer, CountMinSketch>> countMinSketch =
+     *     pc.apply(Combine.perKey(CountMinSketchFn.<String>create(1234)
+     *                  withDimensions(10000, 7)););
+     * } </pre>
+     *
+     * @param width Number of columns, i.e. number of counters for the stream.
+     * @param depth Number of lines, i.e. number of hash functions
+     */
+    public CountMinSketchFn withDimensions(int width, int depth) {
+      if (width <= 0 || depth <= 0) {
+          throw new IllegalArgumentException("depth and width must be positive.");
+      }
+      return new CountMinSketchFn(width, depth, this.seed);
+    }
+
+    /**
+     * Returns an {@code CountMinSketchFn} combiner that will be as accurate as specified. The
+     * relative error {@code epsilon} can be guaranteed only with a certain {@code confidence},
+     * which has to be between 0 and 1 (1 being of course impossible). Those parameters will
+     * determine the size of the Count-min sketch in which the elements will be aggregated.
+     * This method can only be applied to a {@link CountMinSketchFn} already created with the
+     * method {@link CountMinSketchFn#create(int)}.
+     *
+     * <p>The lower the {@code epsilon} value, the greater the width.
+     * <pre>{@code width = (int) 2 / epsilon)}</pre>
+     *
+     * <p>The greater the confidence, the greater the depth.
+     * <pre>{@code depth = (int) -log2(1 - confidence)}</pre>
+     *
+     * <p>Example of use:
+     * <br>1) Globally :
+     * <pre>{@code
+     * PCollection<String> pc = ...;
+     * PCollection<CountMinSketch> countMinSketch =
+     *     pc.apply(Combine.globally(CountMinSketchFn.<String>create(1234)
+     *                  withDimensions(0.001, 0.99));
+     * }</pre>
+     * <br>2) Per key :
+     * <pre>{@code
+     * PCollection<KV<Integer, String>> pc = ...;
+     * PCollection<KV<Integer, CountMinSketch>> countMinSketch =
+     *     pc.apply(Combine.perKey(CountMinSketchFn.<String>create(1234)
+     *                  withAccuracy(0.001, 0.99)););
+     * }</pre>
+     *
+     *
+     * @param epsilon the relative error of the result
+     * @param confidence the confidence in the result to not overcome the relative error
+     */
+    public CountMinSketchFn withAccuracy(double epsilon, double confidence) {
+      return new CountMinSketchFn(epsilon, confidence, this.seed);
+    }
+
+    @Override public CountMinSketch createAccumulator() {
+      return new CountMinSketch(this.depth, this.width, this.seed);
+    }
+
+    @Override public CountMinSketch addInput(CountMinSketch accumulator, String element) {
+      accumulator.add(element, 1);
+      return accumulator;
+    }
+
+    @Override public CountMinSketch mergeAccumulators(Iterable<CountMinSketch> accumulators) {
+      Iterator<CountMinSketch> it = accumulators.iterator();
+      if (!it.hasNext()) {
+        return new CountMinSketch(seed, width, depth);
+      }
+      CountMinSketch merged = it.next();
+      try {
+        while (it.hasNext()) {
+          merged = CountMinSketch.merge(merged, it.next());
+        }
+      } catch (FrequencyMergeException e) {
+        // Should never happen because all the accumulators created are of the same type.
+        LOG.error(e.getMessage(), e);
+      }
+      return merged;
+    }
+
+    @Override public CountMinSketch extractOutput(CountMinSketch accumulator) {
+      return accumulator;
+    }
+
+    @Override public Coder<CountMinSketch> getAccumulatorCoder(CoderRegistry registry,
+        Coder inputCoder) {
+      return new CountMinSketchCoder();
+    }
+
+    @Override public Coder<CountMinSketch> getDefaultOutputCoder(CoderRegistry registry,
+        Coder inputCoder) throws CannotProvideCoderException {
+      return new CountMinSketchCoder();
+    }
+
+    @Override public CountMinSketch defaultValue() {
+      return new CountMinSketch(1, 1, 1);
+    }
+  }
+
+  static class CountMinSketchCoder extends CustomCoder<CountMinSketch> {
+
+    private static final ByteArrayCoder BYTE_ARRAY_CODER = ByteArrayCoder.of();
+
+    @Override public void encode(CountMinSketch value, OutputStream outStream) throws IOException {
+        if (value == null) {
+          throw new CoderException("cannot encode a null Count-min Sketch");
+        }
+        BYTE_ARRAY_CODER.encode(CountMinSketch.serialize(value), outStream);
+    }
+
+    @Override public CountMinSketch decode(InputStream inStream) throws IOException {
+      return CountMinSketch.deserialize(BYTE_ARRAY_CODER.decode(inStream));
+    }
+
+    @Override public boolean consistentWithEquals() {
+      return false;
+    }
+
+    @Override public boolean isRegisterByteSizeObserverCheap(CountMinSketch value) {
+      return true;
+    }
+
+    @Override protected long getEncodedElementByteSize(CountMinSketch value) throws IOException {
+      if (value == null) {
+        throw new CoderException("cannot encode a null Count-min Sketch");
+      } else {
+        // depth and width as computed in the CountMinSketch constructor from the relative error and
+        // confidence.
+        int width = (int) Math.ceil(2 / value.getRelativeError());
 
 Review comment:
   All right I'm going to send a PR to stream-lib and add a Todo in this function then, thanks @lukecwik

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


ArnaudFnr opened a new pull request #4328: [BEAM-2728] Add Count-Min Sketch in sketching extension
URL: https://github.com/apache/beam/pull/4328
 
 
   This pull request adds PTransforms to estimate the frequency of elements in a stream using Stream-Lib's Count-Min sketch implementation. 
   The SketchFrequencies class is designed in the same manner as ApproximateDistinct. It takes any encodable input and outputs a Count-Min Sketch that can be queried.
   
   Some elements to discuss in particular : 
   
   - The stream-lib's Count-Min sketch implementation is embedded in an inner class "Sketch", so the user doesn't have to pull the Stream-Lib dependency.
   
   - The elements are hashed using Google's MurmurHash in 128 bits because Stream-Lib's Count-Min sketch only support Long or String types. This could be simplified using Spark-sketch implementation which also support Byte Arrays as input type, but it would pull more dependencies.
   
   - The user has to provide the element coder in order to query its estimate frequency from the resulting sketch (see estimateCount() method in Sketch class).
   It could be avoided if the coder was defined as an attribute of the inner Sketch, but in that case it should be serialized in the Sketch coder.
   
   Follow this checklist to help us incorporate your contribution quickly and easily:
   
    - [ ] Make sure there is a [JIRA issue](https://issues.apache.org/jira/projects/BEAM/issues/) filed for the change (usually before you start working on it).  Trivial changes like typos do not require a JIRA issue.  Your pull request should address just this issue, without pulling in other changes.
    - [ ] Each commit in the pull request should have a meaningful subject line and body.
    - [ ] Format the pull request title like `[BEAM-XXX] Fixes bug in ApproximateQuantiles`, where you replace `BEAM-XXX` with the appropriate JIRA issue.
    - [ ] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.
    - [ ] Run `mvn clean verify` to make sure basic checks pass. A more thorough check will be performed on your pull request automatically.
    - [ ] If this contribution is large, please file an Apache [Individual Contributor License Agreement](https://www.apache.org/licenses/icla.pdf).
   
   ---
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


lukecwik closed pull request #4328: [BEAM-2728] Add Count-Min Sketch in sketching extension
URL: https://github.com/apache/beam/pull/4328
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/sdks/java/extensions/sketching/pom.xml b/sdks/java/extensions/sketching/pom.xml
index f0538aece63..73902180f83 100755
--- a/sdks/java/extensions/sketching/pom.xml
+++ b/sdks/java/extensions/sketching/pom.xml
@@ -39,6 +39,7 @@
       <artifactId>beam-sdks-java-core</artifactId>
     </dependency>
 
+    <!-- Library containing sketches' implementation -->
     <dependency>
       <groupId>com.clearspring.analytics</groupId>
       <artifactId>stream</artifactId>
diff --git a/sdks/java/extensions/sketching/src/main/java/org/apache/beam/sdk/extensions/sketching/ApproximateDistinct.java b/sdks/java/extensions/sketching/src/main/java/org/apache/beam/sdk/extensions/sketching/ApproximateDistinct.java
index 1da0cc35329..726199ecb0b 100644
--- a/sdks/java/extensions/sketching/src/main/java/org/apache/beam/sdk/extensions/sketching/ApproximateDistinct.java
+++ b/sdks/java/extensions/sketching/src/main/java/org/apache/beam/sdk/extensions/sketching/ApproximateDistinct.java
@@ -233,7 +233,7 @@
   /**
    * Implementation of {@link #globally()}.
    *
-   * @param <InputT>
+   * @param <InputT> the type of the elements in the input {@link PCollection}
    */
   @AutoValue
   public abstract static class GloballyDistinct<InputT>
@@ -284,8 +284,8 @@
   /**
    * Implementation of {@link #perKey()}.
    *
-   * @param <K>
-   * @param <V>
+   * @param <K> type of the keys mapping the elements
+   * @param <V> type of the values being combined per key
    */
   @AutoValue
   public abstract static class PerKeyDistinct<K, V>
@@ -362,7 +362,8 @@ private ApproximateDistinctFn(int p, int sp, Coder<InputT> coder) {
       try {
         coder.verifyDeterministic();
       } catch (Coder.NonDeterministicException e) {
-        throw new IllegalArgumentException("Coder is not deterministic ! " + e.getMessage(), e);
+        throw new IllegalArgumentException("Coder must be deterministic to perform this sketch."
+                + e.getMessage(), e);
       }
       return new ApproximateDistinctFn<>(12, 0, coder);
     }
diff --git a/sdks/java/extensions/sketching/src/main/java/org/apache/beam/sdk/extensions/sketching/SketchFrequencies.java b/sdks/java/extensions/sketching/src/main/java/org/apache/beam/sdk/extensions/sketching/SketchFrequencies.java
new file mode 100644
index 00000000000..a31847362b8
--- /dev/null
+++ b/sdks/java/extensions/sketching/src/main/java/org/apache/beam/sdk/extensions/sketching/SketchFrequencies.java
@@ -0,0 +1,520 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.sdk.extensions.sketching;
+
+import com.clearspring.analytics.stream.frequency.CountMinSketch;
+import com.clearspring.analytics.stream.frequency.FrequencyMergeException;
+import com.google.auto.value.AutoValue;
+import com.google.common.hash.Hashing;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.Serializable;
+import java.util.Iterator;
+
+import org.apache.beam.sdk.annotations.Experimental;
+import org.apache.beam.sdk.coders.ByteArrayCoder;
+import org.apache.beam.sdk.coders.Coder;
+import org.apache.beam.sdk.coders.CoderException;
+import org.apache.beam.sdk.coders.CoderRegistry;
+import org.apache.beam.sdk.coders.CustomCoder;
+import org.apache.beam.sdk.coders.KvCoder;
+import org.apache.beam.sdk.transforms.Combine;
+import org.apache.beam.sdk.transforms.Combine.CombineFn;
+import org.apache.beam.sdk.transforms.PTransform;
+import org.apache.beam.sdk.transforms.ParDo;
+import org.apache.beam.sdk.transforms.display.DisplayData;
+import org.apache.beam.sdk.util.CoderUtils;
+import org.apache.beam.sdk.values.KV;
+import org.apache.beam.sdk.values.PCollection;
+
+/**
+ * {@code PTransform}s to compute the estimate frequency of each element in a stream.
+ *
+ * <p>This class uses the Count-min Sketch structure which allows very efficient queries
+ * on the data stream summarization.
+ *
+ * <h2>References</h2>
+ *
+ * <p>The implementation comes from <a href="https://github.com/addthis/stream-lib">
+ * Addthis' Stream-lib library</a>. <br>
+ * The papers and other useful information about Count-Min Sketch are available on <a
+ * href="https://sites.google.com/site/countminsketch/">this website</a>. <br>
+ *
+ * <h2>Parameters</h2>
+ *
+ * <p>Two parameters can be tuned in order to control the accuracy of the computation:
+ *
+ * <ul>
+ *   <li><b>Relative Error:</b> <br>
+ *       The relative error "{@code epsilon}" controls the accuracy of the estimation.
+ *       By default, the relative is around {@code 1%} of the total count.
+ *   <li><b>Confidence</b> <br>
+ *       The relative error can be guaranteed only with a certain "{@code confidence}",
+ *       between 0 and 1 (1 being of course impossible). <br>
+ *       The default value is set to 0.999 meaning that we can guarantee
+ *       that the relative error will not exceed 1% of the total count in 99.9% of cases.
+ * </ul>
+ *
+ * <p>These two parameters will determine the size of the Count-min sketch, which is
+ * a two-dimensional array with depth and width defined as follows :
+ * <ul>
+ *   <li>{@code width = ceil(2 / epsilon)}</li>
+ *   <li>{@code depth = ceil(-log(1 - confidence) / log(2))}</li>
+ * </ul>
+ *
+ * <p>With the default values, this gives a depth of 200 and a width of 10.
+ *
+ * <p><b>WARNING:</b> The relative error concerns the total number of distinct elements
+ * in a stream. Thus, an element having 1000 occurrences in a stream of 1 million distinct
+ * elements will have 1% of 1 million as relative error, i.e. 10 000. This means the frequency
+ * is 1000 +/- 10 000 for this element. Therefore this is obvious that the relative error must
+ * be really low in very large streams. <br>
+ * Also keep in mind that this algorithm works well on highly skewed data but gives poor
+ * results if the elements are evenly distributed.
+ *
+ * <h2>Examples</h2>
+ *
+ * <p>There are 2 ways of using this class:
+ *
+ * <ul>
+ *   <li>Use the {@link PTransform}s that return a {@link PCollection} singleton that contains
+ *       a Count-min sketch for querying the estimate number of hits of the elements.
+ *   <li>Use the {@link CountMinSketchFn} {@code CombineFn} that is exposed in order to make
+ *       advanced processing involving the Count-Min sketch.
+ * </ul>
+ *
+ * <h3>Example 1: simple default use</h3>
+ *
+ * <p>The simplest use is simply to call the {@link #globally()} or {@link #perKey()} method in
+ * order to retrieve the sketch with an estimate number of hits for each element in the stream.
+ *
+ * <pre><code>
+ * {@literal PCollection<MyObject>} pc = ...;
+ * {@literal PCollection<CountMinSketch>} countMinSketch = pc.apply(SketchFrequencies
+ * {@literal        .<MyObject>}globally()); //{@literal .<MyObject>}perKey();
+ * }
+ * </code></pre>
+ *
+ * <h3>Example 2: tune accuracy parameters</h3>
+ *
+ * <p>One can tune the {@code epsilon} and {@code confidence} parameters in order to
+ * control accuracy and memory. <br>
+ * The tuning works exactly the same for {@link #globally()} and {@link #perKey()}.
+ *
+ * <pre><code>
+ *  double eps = 0.001;
+ *  double conf = 0.9999;
+ * {@literal PCollection<MyObject>} pc = ...;
+ * {@literal PCollection<CountMinSketch>} countMinSketch = pc.apply(SketchFrequencies
+ * {@literal  .<MyObject>}globally() //{@literal .<MyObject>}perKey()
+ *            .withRelativeError(eps)
+ *            .withConfidence(conf));
+ * }
+ * </code></pre>
+ *
+ * <h3>Example 3: query the resulting sketch</h3>
+ *
+ * <p>This example shows how to query the resulting {@link Sketch}.
+ * To estimate the number of hits of an element, one has to use
+ * {@link Sketch#estimateCount(Object, Coder)} method and to provide
+ * the coder for the element type. <br>
+ * For instance, one can build a KV Pair linking each element to an estimation
+ * of its frequency, using the sketch as side input of a {@link ParDo}. <br>
+ *
+ * <pre><code>
+ * {@literal PCollection<MyObject>} pc = ...;
+ * {@literal PCollection<CountMinSketch>} countMinSketch = pc.apply(SketchFrequencies
+ * {@literal       .<MyObject>}globally());
+ *
+ * // Retrieve the coder for MyObject
+ * final{@literal Coder<MyObject>} = pc.getCoder();
+ * // build a View of the sketch so it can be passed a sideInput
+ * final{@literal PCollectionView<CountMinSketch>} sketchView = sketch.apply(View
+ * {@literal       .<CountMinSketch>}asSingleton());
+ *
+ * {@literal PCollection<KV<MyObject, Long>>} pairs = pc.apply(ParDo.of(
+ *        {@literal new DoFn<Long, KV<MyObject, Long>>()} {
+ *          {@literal @ProcessElement}
+ *           public void procesElement(ProcessContext c) {
+ *             Long elem = c.element();
+ *             CountMinSketch sketch = c.sideInput(sketchView);
+ *             sketch.estimateCount(elem, coder);
+ *            }}).withSideInputs(sketchView));
+ * }
+ * </code></pre>
+ *
+ * <h3>Example 4: Using the CombineFn</h3>
+ *
+ * <p>The {@code CombineFn} does the same thing as the {@code PTransform}s but
+ * it can be used for doing stateful processing or in
+ * {@link org.apache.beam.sdk.transforms.CombineFns.ComposedCombineFn}.
+ *
+ * <p>This example is not really interesting but it shows how you can properly create
+ * a {@link CountMinSketchFn}. One must always specify a coder using the {@link
+ * CountMinSketchFn#create(Coder)} method.
+ *
+ * <pre><code>
+ *  double eps = 0.0001;
+ *  double conf = 0.9999;
+ * {@literal PCollection<MyObject>} input = ...;
+ * {@literal PCollection<CountMinSketch>} output = input.apply(Combine.globally(CountMinSketchFn
+ * {@literal    .<MyObject>}create(new MyObjectCoder())
+ *              .withAccuracy(eps, conf)));
+ * }
+ * </code></pre>
+ *
+ * <p><b>Warning: this class is experimental.</b> <br>
+ * Its API is subject to change in future versions of Beam.
+ */
+@Experimental
+public final class SketchFrequencies {
+
+  /**
+   * Create the {@link PTransform} that will build a Count-min sketch for keeping track
+   * of the frequency of the elements in the whole stream.
+   *
+   * <p>It returns a {@code PCollection<{@link CountMinSketch}>}  that can be queried in order to
+   * obtain estimations of the elements' frequencies.
+   *
+   * @param <InputT> the type of the elements in the input {@link PCollection}
+   */
+  public static <InputT> GlobalSketch<InputT> globally() {
+    return GlobalSketch.<InputT>builder().build();
+  }
+
+  /**
+   * Like {@link #globally()} but per key, i.e a Count-min sketch per key
+   * in {@code  PCollection<KV<K, V>>} and returns a
+   * {@code PCollection<KV<K, {@link CountMinSketch}>>}.
+   *
+   * @param <K> type of the keys mapping the elements
+   * @param <V> type of the values being combined per key
+   */
+  public static <K, V> PerKeySketch<K, V> perKey() {
+    return PerKeySketch.<K, V>builder().build();
+  }
+
+  /**
+   * Implementation of {@link #globally()}.
+   *
+   * @param <InputT> the type of the elements in the input {@link PCollection}
+   */
+  @AutoValue
+  public abstract static class GlobalSketch<InputT>
+          extends PTransform<PCollection<InputT>, PCollection<Sketch<InputT>>> {
+
+    abstract double relativeError();
+
+    abstract double confidence();
+
+    abstract Builder<InputT> toBuilder();
+
+    static <InputT> Builder<InputT> builder() {
+      return new AutoValue_SketchFrequencies_GlobalSketch.Builder<InputT>()
+              .setRelativeError(0.01)
+              .setConfidence(0.999);
+    }
+
+    @AutoValue.Builder
+    abstract static class Builder<InputT> {
+      abstract Builder<InputT> setRelativeError(double eps);
+
+      abstract Builder<InputT> setConfidence(double conf);
+
+      abstract GlobalSketch<InputT> build();
+    }
+
+    public GlobalSketch<InputT> withRelativeError(double eps) {
+      return toBuilder().setRelativeError(eps).build();
+    }
+
+    public GlobalSketch<InputT> withConfidence(double conf) {
+      return toBuilder().setConfidence(conf).build();
+    }
+
+    @Override
+    public PCollection<Sketch<InputT>> expand(PCollection<InputT> input) {
+      return input.apply("Compute Count-Min Sketch",
+                      Combine.<InputT, Sketch<InputT>>globally(CountMinSketchFn
+                              .<InputT>create(input.getCoder())
+                              .withAccuracy(relativeError(), confidence())));
+    }
+  }
+
+  /**
+   * Implementation of {@link #perKey()}.
+   *
+   * @param <K> type of the keys mapping the elements
+   * @param <V> type of the values being combined per key
+   */
+  @AutoValue
+  public abstract static class PerKeySketch<K, V>
+          extends PTransform<PCollection<KV<K, V>>, PCollection<KV<K, Sketch<V>>>> {
+
+    abstract double relativeError();
+
+    abstract double confidence();
+
+    abstract Builder<K, V> toBuilder();
+
+    static <K, V> Builder<K, V> builder() {
+      return new AutoValue_SketchFrequencies_PerKeySketch.Builder<K, V>()
+              .setRelativeError(0.01)
+              .setConfidence(0.999);
+    }
+
+    @AutoValue.Builder
+    abstract static class Builder<K, V> {
+      abstract Builder<K, V> setRelativeError(double eps);
+
+      abstract Builder<K, V> setConfidence(double conf);
+
+      abstract PerKeySketch<K, V> build();
+    }
+
+    public PerKeySketch<K, V> withRelativeError(double eps) {
+      return toBuilder().setRelativeError(eps).build();
+    }
+
+    public PerKeySketch<K, V> withConfidence(double conf) {
+      return toBuilder().setConfidence(conf).build();
+    }
+
+    @Override
+    public PCollection<KV<K, Sketch<V>>> expand(PCollection<KV<K, V>> input) {
+      KvCoder<K, V> inputCoder = (KvCoder<K, V>) input.getCoder();
+      return input.apply("Compute Count-Min Sketch perKey",
+              Combine.<K, V, Sketch<V>>perKey(CountMinSketchFn
+                      .<V>create(inputCoder.getValueCoder())
+                      .withAccuracy(relativeError(), confidence())));
+    }
+  }
+
+  /**
+   * Implements the {@link CombineFn} of {@link SketchFrequencies} transforms.
+   *
+   * @param <InputT> the type of the elements in the input {@link PCollection}
+   */
+  public static class CountMinSketchFn<InputT>
+          extends CombineFn<InputT, Sketch<InputT>, Sketch<InputT>> {
+
+    private final Coder<InputT> inputCoder;
+    private final int depth;
+    private final int width;
+    private final double epsilon;
+    private final double confidence;
+
+    private CountMinSketchFn(final Coder<InputT> coder, double eps, double confidence) {
+      this.epsilon = eps;
+      this.confidence = confidence;
+      this.width = (int) Math.ceil(2 / eps);
+      this.depth = (int) Math.ceil(-Math.log(1 - confidence) / Math.log(2));
+      this.inputCoder = coder;
+    }
+
+    /**
+     * Returns an {@link CountMinSketchFn} combiner with the given input coder. <br>
+     * <b>Warning :</b> the coder must be deterministic.
+     *
+     * @param coder the coder that encodes the elements' type
+     */
+    public static <InputT> CountMinSketchFn<InputT> create(Coder<InputT> coder) {
+      try {
+        coder.verifyDeterministic();
+      } catch (Coder.NonDeterministicException e) {
+        throw new IllegalArgumentException("Coder must be deterministic to perform this sketch."
+                + e.getMessage(), e);
+      }
+      return new CountMinSketchFn<>(coder, 0.01, 0.999);
+    }
+
+    /**
+     * Returns a new {@link CountMinSketchFn} combiner with new precision accuracy parameters
+     * {@code epsilon} and {@code confidence}.
+     *
+     * <p>Keep in mind that the lower the {@code epsilon} value, the greater the width,
+     * and the greater the confidence, the greater the depth.
+     *
+     * @param epsilon the error relative to the total number of distinct elements
+     * @param confidence the confidence in the result to not exceed the relative error
+     */
+    public CountMinSketchFn<InputT> withAccuracy(double epsilon, double confidence) {
+      if (epsilon <= 0D) {
+        throw new IllegalArgumentException("The relative error must be positive");
+      }
+
+      if (confidence <= 0D || confidence >= 1D) {
+        throw new IllegalArgumentException("The confidence must be between 0 and 1");
+      }
+      return new CountMinSketchFn<InputT>(inputCoder, epsilon, confidence);
+    }
+
+    @Override public Sketch<InputT> createAccumulator() {
+      return Sketch.<InputT>create(epsilon, confidence);
+    }
+
+    @Override public Sketch<InputT> addInput(Sketch<InputT> accumulator, InputT element) {
+      accumulator.add(element, inputCoder);
+
+      return accumulator;
+    }
+
+    @Override public Sketch<InputT> mergeAccumulators(Iterable<Sketch<InputT>> accumulators) {
+      Iterator<Sketch<InputT>> it = accumulators.iterator();
+      Sketch<InputT> first = it.next();
+      CountMinSketch mergedSketches = first.sketch();
+      try {
+        while (it.hasNext()) {
+          mergedSketches = CountMinSketch.merge(mergedSketches, it.next().sketch());
+        }
+      } catch (FrequencyMergeException e) {
+        // Should never happen because every instantiated accumulator are of the same type.
+        throw new IllegalStateException("The accumulators cannot be merged:" + e.getMessage());
+      }
+
+      return Sketch.<InputT>create(mergedSketches);
+    }
+
+    /** Output the whole structure so it can be queried, reused or stored easily. */
+    @Override public Sketch<InputT> extractOutput(Sketch<InputT> accumulator) {
+      return accumulator;
+    }
+
+
+    @Override public Coder<Sketch<InputT>> getAccumulatorCoder(CoderRegistry registry,
+                                                               Coder inputCoder) {
+      return new CountMinSketchCoder<InputT>();
+    }
+
+    @Override
+    public void populateDisplayData(DisplayData.Builder builder) {
+      super.populateDisplayData(builder);
+      builder
+              .add(DisplayData.item("width", width)
+                      .withLabel("width of the Count-Min sketch array"))
+              .add(DisplayData.item("depth", depth)
+                      .withLabel("depth of the Count-Min sketch array"))
+              .add(DisplayData.item("eps", epsilon)
+                      .withLabel("relative error to the total number of elements"))
+              .add(DisplayData.item("conf", confidence)
+                      .withLabel("confidence in the relative error"));
+    }
+  }
+
+  /**
+   * Wrap StreamLib's Count-Min Sketch to support counting all user types by hashing
+   * the encoded user type using the supplied deterministic coder. This is required
+   * since objects in Apache Beam are considered equal if their encodings are equal.
+   */
+  @AutoValue
+  public abstract static class Sketch<T> implements Serializable {
+
+    static final int SEED = 123456;
+
+    static <T> Sketch<T> create(double eps, double conf) {
+      int width = (int) Math.ceil(2 / eps);
+      int depth = (int) Math.ceil(-Math.log(1 - conf) / Math.log(2));
+      return new AutoValue_SketchFrequencies_Sketch<T>(
+              depth,
+              width,
+              new CountMinSketch(depth, width, SEED));
+    }
+
+    static <T> Sketch<T> create(CountMinSketch sketch) {
+      int width = (int) Math.ceil(2 / sketch.getRelativeError());
+      int depth = (int) Math.ceil(-Math.log(1 - sketch.getConfidence()) / Math.log(2));
+      return new AutoValue_SketchFrequencies_Sketch<T>(
+              depth,
+              width,
+              sketch);
+    }
+
+    abstract int depth();
+    abstract int width();
+    abstract CountMinSketch sketch();
+
+    public void add(T element, long count, Coder<T> coder) {
+      sketch().add(hashElement(element, coder), count);
+    }
+
+    public void add(T element, Coder<T> coder) {
+      add(element, 1L, coder);
+    }
+
+    private long hashElement(T element, Coder<T> coder) {
+      try {
+        byte[] elemBytes = CoderUtils.encodeToByteArray(coder, element);
+        return Hashing.murmur3_128().hashBytes(elemBytes).asLong();
+      } catch (CoderException e) {
+        throw new IllegalStateException("The input value cannot be encoded: " + e.getMessage(), e);
+      }
+    }
+
+    /**
+     * Utility class to retrieve the estimate frequency of an element from a {@link
+     * CountMinSketch}.
+     */
+    public long estimateCount(T element, Coder<T> coder) {
+      return sketch().estimateCount(hashElement(element, coder));
+    }
+
+  }
+
+  /**
+   * Coder for {@link CountMinSketch} class.
+   */
+  static class CountMinSketchCoder<T> extends CustomCoder<Sketch<T>> {
+
+    private static final ByteArrayCoder BYTE_ARRAY_CODER = ByteArrayCoder.of();
+
+    @Override
+    public void encode(Sketch<T> value, OutputStream outStream) throws IOException {
+      if (value == null) {
+        throw new CoderException("cannot encode a null Count-min Sketch");
+      }
+      BYTE_ARRAY_CODER.encode(CountMinSketch.serialize(value.sketch()), outStream);
+    }
+
+    @Override
+    public Sketch<T> decode(InputStream inStream) throws IOException {
+      byte[] sketchBytes = BYTE_ARRAY_CODER.decode(inStream);
+      CountMinSketch sketch = CountMinSketch.deserialize(sketchBytes);
+      return Sketch.<T>create(sketch);
+    }
+
+    @Override
+    public boolean isRegisterByteSizeObserverCheap(Sketch<T> value) {
+      return true;
+    }
+
+    @Override
+    protected long getEncodedElementByteSize(Sketch<T> value) throws IOException {
+      if (value == null) {
+        throw new CoderException("cannot encode a null Count-min Sketch");
+      } else {
+        // 8L is for the sketch's size (long)
+        // 4L * 4 is for depth and width (ints) in Sketch<T> and in the Count-Min sketch
+        // 8L * depth * (width + 1) is a factorization for the sizes of table (long[depth][width])
+        // and hashA (long[depth])
+        return 8L + 4L * 4 + 8L * value.depth() * (value.width() + 1);
+      }
+    }
+  }
+}
diff --git a/sdks/java/extensions/sketching/src/test/java/org/apache/beam/sdk/extensions/sketching/SketchFrequenciesTest.java b/sdks/java/extensions/sketching/src/test/java/org/apache/beam/sdk/extensions/sketching/SketchFrequenciesTest.java
new file mode 100644
index 00000000000..34d9ed145c8
--- /dev/null
+++ b/sdks/java/extensions/sketching/src/test/java/org/apache/beam/sdk/extensions/sketching/SketchFrequenciesTest.java
@@ -0,0 +1,204 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.beam.sdk.extensions.sketching;
+
+import static org.apache.beam.sdk.transforms.display.DisplayDataMatchers.hasDisplayItem;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.Assert.assertEquals;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.avro.Schema;
+import org.apache.avro.SchemaBuilder;
+import org.apache.avro.generic.GenericData;
+import org.apache.avro.generic.GenericRecord;
+import org.apache.beam.sdk.coders.AvroCoder;
+import org.apache.beam.sdk.coders.Coder;
+import org.apache.beam.sdk.coders.VarIntCoder;
+import org.apache.beam.sdk.extensions.sketching.SketchFrequencies.CountMinSketchFn;
+import org.apache.beam.sdk.extensions.sketching.SketchFrequencies.Sketch;
+import org.apache.beam.sdk.testing.CoderProperties;
+import org.apache.beam.sdk.testing.PAssert;
+import org.apache.beam.sdk.testing.TestPipeline;
+import org.apache.beam.sdk.transforms.Create;
+import org.apache.beam.sdk.transforms.SerializableFunction;
+import org.apache.beam.sdk.transforms.Values;
+import org.apache.beam.sdk.transforms.WithKeys;
+import org.apache.beam.sdk.transforms.display.DisplayData;
+import org.apache.beam.sdk.values.PCollection;
+import org.junit.Rule;
+import org.junit.Test;
+
+/**
+ * Tests for {@link SketchFrequencies}.
+ */
+public class SketchFrequenciesTest implements Serializable {
+
+  @Rule public final transient TestPipeline tp = TestPipeline.create();
+
+  private List<Long> smallStream = Arrays.asList(
+          1L,
+          2L, 2L,
+          3L, 3L, 3L,
+          4L, 4L, 4L, 4L,
+          5L, 5L, 5L, 5L, 5L,
+          6L, 6L, 6L, 6L, 6L, 6L,
+          7L, 7L, 7L, 7L, 7L, 7L, 7L,
+          8L, 8L, 8L, 8L, 8L, 8L, 8L, 8L,
+          9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L, 9L);
+
+  private Long[] distinctElems = {1L, 2L, 3L, 4L, 5L, 6L, 8L, 9L};
+  private Long[] frequencies = distinctElems.clone();
+
+  @Test
+  public void perKeyDefault() {
+    PCollection<Long> stream = tp.apply(Create.of(smallStream));
+    PCollection<Sketch<Long>> sketch = stream
+            .apply(WithKeys.<Integer, Long>of(1))
+            .apply(SketchFrequencies.<Integer, Long>perKey())
+            .apply(Values.<Sketch<Long>>create());
+
+    Coder<Long> coder = stream.getCoder();
+
+    PAssert.thatSingleton("Verify number of hits", sketch)
+            .satisfies(new VerifyStreamFrequencies<Long>(coder, distinctElems, frequencies));
+
+    tp.run();
+  }
+
+  @Test
+  public void globallyWithTunedParameters() {
+    double eps = 0.01;
+    double conf = 0.8;
+    PCollection<Long> stream = tp.apply(Create.of(smallStream));
+    PCollection<Sketch<Long>> sketch = stream
+            .apply(SketchFrequencies
+                    .<Long>globally()
+                    .withRelativeError(eps)
+                    .withConfidence(conf));
+
+    Coder<Long> coder = stream.getCoder();
+
+    PAssert.thatSingleton("Verify number of hits", sketch)
+            .satisfies(new VerifyStreamFrequencies<Long>(coder, distinctElems, frequencies));
+
+    tp.run();
+  }
+
+  @Test
+  public void merge() {
+    double eps = 0.01;
+    double conf = 0.8;
+    long nOccurrences = 2L;
+    int size = 3;
+
+    List<Sketch<Integer>> sketches = new ArrayList<>();
+    Coder<Integer> coder = VarIntCoder.of();
+
+    // n sketches each containing [0, 1, 2]
+    for (int i = 0; i < nOccurrences; i++) {
+      Sketch<Integer> sketch = Sketch.<Integer>create(eps, conf);
+      for (int j = 0; j < size; j++) {
+        sketch.add(j, coder);
+      }
+      sketches.add(sketch);
+    }
+
+    CountMinSketchFn<Integer> fn = CountMinSketchFn.create(coder).withAccuracy(eps, conf);
+    Sketch<Integer> merged = fn.mergeAccumulators(sketches);
+    for (int i = 0; i < size; i++) {
+      assertEquals(nOccurrences, merged.estimateCount(i, coder));
+    }
+  }
+
+  @Test
+  public void customObject() {
+    int nUsers = 10;
+    long occurrences = 2L; // occurrence of each user in the stream
+    double eps = 0.01;
+    double conf = 0.8;
+    Sketch<GenericRecord> sketch = Sketch.<GenericRecord>create(eps, conf);
+    Schema schema =
+            SchemaBuilder.record("User")
+                    .fields()
+                    .requiredString("Pseudo")
+                    .requiredInt("Age")
+                    .endRecord();
+    Coder<GenericRecord> coder = AvroCoder.of(schema);
+
+    for (int i = 1; i <= nUsers; i++) {
+      GenericData.Record newRecord = new GenericData.Record(schema);
+      newRecord.put("Pseudo", "User" + i);
+      newRecord.put("Age", i);
+      sketch.add(newRecord, occurrences, coder);
+      assertEquals("Test API", occurrences, sketch.estimateCount(newRecord, coder));
+    }
+  }
+
+  @Test
+  public void testCoder() throws Exception {
+    Sketch<Integer> cMSketch = Sketch.<Integer>create(0.01, 0.8);
+    Coder<Integer> coder = VarIntCoder.of();
+    for (int i = 0; i < 3; i++) {
+      cMSketch.add(i, coder);
+    }
+
+    CoderProperties.<Sketch<Integer>>coderDecodeEncodeEqual(
+            new SketchFrequencies.CountMinSketchCoder<Integer>(), cMSketch);
+  }
+
+  @Test
+  public void testDisplayData() {
+    double eps = 0.01;
+    double conf = 0.8;
+    int width = (int) Math.ceil(2 / eps);
+    int depth = (int) Math.ceil(-Math.log(1 - conf) / Math.log(2));
+
+    final CountMinSketchFn<Integer> fn =
+            CountMinSketchFn.create(VarIntCoder.of()).withAccuracy(eps, conf);
+
+    assertThat(DisplayData.from(fn), hasDisplayItem("width", width));
+    assertThat(DisplayData.from(fn), hasDisplayItem("depth", depth));
+    assertThat(DisplayData.from(fn), hasDisplayItem("eps", eps));
+    assertThat(DisplayData.from(fn), hasDisplayItem("conf", conf));
+  }
+
+  static class VerifyStreamFrequencies<T> implements SerializableFunction<Sketch<T>, Void> {
+
+    Coder<T> coder;
+    Long[] expectedHits;
+    T[] elements;
+
+    VerifyStreamFrequencies(Coder<T> coder, T[] elements, Long[] expectedHits) {
+      this.coder = coder;
+      this.elements = elements;
+      this.expectedHits = expectedHits;
+    }
+
+    @Override
+    public Void apply(Sketch<T> sketch) {
+      for (int i = 0; i < elements.length; i++) {
+        assertEquals((long) expectedHits[i], sketch.estimateCount(elements[i], coder));
+      }
+      return null;
+    }
+  }
+}


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


I'd say this is resolved - we've got the extension and it is going out with 2.3.0

I've created a Jira component just for further tickets on the sketching library.

I am reopening this since we are still missing one of the sketches of the original proposal. KMost frequent, good work [~arnaudfnr]. Just one more and this will be done !

I want to save the sketch itself to BigQuery, to be able to perform merge [https://cloud.google.com/bigquery/docs/reference/standard-sql/hll_functions]

I used this library [https://github.com/apache/beam/tree/master/sdks/java/extensions/sketching]

and in the code:
{code:java}
.apply("hll-count", Combine.perKey(ApproximateDistinct.ApproximateDistinctFn .create(StringUtf8Coder.of())))
.apply("to-table-row", ParDo.of(new DoFn< ValueInSingleWindow<KV<GroupByData,HyperLogLogPlus>>, TableRow>() { 
   @ProcessElement 
   public void processElement(ProcessContext processContext) { 
     ValueInSingleWindow<KV<GroupByData,HyperLogLogPlus>> windowed = processContext.element(); 
     KV<GroupByData, HyperLogLogPlus> keyData = windowed.getValue(); 
     GroupByData key = keyData.getKey(); 
     HyperLogLogPlus hllSketch = keyData.getValue(); 
     TableRow tableRow = new TableRow(); 
     tableRow.set("country_code",key.countryCode); 
     tableRow.set("event", key.event); 
     tableRow.set("profile", key.profile);
 
{code}
// How can I get the HLL ????????
{code:java}
tableRow.set("hll",hllSketch.getBytes());{code}

Hi Brachi! FYI, the open-sourced HLL implementation this library based on is different from Google Cloud BigQuery's implementation of HLL. So the sketch won't be consistent.

 

There are efforts going on to support the same HLL implementation in Beam.

[~robinyqiu] is there a Jira issue tracking this? And is this new 'BigQuery compatibble' sketching implementation using an open source library? or is something that will be open sourced too?

[~iemejia] The new HLL implementation will be open-sourced and once that happens I can work on its integration into Beam.

JIRA: https://issues.apache.org/jira/browse/BEAM-7013

Can I call `ApproximateDistinct.ApproximateDistinctFn` from the apache beam SQL? with DataFlow runner

 
{code:java}
events.apply(SqlTransform.query(query).registerUdaf("ApproximateDistinct", ApproximateDistinct.ApproximateDistinctFn.create(StringUtf8Coder.of()).withSparseRepresentation(16)))
{code}
 
I got an exception:
{code:java}
java.lang.ClassCastException: class sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to class java.lang.Class (sun.reflect.generics.reflectiveObjects.TypeVariableImpl and java.lang.Class are in module java.base of loader 'bootstrap'){code}

This issue is assigned but has not received an update in 30 days so it has been labeled "stale-assigned". If you are still working on the issue, please give an update and remove the label. If you are no longer working on the issue, please unassign so someone else may work on it. In 7 days the issue will be automatically unassigned.

This issue was marked "stale-assigned" and has not received a public comment in 7 days. It is now automatically unassigned. If you are still working on it, you can assign it to yourself again. Please also give an update about the status of the work.

This Jira ticket has a pull request attached to it, but is still open. Did the pull request resolve the issue? If so, could you please mark it resolved? This will help the project have a clear view of its open issues.

This issue has been migrated to https://github.com/apache/beam/issues/18488

