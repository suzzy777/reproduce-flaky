Can you upload the jar you used for this operation? Thanks!

Commit 9f338eb5113bb8b432694f57a72c792eaa806c20 in geode's branch refs/heads/feature/GEODE-4131 from [~jens.deppe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=9f338eb ]

GEODE-4131: Do not reference deployed jars as byte arrays anymore

- All jars are streamed between locators and servers using the RMIIO library.


Commit 9c5de4ada5eb45c75b6729bee57662b2c9dcfe14 in geode's branch refs/heads/feature/GEODE-4131 from [~jens.deppe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=9c5de4a ]

GEODE-4131: Do not reference deployed jars as byte arrays anymore

- All jars are streamed between locators and servers using the RMIIO library.
- Whenever an upload happens (either deploying jars or importing cluster
  config) we stage the files initially and then proceed with the command.


Commit cc6315215b70952011375d6883d7ebb8c7393189 in geode's branch refs/heads/feature/GEODE-4131 from [~jens.deppe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=cc63152 ]

GEODE-4131: Do not reference deployed jars as byte arrays anymore

- All jars are streamed between locators and servers using the RMIIO library.
- Whenever an upload happens (either deploying jars or importing cluster
  config) we stage the files initially and then proceed with the command.


Commit fefcc7a5d9586ec637ada420af6a8bbebc80cb5e in geode's branch refs/heads/feature/GEODE-4131 from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=fefcc7a ]

GEODE-4131: remove ConverterUtil


Commit 2f931ca824016d7388e0b3f246fd2e9bb5668b22 in geode's branch refs/heads/feature/GEODE-4131 from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=2f931ca ]

GEODE-4131: remove the uploaded file after the command is executed, and add more tests


Commit ebccb1451f1b2fd41cac63677d462f9c5bf5a78b in geode's branch refs/heads/feature/GEODE-4131 from [~jens.deppe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=ebccb14 ]

GEODE-4131: Always register UploaderMBean


Commit bae595a88f51510381826ac51b648e9acda434d0 in geode's branch refs/heads/feature/GEODE-4131 from [~jens.deppe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=bae595a ]

GEODE-4131: Clean up staged files


Commit e34fef8069eba8c848ce1f09bfd5faea83ecb939 in geode's branch refs/heads/feature/GEODE-4131 from [~jens.deppe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e34fef8 ]

GEODE-4131: Add permissions to FileUploaderMBean

- Corrected bean retrieval method names in MBeanServerConnectionRule


Commit aaa879b5bf14741cdb07a18893a4c6734cedf2dd in geode's branch refs/heads/feature/GEODE-4131 from [~jens.deppe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=aaa879b ]

GEODE-4131: Spotless changes


Commit cbdb834a74d775774ac091213518ecc25d9b207c in geode's branch refs/heads/feature/GEODE-4131 from [~jens.deppe]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=cbdb834 ]

GEODE-4131: Clean up deletion of staged files

- Add delete method to FileUploader bean


jinmeiliao opened a new pull request #1212: GEODE-4131: Do not reference deployed jars as byte arrays anymore
URL: https://github.com/apache/geode/pull/1212
 
 
   - All jars are streamed between locators and servers using the RMIIO library.
   - Whenever an upload happens (either deploying jars or importing cluster
     config) we stage the files initially and then proceed with the command.
   
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao closed pull request #1212: GEODE-4131: Do not reference deployed jars as byte arrays anymore
URL: https://github.com/apache/geode/pull/1212
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-assembly/build.gradle b/geode-assembly/build.gradle
index 501b27931f..2855632f2e 100755
--- a/geode-assembly/build.gradle
+++ b/geode-assembly/build.gradle
@@ -193,6 +193,7 @@ def cp = {
         it.contains('log4j-jcl') ||
         it.contains('log4j-jul') ||
         it.contains('log4j-slf4j-impl') ||
+        it.contains('rmiio') ||
         it.contains('shiro') ||
         it.contains('slf4j-api') ||
         it.contains('spring-core') ||
diff --git a/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/DeployWithLargeJarTest.java b/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/DeployWithLargeJarTest.java
new file mode 100644
index 0000000000..d683226b4e
--- /dev/null
+++ b/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/DeployWithLargeJarTest.java
@@ -0,0 +1,49 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import java.io.File;
+import java.util.Arrays;
+import java.util.stream.Collectors;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.test.junit.categories.AcceptanceTest;
+import org.apache.geode.test.junit.rules.gfsh.GfshExecution;
+import org.apache.geode.test.junit.rules.gfsh.GfshRule;
+import org.apache.geode.test.junit.rules.gfsh.GfshScript;
+
+@Category(AcceptanceTest.class)
+public class DeployWithLargeJarTest {
+
+  @Rule
+  public GfshRule gfsh = new GfshRule();
+
+  @Test
+  public void deployLargeSetOfJars() throws Exception {
+    File libDir = gfsh.getGfshPath().getParent().getParent().resolve("lib").toFile();
+    String commonLibs = Arrays
+        .stream(libDir
+            .listFiles(x -> x.getName().startsWith("commons") || x.getName().startsWith("spring")))
+        .map(File::getAbsolutePath).collect(Collectors.joining(","));
+    GfshExecution execution = GfshScript.of("start locator --name=locator --max-heap=64m",
+        "start server --name=server --max-heap=64m", "sleep --time=1",
+        "deploy --jars=" + commonLibs).execute(gfsh);
+  }
+
+}
diff --git a/geode-assembly/src/test/resources/expected_jars.txt b/geode-assembly/src/test/resources/expected_jars.txt
index bc49bcef62..51e3dd8f50 100644
--- a/geode-assembly/src/test/resources/expected_jars.txt
+++ b/geode-assembly/src/test/resources/expected_jars.txt
@@ -3,6 +3,7 @@ antlr
 aopalliance
 classmate
 commons-beanutils
+commons-codec
 commons-collections
 commons-digester
 commons-fileupload
@@ -10,7 +11,7 @@ commons-io
 commons-lang
 commons-logging
 commons-modeler
-commons-codec
+commons-validator
 fast-classpath-scanner
 fastutil
 findbugs-annotations
@@ -44,10 +45,11 @@ log4j-jcl
 log4j-jul
 log4j-slf4j-impl
 lucene-analyzers-common
+lucene-analyzers-phonetic
 lucene-core
 lucene-queries
 lucene-queryparser
-lucene-analyzers-phonetic
+mapstruct
 mx4j
 mx4j-remote
 mx4j-tools
@@ -55,6 +57,7 @@ netty-all
 paranamer
 protobuf-java
 ra.jar
+rmiio
 scala-library
 scala-reflect
 shiro-core
@@ -69,6 +72,8 @@ spring-expression
 spring-hateoas
 spring-ldap-core
 spring-oxm
+spring-plugin-core
+spring-plugin-metadata
 spring-security-config
 spring-security-core
 spring-security-ldap
@@ -77,10 +82,6 @@ spring-shell
 spring-tx
 spring-web
 spring-webmvc
-swagger-annotations
-mapstruct
-spring-plugin-core
-spring-plugin-metadata
 springfox-core
 springfox-schema
 springfox-spi
@@ -88,5 +89,5 @@ springfox-spring-web
 springfox-swagger
 springfox-swagger-common
 springfox-swagger-ui
+swagger-annotations
 swagger-models
-commons-validator
diff --git a/geode-core/build.gradle b/geode-core/build.gradle
index 041e411c69..77c02ba83d 100755
--- a/geode-core/build.gradle
+++ b/geode-core/build.gradle
@@ -132,6 +132,7 @@ dependencies {
   // https://mvnrepository.com/artifact/io.github.lukehutch/fast-classpath-scanner
   compile 'io.github.lukehutch:fast-classpath-scanner:' + project.'fast-classpath-scanner.version'
 
+  compile 'com.healthmarketscience.rmiio:rmiio:' + project.'rmiio.version'
 
   compile project(':geode-common')
   compile project(':geode-json')
diff --git a/geode-core/src/main/java/org/apache/geode/distributed/internal/ClusterConfigurationService.java b/geode-core/src/main/java/org/apache/geode/distributed/internal/ClusterConfigurationService.java
index beb6ae5ddc..726cde2abd 100644
--- a/geode-core/src/main/java/org/apache/geode/distributed/internal/ClusterConfigurationService.java
+++ b/geode-core/src/main/java/org/apache/geode/distributed/internal/ClusterConfigurationService.java
@@ -21,11 +21,18 @@
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileFilter;
+import java.io.FileOutputStream;
 import java.io.FileWriter;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.PrintWriter;
 import java.io.StringWriter;
+import java.nio.file.Files;
 import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.StandardCopyOption;
+import java.nio.file.attribute.PosixFilePermission;
+import java.nio.file.attribute.PosixFilePermissions;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -45,8 +52,11 @@
 import javax.xml.transform.TransformerException;
 import javax.xml.transform.TransformerFactoryConfigurationError;
 
+import com.healthmarketscience.rmiio.RemoteInputStream;
+import com.healthmarketscience.rmiio.RemoteInputStreamClient;
 import org.apache.commons.io.FileUtils;
 import org.apache.commons.io.FilenameUtils;
+import org.apache.commons.io.IOUtils;
 import org.apache.commons.io.filefilter.DirectoryFileFilter;
 import org.apache.commons.lang.StringUtils;
 import org.apache.logging.log4j.Logger;
@@ -78,7 +88,7 @@
 import org.apache.geode.management.internal.configuration.domain.Configuration;
 import org.apache.geode.management.internal.configuration.domain.SharedConfigurationStatus;
 import org.apache.geode.management.internal.configuration.domain.XmlEntity;
-import org.apache.geode.management.internal.configuration.functions.UploadJarFunction;
+import org.apache.geode.management.internal.configuration.functions.DownloadJarFunction;
 import org.apache.geode.management.internal.configuration.messages.ConfigurationResponse;
 import org.apache.geode.management.internal.configuration.messages.SharedConfigurationStatusResponse;
 import org.apache.geode.management.internal.configuration.utils.XmlUtils;
@@ -285,12 +295,9 @@ public void modifyXmlAndProperties(Properties properties, XmlEntity xmlEntity, S
   /**
    * Add jar information into the shared configuration and save the jars in the file system used
    * when deploying jars
-   *
-   * @return true on success
    */
-  public boolean addJarsToThisLocator(String[] jarNames, byte[][] jarBytes, String[] groups) {
+  public void addJarsToThisLocator(List<String> jarFullPaths, String[] groups) throws IOException {
     lockSharedConfiguration();
-    boolean success = true;
     try {
       if (groups == null) {
         groups = new String[] {ClusterConfigurationService.CLUSTER_CONFIG};
@@ -305,34 +312,28 @@ public boolean addJarsToThisLocator(String[] jarNames, byte[][] jarBytes, String
         }
 
         String groupDir = FilenameUtils.concat(this.configDirPath, group);
-        for (int i = 0; i < jarNames.length; i++) {
-          String filePath = FilenameUtils.concat(groupDir, jarNames[i]);
-          try {
-            File jarFile = new File(filePath);
-            FileUtils.writeByteArrayToFile(jarFile, jarBytes[i]);
-          } catch (IOException e) {
-            logger.info(e);
-          }
+        Set<String> jarNames = new HashSet<>();
+        for (String jarFullPath : jarFullPaths) {
+          File stagedJar = new File(jarFullPath);
+          jarNames.add(stagedJar.getName());
+          String filePath = FilenameUtils.concat(groupDir, stagedJar.getName());
+          File jarFile = new File(filePath);
+          FileUtils.copyFile(stagedJar, jarFile);
         }
 
         // update the record after writing the jars to the file system, since the listener
         // will need the jars on file to upload to other locators. Need to update the jars
         // using a new copy of the Configuration so that the change listener will pick up the jar
         // name changes.
-
         String memberId = cache.getMyId().getId();
 
         Configuration configurationCopy = new Configuration(configuration);
         configurationCopy.addJarNames(jarNames);
         configRegion.put(group, configurationCopy, memberId);
       }
-    } catch (Exception e) {
-      success = false;
-      logger.info(e.getMessage(), e);
     } finally {
       unlockSharedConfiguration();
     }
-    return success;
   }
 
   /**
@@ -382,23 +383,6 @@ public boolean removeJars(final String[] jarNames, String[] groups) {
     return success;
   }
 
-  /**
-   * read the jar bytes in the file system
-   * <p>
-   * used when creating cluster config response and used when uploading the jars to another locator
-   */
-  public byte[] getJarBytesFromThisLocator(String group, String jarName) throws IOException {
-    Configuration configuration = getConfiguration(group);
-
-    File jar = getPathToJarOnThisLocator(group, jarName).toFile();
-
-    if (configuration == null || !configuration.getJarNames().contains(jarName) || !jar.exists()) {
-      return null;
-    }
-
-    return FileUtils.readFileToByteArray(jar);
-  }
-
   // Only used when a locator is initially starting up
   public void downloadJarFromOtherLocators(String groupName, String jarName)
       throws IllegalStateException, IOException {
@@ -416,10 +400,7 @@ public void downloadJarFromOtherLocators(String groupName, String jarName)
           "Request to download jar " + jarName + " but no other locators are present");
     }
 
-    byte[] jarBytes = downloadJar(locators.get(0), groupName, jarName);
-
-    File jarToWrite = getPathToJarOnThisLocator(groupName, jarName).toFile();
-    FileUtils.writeByteArrayToFile(jarToWrite, jarBytes);
+    downloadJarFromLocator(groupName, jarName, locators.get(0));
   }
 
   // used in the cluster config change listener when jarnames are changed in the internal region
@@ -429,46 +410,46 @@ public void downloadJarFromLocator(String groupName, String jarName,
 
     createConfigDirIfNecessary(groupName);
 
-    byte[] jarBytes = downloadJar(sourceLocator, groupName, jarName);
-
-    if (jarBytes == null) {
-      throw new IllegalStateException("Could not download jar " + jarName + " in " + groupName
-          + " from " + sourceLocator.getName());
-    }
+    File jarFile = downloadJar(sourceLocator, groupName, jarName);
 
     File jarToWrite = getPathToJarOnThisLocator(groupName, jarName).toFile();
-    FileUtils.writeByteArrayToFile(jarToWrite, jarBytes);
+    Files.copy(jarFile.toPath(), jarToWrite.toPath(), StandardCopyOption.REPLACE_EXISTING);
   }
 
-  private byte[] downloadJar(DistributedMember locator, String groupName, String jarName) {
-    ResultCollector<byte[], List<byte[]>> rc =
-        (ResultCollector<byte[], List<byte[]>>) CliUtil.executeFunction(new UploadJarFunction(),
-            new Object[] {groupName, jarName}, Collections.singleton(locator));
-
-    List<byte[]> result = rc.getResult();
-
-    // we should only get one byte[] back in the list
-    return result.get(0);
-  }
-
-  // used when creating cluster config response
-  public Map<String, byte[]> getAllJarsFromThisLocator(Set<String> groups) throws IOException {
-    Map<String, byte[]> jarNamesToJarBytes = new HashMap<>();
-
-    for (String group : groups) {
-      Configuration groupConfig = getConfiguration(group);
-      if (groupConfig == null) {
-        break;
-      }
-
-      Set<String> jars = groupConfig.getJarNames();
-      for (String jar : jars) {
-        byte[] jarBytes = getJarBytesFromThisLocator(group, jar);
-        jarNamesToJarBytes.put(jar, jarBytes);
-      }
-    }
-
-    return jarNamesToJarBytes;
+  /**
+   * Retrieve a deployed jar from a locator. The retrieved file is staged in a temporary location.
+   *
+   * @param locator the DistributedMember
+   * @param groupName the group to use when retrieving the jar
+   * @param jarName the name of the deployed jar
+   * @return a File referencing the downloaded jar. The File is downloaded to a temporary location.
+   */
+  public File downloadJar(DistributedMember locator, String groupName, String jarName)
+      throws IOException {
+    ResultCollector<RemoteInputStream, List<RemoteInputStream>> rc =
+        (ResultCollector<RemoteInputStream, List<RemoteInputStream>>) CliUtil.executeFunction(
+            new DownloadJarFunction(), new Object[] {groupName, jarName},
+            Collections.singleton(locator));
+
+    List<RemoteInputStream> result = rc.getResult();
+    RemoteInputStream jarStream = result.get(0);
+
+    Set<PosixFilePermission> perms = new HashSet<>();
+    perms.add(PosixFilePermission.OWNER_READ);
+    perms.add(PosixFilePermission.OWNER_WRITE);
+    perms.add(PosixFilePermission.OWNER_EXECUTE);
+    Path tempDir =
+        Files.createTempDirectory("deploy-", PosixFilePermissions.asFileAttribute(perms));
+    Path tempJar = Paths.get(tempDir.toString(), jarName);
+    FileOutputStream fos = new FileOutputStream(tempJar.toString());
+    InputStream input = RemoteInputStreamClient.wrap(jarStream);
+
+    IOUtils.copy(input, fos);
+
+    fos.close();
+    input.close();
+
+    return tempJar.toFile();
   }
 
   /**
@@ -547,13 +528,11 @@ public ConfigurationResponse createConfigurationResponse(Set<String> groups) thr
         for (String group : groups) {
           Configuration configuration = getConfiguration(group);
           configResponse.addConfiguration(configuration);
+          if (configuration != null) {
+            configResponse.addJar(group, configuration.getJarNames());
+          }
         }
 
-        Map<String, byte[]> jarNamesToJarBytes = getAllJarsFromThisLocator(groups);
-        String[] jarNames = jarNamesToJarBytes.keySet().stream().toArray(String[]::new);
-        byte[][] jarBytes = jarNamesToJarBytes.values().toArray(new byte[jarNames.length][]);
-
-        configResponse.addJarsToBeDeployed(jarNames, jarBytes);
         return configResponse;
       }
     } finally {
diff --git a/geode-core/src/main/java/org/apache/geode/internal/DeployedJar.java b/geode-core/src/main/java/org/apache/geode/internal/DeployedJar.java
index a341ee3023..f48edc80ed 100644
--- a/geode-core/src/main/java/org/apache/geode/internal/DeployedJar.java
+++ b/geode-core/src/main/java/org/apache/geode/internal/DeployedJar.java
@@ -14,6 +14,7 @@
  */
 package org.apache.geode.internal;
 
+import java.io.BufferedInputStream;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -86,52 +87,44 @@ public int getVersion() {
     return JarDeployer.extractVersionFromFilename(this.file.getName());
   }
 
-  public DeployedJar(File versionedJarFile, String jarName) throws IOException {
-    this(versionedJarFile, jarName, Files.readAllBytes(versionedJarFile.toPath()));
-  }
-
   /**
    * Writes the given jarBytes to versionedJarFile
    */
-  public DeployedJar(File versionedJarFile, final String jarName, byte[] jarBytes)
-      throws FileNotFoundException {
-    Assert.assertTrue(jarBytes != null, "jarBytes cannot be null");
+  public DeployedJar(File versionedJarFile, final String jarName) {
     Assert.assertTrue(jarName != null, "jarName cannot be null");
     Assert.assertTrue(versionedJarFile != null, "versionedJarFile cannot be null");
 
     this.file = versionedJarFile;
     this.jarName = jarName;
 
-    final byte[] fileContent = getJarContent();
-    if (!Arrays.equals(fileContent, jarBytes)) {
-      throw new IllegalStateException("JAR file: " + versionedJarFile.getAbsolutePath()
-          + ", does not have the expected content.");
-    }
-
-    if (!hasValidJarContent(fileContent)) {
+    if (!hasValidJarContent(versionedJarFile)) {
       throw new IllegalArgumentException(
           "File does not contain valid JAR content: " + versionedJarFile.getAbsolutePath());
     }
 
-    if (messageDigest != null) {
-      this.md5hash = messageDigest.digest(jarBytes);
-    } else {
-      this.md5hash = null;
+    byte[] digest = null;
+    try {
+      if (messageDigest != null) {
+        digest = fileDigest(this.file);
+      }
+    } catch (IOException e) {
+      // Ignored
     }
+    this.md5hash = digest;
   }
 
   /**
    * Peek into the JAR data and make sure that it is valid JAR content.
    *
-   * @param inputStream InputStream containing data to be validated.
+   * @param jarFile Jar containing data to be validated.
    * @return True if the data has JAR content, false otherwise
    */
-  private static boolean hasValidJarContent(final InputStream inputStream) {
+  public static boolean hasValidJarContent(File jarFile) {
     JarInputStream jarInputStream = null;
     boolean valid = false;
 
     try {
-      jarInputStream = new JarInputStream(inputStream);
+      jarInputStream = new JarInputStream(new FileInputStream(jarFile));
       valid = jarInputStream.getNextJarEntry() != null;
     } catch (IOException ignore) {
       // Ignore this exception and just return false
@@ -146,16 +139,6 @@ private static boolean hasValidJarContent(final InputStream inputStream) {
     return valid;
   }
 
-  /**
-   * Peek into the JAR data and make sure that it is valid JAR content.
-   *
-   * @param jarBytes Bytes of data to be validated.
-   * @return True if the data has JAR content, false otherwise
-   */
-  static boolean hasValidJarContent(final byte[] jarBytes) {
-    return hasValidJarContent(new ByteArrayInputStream(jarBytes));
-  }
-
   /**
    * Scan the JAR file and attempt to register any function classes found.
    */
@@ -166,13 +149,19 @@ public synchronized void registerFunctions() throws ClassNotFoundException {
       logger.debug("Registering functions with DeployedJar: {}", this);
     }
 
-    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(this.getJarContent());
+    BufferedInputStream bufferedInputStream;
+    try {
+      bufferedInputStream = new BufferedInputStream(new FileInputStream(this.file));
+    } catch (Exception ex) {
+      logger.error("Unable to scan jar file for functions");
+      return;
+    }
 
     JarInputStream jarInputStream = null;
     try {
       Collection<String> functionClasses = findFunctionsInThisJar();
 
-      jarInputStream = new JarInputStream(byteArrayInputStream);
+      jarInputStream = new JarInputStream(bufferedInputStream);
       JarEntry jarEntry = jarInputStream.getNextJarEntry();
 
       while (jarEntry != null) {
@@ -259,16 +248,21 @@ protected synchronized void cleanUp(DeployedJar newVersion) {
    * Uses MD5 hashes to determine if the original byte content of this DeployedJar is the same as
    * that past in.
    *
-   * @param compareToBytes Bytes to compare the original content to
+   * @param stagedFile File to compare the original content to
    * @return True of the MD5 hash is the same o
    */
-  boolean hasSameContentAs(final byte[] compareToBytes) {
+  boolean hasSameContentAs(final File stagedFile) {
     // If the MD5 hash can't be calculated then silently return no match
     if (messageDigest == null || this.md5hash == null) {
-      return Arrays.equals(compareToBytes, getJarContent());
+      return false;
     }
 
-    byte[] compareToMd5 = messageDigest.digest(compareToBytes);
+    byte[] compareToMd5;
+    try {
+      compareToMd5 = fileDigest(stagedFile);
+    } catch (IOException ex) {
+      return false;
+    }
     if (logger.isDebugEnabled()) {
       logger.debug("For JAR file: {}, Comparing MD5 hash {} to {}", this.file.getAbsolutePath(),
           new String(this.md5hash), new String(compareToMd5));
@@ -276,6 +270,18 @@ boolean hasSameContentAs(final byte[] compareToBytes) {
     return Arrays.equals(this.md5hash, compareToMd5);
   }
 
+  private byte[] fileDigest(File file) throws IOException {
+    BufferedInputStream fis = new BufferedInputStream(new FileInputStream(file));
+    byte[] data = new byte[8192];
+
+    int read;
+    while ((read = fis.read(data)) > 0) {
+      messageDigest.update(data, 0, read);
+    }
+
+    return messageDigest.digest();
+  }
+
   /**
    * Check to see if the class implements the Function interface. If so, it will be registered with
    * FunctionService. Also, if the functions's class was originally declared in a cache.xml file
@@ -360,26 +366,6 @@ private Function newFunction(final Class<Function> clazz, final boolean errorOnN
     return null;
   }
 
-  private byte[] getJarContent() {
-    try {
-      InputStream channelInputStream = new FileInputStream(this.file);
-
-      final ByteArrayOutputStream byteOutStream = new ByteArrayOutputStream();
-      final byte[] bytes = new byte[4096];
-
-      int bytesRead;
-      while ((bytesRead = channelInputStream.read(bytes)) != -1) {
-        byteOutStream.write(bytes, 0, bytesRead);
-      }
-      channelInputStream.close();
-      return byteOutStream.toByteArray();
-    } catch (IOException e) {
-      logger.error("Error when attempting to read jar contents: ", e);
-    }
-
-    return ZERO_BYTES;
-  }
-
   /**
    * @return the unversioned name of this jar file, e.g. myJar.jar
    */
diff --git a/geode-core/src/main/java/org/apache/geode/internal/InternalDataSerializer.java b/geode-core/src/main/java/org/apache/geode/internal/InternalDataSerializer.java
index 5079c07998..c3b890b818 100644
--- a/geode-core/src/main/java/org/apache/geode/internal/InternalDataSerializer.java
+++ b/geode-core/src/main/java/org/apache/geode/internal/InternalDataSerializer.java
@@ -156,6 +156,7 @@
           + ";org.apache.shiro.*;org.apache.shiro.authz.*;org.apache.shiro.authc.*" // security
                                                                                     // services
           + ";org.apache.geode.modules.util.SessionCustomExpiry" // geode-modules
+          + ";com.healthmarketscience.rmiio.*;com.sun.proxy.*" // Jar deployment
           + ";";
 
 
diff --git a/geode-core/src/main/java/org/apache/geode/internal/JarDeployer.java b/geode-core/src/main/java/org/apache/geode/internal/JarDeployer.java
index 61650a72ca..47e11d0b57 100644
--- a/geode-core/src/main/java/org/apache/geode/internal/JarDeployer.java
+++ b/geode-core/src/main/java/org/apache/geode/internal/JarDeployer.java
@@ -18,14 +18,11 @@
 import static java.util.stream.Collectors.toList;
 import static java.util.stream.Collectors.toSet;
 
-import java.io.BufferedInputStream;
 import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
 import java.io.IOException;
-import java.io.OutputStream;
 import java.io.Serializable;
 import java.net.URL;
+import java.nio.file.Files;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -46,6 +43,7 @@
 import org.apache.commons.io.FileUtils;
 import org.apache.logging.log4j.Logger;
 
+import org.apache.geode.annotations.TestingOnly;
 import org.apache.geode.internal.logging.LogService;
 
 public class JarDeployer implements Serializable {
@@ -82,12 +80,12 @@ public File getDeployDirectory() {
    * @return the DeployedJar that was written from jarBytes, or null if those bytes matched the
    *         latest deployed version
    */
-  public DeployedJar deployWithoutRegistering(final String jarName, final byte[] jarBytes)
+  public DeployedJar deployWithoutRegistering(final String jarName, final File stagedJar)
       throws IOException {
     lock.lock();
 
     try {
-      boolean shouldDeployNewVersion = shouldDeployNewVersion(jarName, jarBytes);
+      boolean shouldDeployNewVersion = shouldDeployNewVersion(jarName, stagedJar);
       if (!shouldDeployNewVersion) {
         logger.debug("No need to deploy a new version of {}", jarName);
         return null;
@@ -96,9 +94,9 @@ public DeployedJar deployWithoutRegistering(final String jarName, final byte[] j
       verifyWritableDeployDirectory();
 
       File newVersionedJarFile = getNextVersionedJarFile(jarName);
-      writeJarBytesToFile(newVersionedJarFile, jarBytes);
+      Files.copy(stagedJar.toPath(), newVersionedJarFile.toPath());
 
-      return new DeployedJar(newVersionedJarFile, jarName, jarBytes);
+      return new DeployedJar(newVersionedJarFile, jarName);
     } finally {
       lock.unlock();
     }
@@ -151,93 +149,6 @@ protected File getNextVersionedJarFile(String unversionedJarName) {
     return new File(deployDirectory, nextVersionedJarName);
   }
 
-  /**
-   * Attempt to write the given bytes to the given file. If this VM is able to successfully write
-   * the contents to the file, or another VM writes the exact same contents, then the write is
-   * considered to be successful.
-   *
-   * @param file File of the JAR file to deploy.
-   * @param jarBytes Contents of the JAR file to deploy.
-   * @return True if the file was successfully written, false otherwise
-   */
-  private boolean writeJarBytesToFile(final File file, final byte[] jarBytes) throws IOException {
-    final boolean isDebugEnabled = logger.isDebugEnabled();
-    if (file.createNewFile()) {
-      if (isDebugEnabled) {
-        logger.debug("Successfully created new JAR file: {}", file.getAbsolutePath());
-      }
-      final OutputStream outStream = new FileOutputStream(file);
-      outStream.write(jarBytes);
-      outStream.close();
-      return true;
-    }
-    return doesFileMatchBytes(file, jarBytes);
-  }
-
-  /**
-   * Determine if the contents of the file referenced is an exact match for the bytes provided. The
-   * method first checks to see if the file is actively being written by checking the length over
-   * time. If it appears that the file is actively being written, then it loops waiting for that to
-   * complete before doing the comparison.
-   *
-   * @param file File to compare
-   * @param bytes Bytes to compare
-   * @return True if there's an exact match, false otherwise
-   * @throws IOException If there's a problem reading the file
-   */
-  private boolean doesFileMatchBytes(final File file, final byte[] bytes) throws IOException {
-    // First check to see if the file is actively being written (if it's not big enough)
-    final String absolutePath = file.getAbsolutePath();
-    boolean keepTrying = true;
-    final boolean isDebugEnabled = logger.isDebugEnabled();
-    while (file.length() < bytes.length && keepTrying) {
-      if (isDebugEnabled) {
-        logger.debug("Loop waiting for another to write file: {}", absolutePath);
-      }
-      long startingFileLength = file.length();
-      try {
-        Thread.sleep(500);
-      } catch (InterruptedException iex) {
-        // Just keep looping
-      }
-      if (startingFileLength == file.length()) {
-        if (isDebugEnabled) {
-          logger.debug("Done waiting for another to write file: {}", absolutePath);
-        }
-        // Assume the other process has finished writing
-        keepTrying = false;
-      }
-    }
-
-    // If they don't have the same number of bytes then nothing to do
-    if (file.length() != bytes.length) {
-      if (isDebugEnabled) {
-        logger.debug("Unmatching file length when waiting for another to write file: {}",
-            absolutePath);
-      }
-      return false;
-    }
-
-    // Open the file then loop comparing each byte
-    BufferedInputStream inStream = new BufferedInputStream(new FileInputStream(file));
-    int index = 0;
-    try {
-      for (; index < bytes.length; index++) {
-        if (((byte) inStream.read()) != bytes[index]) {
-          if (isDebugEnabled) {
-            logger.debug("Did not find a match when waiting for another to write file: {}",
-                absolutePath);
-          }
-          return false;
-        }
-      }
-    } finally {
-      inStream.close();
-    }
-
-    return true;
-  }
-
   /**
    * Find the version number that's embedded in the name of this file
    *
@@ -420,14 +331,8 @@ public DeployedJar findLatestValidDeployedJarFromDisk(String unversionedJarName)
       throws IOException {
     final File[] jarFiles = findSortedOldVersionsOfJar(unversionedJarName);
 
-    Optional<File> latestValidDeployedJarOptional =
-        Arrays.stream(jarFiles).filter(Objects::nonNull).filter(jarFile -> {
-          try {
-            return DeployedJar.hasValidJarContent(FileUtils.readFileToByteArray(jarFile));
-          } catch (IOException e) {
-            return false;
-          }
-        }).findFirst();
+    Optional<File> latestValidDeployedJarOptional = Arrays.stream(jarFiles).filter(Objects::nonNull)
+        .filter(jarFile -> DeployedJar.hasValidJarContent(jarFile)).findFirst();
 
     if (!latestValidDeployedJarOptional.isPresent()) {
       // No valid version of this jar
@@ -482,46 +387,43 @@ public DeployedJar findLatestValidDeployedJarFromDisk(String unversionedJarName)
   /**
    * Deploy the given JAR files.
    *
-   * @param jarNames Array of names of the JAR files to deploy.
-   * @param jarBytes Array of contents of the JAR files to deploy.
+   * @param stagedJarFiles A map of Files which have been staged in another location and are ready
+   *        to be deployed as a unit.
    * @return An array of newly created JAR class loaders. Entries will be null for an JARs that were
    *         already deployed.
    * @throws IOException When there's an error saving the JAR file to disk
    */
-  public List<DeployedJar> deploy(final String jarNames[], final byte[][] jarBytes)
+  public List<DeployedJar> deploy(final Map<String, File> stagedJarFiles)
       throws IOException, ClassNotFoundException {
-    DeployedJar[] deployedJars = new DeployedJar[jarNames.length];
+    List<DeployedJar> deployedJars = new ArrayList<>(stagedJarFiles.size());
 
-    for (int i = 0; i < jarNames.length; i++) {
-      if (!DeployedJar.hasValidJarContent(jarBytes[i])) {
+    for (File jar : stagedJarFiles.values()) {
+      if (!DeployedJar.hasValidJarContent(jar)) {
         throw new IllegalArgumentException(
-            "File does not contain valid JAR content: " + jarNames[i]);
+            "File does not contain valid JAR content: " + jar.getName());
       }
     }
 
     lock.lock();
     try {
-      for (int i = 0; i < jarNames.length; i++) {
-        String jarName = jarNames[i];
-        byte[] newJarBytes = jarBytes[i];
-
-        deployedJars[i] = deployWithoutRegistering(jarName, newJarBytes);
+      for (String fileName : stagedJarFiles.keySet()) {
+        deployedJars.add(deployWithoutRegistering(fileName, stagedJarFiles.get(fileName)));
       }
 
-      return registerNewVersions(Arrays.asList(deployedJars));
+      return registerNewVersions(deployedJars);
     } finally {
       lock.unlock();
     }
   }
 
-  private boolean shouldDeployNewVersion(String jarName, byte[] newJarBytes) throws IOException {
+  private boolean shouldDeployNewVersion(String jarName, File stagedJar) throws IOException {
     DeployedJar oldDeployedJar = this.deployedJars.get(jarName);
 
     if (oldDeployedJar == null) {
       return true;
     }
 
-    if (oldDeployedJar.hasSameContentAs(newJarBytes)) {
+    if (oldDeployedJar.hasSameContentAs(stagedJar)) {
       logger.warn("Jar is identical to the latest deployed version: {}",
           oldDeployedJar.getFileCanonicalPath());
 
@@ -536,16 +438,20 @@ private boolean shouldDeployNewVersion(String jarName, byte[] newJarBytes) throw
    *
    * @param jarName - the unversioned jar name, e.g. myJar.jar
    */
-  public DeployedJar findDeployedJar(String jarName) {
+  public DeployedJar getDeployedJar(String jarName) {
     return this.deployedJars.get(jarName);
   }
 
-  public DeployedJar deploy(final String jarName, final byte[] jarBytes)
+  @TestingOnly
+  public DeployedJar deploy(final String jarName, final File stagedJarFile)
       throws IOException, ClassNotFoundException {
     lock.lock();
 
+    Map<String, File> jarFiles = new HashMap<>();
+    jarFiles.put(jarName, stagedJarFile);
+
     try {
-      List<DeployedJar> deployedJars = deploy(new String[] {jarName}, new byte[][] {jarBytes});
+      List<DeployedJar> deployedJars = deploy(jarFiles);
       if (deployedJars == null || deployedJars.size() == 0) {
         return null;
       }
diff --git a/geode-core/src/main/java/org/apache/geode/internal/cache/ClusterConfigurationLoader.java b/geode-core/src/main/java/org/apache/geode/internal/cache/ClusterConfigurationLoader.java
index cd1a85a7d7..7716c13ca6 100644
--- a/geode-core/src/main/java/org/apache/geode/internal/cache/ClusterConfigurationLoader.java
+++ b/geode-core/src/main/java/org/apache/geode/internal/cache/ClusterConfigurationLoader.java
@@ -18,11 +18,20 @@
 import static java.util.stream.Collectors.toList;
 
 import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.UnknownHostException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.attribute.PosixFilePermission;
+import java.nio.file.attribute.PosixFilePermissions;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
@@ -31,9 +40,8 @@
 import java.util.Properties;
 import java.util.Set;
 import java.util.stream.Collectors;
-import java.util.stream.Stream;
 
-import org.apache.commons.lang.ArrayUtils;
+import com.healthmarketscience.rmiio.RemoteInputStream;
 import org.apache.commons.lang.StringUtils;
 import org.apache.logging.log4j.Logger;
 
@@ -41,6 +49,7 @@
 import org.apache.geode.cache.Cache;
 import org.apache.geode.cache.execute.FunctionService;
 import org.apache.geode.cache.execute.ResultCollector;
+import org.apache.geode.distributed.DistributedMember;
 import org.apache.geode.distributed.internal.ClusterConfigurationService;
 import org.apache.geode.distributed.internal.DistributionConfig;
 import org.apache.geode.distributed.internal.membership.InternalDistributedMember;
@@ -50,7 +59,9 @@
 import org.apache.geode.internal.JarDeployer;
 import org.apache.geode.internal.config.ClusterConfigurationNotAvailableException;
 import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.management.internal.cli.CliUtil;
 import org.apache.geode.management.internal.configuration.domain.Configuration;
+import org.apache.geode.management.internal.configuration.functions.DownloadJarFunction;
 import org.apache.geode.management.internal.configuration.functions.GetClusterConfigurationFunction;
 import org.apache.geode.management.internal.configuration.messages.ConfigurationResponse;
 
@@ -62,34 +73,36 @@
    * Deploys the jars received from shared configuration, it undeploys any other jars that were not
    * part of shared configuration
    *
-   * @param cache Cache of this member
    * @param response {@link ConfigurationResponse} received from the locators
    */
-  public void deployJarsReceivedFromClusterConfiguration(Cache cache,
-      ConfigurationResponse response) throws IOException, ClassNotFoundException {
+  public void deployJarsReceivedFromClusterConfiguration(ConfigurationResponse response)
+      throws IOException, ClassNotFoundException {
     logger.info("Requesting cluster configuration");
     if (response == null) {
       return;
     }
 
-    String[] jarFileNames = response.getJarNames();
-    byte[][] jarBytes = response.getJars();
+    List<String> jarFileNames =
+        response.getJarNames().values().stream().flatMap(Set::stream).collect(Collectors.toList());
 
-    if (jarFileNames != null && jarBytes != null) {
-      logger.info("Got response with jars: {}", Stream.of(jarFileNames).collect(joining(",")));
+    if (jarFileNames != null && !jarFileNames.isEmpty()) {
+      logger.info("Got response with jars: {}", jarFileNames.stream().collect(joining(",")));
       JarDeployer jarDeployer = ClassPathLoader.getLatest().getJarDeployer();
       jarDeployer.suspendAll();
       try {
         List<String> extraJarsOnServer =
             jarDeployer.findDeployedJars().stream().map(DeployedJar::getJarName)
-                .filter(jarName -> !ArrayUtils.contains(jarFileNames, jarName)).collect(toList());
+                .filter(jarName -> !jarFileNames.contains(jarName)).collect(toList());
 
         for (String extraJar : extraJarsOnServer) {
           logger.info("Removing jar not present in cluster configuration: {}", extraJar);
           jarDeployer.deleteAllVersionsOfJar(extraJar);
         }
 
-        List<DeployedJar> deployedJars = jarDeployer.deploy(jarFileNames, jarBytes);
+        Map<String, File> stagedJarFiles =
+            getJarsFromLocator(response.getMember(), response.getJarNames());
+
+        List<DeployedJar> deployedJars = jarDeployer.deploy(stagedJarFiles);
 
         deployedJars.stream().filter(Objects::nonNull)
             .forEach((jar) -> logger.info("Deployed: {}", jar.getFile().getAbsolutePath()));
@@ -99,6 +112,53 @@ public void deployJarsReceivedFromClusterConfiguration(Cache cache,
     }
   }
 
+  private Map<String, File> getJarsFromLocator(DistributedMember locator,
+      Map<String, Set<String>> jarNames) throws IOException {
+    Map<String, File> results = new HashMap<>();
+
+    for (String group : jarNames.keySet()) {
+      for (String jar : jarNames.get(group)) {
+        results.put(jar, downloadJar(locator, group, jar));
+      }
+    }
+
+    return results;
+  }
+
+  public File downloadJar(DistributedMember locator, String groupName, String jarName)
+      throws IOException {
+    ResultCollector<RemoteInputStream, List<RemoteInputStream>> rc =
+        (ResultCollector<RemoteInputStream, List<RemoteInputStream>>) CliUtil.executeFunction(
+            new DownloadJarFunction(), new Object[] {groupName, jarName},
+            Collections.singleton(locator));
+
+    List<RemoteInputStream> result = rc.getResult();
+    RemoteInputStream jarStream = result.get(0);
+
+    Set<PosixFilePermission> perms = new HashSet<>();
+    perms.add(PosixFilePermission.OWNER_READ);
+    perms.add(PosixFilePermission.OWNER_WRITE);
+    perms.add(PosixFilePermission.OWNER_EXECUTE);
+    Path tempDir =
+        Files.createTempDirectory("deploy-", PosixFilePermissions.asFileAttribute(perms));
+    Path tempJar = Paths.get(tempDir.toString(), jarName);
+    FileOutputStream fos = new FileOutputStream(tempJar.toString());
+
+    int packetId = 0;
+    while (true) {
+      byte[] data = jarStream.readPacket(packetId);
+      if (data == null) {
+        break;
+      }
+      fos.write(data);
+      packetId++;
+    }
+    fos.close();
+    jarStream.close(true);
+
+    return tempJar.toFile();
+  }
+
   /***
    * Apply the cache-xml cluster configuration on this member
    */
@@ -225,6 +285,7 @@ public ConfigurationResponse requestConfigurationFromLocators(String groupList,
       Object result = ((ArrayList) resultCollector.getResult()).get(0);
       if (result instanceof ConfigurationResponse) {
         response = (ConfigurationResponse) result;
+        response.setMember(locator);
         break;
       } else {
         logger.error("Received invalid result from {}: {}", locator.toString(), result);
diff --git a/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java b/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java
index de9b561684..98d92d1383 100755
--- a/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java
+++ b/geode-core/src/main/java/org/apache/geode/internal/cache/GemFireCacheImpl.java
@@ -1018,25 +1018,20 @@ private ConfigurationResponse requestSharedConfiguration() {
     }
 
     // can't simply return null if server is not using shared configuration, since we need to find
-    // out
-    // if the locator is running in secure mode or not, if yes, then we need to throw an exception
-    // if server is not using cluster config
+    // out if the locator is running in secure mode or not, if yes, then we need to throw an
+    // exception if server is not using cluster config.
 
-    Map<InternalDistributedMember, Collection<String>> scl =
+    Map<InternalDistributedMember, Collection<String>> locatorsWithClusterConfig =
         getDistributionManager().getAllHostedLocatorsWithSharedConfiguration();
 
     // If there are no locators with Shared configuration, that means the system has been started
-    // without shared configuration
-    // then do not make requests to the locators
-    if (scl.isEmpty()) {
+    // without shared configuration then do not make requests to the locators.
+    if (locatorsWithClusterConfig.isEmpty()) {
       logger.info(LocalizedMessage
           .create(LocalizedStrings.GemFireCache_NO_LOCATORS_FOUND_WITH_SHARED_CONFIGURATION));
       return null;
     }
 
-    Map<InternalDistributedMember, Collection<String>> locatorsWithClusterConfig =
-        getDistributionManager().getAllHostedLocatorsWithSharedConfiguration();
-
     try {
       ConfigurationResponse response = ccLoader.requestConfigurationFromLocators(
           this.system.getConfig().getGroups(), locatorsWithClusterConfig.keySet());
@@ -1169,7 +1164,7 @@ private void initialize() {
     ClassPathLoader.setLatestToDefault(this.system.getConfig().getDeployWorkingDir());
 
     try {
-      ccLoader.deployJarsReceivedFromClusterConfiguration(this, this.configurationResponse);
+      ccLoader.deployJarsReceivedFromClusterConfiguration(this.configurationResponse);
     } catch (IOException | ClassNotFoundException e) {
       throw new GemFireConfigException(
           LocalizedStrings.GemFireCache_EXCEPTION_OCCURRED_WHILE_DEPLOYING_JARS_FROM_SHARED_CONDFIGURATION
diff --git a/geode-core/src/main/java/org/apache/geode/management/MemberMXBean.java b/geode-core/src/main/java/org/apache/geode/management/MemberMXBean.java
index 9f89ce4ceb..68eb10586d 100644
--- a/geode-core/src/main/java/org/apache/geode/management/MemberMXBean.java
+++ b/geode-core/src/main/java/org/apache/geode/management/MemberMXBean.java
@@ -14,6 +14,7 @@
  */
 package org.apache.geode.management;
 
+import java.util.List;
 import java.util.Map;
 
 import org.apache.geode.distributed.DistributedMember;
@@ -214,11 +215,12 @@
    *
    * @param commandString Command to be execute.
    * @param env Environmental properties to use during command execution.
-   * @param binaryData Binary data specific to the command being executed.
+   * @param stagedFilePaths Local files (as relevant to the command). May be null.
    * @return Result of the execution in JSON format.
    */
   @ResourceOperation()
-  String processCommand(String commandString, Map<String, String> env, Byte[][] binaryData);
+  String processCommand(String commandString, Map<String, String> env,
+      List<String> stagedFilePaths);
 
   /**
    * Returns the name of all disk stores in use by this member.
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/ManagementAgent.java b/geode-core/src/main/java/org/apache/geode/management/internal/ManagementAgent.java
index 243458d7f1..668b0b6a65 100755
--- a/geode-core/src/main/java/org/apache/geode/management/internal/ManagementAgent.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/ManagementAgent.java
@@ -64,6 +64,7 @@
 import org.apache.geode.management.ManagementException;
 import org.apache.geode.management.ManagementService;
 import org.apache.geode.management.ManagerMXBean;
+import org.apache.geode.management.internal.beans.FileUploader;
 import org.apache.geode.management.internal.security.AccessControlMBean;
 import org.apache.geode.management.internal.security.MBeanServerWrapper;
 import org.apache.geode.management.internal.security.ResourceConstants;
@@ -491,6 +492,7 @@ public synchronized void start() throws IOException {
         controller.setMBeanServer(mbs);
       }
     }
+    registerFileUploaderMBean();
 
     jmxConnectorServer.start();
     if (logger.isDebugEnabled()) {
@@ -521,6 +523,22 @@ private void registerAccessControlMBean() {
     }
   }
 
+  private void registerFileUploaderMBean() {
+    try {
+      ObjectName mbeanON = new ObjectName(ManagementConstants.OBJECTNAME__FILEUPLOADER_MBEAN);
+      MBeanServer platformMBeanServer = ManagementFactory.getPlatformMBeanServer();
+
+      Set<ObjectName> names = platformMBeanServer.queryNames(mbeanON, null);
+      if (names.isEmpty()) {
+        platformMBeanServer.registerMBean(new FileUploader(), mbeanON);
+        logger.info("Registered FileUploaderMBean on " + mbeanON);
+      }
+    } catch (InstanceAlreadyExistsException | MBeanRegistrationException
+        | NotCompliantMBeanException | MalformedObjectNameException e) {
+      throw new GemFireConfigException("Error while configuring FileUploader MBean", e);
+    }
+  }
+
   public JMXConnectorServer getJmxConnectorServer() {
     return jmxConnectorServer;
   }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/ManagementConstants.java b/geode-core/src/main/java/org/apache/geode/management/internal/ManagementConstants.java
index 7baa784970..54a7a8051b 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/ManagementConstants.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/ManagementConstants.java
@@ -135,6 +135,9 @@
   public static final String OBJECTNAME__CACHESERVICE_MXBEAN =
       OBJECTNAME__PREFIX + "service=CacheService,name={0},type=Member,member={1}";
 
+  public static final String OBJECTNAME__FILEUPLOADER_MBEAN =
+      OBJECTNAME__PREFIX + "service=FileUploader,type=Distributed";
+
   public static final String AGGREGATE_MBEAN_PATTERN = OBJECTNAME__PREFIX + "*,type=Distributed";
   // Object Name keys
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/beans/FileUploader.java b/geode-core/src/main/java/org/apache/geode/management/internal/beans/FileUploader.java
new file mode 100644
index 0000000000..929266e5b4
--- /dev/null
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/beans/FileUploader.java
@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.beans;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.attribute.PosixFilePermission;
+import java.nio.file.attribute.PosixFilePermissions;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import com.healthmarketscience.rmiio.RemoteInputStream;
+import com.healthmarketscience.rmiio.RemoteInputStreamClient;
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.io.IOUtils;
+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.security.GemFireSecurityException;
+
+public class FileUploader implements FileUploaderMBean {
+  public static String STAGED_DIR_PREFIX = "uploaded-";
+  private static Logger logger = LogService.getLogger();
+
+  @Override
+  public List<String> uploadFile(Map<String, RemoteInputStream> remoteFiles) throws IOException {
+    List<String> stagedFiles = new ArrayList<>();
+
+    Set<PosixFilePermission> perms = new HashSet<>();
+    perms.add(PosixFilePermission.OWNER_READ);
+    perms.add(PosixFilePermission.OWNER_WRITE);
+    perms.add(PosixFilePermission.OWNER_EXECUTE);
+    Path tempDir =
+        Files.createTempDirectory(STAGED_DIR_PREFIX, PosixFilePermissions.asFileAttribute(perms));
+
+    for (String filename : remoteFiles.keySet()) {
+      File stagedFile = new File(tempDir.toString(), filename);
+      FileOutputStream fos = new FileOutputStream(stagedFile);
+
+      InputStream input = RemoteInputStreamClient.wrap(remoteFiles.get(filename));
+      IOUtils.copyLarge(input, fos);
+
+      fos.close();
+      input.close();
+
+      stagedFiles.add(stagedFile.getAbsolutePath());
+    }
+
+    return stagedFiles;
+  }
+
+  @Override
+  public void deleteFiles(List<String> files) {
+    if (files == null || files.isEmpty()) {
+      return;
+    }
+
+    Path parent = Paths.get(files.get(0)).getParent();
+    if (!parent.getFileName().toString().startsWith(STAGED_DIR_PREFIX)) {
+      throw new GemFireSecurityException(
+          String.format("Cannot delete %s, not in the uploaded directory.", files.get(0)));
+    }
+    try {
+      FileUtils.deleteDirectory(parent.toFile());
+    } catch (IOException e) {
+      logger.error(e.getMessage(), e);
+    }
+  }
+}
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/beans/FileUploaderMBean.java b/geode-core/src/main/java/org/apache/geode/management/internal/beans/FileUploaderMBean.java
new file mode 100644
index 0000000000..d504058a48
--- /dev/null
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/beans/FileUploaderMBean.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.beans;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.Map;
+
+import com.healthmarketscience.rmiio.RemoteInputStream;
+
+import org.apache.geode.management.internal.security.ResourceOperation;
+import org.apache.geode.security.ResourcePermission;
+
+@ResourceOperation(resource = ResourcePermission.Resource.CLUSTER,
+    operation = ResourcePermission.Operation.MANAGE, target = ResourcePermission.Target.DEPLOY)
+public interface FileUploaderMBean {
+
+  List<String> uploadFile(Map<String, RemoteInputStream> remoteFiles) throws IOException;
+
+  void deleteFiles(List<String> files);
+}
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/beans/MemberMBean.java b/geode-core/src/main/java/org/apache/geode/management/internal/beans/MemberMBean.java
index 19a76aa6f4..c5410512c0 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/beans/MemberMBean.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/beans/MemberMBean.java
@@ -15,11 +15,11 @@
 package org.apache.geode.management.internal.beans;
 
 import java.util.Collections;
+import java.util.List;
 import java.util.Map;
 
 import javax.management.NotificationBroadcasterSupport;
 
-import org.apache.geode.internal.util.ArrayUtils;
 import org.apache.geode.management.GemFireProperties;
 import org.apache.geode.management.JVMMetrics;
 import org.apache.geode.management.MemberMXBean;
@@ -402,8 +402,9 @@ public String processCommand(String commandString, Map<String, String> env) {
   }
 
   @Override
-  public String processCommand(String commandString, Map<String, String> env, Byte[][] binaryData) {
-    return bridge.processCommand(commandString, env, ArrayUtils.toBytes(binaryData));
+  public String processCommand(String commandString, Map<String, String> env,
+      List<String> stagedFilePaths) {
+    return bridge.processCommand(commandString, env, stagedFilePaths);
   }
 
   @Override
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/beans/MemberMBeanBridge.java b/geode-core/src/main/java/org/apache/geode/management/internal/beans/MemberMBeanBridge.java
index 26483bbeec..f0511bcb44 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/beans/MemberMBeanBridge.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/beans/MemberMBeanBridge.java
@@ -1565,16 +1565,18 @@ public float getPDXDeserializationRate() {
    *
    * @param commandString command string to be processed
    * @param env environment information to be used for processing the command
+   * @param stagedFilePaths list of local files to be deployed
    * @return result of the processing the given command string.
    */
-  public String processCommand(String commandString, Map<String, String> env, byte[][] binaryData) {
+  public String processCommand(String commandString, Map<String, String> env,
+      List<String> stagedFilePaths) {
     if (commandProcessor == null) {
       throw new JMRuntimeException(
           "Command can not be processed as Command Service did not get initialized. Reason: "
               + commandServiceInitError);
     }
 
-    Result result = commandProcessor.executeCommand(commandString, env, binaryData);
+    Result result = commandProcessor.executeCommand(commandString, env, stagedFilePaths);
     return CommandResponseBuilder.createCommandResponseJson(getMember(), (CommandResult) result);
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java
index 8ad2282797..6718fe00e2 100755
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java
@@ -537,7 +537,7 @@ public static boolean contains(Object[] array, Object object) {
   }
 
   /***
-   * Executes a function with arguments on a set of members , ignores the departed members.
+   * Executes a function with arguments on a set of members, ignoring the departed members.
    *
    * @param function Function to be executed.
    * @param args Arguments passed to the function, pass null if you wish to pass no arguments to the
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/CommandRequest.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/CommandRequest.java
index a9772e8336..7fabcc0f98 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/CommandRequest.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/CommandRequest.java
@@ -14,7 +14,9 @@
  */
 package org.apache.geode.management.internal.cli;
 
+import java.io.File;
 import java.util.Collections;
+import java.util.List;
 import java.util.Map;
 
 import org.apache.geode.annotations.TestingOnly;
@@ -30,7 +32,7 @@
  */
 @SuppressWarnings("unused")
 public class CommandRequest {
-  private final byte[][] fileData;
+  private final List<File> fileList;
   private final GfshParseResult parseResult;
   private final Map<String, String> env;
   private final boolean downloadFile;
@@ -39,24 +41,24 @@
   @TestingOnly
   public CommandRequest(final Map<String, String> env) {
     this.env = env;
-    this.fileData = null;
+    this.fileList = null;
     this.parseResult = null;
     downloadFile = false;
   }
 
-  public CommandRequest(final Map<String, String> env, final byte[][] fileData) {
+  public CommandRequest(final Map<String, String> env, final List<File> fileList) {
     this.env = env;
-    this.fileData = fileData;
+    this.fileList = fileList;
     this.parseResult = null;
     downloadFile = false;
   }
 
   public CommandRequest(final GfshParseResult parseResult, final Map<String, String> env,
-      final byte[][] fileData) {
+      final List<File> fileList) {
     assert parseResult != null : "The Gfsh ParseResult cannot be null!";
     assert env != null : "The reference to the Gfsh CLI environment cannot be null!";
     this.env = env;
-    this.fileData = fileData;
+    this.fileList = fileList;
     this.parseResult = parseResult;
 
     CliMetaData metaData = parseResult.getMethod().getDeclaredAnnotation(CliMetaData.class);
@@ -73,12 +75,12 @@ public boolean isDownloadFile() {
     return Collections.unmodifiableMap(env);
   }
 
-  public byte[][] getFileData() {
-    return fileData;
+  public List<File> getFileList() {
+    return fileList;
   }
 
-  public boolean hasFileData() {
-    return (getFileData() != null);
+  public boolean hasFileList() {
+    return (getFileList() != null);
   }
 
   protected GfshParseResult getParseResult() {
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DeployCommand.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DeployCommand.java
index 5ee16facb0..46f8502fd5 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DeployCommand.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/DeployCommand.java
@@ -17,13 +17,17 @@
 
 import static org.apache.commons.io.FileUtils.ONE_MB;
 
-import java.io.FileNotFoundException;
+import java.io.File;
+import java.io.FileInputStream;
 import java.io.IOException;
 import java.text.DecimalFormat;
-import java.util.Arrays;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 
+import com.healthmarketscience.rmiio.RemoteInputStream;
+import com.healthmarketscience.rmiio.SimpleRemoteInputStream;
+import org.apache.commons.io.FilenameUtils;
 import org.apache.commons.lang.ArrayUtils;
 import org.apache.commons.lang.StringUtils;
 import org.springframework.shell.core.annotation.CliCommand;
@@ -31,6 +35,7 @@
 
 import org.apache.geode.cache.execute.ResultCollector;
 import org.apache.geode.distributed.DistributedMember;
+import org.apache.geode.distributed.internal.ClusterConfigurationService;
 import org.apache.geode.management.cli.CliMetaData;
 import org.apache.geode.management.cli.ConverterHint;
 import org.apache.geode.management.cli.Result;
@@ -69,48 +74,69 @@ public Result deploy(
           optionContext = ConverterHint.MEMBERGROUP) String[] groups,
       @CliOption(key = {CliStrings.JAR, CliStrings.JARS},
           help = CliStrings.DEPLOY__JAR__HELP) String[] jars,
-      @CliOption(key = {CliStrings.DEPLOY__DIR}, help = CliStrings.DEPLOY__DIR__HELP) String dir) {
+      @CliOption(key = {CliStrings.DEPLOY__DIR}, help = CliStrings.DEPLOY__DIR__HELP) String dir)
+      throws IOException {
 
     TabularResultData tabularData = ResultBuilder.createTabularResultData();
 
-    byte[][] shellBytesData = CommandExecutionContext.getBytesFromShell();
-    String[] jarNames = CliUtil.bytesToNames(shellBytesData);
-    byte[][] jarBytes = CliUtil.bytesToData(shellBytesData);
+    List<String> jarFullPaths = CommandExecutionContext.getFilePathFromShell();
 
     Set<DistributedMember> targetMembers;
-
     targetMembers = CliUtil.findMembers(groups, null);
 
-    if (targetMembers.size() > 0) {
+    List results = new ArrayList();
+    for (DistributedMember member : targetMembers) {
+      List<RemoteInputStream> remoteStreams = new ArrayList<>();
+      List<String> jarNames = new ArrayList<>();
+      for (String jarFullPath : jarFullPaths) {
+        remoteStreams.add(new SimpleRemoteInputStream(new FileInputStream(jarFullPath)).export());
+        jarNames.add(FilenameUtils.getName(jarFullPath));
+      }
+
       // this deploys the jars to all the matching servers
-      ResultCollector<?, ?> resultCollector = CliUtil.executeFunction(this.deployFunction,
-          new Object[] {jarNames, jarBytes}, targetMembers);
+      ResultCollector<?, ?> resultCollector =
+          executeFunction(this.deployFunction, new Object[] {jarNames, remoteStreams}, member);
 
-      List<CliFunctionResult> results =
-          CliFunctionResult.cleanResults((List<?>) resultCollector.getResult());
+      results.add(((List) resultCollector.getResult()).get(0));
+
+      for (RemoteInputStream ris : remoteStreams) {
+        try {
+          ris.close(true);
+        } catch (IOException ex) {
+          // Ignored. the stream may have already been closed.
+        }
+      }
+    }
 
-      for (CliFunctionResult result : results) {
-        if (result.getThrowable() != null) {
+    List<CliFunctionResult> cleanedResults = CliFunctionResult.cleanResults(results);
+
+    for (CliFunctionResult result : cleanedResults) {
+      if (result.getThrowable() != null) {
+        tabularData.accumulate("Member", result.getMemberIdOrName());
+        tabularData.accumulate("Deployed JAR", "");
+        tabularData.accumulate("Deployed JAR Location",
+            "ERROR: " + result.getThrowable().getClass().getName() + ": "
+                + result.getThrowable().getMessage());
+        tabularData.setStatus(Result.Status.ERROR);
+      } else {
+        String[] strings = (String[]) result.getSerializables();
+        for (int i = 0; i < strings.length; i += 2) {
           tabularData.accumulate("Member", result.getMemberIdOrName());
-          tabularData.accumulate("Deployed JAR", "");
-          tabularData.accumulate("Deployed JAR Location",
-              "ERROR: " + result.getThrowable().getClass().getName() + ": "
-                  + result.getThrowable().getMessage());
-          tabularData.setStatus(Result.Status.ERROR);
-        } else {
-          String[] strings = (String[]) result.getSerializables();
-          for (int i = 0; i < strings.length; i += 2) {
-            tabularData.accumulate("Member", result.getMemberIdOrName());
-            tabularData.accumulate("Deployed JAR", strings[i]);
-            tabularData.accumulate("Deployed JAR Location", strings[i + 1]);
-          }
+          tabularData.accumulate("Deployed JAR", strings[i]);
+          tabularData.accumulate("Deployed JAR Location", strings[i + 1]);
         }
       }
     }
 
     Result result = ResultBuilder.buildResult(tabularData);
-    persistClusterConfiguration(result,
-        () -> getSharedConfiguration().addJarsToThisLocator(jarNames, jarBytes, groups));
+    ClusterConfigurationService sc = getSharedConfiguration();
+    if (sc == null) {
+      result.setCommandPersisted(false);
+    } else {
+      sc.addJarsToThisLocator(jarFullPaths, groups);
+      result.setCommandPersisted(true);
+    }
+
     return result;
   }
 
@@ -122,10 +148,8 @@ public Result deploy(
 
     @Override
     public Result preExecution(GfshParseResult parseResult) {
-      // 2nd argument is the jar
-      String[] jars = (String[]) parseResult.getArguments()[1];
-      // 3rd argument is the dir
-      String dir = (String) parseResult.getArguments()[2];
+      String[] jars = (String[]) parseResult.getParamValue("jar");
+      String dir = (String) parseResult.getParamValue("dir");
 
       if (ArrayUtils.isEmpty(jars) && StringUtils.isBlank(dir)) {
         return ResultBuilder.createUserErrorResult(
@@ -137,34 +161,37 @@ public Result preExecution(GfshParseResult parseResult) {
             .createUserErrorResult("Parameters \"jar\" and \"dir\" can not both be specified.");
       }
 
-      FileResult fileResult;
-      String[] filesToUpload = jars;
-      if (filesToUpload == null) {
-        filesToUpload = new String[] {dir};
-      }
-      try {
-
-        fileResult = new FileResult(filesToUpload);
-      } catch (FileNotFoundException fnfex) {
-        return ResultBuilder
-            .createGemFireErrorResult("'" + Arrays.toString(filesToUpload) + "' not found.");
-      } catch (IOException ioex) {
-        return ResultBuilder.createGemFireErrorResult("I/O error when reading jar/dir: "
-            + ioex.getClass().getName() + ": " + ioex.getMessage());
+      FileResult fileResult = new FileResult();
+      if (jars != null) {
+        for (String jar : jars) {
+          File jarFile = new File(jar);
+          if (!jarFile.exists()) {
+            return ResultBuilder.createUserErrorResult(jar + " not found.");
+          }
+          fileResult.addFile(jarFile);
+        }
+      } else {
+        File fileDir = new File(dir);
+        if (!fileDir.isDirectory()) {
+          return ResultBuilder.createUserErrorResult(dir + " is not a directory");
+        }
+        File[] childJarFile = fileDir.listFiles(CliUtil.JAR_FILE_FILTER);
+        for (File file : childJarFile) {
+          fileResult.addFile(file);
+        }
       }
 
-      // Only do this additional check if a dir was provided
-      if (dir != null) {
-        String message =
-            "\nDeploying files: " + fileResult.getFormattedFileList() + "\nTotal file size is: "
-                + this.numFormatter.format((double) fileResult.computeFileSizeTotal() / ONE_MB)
-                + "MB\n\nContinue? ";
+      // check if user wants to upload with the computed file size
+      String message =
+          "\nDeploying files: " + fileResult.getFormattedFileList() + "\nTotal file size is: "
+              + this.numFormatter.format((double) fileResult.computeFileSizeTotal() / ONE_MB)
+              + "MB\n\nContinue? ";
 
-        if (readYesNo(message, Response.YES) == Response.NO) {
-          return ResultBuilder.createShellClientAbortOperationResult(
-              "Aborted deploy of " + Arrays.toString(filesToUpload) + ".");
-        }
+      if (readYesNo(message, Response.YES) == Response.NO) {
+        return ResultBuilder.createShellClientAbortOperationResult(
+            "Aborted deploy of " + fileResult.getFormattedFileList() + ".");
       }
+
       return fileResult;
     }
   }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportImportClusterConfigurationCommands.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportImportClusterConfigurationCommands.java
index e85c1aed36..b5690e38fa 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportImportClusterConfigurationCommands.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/commands/ExportImportClusterConfigurationCommands.java
@@ -18,7 +18,6 @@
 import static java.util.stream.Collectors.toSet;
 
 import java.io.File;
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.nio.file.Files;
 import java.nio.file.Path;
@@ -26,11 +25,15 @@
 import java.util.List;
 import java.util.Set;
 
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.TransformerException;
+
 import org.apache.commons.io.FileUtils;
 import org.apache.commons.lang.StringUtils;
 import org.apache.logging.log4j.Logger;
 import org.springframework.shell.core.annotation.CliCommand;
 import org.springframework.shell.core.annotation.CliOption;
+import org.xml.sax.SAXException;
 
 import org.apache.geode.cache.execute.ResultCollector;
 import org.apache.geode.distributed.DistributedMember;
@@ -127,8 +130,10 @@ public Result exportSharedConfig(@CliOption(key = {CliStrings.EXPORT_SHARED_CONF
       isFileUploaded = true, relatedTopic = {CliStrings.TOPIC_GEODE_CONFIG})
   @ResourceOperation(resource = Resource.CLUSTER, operation = Operation.MANAGE)
   @SuppressWarnings("unchecked")
-  public Result importSharedConfig(@CliOption(key = {CliStrings.IMPORT_SHARED_CONFIG__ZIP},
-      mandatory = true, help = CliStrings.IMPORT_SHARED_CONFIG__ZIP__HELP) String zip) {
+  public Result importSharedConfig(
+      @CliOption(key = {CliStrings.IMPORT_SHARED_CONFIG__ZIP}, mandatory = true,
+          help = CliStrings.IMPORT_SHARED_CONFIG__ZIP__HELP) String zip)
+      throws IOException, TransformerException, SAXException, ParserConfigurationException {
 
     InternalLocator locator = InternalLocator.getLocator();
 
@@ -151,41 +156,25 @@ public Result importSharedConfig(@CliOption(key = {CliStrings.IMPORT_SHARED_CONF
               + regionsWithData.stream().collect(joining(",")));
     }
 
-    byte[][] shellBytesData = CommandExecutionContext.getBytesFromShell();
-    String zipFileName = CliUtil.bytesToNames(shellBytesData)[0];
-    byte[] zipBytes = CliUtil.bytesToData(shellBytesData)[0];
+    List<String> filePathFromShell = CommandExecutionContext.getFilePathFromShell();
 
     Result result;
     InfoResultData infoData = ResultBuilder.createInfoResultData();
-    File zipFile = new File(zipFileName);
-    try {
-      ClusterConfigurationService sc = locator.getSharedConfiguration();
+    String zipFilePath = filePathFromShell.get(0);
 
-      // backup the old config
-      for (Configuration config : sc.getConfigurationRegion().values()) {
-        sc.writeConfigToFile(config);
-      }
-      sc.renameExistingSharedConfigDirectory();
+    ClusterConfigurationService sc = locator.getSharedConfiguration();
 
-      FileUtils.writeByteArrayToFile(zipFile, zipBytes);
-      ZipUtils.unzip(zipFileName, sc.getSharedConfigurationDirPath());
+    // backup the old config
+    for (Configuration config : sc.getConfigurationRegion().values()) {
+      sc.writeConfigToFile(config);
+    }
+    sc.renameExistingSharedConfigDirectory();
 
-      // load it from the disk
-      sc.loadSharedConfigurationFromDisk();
-      infoData.addLine(CliStrings.IMPORT_SHARED_CONFIG__SUCCESS__MSG);
+    ZipUtils.unzip(zipFilePath, sc.getSharedConfigurationDirPath());
 
-    } catch (Exception e) {
-      ErrorResultData errorData = ResultBuilder.createErrorResultData();
-      errorData.addLine("Import failed");
-      if (Gfsh.getCurrentInstance() != null) {
-        Gfsh.getCurrentInstance().logSevere(e.getMessage(), e);
-      }
-      result = ResultBuilder.buildResult(errorData);
-      // if import is unsuccessful, don't need to bounce the server.
-      return result;
-    } finally {
-      FileUtils.deleteQuietly(zipFile);
-    }
+    // load it from the disk
+    sc.loadSharedConfigurationFromDisk();
+    infoData.addLine(CliStrings.IMPORT_SHARED_CONFIG__SUCCESS__MSG);
 
     // Bounce the cache of each member
     Set<CliFunctionResult> functionResults =
@@ -270,17 +259,15 @@ public Result preExecution(GfshParseResult parseResult) {
             CliStrings.format(CliStrings.INVALID_FILE_EXTENSION, CliStrings.ZIP_FILE_EXTENSION));
       }
 
-      FileResult fileResult;
+      FileResult fileResult = new FileResult();
 
-      try {
-        fileResult = new FileResult(new String[] {zip});
-      } catch (FileNotFoundException fnfex) {
-        return ResultBuilder.createUserErrorResult("'" + zip + "' not found.");
-      } catch (IOException ioex) {
-        return ResultBuilder
-            .createGemFireErrorResult(ioex.getClass().getName() + ": " + ioex.getMessage());
+      File zipFile = new File(zip);
+      if (!zipFile.exists()) {
+        return ResultBuilder.createUserErrorResult(zip + " not found");
       }
 
+      fileResult.addFile(zipFile);
+
       return fileResult;
     }
   }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/CliFunctionResult.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/CliFunctionResult.java
index fb36a7c220..bc360bb027 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/CliFunctionResult.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/CliFunctionResult.java
@@ -51,13 +51,6 @@ public CliFunctionResult(final String memberIdOrName, final Serializable[] seria
     this.successful = true;
   }
 
-  public CliFunctionResult(final String memberIdOrName, final byte[] byteData,
-      final Serializable[] serializables) {
-    this.byteData = byteData;
-    this.serializables = serializables;
-    this.successful = true;
-  }
-
   public CliFunctionResult(final String memberIdOrName, final XmlEntity xmlEntity) {
     this.memberIdOrName = memberIdOrName;
     this.xmlEntity = xmlEntity;
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/DeployFunction.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/DeployFunction.java
index c9ef06a818..dd82a8fdde 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/DeployFunction.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/functions/DeployFunction.java
@@ -14,9 +14,26 @@
  */
 package org.apache.geode.management.internal.cli.functions;
 
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.attribute.PosixFilePermission;
+import java.nio.file.attribute.PosixFilePermissions;
 import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
+import com.healthmarketscience.rmiio.RemoteInputStream;
+import com.healthmarketscience.rmiio.RemoteInputStreamClient;
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.Logger;
 
 import org.apache.geode.SystemFailure;
@@ -41,13 +58,14 @@
   public void execute(FunctionContext context) {
     // Declared here so that it's available when returning a Throwable
     String memberId = "";
+    File stagingDir = null;
 
     try {
       final Object[] args = (Object[]) context.getArguments();
-      final String[] jarFilenames = (String[]) args[0];
-      final byte[][] jarBytes = (byte[][]) args[1];
-      InternalCache cache = (InternalCache) context.getCache();
+      final List<String> jarFilenames = (List<String>) args[0];
+      final List<RemoteInputStream> jarStreams = (List<RemoteInputStream>) args[1];
 
+      InternalCache cache = (InternalCache) context.getCache();
       DistributedMember member = cache.getDistributedSystem().getDistributedMember();
 
       memberId = member.getId();
@@ -56,11 +74,16 @@ public void execute(FunctionContext context) {
         memberId = member.getName();
       }
 
-      List<String> deployedList = new ArrayList<String>();
+      Map<String, File> stagedFiles;
+
+      stagedFiles = stageJarContent(jarFilenames, jarStreams);
+      stagingDir = stagedFiles.values().stream().findFirst().get().getParentFile();
+
+      List<String> deployedList = new ArrayList<>();
       List<DeployedJar> jarClassLoaders =
-          ClassPathLoader.getLatest().getJarDeployer().deploy(jarFilenames, jarBytes);
-      for (int i = 0; i < jarFilenames.length; i++) {
-        deployedList.add(jarFilenames[i]);
+          ClassPathLoader.getLatest().getJarDeployer().deploy(stagedFiles);
+      for (int i = 0; i < jarFilenames.size(); i++) {
+        deployedList.add(jarFilenames.get(i));
         if (jarClassLoaders.get(i) != null) {
           deployedList.add(jarClassLoaders.get(i).getFileCanonicalPath());
         } else {
@@ -72,6 +95,10 @@ public void execute(FunctionContext context) {
           new CliFunctionResult(memberId, deployedList.toArray(new String[0]));
       context.getResultSender().lastResult(result);
 
+    } catch (IOException ex) {
+      CliFunctionResult result =
+          new CliFunctionResult(memberId, ex, "error staging jars for deployment");
+      context.getResultSender().lastResult(result);
     } catch (CacheClosedException cce) {
       CliFunctionResult result = new CliFunctionResult(memberId, false, null);
       context.getResultSender().lastResult(result);
@@ -86,6 +113,8 @@ public void execute(FunctionContext context) {
 
       CliFunctionResult result = new CliFunctionResult(memberId, th, null);
       context.getResultSender().lastResult(result);
+    } finally {
+      deleteStagingDir(stagingDir);
     }
   }
 
@@ -108,4 +137,55 @@ public boolean optimizeForWrite() {
   public boolean isHA() {
     return false;
   }
+
+  private void deleteStagingDir(File stagingDir) {
+    if (stagingDir == null) {
+      return;
+    }
+
+    try {
+      FileUtils.deleteDirectory(stagingDir);
+    } catch (IOException iox) {
+      logger.error("Unable to delete staging directory: {}", iox.getMessage());
+    }
+  }
+
+  private Map<String, File> stageJarContent(List<String> jarNames,
+      List<RemoteInputStream> jarStreams) throws IOException {
+    Map<String, File> stagedJars = new HashMap<>();
+
+    try {
+      Set<PosixFilePermission> perms = new HashSet<>();
+      perms.add(PosixFilePermission.OWNER_READ);
+      perms.add(PosixFilePermission.OWNER_WRITE);
+      perms.add(PosixFilePermission.OWNER_EXECUTE);
+      Path tempDir =
+          Files.createTempDirectory("deploy-", PosixFilePermissions.asFileAttribute(perms));
+
+      for (int i = 0; i < jarNames.size(); i++) {
+        Path tempJar = Paths.get(tempDir.toString(), jarNames.get(i));
+        FileOutputStream fos = new FileOutputStream(tempJar.toString());
+
+        InputStream input = RemoteInputStreamClient.wrap(jarStreams.get(i));
+
+        IOUtils.copyLarge(input, fos);
+
+        fos.close();
+        input.close();
+
+        stagedJars.put(jarNames.get(i), tempJar.toFile());
+      }
+    } catch (IOException iox) {
+      for (int i = 0; i < jarStreams.size(); i++) {
+        try {
+          jarStreams.get(i).close(true);
+        } catch (IOException ex) {
+          // Ignored
+        }
+      }
+      throw iox;
+    }
+
+    return stagedJars;
+  }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/CommandExecutionContext.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/CommandExecutionContext.java
index 41456f453a..7d32defd79 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/CommandExecutionContext.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/CommandExecutionContext.java
@@ -15,6 +15,7 @@
 package org.apache.geode.management.internal.cli.remote;
 
 import java.util.Collections;
+import java.util.List;
 import java.util.Map;
 
 import org.apache.geode.management.internal.cli.CommandResponseWriter;
@@ -29,7 +30,7 @@
   // ThreadLocal variables that can be uses by commands
   private static final ThreadLocal<Map<String, String>> ENV = new ThreadLocal<>();
   private static final ThreadLocal<Boolean> FROM_SHELL = new ThreadLocal<>();
-  private static final ThreadLocal<byte[][]> SHELL_BYTES_DATA = new ThreadLocal<>();
+  private static final ThreadLocal<List<String>> SHELL_FILEPATH = new ThreadLocal<>();
 
   private static final WrapperThreadLocal<CommandResponseWriter> WRITER_WRAPPER =
       new WrapperThreadLocal<CommandResponseWriter>() {
@@ -74,12 +75,12 @@ public static void setShellEnv(Map<String, String> env) {
     ENV.set(env);
   }
 
-  public static byte[][] getBytesFromShell() {
-    return SHELL_BYTES_DATA.get();
+  public static List<String> getFilePathFromShell() {
+    return SHELL_FILEPATH.get();
   }
 
-  public static void setBytesFromShell(byte[][] data) {
-    SHELL_BYTES_DATA.set(data);
+  public static void setFilePathToShell(List<String> data) {
+    SHELL_FILEPATH.set(data);
   }
 
   public static boolean isShellRequest() {
@@ -110,7 +111,7 @@ public static void clear() {
     ENV.set(null);
 
     FROM_SHELL.set(false);
-    SHELL_BYTES_DATA.set(null);
+    SHELL_FILEPATH.set(null);
     WRITER_WRAPPER.set(null);
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/OnlineCommandProcessor.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/OnlineCommandProcessor.java
index 7fa4acba51..4fc563adf6 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/OnlineCommandProcessor.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/remote/OnlineCommandProcessor.java
@@ -17,6 +17,7 @@
 import java.io.IOException;
 import java.lang.reflect.Method;
 import java.util.Collections;
+import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 
@@ -95,7 +96,8 @@ public Result executeCommand(String command, Map<String, String> env) {
     return executeCommand(command, env, null);
   }
 
-  public Result executeCommand(String command, Map<String, String> env, byte[][] binaryData) {
+  public Result executeCommand(String command, Map<String, String> env,
+      List<String> stagedFilePaths) {
     CommentSkipHelper commentSkipper = new CommentSkipHelper();
     String commentLessLine = commentSkipper.skipComments(command);
     if (StringUtils.isEmpty(commentLessLine)) {
@@ -103,7 +105,7 @@ public Result executeCommand(String command, Map<String, String> env, byte[][] b
     }
 
     CommandExecutionContext.setShellEnv(env);
-    CommandExecutionContext.setBytesFromShell(binaryData);
+    CommandExecutionContext.setFilePathToShell(stagedFilePaths);
 
     final CommandExecutor commandExecutor = getCommandExecutor();
     ParseResult parseResult = parseCommand(commentLessLine);
@@ -123,7 +125,7 @@ public Result executeCommand(String command, Map<String, String> env, byte[][] b
 
     // this command processor does not exeucte command that needs fileData passed from client
     CliMetaData metaData = method.getAnnotation(CliMetaData.class);
-    if (metaData != null && metaData.isFileUploaded() && binaryData == null) {
+    if (metaData != null && metaData.isFileUploaded() && stagedFilePaths == null) {
       return ResultBuilder
           .createUserErrorResult(command + " can not be executed only from server side");
     }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/result/FileResult.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/result/FileResult.java
index 8d3ffacfb6..3d5db9bc9b 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/result/FileResult.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/result/FileResult.java
@@ -14,11 +14,13 @@
  */
 package org.apache.geode.management.internal.cli.result;
 
-import java.io.FileNotFoundException;
+import java.io.File;
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
 
 import org.apache.geode.management.cli.Result;
-import org.apache.geode.management.internal.cli.CliUtil;
 
 /**
  *
@@ -26,21 +28,15 @@
  * @since GemFire 7.0
  */
 public class FileResult implements Result {
-  private String[] filePaths;
-  private int fileIndex;
-  private Status status = Status.ERROR;
-  private byte[][] localFileData = null;
-  private boolean failedToPersist = false;
+  private List<File> files = new ArrayList<>();
 
-  public FileResult(String[] filePathsToRead) throws FileNotFoundException, IOException {
-    this.filePaths = filePathsToRead;
-    this.localFileData = CliUtil.filesToBytes(filePathsToRead);
-    this.status = Status.OK;
+  public void addFile(File file) {
+    files.add(file);
   }
 
   @Override
   public Status getStatus() {
-    return status;
+    return Status.OK;
   }
 
   @Override
@@ -48,16 +44,16 @@ public void resetToFirstLine() {}
 
   @Override
   public boolean hasNextLine() {
-    return fileIndex < filePaths.length;
+    return false;
   }
 
   @Override
   public String nextLine() {
-    return filePaths[fileIndex++];
+    return "";
   }
 
-  public byte[][] toBytes() {
-    return localFileData;
+  public List<File> getFiles() {
+    return files;
   }
 
   /**
@@ -67,8 +63,8 @@ public String nextLine() {
    */
   public long computeFileSizeTotal() {
     long byteCount = 0;
-    for (int i = 1; i < this.localFileData.length; i += 2) {
-      byteCount += localFileData[i].length;
+    for (File file : files) {
+      byteCount += file.length();
     }
     return byteCount;
   }
@@ -79,14 +75,7 @@ public long computeFileSizeTotal() {
    * @return Comma separated list of files.
    */
   public String getFormattedFileList() {
-    StringBuffer formattedFileList = new StringBuffer();
-    for (int i = 0; i < this.localFileData.length; i += 2) {
-      formattedFileList.append(new String(this.localFileData[i]));
-      if (i < this.localFileData.length - 2) {
-        formattedFileList.append(", ");
-      }
-    }
-    return formattedFileList.toString();
+    return files.stream().map(File::getName).collect(Collectors.joining(", "));
   }
 
   @Override
@@ -97,17 +86,16 @@ public boolean hasIncomingFiles() {
   @Override
   public void saveIncomingFiles(String directory)
       throws UnsupportedOperationException, IOException {
-    // dump file data if any
-    CliUtil.bytesToFiles(localFileData, directory, true);
+    throw new UnsupportedOperationException("not supported");
   }
 
   @Override
   public boolean failedToPersist() {
-    return this.failedToPersist;
+    return false;
   }
 
   @Override
   public void setCommandPersisted(boolean commandPersisted) {
-    this.failedToPersist = !commandPersisted;
+    throw new UnsupportedOperationException("not supported");
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/shell/GfshExecutionStrategy.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/shell/GfshExecutionStrategy.java
index 592c389664..62b9c3188a 100755
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/shell/GfshExecutionStrategy.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/shell/GfshExecutionStrategy.java
@@ -14,8 +14,10 @@
  */
 package org.apache.geode.management.internal.cli.shell;
 
+import java.io.File;
 import java.lang.reflect.Method;
 import java.nio.file.Path;
+import java.util.List;
 import java.util.Map;
 
 import org.apache.commons.lang.StringUtils;
@@ -148,7 +150,7 @@ private Result executeOnRemote(GfshParseResult parseResult) {
       return null;
     }
 
-    byte[][] fileData = null;
+    List<File> fileData = null;
     CliAroundInterceptor interceptor = null;
 
     String interceptorClass = getInterceptor(parseResult.getMethod());
@@ -174,7 +176,7 @@ private Result executeOnRemote(GfshParseResult parseResult) {
       // when the preExecution yields a FileResult, we will get the fileData out of it
       if (preExecResult instanceof FileResult) {
         FileResult fileResult = (FileResult) preExecResult;
-        fileData = fileResult.toBytes();
+        fileData = fileResult.getFiles();
       }
     }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/shell/JmxOperationInvoker.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/shell/JmxOperationInvoker.java
index 6c0b30484e..1ce9339e18 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/shell/JmxOperationInvoker.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/shell/JmxOperationInvoker.java
@@ -14,10 +14,13 @@
  */
 package org.apache.geode.management.internal.cli.shell;
 
+import java.io.File;
+import java.io.FileInputStream;
 import java.io.IOException;
 import java.text.MessageFormat;
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
@@ -41,14 +44,17 @@
 import javax.management.remote.JMXServiceURL;
 import javax.rmi.ssl.SslRMIClientSocketFactory;
 
+import com.healthmarketscience.rmiio.RemoteInputStream;
+import com.healthmarketscience.rmiio.SimpleRemoteInputStream;
+
 import org.apache.geode.internal.admin.SSLConfig;
 import org.apache.geode.internal.net.SSLConfigurationFactory;
 import org.apache.geode.internal.security.SecurableCommunicationChannel;
-import org.apache.geode.internal.util.ArrayUtils;
 import org.apache.geode.management.DistributedSystemMXBean;
 import org.apache.geode.management.MemberMXBean;
 import org.apache.geode.management.internal.MBeanJMXAdapter;
 import org.apache.geode.management.internal.ManagementConstants;
+import org.apache.geode.management.internal.beans.FileUploaderMBean;
 import org.apache.geode.management.internal.cli.CommandRequest;
 import org.apache.geode.management.internal.cli.LogWrapper;
 
@@ -80,6 +86,7 @@
   // MBean Proxies
   private DistributedSystemMXBean distributedSystemMXBeanProxy;
   private MemberMXBean memberMXBeanProxy;
+  private FileUploaderMBean fileUploadMBeanProxy;
 
   private ObjectName managerMemberObjectName;
 
@@ -159,6 +166,9 @@ public JmxOperationInvoker(final String host, final int port, Properties gfPrope
         } else {
           this.memberMXBeanProxy =
               JMX.newMXBeanProxy(mbsc, managerMemberObjectName, MemberMXBean.class);
+          this.fileUploadMBeanProxy = JMX.newMBeanProxy(mbsc,
+              new ObjectName(ManagementConstants.OBJECTNAME__FILEUPLOADER_MBEAN),
+              FileUploaderMBean.class);
         }
       }
 
@@ -245,13 +255,33 @@ protected Object invoke(ObjectName resource, String operationName, Object[] para
   }
 
   @Override
-  public Object processCommand(final CommandRequest commandRequest) throws JMXInvocationException {
-    Byte[][] binaryData = null;
-    if (commandRequest.hasFileData()) {
-      binaryData = ArrayUtils.toByteArray(commandRequest.getFileData());
+  public Object processCommand(final CommandRequest commandRequest) {
+    // upload the files first
+
+    List<String> stagedFilePaths = null;
+    try {
+      if (commandRequest.hasFileList()) {
+        Map<String, RemoteInputStream> remoteFiles = new HashMap<>();
+
+        for (File file : commandRequest.getFileList()) {
+          RemoteInputStream ris = new SimpleRemoteInputStream(new FileInputStream(file)).export();
+          remoteFiles.put(file.getName(), ris);
+        }
+
+        stagedFilePaths = fileUploadMBeanProxy.uploadFile(remoteFiles);
+      }
+    } catch (IOException e) {
+      throw new JMXInvocationException("Unable to upload file", e);
+    }
+
+    try {
+      return memberMXBeanProxy.processCommand(commandRequest.getUserInput(),
+          commandRequest.getEnvironment(), stagedFilePaths);
+    } finally {
+      if (stagedFilePaths != null) {
+        fileUploadMBeanProxy.deleteFiles(stagedFilePaths);
+      }
     }
-    return memberMXBeanProxy.processCommand(commandRequest.getUserInput(),
-        commandRequest.getEnvironment(), binaryData);
   }
 
   @Override
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/configuration/functions/UploadJarFunction.java b/geode-core/src/main/java/org/apache/geode/management/internal/configuration/functions/DownloadJarFunction.java
similarity index 60%
rename from geode-core/src/main/java/org/apache/geode/management/internal/configuration/functions/UploadJarFunction.java
rename to geode-core/src/main/java/org/apache/geode/management/internal/configuration/functions/DownloadJarFunction.java
index 56225ca094..fd93ecb34c 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/configuration/functions/UploadJarFunction.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/configuration/functions/DownloadJarFunction.java
@@ -15,19 +15,28 @@
  */
 package org.apache.geode.management.internal.configuration.functions;
 
-import java.util.List;
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.rmi.RemoteException;
 
+import com.healthmarketscience.rmiio.GZIPRemoteInputStream;
+import com.healthmarketscience.rmiio.RemoteInputStream;
+import com.healthmarketscience.rmiio.RemoteInputStreamServer;
+import com.healthmarketscience.rmiio.SimpleRemoteInputStream;
 import org.apache.logging.log4j.Logger;
 
 import org.apache.geode.cache.execute.Function;
 import org.apache.geode.cache.execute.FunctionContext;
+import org.apache.geode.cache.execute.FunctionException;
 import org.apache.geode.distributed.Locator;
 import org.apache.geode.distributed.internal.ClusterConfigurationService;
 import org.apache.geode.distributed.internal.InternalLocator;
 import org.apache.geode.internal.InternalEntity;
 import org.apache.geode.internal.logging.LogService;
 
-public class UploadJarFunction implements Function<Object[]>, InternalEntity {
+public class DownloadJarFunction implements Function<Object[]>, InternalEntity {
   private static final Logger logger = LogService.getLogger();
 
   private static final long serialVersionUID = 1L;
@@ -39,24 +48,41 @@ public void execute(FunctionContext<Object[]> context) {
     String group = (String) args[0];
     String jarName = (String) args[1];
 
-    byte[] jarBytes = null;
+    RemoteInputStream result = null;
     if (locator != null && group != null && jarName != null) {
       ClusterConfigurationService sharedConfig = locator.getSharedConfiguration();
       if (sharedConfig != null) {
         try {
-          jarBytes = sharedConfig.getJarBytesFromThisLocator(group, jarName);
-          context.getResultSender().lastResult(jarBytes);
+          File jarFile = sharedConfig.getPathToJarOnThisLocator(group, jarName).toFile();
+
+          RemoteInputStreamServer istream = null;
+          try {
+            istream =
+                new SimpleRemoteInputStream(new BufferedInputStream(new FileInputStream(jarFile)));
+            result = istream.export();
+            istream = null;
+          } catch (FileNotFoundException | RemoteException ex) {
+            throw new FunctionException(ex);
+          } finally {
+            // we will only close the stream here if the server fails before
+            // returning an exported stream
+            if (istream != null) {
+              istream.close();
+            }
+          }
         } catch (Exception e) {
           logger.error(e);
           throw new IllegalStateException(e.getMessage());
         }
       }
     }
+
+    context.getResultSender().lastResult(result);
   }
 
   @Override
   public String getId() {
-    return UploadJarFunction.class.getName();
+    return DownloadJarFunction.class.getName();
   }
 
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/configuration/functions/GetClusterConfigurationFunction.java b/geode-core/src/main/java/org/apache/geode/management/internal/configuration/functions/GetClusterConfigurationFunction.java
index bc7ab6b3b6..c64e876f78 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/configuration/functions/GetClusterConfigurationFunction.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/configuration/functions/GetClusterConfigurationFunction.java
@@ -55,7 +55,7 @@ public void execute(FunctionContext context) {
           clusterConfigurationService.createConfigurationResponse(groups);
       context.getResultSender().lastResult(response);
     } catch (IOException e) {
-      logger.error("Unable to retrieve the cluster configuraton", e);
+      logger.error("Unable to retrieve the cluster configuration", e);
       context.getResultSender().lastResult(e);
     }
   }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/configuration/messages/ConfigurationResponse.java b/geode-core/src/main/java/org/apache/geode/management/internal/configuration/messages/ConfigurationResponse.java
index a7188b2a1c..2eb0a1775f 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/configuration/messages/ConfigurationResponse.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/configuration/messages/ConfigurationResponse.java
@@ -32,6 +32,7 @@
 
 import org.apache.geode.DataSerializer;
 import org.apache.geode.InternalGemFireError;
+import org.apache.geode.distributed.DistributedMember;
 import org.apache.geode.internal.DataSerializableFixedID;
 import org.apache.geode.internal.Version;
 import org.apache.geode.management.internal.configuration.domain.Configuration;
@@ -39,11 +40,13 @@
 
 public class ConfigurationResponse implements DataSerializableFixedID {
 
-  private Map<String, Configuration> requestedConfiguration = new HashMap<String, Configuration>();
-  private byte[][] jarBytes;
-  private String[] jarNames;
+  private Map<String, Configuration> requestedConfiguration = new HashMap<>();
+  private Map<String, Set<String>> jarNames = new HashMap<>();
   private boolean failedToGetSharedConfig = false;
 
+  // This is set to the member from which this object was received
+  private transient DistributedMember member;
+
   @Override
   public int getDSFID() {
     return DataSerializableFixedID.CONFIGURATION_RESPONSE;
@@ -51,17 +54,15 @@ public int getDSFID() {
 
   @Override
   public void toData(DataOutput out) throws IOException {
-    DataSerializer.writeHashMap((HashMap<?, ?>) requestedConfiguration, out);
-    DataSerializer.writeStringArray(jarNames, out);
-    DataSerializer.writeArrayOfByteArrays(jarBytes, out);
+    DataSerializer.writeHashMap(requestedConfiguration, out);
+    DataSerializer.writeHashMap(jarNames, out);
     DataSerializer.writeBoolean(Boolean.valueOf(failedToGetSharedConfig), out);
   }
 
   @Override
   public void fromData(DataInput in) throws IOException, ClassNotFoundException {
     this.requestedConfiguration = DataSerializer.readHashMap(in);
-    this.jarNames = DataSerializer.readStringArray(in);
-    this.jarBytes = DataSerializer.readArrayOfByteArrays(in);
+    this.jarNames = DataSerializer.readHashMap(in);
     this.failedToGetSharedConfig = DataSerializer.readBoolean(in);
   }
 
@@ -126,18 +127,20 @@ public String describeConfig() {
     return sb.toString();
   }
 
+  public void addJar(String group, Set<String> jarNames) {
+    this.jarNames.put(group, jarNames);
+  }
 
-  public String[] getJarNames() {
-    return this.jarNames;
+  public Map<String, Set<String>> getJarNames() {
+    return jarNames;
   }
 
-  public byte[][] getJars() {
-    return this.jarBytes;
+  public DistributedMember getMember() {
+    return member;
   }
 
-  public void addJarsToBeDeployed(String[] jarNames, byte[][] jarBytes) {
-    this.jarNames = jarNames;
-    this.jarBytes = jarBytes;
+  public void setMember(DistributedMember member) {
+    this.member = member;
   }
 
   public Version[] getSerializationVersions() {
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/web/controllers/AbstractCommandsController.java b/geode-core/src/main/java/org/apache/geode/management/internal/web/controllers/AbstractCommandsController.java
index 735c58461a..2959200e21 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/web/controllers/AbstractCommandsController.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/web/controllers/AbstractCommandsController.java
@@ -14,11 +14,20 @@
  */
 package org.apache.geode.management.internal.web.controllers;
 
+import java.io.File;
+import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
-import java.lang.management.ManagementFactory;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.attribute.PosixFilePermission;
+import java.nio.file.attribute.PosixFilePermissions;
+import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 import javax.management.InstanceNotFoundException;
 import javax.management.JMX;
@@ -26,6 +35,7 @@
 import javax.management.MalformedObjectNameException;
 import javax.management.ObjectName;
 
+import org.apache.commons.io.FileUtils;
 import org.apache.logging.log4j.Logger;
 import org.springframework.beans.propertyeditors.StringArrayPropertyEditor;
 import org.springframework.http.HttpStatus;
@@ -33,14 +43,11 @@
 import org.springframework.web.bind.WebDataBinder;
 import org.springframework.web.bind.annotation.ExceptionHandler;
 import org.springframework.web.bind.annotation.InitBinder;
-import org.springframework.web.bind.annotation.ResponseBody;
+import org.springframework.web.multipart.MultipartFile;
 
 import org.apache.geode.internal.cache.GemFireCacheImpl;
 import org.apache.geode.internal.cache.InternalCache;
 import org.apache.geode.internal.logging.LogService;
-import org.apache.geode.internal.logging.log4j.LogMarker;
-import org.apache.geode.internal.security.SecurityService;
-import org.apache.geode.internal.util.ArrayUtils;
 import org.apache.geode.management.DistributedSystemMXBean;
 import org.apache.geode.management.ManagementService;
 import org.apache.geode.management.MemberMXBean;
@@ -48,11 +55,9 @@
 import org.apache.geode.management.internal.ManagementAgent;
 import org.apache.geode.management.internal.SystemManagementService;
 import org.apache.geode.management.internal.cli.shell.Gfsh;
-import org.apache.geode.management.internal.security.MBeanServerWrapper;
 import org.apache.geode.management.internal.web.controllers.support.LoginHandlerInterceptor;
 import org.apache.geode.management.internal.web.util.UriUtils;
 import org.apache.geode.security.AuthenticationFailedException;
-import org.apache.geode.security.GemFireSecurityException;
 import org.apache.geode.security.NotAuthorizedException;
 
 /**
@@ -232,18 +237,36 @@ private MemberMXBean createMemberMXBeanForManagerUsingProxy(final MBeanServer se
    *        Gfsh, the key/value pair (APP_NAME=gfsh) is a specified mapping in the "environment.
    *        Note, it is common for the REST API to act as a bridge, or an adapter between Gfsh and
    *        the Manager, and thus need to specify this key/value pair mapping.
-   * @param fileData is a two-dimensional byte array containing the pathnames and contents of file
-   *        data streamed to the Manager, usually for the 'deploy' Gfsh command.
+   * @param multipartFiles uploaded files
    * @return a result of the command execution as a String, typically marshalled in JSON to be
    *         serialized back to Gfsh.
-   * @see org.apache.geode.management.MemberMXBean#processCommand(String, java.util.Map, Byte[][])
    */
   protected String processCommand(final String command, final Map<String, String> environment,
-      final byte[][] fileData) {
-    logger.debug(LogMarker.CONFIG,
-        "Processing Command ({}) with Environment ({}) having File Data ({})...", command,
-        environment, (fileData != null && fileData.length > 0));
+      final MultipartFile[] multipartFiles) throws IOException {
+    List<String> filePaths = null;
+    Path tempDir = null;
+    if (multipartFiles != null) {
+      Set<PosixFilePermission> perms = new HashSet<>();
+      perms.add(PosixFilePermission.OWNER_READ);
+      perms.add(PosixFilePermission.OWNER_WRITE);
+      perms.add(PosixFilePermission.OWNER_EXECUTE);
+      tempDir = Files.createTempDirectory("uploaded-", PosixFilePermissions.asFileAttribute(perms));
+      // staging the files to local
+      filePaths = new ArrayList<>();
+      for (MultipartFile multipartFile : multipartFiles) {
+        File dest = new File(tempDir.toFile(), multipartFile.getOriginalFilename());
+        multipartFile.transferTo(dest);
+        filePaths.add(dest.getAbsolutePath());
+      }
+    }
+
     MemberMXBean manager = getManagingMemberMXBean();
-    return manager.processCommand(command, environment, ArrayUtils.toByteArray(fileData));
+    try {
+      return manager.processCommand(command, environment, filePaths);
+    } finally {
+      if (tempDir != null) {
+        FileUtils.deleteDirectory(tempDir.toFile());
+      }
+    }
   }
 }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/web/controllers/ShellCommandsController.java b/geode-core/src/main/java/org/apache/geode/management/internal/web/controllers/ShellCommandsController.java
index 9c65090f6a..39b075368a 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/web/controllers/ShellCommandsController.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/web/controllers/ShellCommandsController.java
@@ -52,7 +52,6 @@
 import org.apache.geode.management.internal.cli.result.CommandResult;
 import org.apache.geode.management.internal.cli.result.ResultBuilder;
 import org.apache.geode.management.internal.web.domain.QueryParameterSource;
-import org.apache.geode.management.internal.web.util.ConvertUtils;
 
 /**
  * The ShellCommandsController class implements GemFire REST API calls for Gfsh Shell Commands.
@@ -73,8 +72,7 @@
   public ResponseEntity<InputStreamResource> command(@RequestParam(value = "cmd") String command,
       @RequestParam(value = "resources", required = false) MultipartFile[] fileResource)
       throws IOException {
-    String result =
-        processCommand(decode(command), getEnvironment(), ConvertUtils.convert(fileResource));
+    String result = processCommand(decode(command), getEnvironment(), fileResource);
     return getResponse(result);
   }
 
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/web/shell/HttpOperationInvoker.java b/geode-core/src/main/java/org/apache/geode/management/internal/web/shell/HttpOperationInvoker.java
index ce4aaec4b7..056cf55142 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/web/shell/HttpOperationInvoker.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/web/shell/HttpOperationInvoker.java
@@ -14,6 +14,7 @@
  */
 package org.apache.geode.management.internal.web.shell;
 
+import java.io.File;
 import java.io.IOException;
 import java.net.URI;
 import java.util.Properties;
@@ -26,7 +27,7 @@
 import javax.management.QueryExp;
 
 import org.apache.logging.log4j.Logger;
-import org.springframework.core.io.Resource;
+import org.springframework.core.io.FileSystemResource;
 import org.springframework.http.MediaType;
 import org.springframework.util.LinkedMultiValueMap;
 import org.springframework.util.MultiValueMap;
@@ -42,7 +43,6 @@
 import org.apache.geode.management.internal.web.domain.QueryParameterSource;
 import org.apache.geode.management.internal.web.http.support.HttpRequester;
 import org.apache.geode.management.internal.web.shell.support.HttpMBeanProxyFactory;
-import org.apache.geode.management.internal.web.util.ConvertUtils;
 
 /**
  * The HttpOperationInvoker class is an abstract base class encapsulating common functionality for
@@ -417,12 +417,11 @@ public String toString() {
   public Object processCommand(final CommandRequest command) {
     URI link =
         HttpRequester.createURI(baseUrl, COMMANDS_URI, CMD_QUERY_PARAMETER, command.getUserInput());
-    if (command.hasFileData()) {
+    if (command.hasFileList()) {
       MultiValueMap<String, Object> content = new LinkedMultiValueMap<String, Object>();
 
-      Resource[] resources = ConvertUtils.convert(command.getFileData());
-      for (Resource resource : resources) {
-        content.add(RESOURCES_REQUEST_PARAMETER, resource);
+      for (File file : command.getFileList()) {
+        content.add(RESOURCES_REQUEST_PARAMETER, new FileSystemResource(file));
       }
       return httpRequester.post(link, MediaType.MULTIPART_FORM_DATA, content, String.class);
     }
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/web/util/ConvertUtils.java b/geode-core/src/main/java/org/apache/geode/management/internal/web/util/ConvertUtils.java
deleted file mode 100644
index b8f5c0c67c..0000000000
--- a/geode-core/src/main/java/org/apache/geode/management/internal/web/util/ConvertUtils.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-package org.apache.geode.management.internal.web.util;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.commons.lang.StringUtils;
-import org.springframework.core.io.ByteArrayResource;
-import org.springframework.core.io.Resource;
-import org.springframework.web.multipart.MultipartFile;
-
-import org.apache.geode.internal.util.IOUtils;
-import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.web.io.MultipartFileResourceAdapter;
-
-/**
- * The ConvertUtils class is a support class for performing conversions used by the GemFire web
- * application and REST interface.
- * <p/>
- *
- * @see org.apache.geode.management.internal.cli.CliUtil
- * @since GemFire 8.0
- */
-@SuppressWarnings("unused")
-public abstract class ConvertUtils {
-
-  /**
-   * Converts the 2-dimensional byte array of file data, which includes the name of the file as
-   * bytes followed by the byte content of the file, for all files being transmitted by Gfsh to the
-   * GemFire Manager.
-   * <p/>
-   *
-   * @param fileData a 2 dimensional byte array of files names and file content.
-   * @return an array of Spring Resource objects encapsulating the details (name and content) of
-   *         each file being transmitted by Gfsh to the GemFire Manager.
-   * @see org.springframework.core.io.ByteArrayResource
-   * @see org.springframework.core.io.Resource
-   * @see org.apache.geode.management.internal.cli.CliUtil#bytesToData(byte[][])
-   * @see org.apache.geode.management.internal.cli.CliUtil#bytesToNames(byte[][])
-   */
-  public static Resource[] convert(final byte[][] fileData) {
-    if (fileData == null) {
-      return new Resource[0];
-    }
-
-    final String[] fileNames = CliUtil.bytesToNames(fileData);
-    final byte[][] fileContent = CliUtil.bytesToData(fileData);
-
-    final List<Resource> resources = new ArrayList<Resource>(fileNames.length);
-
-    for (int index = 0; index < fileNames.length; index++) {
-      final String filename = fileNames[index];
-      resources.add(new ByteArrayResource(fileContent[index],
-          String.format("Contents of JAR file (%1$s).", filename)) {
-        @Override
-        public String getFilename() {
-          return filename;
-        }
-      });
-    }
-
-    return resources.toArray(new Resource[resources.size()]);
-  }
-
-  /**
-   * Converts the array of MultipartFiles into a 2-dimensional byte array containing content from
-   * each MultipartFile. The 2-dimensional byte array format is used by Gfsh and the GemFire Manager
-   * to transmit file data.
-   * <p/>
-   *
-   * @param files an array of Spring MultipartFile objects to convert into the 2-dimensional byte
-   *        array format.
-   * @return a 2-dimensional byte array containing the content of each MultipartFile.
-   * @throws IOException if an I/O error occurs reading the contents of a MultipartFile.
-   * @see #convert(org.springframework.core.io.Resource...)
-   * @see org.springframework.web.multipart.MultipartFile
-   */
-  public static byte[][] convert(final MultipartFile... files) throws IOException {
-    if (files == null) {
-      return new byte[0][];
-    }
-
-    final List<Resource> resources = new ArrayList<Resource>(files.length);
-    for (final MultipartFile file : files) {
-      resources.add(new MultipartFileResourceAdapter(file));
-    }
-    return convert(resources.toArray(new Resource[resources.size()]));
-  }
-
-  /**
-   * Converts the array of Resources into a 2-dimensional byte array containing content from each
-   * Resource. The 2-dimensional byte array format is used by Gfsh and the GemFire Manager to
-   * transmit file data.
-   * <p/>
-   *
-   * @param resources an array of Spring Resource objects to convert into the 2-dimensional byte
-   *        array format.
-   * @return a 2-dimensional byte array containing the content of each Resource.
-   * @throws IllegalArgumentException if the filename of a Resource was not specified.
-   * @throws IOException if an I/O error occurs reading the contents of a Resource!
-   * @see org.springframework.core.io.Resource
-   */
-  public static byte[][] convert(final Resource... resources) throws IOException {
-    if (resources == null) {
-      return new byte[0][];
-    }
-
-    final List<byte[]> fileData = new ArrayList<byte[]>(resources.length * 2);
-
-    for (final Resource resource : resources) {
-      if (StringUtils.isBlank(resource.getFilename())) {
-        throw new IllegalArgumentException(String.format(
-            "The filename of Resource (%1$s) must be specified!", resource.getDescription()));
-      }
-
-      fileData.add(resource.getFilename().getBytes());
-      fileData.add(IOUtils.toByteArray(resource.getInputStream()));
-    }
-
-    return fileData.toArray(new byte[fileData.size()][]);
-  }
-}
diff --git a/geode-core/src/main/resources/org/apache/geode/internal/sanctioned-geode-core-serializables.txt b/geode-core/src/main/resources/org/apache/geode/internal/sanctioned-geode-core-serializables.txt
index cfe475f192..c7d832a6b9 100644
--- a/geode-core/src/main/resources/org/apache/geode/internal/sanctioned-geode-core-serializables.txt
+++ b/geode-core/src/main/resources/org/apache/geode/internal/sanctioned-geode-core-serializables.txt
@@ -587,7 +587,7 @@ org/apache/geode/management/internal/configuration/domain/SharedConfigurationSta
 org/apache/geode/management/internal/configuration/functions/GetClusterConfigurationFunction,false
 org/apache/geode/management/internal/configuration/functions/GetRegionNamesFunction,false
 org/apache/geode/management/internal/configuration/functions/RecreateCacheFunction,false
-org/apache/geode/management/internal/configuration/functions/UploadJarFunction,true,1
+org/apache/geode/management/internal/configuration/functions/DownloadJarFunction,true,1
 org/apache/geode/management/internal/web/domain/QueryParameterSource,true,34131123582155,objectName:javax/management/ObjectName,queryExpression:javax/management/QueryExp
 org/apache/geode/management/internal/web/shell/MBeanAccessException,true,813768898269516238
 org/apache/geode/memcached/GemFireMemcachedServer$Protocol,false
diff --git a/geode-core/src/test/java/org/apache/geode/internal/ClassPathLoaderIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/internal/ClassPathLoaderIntegrationTest.java
index c442b19a95..d0a319ba81 100644
--- a/geode-core/src/test/java/org/apache/geode/internal/ClassPathLoaderIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/internal/ClassPathLoaderIntegrationTest.java
@@ -22,7 +22,10 @@
 import static org.junit.Assert.assertNull;
 
 import java.io.BufferedInputStream;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -36,7 +39,7 @@
 import org.apache.bcel.Constants;
 import org.apache.bcel.classfile.JavaClass;
 import org.apache.bcel.generic.ClassGen;
-import org.apache.commons.io.FileUtils;
+import org.apache.commons.io.IOUtils;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -109,10 +112,10 @@ public void testClassLoaderWithNullTccl() throws IOException, ClassNotFoundExcep
 
     String classAName = "integration.parent.ClassA";
 
-    byte[] firstJarBytes = createJarWithClass("ClassA");
+    File firstJar = createJarWithClass("ClassA");
 
     // First deploy of the JAR file
-    ClassPathLoader.getLatest().getJarDeployer().deploy(jarName, firstJarBytes).getFile();
+    ClassPathLoader.getLatest().getJarDeployer().deploy(jarName, firstJar).getFile();
 
     assertThatClassCanBeLoaded(classAName);
     assertThatResourceCanBeLoaded(classAResource);
@@ -128,13 +131,15 @@ public void testDeployFileAndChange() throws IOException, ClassNotFoundException
     String classAName = "integration.parent.ClassA";
     String classBName = "integration.parent.ClassB";
 
-    byte[] firstJarBytes = createJarWithClass("ClassA");
+    File firstJar = createJarWithClass("ClassA");
+    ByteArrayOutputStream firstJarBytes = new ByteArrayOutputStream();
+    IOUtils.copy(new FileInputStream(firstJar), firstJarBytes);
 
     // First deploy of the JAR file
     File firstDeployedJarFile =
-        ClassPathLoader.getLatest().getJarDeployer().deploy(jarName, firstJarBytes).getFile();
+        ClassPathLoader.getLatest().getJarDeployer().deploy(jarName, firstJar).getFile();
 
-    assertThat(firstDeployedJarFile).exists().hasBinaryContent(firstJarBytes);
+    assertThat(firstDeployedJarFile).exists().hasBinaryContent(firstJarBytes.toByteArray());
     assertThat(firstDeployedJarFile.getName()).contains(".v1.").doesNotContain(".v2.");
 
     assertThatClassCanBeLoaded(classAName);
@@ -145,12 +150,14 @@ public void testDeployFileAndChange() throws IOException, ClassNotFoundException
 
     // Now deploy an updated JAR file and make sure that the next version of the JAR file
     // was created and the first one is no longer used
-    byte[] secondJarBytes = createJarWithClass("ClassB");
+    File secondJar = createJarWithClass("ClassB");
+    ByteArrayOutputStream secondJarBytes = new ByteArrayOutputStream();
+    IOUtils.copy(new FileInputStream(secondJar), secondJarBytes);
 
     File secondDeployedJarFile =
-        ClassPathLoader.getLatest().getJarDeployer().deploy(jarName, secondJarBytes).getFile();
+        ClassPathLoader.getLatest().getJarDeployer().deploy(jarName, secondJar).getFile();
 
-    assertThat(secondDeployedJarFile).exists().hasBinaryContent(secondJarBytes);
+    assertThat(secondDeployedJarFile).exists().hasBinaryContent(secondJarBytes.toByteArray());
     assertThat(secondDeployedJarFile.getName()).contains(".v2.").doesNotContain(".v1.");
 
     assertThatClassCanBeLoaded(classBName);
@@ -174,8 +181,10 @@ public void testDeployNoUpdateWhenNoChange() throws IOException, ClassNotFoundEx
 
     // First deploy of the JAR file
     byte[] jarBytes = new ClassBuilder().createJarFromName("JarDeployerDUnitDNUWNC");
+    File jarFile = temporaryFolder.newFile();
+    writeJarBytesToFile(jarFile, jarBytes);
     DeployedJar jarClassLoader =
-        ClassPathLoader.getLatest().getJarDeployer().deploy(jarName, jarBytes);
+        ClassPathLoader.getLatest().getJarDeployer().deploy(jarName, jarFile);
     File deployedJar = new File(jarClassLoader.getFileCanonicalPath());
 
     assertThat(deployedJar).exists();
@@ -183,7 +192,7 @@ public void testDeployNoUpdateWhenNoChange() throws IOException, ClassNotFoundEx
 
     // Re-deploy of the same JAR should do nothing
     DeployedJar newJarClassLoader =
-        ClassPathLoader.getLatest().getJarDeployer().deploy(jarName, jarBytes);
+        ClassPathLoader.getLatest().getJarDeployer().deploy(jarName, jarFile);
     assertThat(newJarClassLoader).isNull();
     assertThat(deployedJar).exists();
 
@@ -274,8 +283,7 @@ public void deployNewVersionOfFunctionOverOldVersion() throws Exception {
     GemFireCacheImpl gemFireCache = GemFireCacheImpl.getInstance();
     DistributedSystem distributedSystem = gemFireCache.getDistributedSystem();
 
-    ClassPathLoader.getLatest().getJarDeployer().deploy("MyJar.jar",
-        FileUtils.readFileToByteArray(jarVersion1));
+    ClassPathLoader.getLatest().getJarDeployer().deploy("MyJar.jar", jarVersion1);
 
     assertThatClassCanBeLoaded("jddunit.function.MyFunction");
     Execution execution = FunctionService.onMember(distributedSystem.getDistributedMember());
@@ -283,8 +291,7 @@ public void deployNewVersionOfFunctionOverOldVersion() throws Exception {
     List<String> result = (List<String>) execution.execute("MyFunction").getResult();
     assertThat(result.get(0)).isEqualTo("Version1");
 
-    ClassPathLoader.getLatest().getJarDeployer().deploy("MyJar.jar",
-        FileUtils.readFileToByteArray(jarVersion2));
+    ClassPathLoader.getLatest().getJarDeployer().deploy("MyJar.jar", jarVersion2);
     result = (List<String>) execution.execute("MyFunction").getResult();
     assertThat(result.get(0)).isEqualTo("Version2");
 
@@ -461,7 +468,7 @@ public void testGetResourceAsStreamWithTCCL() throws Exception {
 
   @Test
   public void testDeclarableFunctionsWithNoCacheXml() throws Exception {
-    final String jarName = "JarClassLoaderJUnitNoXml.jar";
+    final String jarFilename = "JarClassLoaderJUnitNoXml.jar";
 
     // Add a Declarable Function without parameters for the class to the Classpath
     String functionString =
@@ -478,8 +485,10 @@ public void testDeclarableFunctionsWithNoCacheXml() throws Exception {
 
     byte[] jarBytes = this.classBuilder
         .createJarFromClassContent("JarClassLoaderJUnitFunctionNoXml", functionString);
+    File jarFile = temporaryFolder.newFile();
+    writeJarBytesToFile(jarFile, jarBytes);
 
-    ClassPathLoader.getLatest().getJarDeployer().deploy(jarName, jarBytes);
+    ClassPathLoader.getLatest().getJarDeployer().deploy(jarFilename, jarFile);
 
     ClassPathLoader.getLatest().forName("JarClassLoaderJUnitFunctionNoXml");
 
@@ -506,7 +515,8 @@ public void testDependencyBetweenJars() throws Exception {
     byte[] jarBytes = this.classBuilder.createJarFromClassContent(
         "jcljunit/parent/JarClassLoaderJUnitParent", stringBuffer.toString());
     writeJarBytesToFile(parentJarFile, jarBytes);
-    ClassPathLoader.getLatest().getJarDeployer().deploy("JarClassLoaderJUnitParent.jar", jarBytes);
+    ClassPathLoader.getLatest().getJarDeployer().deploy("JarClassLoaderJUnitParent.jar",
+        parentJarFile);
 
     stringBuffer = new StringBuffer();
     stringBuffer.append("package jcljunit.uses;");
@@ -517,7 +527,7 @@ public void testDependencyBetweenJars() throws Exception {
     jarBytes = this.classBuilder.createJarFromClassContent("jcljunit/uses/JarClassLoaderJUnitUses",
         stringBuffer.toString());
     writeJarBytesToFile(usesJarFile, jarBytes);
-    ClassPathLoader.getLatest().getJarDeployer().deploy("JarClassLoaderJUnitUses.jar", jarBytes);
+    ClassPathLoader.getLatest().getJarDeployer().deploy("JarClassLoaderJUnitUses.jar", usesJarFile);
 
     stringBuffer = new StringBuffer();
     stringBuffer.append("package jcljunit.function;");
@@ -540,9 +550,11 @@ public void testDependencyBetweenJars() throws Exception {
     functionClassBuilder.addToClassPath(usesJarFile.getAbsolutePath());
     jarBytes = functionClassBuilder.createJarFromClassContent(
         "jcljunit/function/JarClassLoaderJUnitFunction", stringBuffer.toString());
+    File jarFunction = temporaryFolder.newFile();
+    writeJarBytesToFile(jarFunction, jarBytes);
 
     ClassPathLoader.getLatest().getJarDeployer().deploy("JarClassLoaderJUnitFunction.jar",
-        jarBytes);
+        jarFunction);
 
     Function function = FunctionService.getFunction("JarClassLoaderJUnitFunction");
     assertThat(function).isNotNull();
@@ -559,8 +571,9 @@ public void testFindResource() throws IOException, ClassNotFoundException {
     final String fileContent = "FILE CONTENT";
 
     byte[] jarBytes = this.classBuilder.createJarFromFileContent(fileName, fileContent);
-    ClassPathLoader.getLatest().getJarDeployer().deploy("JarClassLoaderJUnitResource.jar",
-        jarBytes);
+    File tempJar = temporaryFolder.newFile();
+    writeJarBytesToFile(tempJar, jarBytes);
+    ClassPathLoader.getLatest().getJarDeployer().deploy("JarClassLoaderJUnitResource.jar", tempJar);
 
     InputStream inputStream = ClassPathLoader.getLatest().getResourceAsStream(fileName);
     assertThat(inputStream).isNotNull();
@@ -577,7 +590,9 @@ public void testUpdateClassInJar() throws Exception {
     // First use of the JAR file
     byte[] jarBytes = this.classBuilder.createJarFromClassContent("JarClassLoaderJUnitTestClass",
         "public class JarClassLoaderJUnitTestClass { public Integer getValue5() { return new Integer(5); } }");
-    ClassPathLoader.getLatest().getJarDeployer().deploy("JarClassLoaderJUnitUpdate.jar", jarBytes);
+    File jarFile = temporaryFolder.newFile();
+    writeJarBytesToFile(jarFile, jarBytes);
+    ClassPathLoader.getLatest().getJarDeployer().deploy("JarClassLoaderJUnitUpdate.jar", jarFile);
 
     Class<?> clazz = ClassPathLoader.getLatest().forName("JarClassLoaderJUnitTestClass");
     Object object = clazz.newInstance();
@@ -589,7 +604,9 @@ public void testUpdateClassInJar() throws Exception {
     // class is available.
     jarBytes = this.classBuilder.createJarFromClassContent("JarClassLoaderJUnitTestClass",
         "public class JarClassLoaderJUnitTestClass { public Integer getValue10() { return new Integer(10); } }");
-    ClassPathLoader.getLatest().getJarDeployer().deploy("JarClassLoaderJUnitUpdate.jar", jarBytes);
+    File jarFile2 = temporaryFolder.newFile();
+    writeJarBytesToFile(jarFile2, jarBytes);
+    ClassPathLoader.getLatest().getJarDeployer().deploy("JarClassLoaderJUnitUpdate.jar", jarFile2);
 
     clazz = ClassPathLoader.getLatest().forName("JarClassLoaderJUnitTestClass");
     object = clazz.newInstance();
@@ -678,11 +695,16 @@ protected File getTempFile() {
     }
   }
 
-  private byte[] createJarWithClass(String className) throws IOException {
+  private File createJarWithClass(String className) throws IOException {
     String stringBuilder = "package integration.parent;" + "public class " + className + " {}";
 
-    return new ClassBuilder().createJarFromClassContent("integration/parent/" + className,
-        stringBuilder);
+    byte[] jarBytes = new ClassBuilder()
+        .createJarFromClassContent("integration/parent/" + className, stringBuilder);
+
+    File jarFile = temporaryFolder.newFile();
+    IOUtils.copy(new ByteArrayInputStream(jarBytes), new FileOutputStream(jarFile));
+
+    return jarFile;
   }
 
   private static class TestResultSender implements ResultSender<Object> {
diff --git a/geode-core/src/test/java/org/apache/geode/internal/ClassPathLoaderTest.java b/geode-core/src/test/java/org/apache/geode/internal/ClassPathLoaderTest.java
index 99acbc9a7b..f96d963da8 100755
--- a/geode-core/src/test/java/org/apache/geode/internal/ClassPathLoaderTest.java
+++ b/geode-core/src/test/java/org/apache/geode/internal/ClassPathLoaderTest.java
@@ -19,21 +19,27 @@
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
 import java.io.BufferedInputStream;
+import java.io.ByteArrayInputStream;
 import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Vector;
 
 import org.apache.bcel.Constants;
 import org.apache.bcel.classfile.JavaClass;
 import org.apache.bcel.generic.ClassGen;
+import org.apache.commons.io.IOUtils;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.contrib.java.lang.system.RestoreSystemProperties;
 import org.junit.experimental.categories.Category;
+import org.junit.rules.TemporaryFolder;
 
 import org.apache.geode.test.compiler.ClassBuilder;
 import org.apache.geode.test.junit.categories.UnitTest;
@@ -51,6 +57,9 @@
   @Rule
   public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();
 
+  @Rule
+  public TemporaryFolder tempFolder = new TemporaryFolder();
+
   @Before
   public void setUp() throws Exception {
     System.setProperty(ClassPathLoader.EXCLUDE_TCCL_PROPERTY, "false");
@@ -68,17 +77,28 @@ public void testLatestExists() throws Exception {
   }
 
   @Test
-  public void testZeroLengthFile() throws IOException, ClassNotFoundException {
+  public void testZeroLengthFile() throws IOException {
+    File zeroFile = tempFolder.newFile();
+    zeroFile.createNewFile();
+
+    Map<String, File> jarFiles = new HashMap<>();
+    jarFiles.put("JarDeployerDUnitZLF.jar", zeroFile);
+
     assertThatThrownBy(() -> {
-      ClassPathLoader.getLatest().getJarDeployer().deploy(new String[] {"JarDeployerDUnitZLF.jar"},
-          new byte[][] {new byte[0]});
+      ClassPathLoader.getLatest().getJarDeployer().deploy(jarFiles);
     }).isInstanceOf(IllegalArgumentException.class);
 
-    assertThatThrownBy(() -> {
-      ClassPathLoader.getLatest().getJarDeployer().deploy(
-          new String[] {"JarDeployerDUnitZLF1.jar", "JarDeployerDUnitZLF2.jar"},
-          new byte[][] {new ClassBuilder().createJarFromName("JarDeployerDUnitZLF1"), new byte[0]});
+    byte[] validBytes = new ClassBuilder().createJarFromName("JarDeployerDUnitZLF1");
+    File validFile = tempFolder.newFile();
 
+    IOUtils.copy(new ByteArrayInputStream(validBytes), new FileOutputStream(validFile));
+
+    jarFiles.put("JarDeployerDUnitZLF1.jar", validFile);
+
+    jarFiles.put("JarDeployerDUnitZLF2.jar", zeroFile);
+
+    assertThatThrownBy(() -> {
+      ClassPathLoader.getLatest().getJarDeployer().deploy(jarFiles);
     }).isInstanceOf(IllegalArgumentException.class);
   }
 
diff --git a/geode-core/src/test/java/org/apache/geode/internal/DeployedJarJUnitTest.java b/geode-core/src/test/java/org/apache/geode/internal/DeployedJarJUnitTest.java
index abaa458156..4b62b5a303 100644
--- a/geode-core/src/test/java/org/apache/geode/internal/DeployedJarJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/internal/DeployedJarJUnitTest.java
@@ -15,7 +15,6 @@
 package org.apache.geode.internal;
 
 
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
 import java.io.File;
@@ -51,30 +50,17 @@ public void setup() throws Exception {
 
   @Test
   public void validJarContentDoesNotThrow() throws Exception {
-    new DeployedJar(jarFile, JAR_NAME, expectedJarBytes);
-  }
-
-  @Test
-  public void unexpectedContentThrowsException() throws Exception {
-    givenUnexpectedJarFileContents();
-
-    assertThatThrownBy(() -> new DeployedJar(jarFile, JAR_NAME, expectedJarBytes))
-        .isInstanceOf(IllegalStateException.class);
+    new DeployedJar(jarFile, JAR_NAME);
   }
 
   @Test
   public void invalidContentThrowsException() throws Exception {
-    byte[] invalidJarBytes = givenInvalidJarBytes();
+    givenInvalidJarBytes();
 
-    assertThatThrownBy(() -> new DeployedJar(jarFile, JAR_NAME, invalidJarBytes))
+    assertThatThrownBy(() -> new DeployedJar(jarFile, JAR_NAME))
         .isInstanceOf(IllegalArgumentException.class);
   }
 
-  private void givenUnexpectedJarFileContents() throws IOException {
-    FileUtils.deleteQuietly(jarFile);
-    jarBuilder.buildJarFromClassNames(jarFile, "UnexpectedClass");
-  }
-
   private byte[] givenInvalidJarBytes() throws IOException {
     byte[] invalidJarBytes = "INVALID JAR CONTENT".getBytes();
     FileUtils.writeByteArrayToFile(jarFile, invalidJarBytes);
diff --git a/geode-core/src/test/java/org/apache/geode/internal/JarDeployerDeadlockTest.java b/geode-core/src/test/java/org/apache/geode/internal/JarDeployerDeadlockTest.java
index c03b1143ec..e20ca62417 100644
--- a/geode-core/src/test/java/org/apache/geode/internal/JarDeployerDeadlockTest.java
+++ b/geode-core/src/test/java/org/apache/geode/internal/JarDeployerDeadlockTest.java
@@ -16,7 +16,9 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
+import java.io.ByteArrayInputStream;
 import java.io.File;
+import java.io.FileOutputStream;
 import java.lang.management.ManagementFactory;
 import java.lang.management.ThreadInfo;
 import java.lang.management.ThreadMXBean;
@@ -25,6 +27,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 
+import org.apache.commons.io.IOUtils;
 import org.awaitility.Awaitility;
 import org.junit.After;
 import org.junit.Before;
@@ -68,11 +71,15 @@ public void tearDown() throws Exception {
   public void testMultiThreadingDoesNotCauseDeadlock() throws Exception {
     // Add two JARs to the classpath
     byte[] jarBytes = this.classBuilder.createJarFromName("JarClassLoaderJUnitA");
-    ClassPathLoader.getLatest().getJarDeployer().deploy("JarClassLoaderJUnitA.jar", jarBytes);
+    File jarFile = temporaryFolder.newFile();
+    IOUtils.copy(new ByteArrayInputStream(jarBytes), new FileOutputStream(jarFile));
+    ClassPathLoader.getLatest().getJarDeployer().deploy("JarClassLoaderJUnitA.jar", jarFile);
 
     jarBytes = this.classBuilder.createJarFromClassContent("com/jcljunit/JarClassLoaderJUnitB",
         "package com.jcljunit; public class JarClassLoaderJUnitB {}");
-    ClassPathLoader.getLatest().getJarDeployer().deploy("JarClassLoaderJUnitB.jar", jarBytes);
+    File jarFile2 = temporaryFolder.newFile();
+    IOUtils.copy(new ByteArrayInputStream(jarBytes), new FileOutputStream(jarFile2));
+    ClassPathLoader.getLatest().getJarDeployer().deploy("JarClassLoaderJUnitB.jar", jarFile2);
 
     String[] classNames = new String[] {"JarClassLoaderJUnitA", "com.jcljunit.JarClassLoaderJUnitB",
         "NON-EXISTENT CLASS"};
diff --git a/geode-core/src/test/java/org/apache/geode/internal/JarDeployerIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/internal/JarDeployerIntegrationTest.java
index ed7d23f65a..90402c1fe0 100644
--- a/geode-core/src/test/java/org/apache/geode/internal/JarDeployerIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/internal/JarDeployerIntegrationTest.java
@@ -20,12 +20,15 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
+import java.io.ByteArrayInputStream;
 import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.util.Set;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
+import org.apache.commons.io.IOUtils;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -62,9 +65,10 @@ public void testFileVersioning() throws Exception {
     String jarName = "JarDeployerIntegrationTest.jar";
 
     byte[] firstJarBytes = createJarWithClass("ClassA");
+    File jarFile1 = writeJarBytes(firstJarBytes);
 
     // First deploy of the JAR file
-    DeployedJar firstDeployedJar = jarDeployer.deployWithoutRegistering(jarName, firstJarBytes);
+    DeployedJar firstDeployedJar = jarDeployer.deployWithoutRegistering(jarName, jarFile1);
 
     assertThat(firstDeployedJar.getFile()).exists().hasBinaryContent(firstJarBytes);
     assertThat(firstDeployedJar.getFile().getName()).contains(".v1.").doesNotContain(".v2.");
@@ -72,8 +76,9 @@ public void testFileVersioning() throws Exception {
     // Now deploy an updated JAR file and make sure that the next version of the JAR file
     // was created
     byte[] secondJarBytes = createJarWithClass("ClassB");
+    File jarFile2 = writeJarBytes(secondJarBytes);
 
-    DeployedJar secondDeployedJar = jarDeployer.deployWithoutRegistering(jarName, secondJarBytes);
+    DeployedJar secondDeployedJar = jarDeployer.deployWithoutRegistering(jarName, jarFile2);
     File secondDeployedJarFile = new File(secondDeployedJar.getFileCanonicalPath());
 
     assertThat(secondDeployedJarFile).exists().hasBinaryContent(secondJarBytes);
@@ -93,10 +98,11 @@ public void testDeployToInvalidDirectory() throws Exception {
 
     final JarDeployer jarDeployer = new JarDeployer(alternateDir);
     final byte[] jarBytes = this.classBuilder.createJarFromName("JarDeployerDUnitDTID");
+    File jarFile = writeJarBytes(jarBytes);
 
     // Test to verify that deployment fails if the directory doesn't exist.
     assertThatThrownBy(() -> {
-      jarDeployer.deployWithoutRegistering("JarDeployerIntegrationTest.jar", jarBytes);
+      jarDeployer.deployWithoutRegistering("JarDeployerIntegrationTest.jar", jarFile);
     }).isInstanceOf(IOException.class).hasMessageContaining("Unable to write to deploy directory:");
   }
 
@@ -106,12 +112,13 @@ public void testVersionNumberCreation() throws Exception {
     assertThat(versionedName.getName()).isEqualTo("myJar.v1.jar");
 
     byte[] jarBytes = this.classBuilder.createJarFromName("ClassA");
-    File deployedJarFile = jarDeployer.deployWithoutRegistering("myJar.jar", jarBytes).getFile();
+    File jarFile = writeJarBytes(jarBytes);
+    File deployedJarFile = jarDeployer.deployWithoutRegistering("myJar.jar", jarFile).getFile();
 
     assertThat(deployedJarFile.getName()).isEqualTo("myJar.v1.jar");
 
     File secondDeployedJarFile =
-        jarDeployer.deployWithoutRegistering("myJar.jar", jarBytes).getFile();
+        jarDeployer.deployWithoutRegistering("myJar.jar", deployedJarFile).getFile();
 
     assertThat(secondDeployedJarFile.getName()).isEqualTo("myJar.v2.jar");
   }
@@ -246,5 +253,10 @@ public void testDeleteOtherVersionsOfJar() throws Exception {
     assertThat(jarBVersion3).exists();
   }
 
+  private File writeJarBytes(byte[] content) throws IOException {
+    File tempJar = temporaryFolder.newFile();
+    IOUtils.copy(new ByteArrayInputStream(content), new FileOutputStream(tempJar));
+    return tempJar;
+  }
 
 }
diff --git a/geode-core/src/test/java/org/apache/geode/internal/cache/backup/IncrementalBackupDistributedTest.java b/geode-core/src/test/java/org/apache/geode/internal/cache/backup/IncrementalBackupDistributedTest.java
index d71bb85f49..6b09aed73e 100644
--- a/geode-core/src/test/java/org/apache/geode/internal/cache/backup/IncrementalBackupDistributedTest.java
+++ b/geode-core/src/test/java/org/apache/geode/internal/cache/backup/IncrementalBackupDistributedTest.java
@@ -21,8 +21,10 @@
 import static org.junit.Assert.assertTrue;
 
 import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.FileFilter;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.nio.file.Files;
@@ -36,6 +38,7 @@
 import java.util.regex.Pattern;
 
 import org.apache.commons.io.FileUtils;
+import org.apache.commons.io.IOUtils;
 import org.apache.commons.io.filefilter.DirectoryFileFilter;
 import org.apache.commons.io.filefilter.RegexFileFilter;
 import org.apache.logging.log4j.Logger;
@@ -1002,6 +1005,9 @@ public void testBackupUserDeployedJarFiles() throws Exception {
     final ClassBuilder classBuilder = new ClassBuilder();
     final byte[] classBytes = classBuilder.createJarFromName(jarName);
 
+    File jarFile = tempDir.newFile();
+    IOUtils.copyLarge(new ByteArrayInputStream(classBytes), new FileOutputStream(jarFile));
+
     VM vm0 = Host.getHost(0).getVM(0);
 
     /*
@@ -1009,7 +1015,7 @@ public void testBackupUserDeployedJarFiles() throws Exception {
      */
     File deployedJarFile = vm0.invoke(() -> {
       DeployedJar deployedJar =
-          ClassPathLoader.getLatest().getJarDeployer().deploy(jarName, classBytes);
+          ClassPathLoader.getLatest().getJarDeployer().deploy(jarName, jarFile);
       return deployedJar.getFile();
     });
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/JMXMBeanDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/JMXMBeanDUnitTest.java
index 31e8baa02d..1c2717e6d4 100644
--- a/geode-core/src/test/java/org/apache/geode/management/JMXMBeanDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/JMXMBeanDUnitTest.java
@@ -197,7 +197,7 @@ private void validateJmxConnection(MBeanServerConnectionRule mBeanServerConnecti
       throws Exception {
     // Get MBean proxy instance that will be used to make calls to registered MBean
     DistributedSystemMXBean distributedSystemMXBean =
-        mBeanServerConnectionRule.getProxyMBean(DistributedSystemMXBean.class);
+        mBeanServerConnectionRule.getProxyMXBean(DistributedSystemMXBean.class);
     assertEquals(1, distributedSystemMXBean.getMemberCount());
     assertEquals(1, distributedSystemMXBean.getLocatorCount());
   }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/beans/FileUploaderTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/beans/FileUploaderTest.java
new file mode 100644
index 0000000000..4f9e97d98e
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/beans/FileUploaderTest.java
@@ -0,0 +1,84 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.beans;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.io.FileUtils;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+import org.junit.rules.TemporaryFolder;
+
+import org.apache.geode.security.GemFireSecurityException;
+import org.apache.geode.test.junit.categories.UnitTest;
+
+
+@Category(UnitTest.class)
+public class FileUploaderTest {
+
+  @Rule
+  public TemporaryFolder temporaryFolder = new TemporaryFolder();
+
+  private FileUploader fileUploader;
+  private List<String> files;
+
+  @Before
+  public void before() {
+    fileUploader = new FileUploader();
+    files = new ArrayList<>();
+  }
+
+  @Test
+  // this is to make sure that the naming convention of the fileuploader is MBean compliant
+  public void fileUploaderAndInterfaceInTheSamePackage() {
+    String fileUploaderClassName = FileUploader.class.getName();
+    String parentName = FileUploader.class.getInterfaces()[0].getName();
+    assertThat(fileUploaderClassName + "MBean").isEqualTo(parentName);
+  }
+
+  @Test
+  public void delteFileNotInTheUploadedDir() throws IOException {
+    File file = temporaryFolder.newFile("a.jar");
+    files.add(file.getAbsolutePath());
+
+    assertThatThrownBy(() -> fileUploader.deleteFiles(files))
+        .isInstanceOf(GemFireSecurityException.class);
+  }
+
+  @Test
+  public void deleteFilesInUploadedDir() throws IOException {
+    File dir = temporaryFolder.newFolder(FileUploader.STAGED_DIR_PREFIX + "test");
+    File file = new File(dir, "test.txt");
+    FileUtils.writeStringToFile(file, "test", "UTF-8");
+
+    assertThat(file).exists();
+    files.add(file.getAbsolutePath());
+
+    fileUploader.deleteFiles(files);
+
+    // assertThat both parent dir and file are deleted
+    assertThat(file).doesNotExist();
+    assertThat(dir).doesNotExist();
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/beans/RegionMBeanAttributesTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/beans/RegionMBeanAttributesTest.java
index 0ab77b0119..2a2fed0330 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/beans/RegionMBeanAttributesTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/beans/RegionMBeanAttributesTest.java
@@ -64,7 +64,7 @@ public void regionMBeanContainsAsyncEventQueueId() throws Exception {
     gfsh.executeAndAssertThat("alter region --name=FOO --async-event-queue-id=AEQ1")
         .statusIsSuccess();
 
-    bean = mBeanRule.getProxyMBean(RegionMXBean.class);
+    bean = mBeanRule.getProxyMXBean(RegionMXBean.class);
 
     assertThat(bean).isNotNull();
     Set<String> eventQueueIds = bean.listRegionAttributes().getAsyncEventQueueIds();
@@ -79,7 +79,7 @@ public void removingEventQueueAlsoRemovesFromMBean() throws Exception {
     gfsh.executeAndAssertThat("alter region --name=FOO --async-event-queue-id=AEQ1")
         .statusIsSuccess();
 
-    bean = mBeanRule.getProxyMBean(RegionMXBean.class);
+    bean = mBeanRule.getProxyMXBean(RegionMXBean.class);
 
     assertThat(bean).isNotNull();
     Set<String> eventQueueIds = bean.listRegionAttributes().getAsyncEventQueueIds();
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandRedeployDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandRedeployDUnitTest.java
index 629360a452..23387f43e9 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandRedeployDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandRedeployDUnitTest.java
@@ -209,7 +209,7 @@ private static void assertThatFunctionHasVersion(String functionId, String versi
 
   private static void assertThatCanLoad(String jarName, String className)
       throws ClassNotFoundException {
-    assertThat(ClassPathLoader.getLatest().getJarDeployer().findDeployedJar(jarName)).isNotNull();
+    assertThat(ClassPathLoader.getLatest().getJarDeployer().getDeployedJar(jarName)).isNotNull();
     assertThat(ClassPathLoader.getLatest().forName(className)).isNotNull();
   }
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandTest.java
new file mode 100644
index 0000000000..b585309ec5
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployCommandTest.java
@@ -0,0 +1,63 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.commands;
+
+import static org.mockito.Mockito.spy;
+
+import org.junit.Before;
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.test.junit.categories.UnitTest;
+import org.apache.geode.test.junit.rules.GfshParserRule;
+
+@Category(UnitTest.class)
+public class DeployCommandTest {
+
+  @ClassRule
+  public static GfshParserRule gfsh = new GfshParserRule();
+
+  private DeployCommand command;
+
+  @Before
+  public void before() {
+    command = spy(DeployCommand.class);
+  }
+
+  @Test
+  public void jarNotFound() {
+    gfsh.executeAndAssertThat(command, "deploy --jar=abc.jar").statusIsError()
+        .containsOutput("not found");
+  }
+
+  @Test
+  public void notDirectory() {
+    gfsh.executeAndAssertThat(command, "deploy --dir=notExist").statusIsError()
+        .containsOutput("not a directory");
+  }
+
+  @Test
+  public void bothDirAndJar() {
+    gfsh.executeAndAssertThat(command, "deploy --dir=a --jar=b").statusIsError()
+        .containsOutput("can not both be specified");
+  }
+
+  @Test
+  public void missingDirOrJar() {
+    gfsh.executeAndAssertThat(command, "deploy").statusIsError().containsOutput("is required");
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployWithGroupsDUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployWithGroupsDUnitTest.java
index 9198a0d6b1..6441df7ce6 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployWithGroupsDUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/commands/DeployWithGroupsDUnitTest.java
@@ -253,12 +253,12 @@ public void undeployOfMultipleJars() throws Exception {
   }
 
   private void assertThatCanLoad(String jarName, String className) throws ClassNotFoundException {
-    assertThat(ClassPathLoader.getLatest().getJarDeployer().findDeployedJar(jarName)).isNotNull();
+    assertThat(ClassPathLoader.getLatest().getJarDeployer().getDeployedJar(jarName)).isNotNull();
     assertThat(ClassPathLoader.getLatest().forName(className)).isNotNull();
   }
 
   private void assertThatCannotLoad(String jarName, String className) {
-    assertThat(ClassPathLoader.getLatest().getJarDeployer().findDeployedJar(jarName)).isNull();
+    assertThat(ClassPathLoader.getLatest().getJarDeployer().getDeployedJar(jarName)).isNull();
     assertThatThrownBy(() -> ClassPathLoader.getLatest().forName(className))
         .isExactlyInstanceOf(ClassNotFoundException.class);
   }
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/remote/OnlineCommandProcessorTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/remote/OnlineCommandProcessorTest.java
index df00cf17aa..f4e2955d03 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/remote/OnlineCommandProcessorTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/remote/OnlineCommandProcessorTest.java
@@ -24,8 +24,10 @@
 import java.util.Properties;
 
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
+import org.junit.rules.TemporaryFolder;
 
 import org.apache.geode.internal.security.SecurityService;
 import org.apache.geode.management.cli.Result;
@@ -42,6 +44,9 @@
   OnlineCommandProcessor onlineCommandProcessor;
   Result result;
 
+  @Rule
+  public TemporaryFolder temporaryFolder = new TemporaryFolder();
+
   @Before
   public void before() {
     properties = new Properties();
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/result/FileResultTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/result/FileResultTest.java
new file mode 100644
index 0000000000..beb57c019f
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/result/FileResultTest.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.cli.result;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.io.File;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.test.junit.categories.UnitTest;
+
+
+@Category(UnitTest.class)
+public class FileResultTest {
+
+  private FileResult fileResult;
+
+  @Before
+  public void before() {
+    fileResult = new FileResult();
+  }
+
+  @Test
+  public void getFormattedFileList() {
+    fileResult.addFile(new File("file1.txt"));
+    fileResult.addFile(new File("file2.txt"));
+    assertThat(fileResult.getFormattedFileList()).isEqualTo("file1.txt, file2.txt");
+  }
+
+  @Test
+  public void getFiles() {
+    assertThat(fileResult.getFiles()).isEmpty();
+
+    File file1 = new File("file1.txt");
+    File file2 = new File("file2.txt");
+    fileResult.addFile(file1);
+    fileResult.addFile(file2);
+    assertThat(fileResult.getFiles()).containsExactlyInAnyOrder(file1, file2);
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfig.java b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfig.java
index 331d4b70ff..b62231d440 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfig.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/configuration/ClusterConfig.java
@@ -160,7 +160,7 @@ public void verifyServer(MemberVM serverVM) {
       }
 
       for (String jar : this.getJarNames()) {
-        DeployedJar deployedJar = ClassPathLoader.getLatest().getJarDeployer().findDeployedJar(jar);
+        DeployedJar deployedJar = ClassPathLoader.getLatest().getJarDeployer().getDeployedJar(jar);
         assertThat(deployedJar).isNotNull();
         assertThat(Class.forName(nameOfClassContainedInJar(jar), true,
             new URLClassLoader(new URL[] {deployedJar.getFileURL()}))).isNotNull();
@@ -172,7 +172,7 @@ public void verifyServer(MemberVM serverVM) {
       for (String jar : undeployedJarNames) {
         System.out.println("Verifying undeployed jar: " + jar);
         DeployedJar undeployedJar =
-            ClassPathLoader.getLatest().getJarDeployer().findDeployedJar(jar);
+            ClassPathLoader.getLatest().getJarDeployer().getDeployedJar(jar);
         assertThat(undeployedJar).isNull();
       }
     });
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/security/CacheServerMBeanAuthenticationJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/security/CacheServerMBeanAuthenticationJUnitTest.java
index d98ba6850e..511e02ee1f 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/security/CacheServerMBeanAuthenticationJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/security/CacheServerMBeanAuthenticationJUnitTest.java
@@ -43,7 +43,7 @@
 
   @Before
   public void setUp() throws Exception {
-    bean = connectionRule.getProxyMBean(CacheServerMXBean.class, "GemFire:service=CacheServer,*");
+    bean = connectionRule.getProxyMXBean(CacheServerMXBean.class, "GemFire:service=CacheServer,*");
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/security/CacheServerMBeanAuthorizationJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/security/CacheServerMBeanAuthorizationJUnitTest.java
index 8d9ae30a02..66faa391dd 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/security/CacheServerMBeanAuthorizationJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/security/CacheServerMBeanAuthorizationJUnitTest.java
@@ -49,7 +49,7 @@
 
   @Before
   public void setUp() throws Exception {
-    bean = connectionRule.getProxyMBean(CacheServerMXBean.class);
+    bean = connectionRule.getProxyMXBean(CacheServerMXBean.class);
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/security/CacheServerMBeanWithShiroIniIntegrationTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/security/CacheServerMBeanWithShiroIniIntegrationTest.java
index 235440eea4..17f0a5fa37 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/security/CacheServerMBeanWithShiroIniIntegrationTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/security/CacheServerMBeanWithShiroIniIntegrationTest.java
@@ -44,7 +44,7 @@
 
   @Before
   public void setUp() throws Exception {
-    bean = connectionRule.getProxyMBean(CacheServerMXBean.class);
+    bean = connectionRule.getProxyMXBean(CacheServerMXBean.class);
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/security/CliCommandsSecurityTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/security/CliCommandsSecurityTest.java
index 03a78bade5..b39de436d3 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/security/CliCommandsSecurityTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/security/CliCommandsSecurityTest.java
@@ -54,7 +54,7 @@
 
   @Before
   public void setUp() throws Exception {
-    bean = connectionRule.getProxyMBean(MemberMXBean.class);
+    bean = connectionRule.getProxyMXBean(MemberMXBean.class);
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/security/DataCommandsSecurityTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/security/DataCommandsSecurityTest.java
index 9ace4a1639..7bcbabe680 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/security/DataCommandsSecurityTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/security/DataCommandsSecurityTest.java
@@ -59,7 +59,7 @@ public static void beforeClass() throws Exception {
 
   @Before
   public void setUp() throws Exception {
-    bean = connectionRule.getProxyMBean(MemberMXBean.class);
+    bean = connectionRule.getProxyMXBean(MemberMXBean.class);
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/security/DeployCommandsSecurityTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/security/DeployCommandsSecurityTest.java
index 9568647161..8bc4c0ed46 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/security/DeployCommandsSecurityTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/security/DeployCommandsSecurityTest.java
@@ -62,7 +62,7 @@ public static void beforeClass() throws Exception {
 
   @Before
   public void setUp() throws Exception {
-    bean = connectionRule.getProxyMBean(MemberMXBean.class);
+    bean = connectionRule.getProxyMXBean(MemberMXBean.class);
   }
 
 
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/security/DiskStoreMXBeanSecurityJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/security/DiskStoreMXBeanSecurityJUnitTest.java
index 9215de5def..e7a2a4027d 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/security/DiskStoreMXBeanSecurityJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/security/DiskStoreMXBeanSecurityJUnitTest.java
@@ -47,7 +47,7 @@
   @Before
   public void setUp() throws Exception {
     server.getCache().createDiskStoreFactory().create("diskstore");
-    bean = connectionRule.getProxyMBean(DiskStoreMXBean.class);
+    bean = connectionRule.getProxyMXBean(DiskStoreMXBean.class);
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/security/DistributedSystemMXBeanSecurityTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/security/DistributedSystemMXBeanSecurityTest.java
index 171191785d..6b34f0f772 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/security/DistributedSystemMXBeanSecurityTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/security/DistributedSystemMXBeanSecurityTest.java
@@ -50,7 +50,7 @@
 
   @Before
   public void setUp() throws Exception {
-    bean = connectionRule.getProxyMBean(DistributedSystemMXBean.class);
+    bean = connectionRule.getProxyMXBean(DistributedSystemMXBean.class);
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/security/FileUploaderMBeanSecurityTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/security/FileUploaderMBeanSecurityTest.java
new file mode 100644
index 0000000000..e0d0de2c62
--- /dev/null
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/security/FileUploaderMBeanSecurityTest.java
@@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.apache.geode.management.internal.security;
+
+import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_MANAGER;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
+import org.junit.Before;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.geode.management.internal.beans.FileUploaderMBean;
+import org.apache.geode.security.NotAuthorizedException;
+import org.apache.geode.security.SimpleTestSecurityManager;
+import org.apache.geode.security.TestSecurityManager;
+import org.apache.geode.test.junit.categories.IntegrationTest;
+import org.apache.geode.test.junit.categories.SecurityTest;
+import org.apache.geode.test.junit.rules.ConnectionConfiguration;
+import org.apache.geode.test.junit.rules.MBeanServerConnectionRule;
+import org.apache.geode.test.junit.rules.ServerStarterRule;
+
+@Category({IntegrationTest.class, SecurityTest.class})
+public class FileUploaderMBeanSecurityTest {
+
+  private FileUploaderMBean bean;
+
+  @ClassRule
+  public static ServerStarterRule server = new ServerStarterRule().withJMXManager()
+      .withProperty(SECURITY_MANAGER, TestSecurityManager.class.getName())
+      .withSecurityManager(SimpleTestSecurityManager.class).withAutoStart();
+
+  @Rule
+  public MBeanServerConnectionRule connectionRule =
+      new MBeanServerConnectionRule(server::getJmxPort);
+
+  @Before
+  public void setUp() throws Exception {
+    bean = connectionRule.getProxyMBean(FileUploaderMBean.class);
+  }
+
+  @Test
+  @ConnectionConfiguration(user = "clusterManageDeploy", password = "clusterManageDeploy")
+  public void testClusterManageDeployAccess() throws Exception {
+    assertThatThrownBy(() -> bean.uploadFile(null)).isNotInstanceOf(NotAuthorizedException.class);
+  }
+
+  @Test
+  @ConnectionConfiguration(user = "clusterManage", password = "clusterManage")
+  public void testClusterManageAccess() throws Exception {
+    assertThatThrownBy(() -> bean.uploadFile(null)).isNotInstanceOf(NotAuthorizedException.class);
+  }
+}
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/security/GatewayReceiverMBeanSecurityTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/security/GatewayReceiverMBeanSecurityTest.java
index be9d3689fe..773bb5b29d 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/security/GatewayReceiverMBeanSecurityTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/security/GatewayReceiverMBeanSecurityTest.java
@@ -70,7 +70,7 @@ public static void afterClass() {
 
   @Before
   public void before() throws Exception {
-    bean = connectionRule.getProxyMBean(GatewayReceiverMXBean.class);
+    bean = connectionRule.getProxyMXBean(GatewayReceiverMXBean.class);
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/security/GatewaySenderMBeanSecurityTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/security/GatewaySenderMBeanSecurityTest.java
index 35cb467bfb..c274735f78 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/security/GatewaySenderMBeanSecurityTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/security/GatewaySenderMBeanSecurityTest.java
@@ -70,7 +70,7 @@ public static void afterClass() {
 
   @Before
   public void before() throws Exception {
-    bean = connectionRule.getProxyMBean(GatewaySenderMXBean.class);
+    bean = connectionRule.getProxyMXBean(GatewaySenderMXBean.class);
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/security/LockServiceMBeanAuthorizationJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/security/LockServiceMBeanAuthorizationJUnitTest.java
index b3683f24ff..2241713555 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/security/LockServiceMBeanAuthorizationJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/security/LockServiceMBeanAuthorizationJUnitTest.java
@@ -57,7 +57,7 @@ public static void beforeClassSetUp() {
 
   @Before
   public void setUp() throws Exception {
-    lockServiceMBean = connectionRule.getProxyMBean(LockServiceMXBean.class);
+    lockServiceMBean = connectionRule.getProxyMXBean(LockServiceMXBean.class);
   }
 
   @AfterClass
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/security/ManagerMBeanAuthorizationJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/security/ManagerMBeanAuthorizationJUnitTest.java
index a51103fdaf..3f080bbb75 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/security/ManagerMBeanAuthorizationJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/security/ManagerMBeanAuthorizationJUnitTest.java
@@ -63,7 +63,7 @@ public static void beforeClassSetup() throws Exception {
 
   @Before
   public void setUp() throws Exception {
-    managerMXBean = connectionRule.getProxyMBean(ManagerMXBean.class, "GemFire:mock=Manager");
+    managerMXBean = connectionRule.getProxyMXBean(ManagerMXBean.class, "GemFire:mock=Manager");
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/security/MemberMBeanSecurityJUnitTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/security/MemberMBeanSecurityJUnitTest.java
index 7cb0d6f31c..431e60df44 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/security/MemberMBeanSecurityJUnitTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/security/MemberMBeanSecurityJUnitTest.java
@@ -53,7 +53,7 @@
 
   @Before
   public void setUp() throws Exception {
-    bean = connectionRule.getProxyMBean(MemberMXBean.class);
+    bean = connectionRule.getProxyMXBean(MemberMXBean.class);
   }
 
   @Test
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/web/controllers/ShellCommandsControllerProcessCommandTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/web/controllers/ShellCommandsControllerProcessCommandTest.java
index 3c4d8ff9fa..a0139ddf34 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/web/controllers/ShellCommandsControllerProcessCommandTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/web/controllers/ShellCommandsControllerProcessCommandTest.java
@@ -31,6 +31,7 @@
 import org.springframework.http.HttpHeaders;
 import org.springframework.http.MediaType;
 import org.springframework.http.ResponseEntity;
+import org.springframework.web.multipart.MultipartFile;
 
 import org.apache.geode.management.internal.cli.CommandResponseBuilder;
 import org.apache.geode.management.internal.cli.result.CommandResult;
@@ -53,7 +54,7 @@ public void setup() {
     controller = new ShellCommandsController() {
       @Override
       protected String processCommand(String command, final Map<String, String> environment,
-          byte[][] fileData) {
+          MultipartFile[] fileData) {
         return CommandResponseBuilder.createCommandResponseJson("someMember", fakeResult);
       }
     };
diff --git a/geode-core/src/test/java/org/apache/geode/test/junit/rules/MBeanServerConnectionRule.java b/geode-core/src/test/java/org/apache/geode/test/junit/rules/MBeanServerConnectionRule.java
index 4c2e3d23f1..8e1cdca15b 100644
--- a/geode-core/src/test/java/org/apache/geode/test/junit/rules/MBeanServerConnectionRule.java
+++ b/geode-core/src/test/java/org/apache/geode/test/junit/rules/MBeanServerConnectionRule.java
@@ -90,12 +90,36 @@ protected void after(Description description) throws Exception {
     disconnect();
   }
 
+  /**
+   * Retrieve a new proxy MXBean
+   *
+   * @return A new proxy MXBean of the same type with which the class was constructed
+   */
+  public <T> T getProxyMXBean(Class<T> proxyClass, String beanQueryName)
+      throws MalformedObjectNameException, IOException {
+    return JMX.newMXBeanProxy(con, getObjectName(proxyClass, beanQueryName), proxyClass);
+  }
+
   /**
    * Retrieve a new proxy MBean
    *
    * @return A new proxy MBean of the same type with which the class was constructed
    */
   public <T> T getProxyMBean(Class<T> proxyClass, String beanQueryName)
+      throws IOException, MalformedObjectNameException {
+    return JMX.newMBeanProxy(con, getObjectName(proxyClass, beanQueryName), proxyClass);
+  }
+
+  /**
+   * Retrieve a new proxy MBean
+   *
+   * @return A new proxy MBean of the same type with which the class was constructed
+   */
+  public <T> T getProxyMBean(Class<T> proxyClass) throws MalformedObjectNameException, IOException {
+    return getProxyMBean(proxyClass, null);
+  }
+
+  private ObjectName getObjectName(Class<?> proxyClass, String beanQueryName)
       throws MalformedObjectNameException, IOException {
     ObjectName name = null;
     QueryExp query = null;
@@ -112,8 +136,7 @@ protected void after(Description description) throws Exception {
     assertEquals("failed to find only one instance of type " + proxyClass.getName() + " with name "
         + beanQueryName, 1, beans.size());
 
-    return JMX.newMXBeanProxy(con, ((ObjectInstance) beans.toArray()[0]).getObjectName(),
-        proxyClass);
+    return ((ObjectInstance) beans.toArray()[0]).getObjectName();
   }
 
   public AccessControlMXBean getAccessControlMBean() throws Exception {
@@ -122,17 +145,18 @@ public AccessControlMXBean getAccessControlMBean() throws Exception {
   }
 
   /**
-   * Retrieve a new proxy MBean
+   * Retrieve a new proxy MXBean
    *
-   * @return A new proxy MBean of the same type with which the class was constructed
+   * @return A new proxy MXBean of the same type with which the class was constructed
    */
-  public <T> T getProxyMBean(Class<T> proxyClass) throws MalformedObjectNameException, IOException {
-    return getProxyMBean(proxyClass, null);
+  public <T> T getProxyMXBean(Class<T> proxyClass)
+      throws MalformedObjectNameException, IOException {
+    return getProxyMXBean(proxyClass, null);
   }
 
-  public <T> T getProxyMBean(String beanQueryName)
+  public <T> T getProxyMXBean(String beanQueryName)
       throws MalformedObjectNameException, IOException {
-    return getProxyMBean(null, beanQueryName);
+    return getProxyMXBean(null, beanQueryName);
   }
 
   public MBeanServerConnection getMBeanServerConnection() throws IOException {
diff --git a/geode-core/src/test/resources/org/apache/geode/codeAnalysis/sanctionedDataSerializables.txt b/geode-core/src/test/resources/org/apache/geode/codeAnalysis/sanctionedDataSerializables.txt
index e9a08a5290..5194f46485 100644
--- a/geode-core/src/test/resources/org/apache/geode/codeAnalysis/sanctionedDataSerializables.txt
+++ b/geode-core/src/test/resources/org/apache/geode/codeAnalysis/sanctionedDataSerializables.txt
@@ -2089,8 +2089,8 @@ toData,22,2a2bb600682ab400162bb800692ab400172bb80069b1
 toDataPre_GEODE_1_1_1_0,49,2ab400062bb800692ab400032bb8006a2ab400022bb800692ab4001f2bb800692ab400052bb800692ab400042bb80069b1
 
 org/apache/geode/management/internal/configuration/messages/ConfigurationResponse,2
-fromData,36,2a2bb8000eb500042a2bb8000fb500082a2bb80010b5000a2a2bb80011b60012b50005b1
-toData,39,2ab40004c000022bb800072ab400082bb800092ab4000a2bb8000b2ab40005b8000c2bb8000db1
+fromData,28,2a2bb8000bb500042a2bb8000bb500052a2bb8000cb6000db50006b1
+toData,28,2ab400042bb800082ab400052bb800082ab40006b800092bb8000ab1
 
 org/apache/geode/management/internal/configuration/messages/SharedConfigurationStatusRequest,2
 fromData,1,b1
@@ -2135,4 +2135,3 @@ toData,9,2ab400022bb80005b1
 org/apache/geode/redis/internal/DoubleWrapper,2
 fromData,9,2a2bb80004b50002b1
 toData,9,2ab400022bb80003b1
-
diff --git a/geode-junit/src/main/java/org/apache/geode/test/compiler/JarBuilder.java b/geode-junit/src/main/java/org/apache/geode/test/compiler/JarBuilder.java
index c3d4d1972a..0c22801cb4 100644
--- a/geode-junit/src/main/java/org/apache/geode/test/compiler/JarBuilder.java
+++ b/geode-junit/src/main/java/org/apache/geode/test/compiler/JarBuilder.java
@@ -56,15 +56,6 @@
  *   jarBuilder.buildJar(outputJar, sourceFileOne, sourceFileTwo);
  * }
  *
- * &#064;Test
- * public void buildJarUsingClassNames() {
- *   JarBuilder jarBuilder = new JarBuilder();
- *   File outputJar = new File("output.jar");
- *
- *   String classInFooBarPackage = "foo.bar.ClassInFooBarPackage";
- *   String classInDefaultPackage = "ClassInDefaultPackage";
- *   jarBuilder.buildJar(outputJar, classInFooBarPackage, classInDefaultPackage);
- * }
  * </pre>
  **/
 public class JarBuilder {
diff --git a/geode-junit/src/main/java/org/apache/geode/test/junit/rules/gfsh/GfshRule.java b/geode-junit/src/main/java/org/apache/geode/test/junit/rules/gfsh/GfshRule.java
index e2ccf0ca1e..d5e08156e9 100644
--- a/geode-junit/src/main/java/org/apache/geode/test/junit/rules/gfsh/GfshRule.java
+++ b/geode-junit/src/main/java/org/apache/geode/test/junit/rules/gfsh/GfshRule.java
@@ -79,6 +79,10 @@ public TemporaryFolder getTemporaryFolder() {
     return temporaryFolder;
   }
 
+  public Path getGfshPath() {
+    return gfsh;
+  }
+
   public GfshExecution execute(String... commands) {
     return execute(GfshScript.of(commands));
   }
diff --git a/geode-web/src/test/java/org/apache/geode/management/internal/web/util/ConvertUtilsJUnitTest.java b/geode-web/src/test/java/org/apache/geode/management/internal/web/util/ConvertUtilsJUnitTest.java
deleted file mode 100644
index 6c09a2e303..0000000000
--- a/geode-web/src/test/java/org/apache/geode/management/internal/web/util/ConvertUtilsJUnitTest.java
+++ /dev/null
@@ -1,185 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
- * agreements. See the NOTICE file distributed with this work for additional information regarding
- * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-package org.apache.geode.management.internal.web.util;
-
-import static org.junit.Assert.*;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.junit.Test;
-import org.junit.experimental.categories.Category;
-import org.springframework.core.io.ByteArrayResource;
-import org.springframework.core.io.Resource;
-import org.springframework.web.multipart.MultipartFile;
-
-import org.apache.geode.internal.util.IOUtils;
-import org.apache.geode.management.internal.web.io.MultipartFileAdapter;
-import org.apache.geode.test.junit.categories.UnitTest;
-
-/**
- * The ConvertUtilsJUnitTest class is a test suite testing the contract and functionality of the
- * ConvertUtilsJUnitTest class.
- * <p/>
- *
- * @see org.apache.geode.management.internal.web.util.ConvertUtils
- * @see org.junit.Assert
- * @see org.junit.Test
- * @since GemFire 8.0
- */
-@Category(UnitTest.class)
-public class ConvertUtilsJUnitTest {
-
-  private MultipartFile createMultipartFile(final String filename, final byte[] content) {
-    return new MultipartFileAdapter() {
-      @Override
-      public byte[] getBytes() throws IOException {
-        return content;
-      }
-
-      @Override
-      public InputStream getInputStream() throws IOException {
-        return new ByteArrayInputStream(getBytes());
-      }
-
-      @Override
-      public String getName() {
-        return filename;
-      }
-
-      @Override
-      public String getOriginalFilename() {
-        return filename;
-      }
-
-      @Override
-      public long getSize() {
-        return content.length;
-      }
-    };
-  }
-
-  private Resource createResource(final String filename, final byte[] content) {
-    return new ByteArrayResource(content, String.format("Content of file (%1$s).", filename)) {
-      @Override
-      public String getFilename() {
-        return filename;
-      }
-    };
-  }
-
-  @Test
-  public void testConvertFileData() throws IOException {
-    final String[] filenames = {"/path/to/file1.ext", "/path/to/another/file2.ext"};
-    final String[] fileContent =
-        {"This is the contents of file 1.", "This is the contents of file 2."};
-
-    final List<byte[]> fileData = new ArrayList<byte[]>(2);
-
-    for (int index = 0; index < filenames.length; index++) {
-      fileData.add(filenames[index].getBytes());
-      fileData.add(fileContent[index].getBytes());
-    }
-
-    final Resource[] resources =
-        ConvertUtils.convert(fileData.toArray(new byte[fileData.size()][]));
-
-    assertNotNull(resources);
-    assertEquals(filenames.length, resources.length);
-
-    for (int index = 0; index < resources.length; index++) {
-      assertEquals(filenames[index], resources[index].getFilename());
-      assertEquals(fileContent[index],
-          new String(IOUtils.toByteArray(resources[index].getInputStream())));
-    }
-  }
-
-  @Test
-  public void testConvertFileDataWithNull() {
-    final Resource[] resources = ConvertUtils.convert((byte[][]) null);
-
-    assertNotNull(resources);
-    assertEquals(0, resources.length);
-  }
-
-  @Test
-  public void testConvertMultipartFile() throws IOException {
-    final MultipartFile[] files = {
-        createMultipartFile("/path/to/multi-part/file1.txt",
-            "The contents of multi-part file1.".getBytes()),
-        createMultipartFile("/path/to/multi-part/file2.txt",
-            "The contents of multi-part file2.".getBytes())};
-
-    final byte[][] fileData = ConvertUtils.convert(files);
-
-    assertNotNull(fileData);
-    assertEquals(files.length * 2, fileData.length);
-
-    for (int index = 0; index < fileData.length; index += 2) {
-      assertEquals(files[index / 2].getOriginalFilename(), new String(fileData[index]));
-      assertEquals(new String(files[index / 2].getBytes()), new String(fileData[index + 1]));
-    }
-  }
-
-  @Test
-  public void testConvertResource() throws IOException {
-    final Resource[] resources =
-        {createResource("/path/to/file1.txt", "Contents of file1.".getBytes()),
-            createResource("/path/to/file2.txt", "Contents of file2.".getBytes())};
-
-    final byte[][] fileData = ConvertUtils.convert(resources);
-
-    assertNotNull(fileData);
-    assertEquals(resources.length * 2, fileData.length);
-
-    for (int index = 0; index < fileData.length; index += 2) {
-      assertEquals(resources[index / 2].getFilename(), new String(fileData[index]));
-      assertEquals(new String(IOUtils.toByteArray(resources[index / 2].getInputStream())),
-          new String(fileData[index + 1]));
-    }
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void testConvertResourceWithResourceHavingNoFilename() throws IOException {
-    try {
-      ConvertUtils.convert(createResource(null, "test".getBytes()));
-    } catch (IllegalArgumentException expected) {
-      assertEquals(
-          "The filename of Resource (Byte array resource [Content of file (null).]) must be specified!",
-          expected.getMessage());
-      throw expected;
-    }
-  }
-
-  @Test
-  public void testConvertResourceWithEmpty() throws IOException {
-    final byte[][] fileData = ConvertUtils.convert(new Resource[0]);
-
-    assertNotNull(fileData);
-    assertEquals(0, fileData.length);
-  }
-
-  @Test
-  public void testConvertResourceWithNull() throws IOException {
-    final byte[][] fileData = ConvertUtils.convert((Resource[]) null);
-
-    assertNotNull(fileData);
-    assertEquals(0, fileData.length);
-  }
-
-}
diff --git a/gradle/dependency-versions.properties b/gradle/dependency-versions.properties
index 723a2e5e5d..f5bf44ad16 100644
--- a/gradle/dependency-versions.properties
+++ b/gradle/dependency-versions.properties
@@ -80,6 +80,7 @@ powermock.version = 1.7.1
 protobuf-gradle-plugin.version = 0.8.1
 protobuf-java.version = 3.3.1
 protoc.version = 3.0.0
+rmiio.version = 2.1.2
 selenium.version=3.0.1
 shiro.version=1.3.2
 slf4j-api.version = 1.7.24


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 86ddafac529aaba06fcaba05fde378d8e56bb6c1 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=86ddafa ]

GEODE-4131: Do not reference deployed jars as byte arrays anymore (#1212)

* GEODE-4131: Do not reference deployed jars as byte arrays anymore

- All jars are streamed between locators and servers using the RMIIO library.
- Whenever an upload happens (either deploying jars or importing cluster
  config) we stage the files initially and then proceed with the command.

Commit 86ddafac529aaba06fcaba05fde378d8e56bb6c1 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=86ddafa ]

GEODE-4131: Do not reference deployed jars as byte arrays anymore (#1212)

* GEODE-4131: Do not reference deployed jars as byte arrays anymore

- All jars are streamed between locators and servers using the RMIIO library.
- Whenever an upload happens (either deploying jars or importing cluster
  config) we stage the files initially and then proceed with the command.

jinmeiliao opened a new pull request #1231: GEODE-4131: add the deprecated API in MemberMXBean
URL: https://github.com/apache/geode/pull/1231
 
 
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao closed pull request #1231: GEODE-4131: add the deprecated API in MemberMXBean
URL: https://github.com/apache/geode/pull/1231
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-core/src/main/java/org/apache/geode/management/MemberMXBean.java b/geode-core/src/main/java/org/apache/geode/management/MemberMXBean.java
index 68eb10586d..15a309c3ab 100644
--- a/geode-core/src/main/java/org/apache/geode/management/MemberMXBean.java
+++ b/geode-core/src/main/java/org/apache/geode/management/MemberMXBean.java
@@ -222,6 +222,22 @@
   String processCommand(String commandString, Map<String, String> env,
       List<String> stagedFilePaths);
 
+  /**
+   * Executes a command on the member. this is the method that's used by the HttpOperationInvoker
+   * and JmxOperationInvoker
+   *
+   * @param commandString Command to be execute.
+   * @param env Environmental properties to use during command execution.
+   * @param binaryData Binary data specific to the command being executed.
+   * @return Result of the execution in JSON format.
+   *
+   * @deprecated since 1.4 use processCommand(String commandString, Map<String, String> env,
+   *             List<String> stagedFilePaths) instead
+   */
+  @Deprecated
+  @ResourceOperation()
+  String processCommand(String commandString, Map<String, String> env, Byte[][] binaryData);
+
   /**
    * Returns the name of all disk stores in use by this member.
    *
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/beans/MemberMBean.java b/geode-core/src/main/java/org/apache/geode/management/internal/beans/MemberMBean.java
index c5410512c0..b05258f03a 100644
--- a/geode-core/src/main/java/org/apache/geode/management/internal/beans/MemberMBean.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/beans/MemberMBean.java
@@ -14,16 +14,21 @@
  */
 package org.apache.geode.management.internal.beans;
 
+import java.io.File;
+import java.io.IOException;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
 import javax.management.NotificationBroadcasterSupport;
 
+import org.apache.commons.io.FileUtils;
+
 import org.apache.geode.management.GemFireProperties;
 import org.apache.geode.management.JVMMetrics;
 import org.apache.geode.management.MemberMXBean;
 import org.apache.geode.management.OSMetrics;
+import org.apache.geode.management.internal.cli.CliUtil;
 
 /**
  * This MBean is a gateway to cache and a member
@@ -398,7 +403,7 @@ public String processCommand(String commandString) {
 
   @Override
   public String processCommand(String commandString, Map<String, String> env) {
-    return processCommand(commandString, env, null);
+    return processCommand(commandString, env, (List<String>) null);
   }
 
   @Override
@@ -407,6 +412,29 @@ public String processCommand(String commandString, Map<String, String> env,
     return bridge.processCommand(commandString, env, stagedFilePaths);
   }
 
+  @Override
+  /**
+   * We don't expect any callers to call this code, but just in case, implementation is provided for
+   * backward compatibility
+   *
+   * @deprecated since 1.4 use processCommand(String commandString, Map<String, String> env,
+   *             List<String> stagedFilePaths)
+   */
+  public String processCommand(String commandString, Map<String, String> env, Byte[][] binaryData) {
+    // save the binaryData into stagedFile first, and then call the new api
+    File tempDir = FileUtils.getTempDirectory();
+    List<String> filePaths = null;
+    try {
+      filePaths = CliUtil.bytesToFiles(binaryData, tempDir.getAbsolutePath());
+      return bridge.processCommand(commandString, env, filePaths);
+    } catch (IOException e) {
+      throw new RuntimeException(e.getMessage(), e);
+    } finally {
+      // delete the staged files
+      FileUtils.deleteQuietly(tempDir);
+    }
+  }
+
   @Override
   public String[] listDiskStores(boolean includeRegionOwned) {
     return bridge.listDiskStores(includeRegionOwned);
diff --git a/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java b/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java
index 6718fe00e2..ed6ee28445 100755
--- a/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java
+++ b/geode-core/src/main/java/org/apache/geode/management/internal/cli/CliUtil.java
@@ -40,6 +40,7 @@
 import java.util.zip.Deflater;
 import java.util.zip.Inflater;
 
+import org.apache.commons.lang.ArrayUtils;
 import org.apache.commons.lang.StringUtils;
 
 import org.apache.geode.cache.CacheClosedException;
@@ -127,7 +128,14 @@ public static InternalCache getCacheIfExists() {
     return cache;
   }
 
-  public static byte[][] filesToBytes(String[] fileNames) throws IOException {
+  /**
+   * Even thought this is only used in a test, caller of MemberMXBean.processCommand(String, Map,
+   * Byte[][]) will need to use this method to convert a fileList to Byte[][] to call that
+   * deprecated API.
+   *
+   * Once that deprecated API is removed, we can delete this method and the tests.
+   */
+  public static Byte[][] filesToBytes(List<String> fileNames) throws IOException {
     List<byte[]> filesDataList = new ArrayList<>();
 
     for (String fileName : fileNames) {
@@ -151,11 +159,10 @@ public static InternalCache getCacheIfExists() {
       }
     }
 
-    byte[][] filesData = new byte[filesDataList.size()][];
-
-    filesData = filesDataList.toArray(filesData);
+    List<Byte[]> convertedList =
+        filesDataList.stream().map(ArrayUtils::toObject).collect(Collectors.toList());
 
-    return filesData;
+    return convertedList.toArray(new Byte[convertedList.size()][]);
   }
 
   public static byte[] toByteArray(InputStream input) throws IOException {
@@ -169,46 +176,32 @@ public static InternalCache getCacheIfExists() {
     return output.toByteArray();
   }
 
-  public static String[] bytesToNames(byte[][] fileData) {
-    String[] names = new String[fileData.length / 2];
-    for (int i = 0; i < fileData.length; i += 2) {
-      names[i / 2] = new String(fileData[i]);
-    }
-
-    return names;
-  }
-
-  public static byte[][] bytesToData(byte[][] fileData) {
-    byte[][] data = new byte[fileData.length / 2][];
-    for (int i = 1; i < fileData.length; i += 2) {
-      data[i / 2] = fileData[i];
-    }
-
-    return data;
-  }
-
-  public static void bytesToFiles(byte[][] fileData, String parentDirPath, boolean mkRequireddirs)
+  public static List<String> bytesToFiles(Byte[][] fileData, String parentDirPath)
       throws IOException, UnsupportedOperationException {
+    List<String> filesPaths = new ArrayList<>();
     FileOutputStream fos = null;
+    File file = null;
 
     File parentDir = new File(parentDirPath);
-    if (mkRequireddirs && !parentDir.exists()) {
-      if (!parentDir.mkdirs()) {
-        throw new UnsupportedOperationException(
-            "Couldn't create required directory structure for " + parentDirPath);
-      }
+    if (!parentDir.exists() && !parentDir.mkdirs()) {
+      throw new UnsupportedOperationException(
+          "Couldn't create required directory structure for " + parentDirPath);
     }
     for (int i = 0; i < fileData.length; i++) {
+      byte[] bytes = ArrayUtils.toPrimitive(fileData[i]);
       if (i % 2 == 0) {
         // Expect file name as bytes at even index
-        String fileName = new String(fileData[i]);
-        fos = new FileOutputStream(new File(parentDir, fileName));
+        String fileName = new String(bytes);
+        file = new File(parentDir, fileName);
+        fos = new FileOutputStream(file);
       } else {
         // Expect file contents as bytes at odd index
-        fos.write(fileData[i]);
+        fos.write(bytes);
         fos.close();
+        filesPaths.add(file.getAbsolutePath());
       }
     }
+    return filesPaths;
   }
 
   private static InternalCache getInternalCache() {
diff --git a/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilTest.java b/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilTest.java
index 9f049c2456..d181054aff 100644
--- a/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilTest.java
+++ b/geode-core/src/test/java/org/apache/geode/management/internal/cli/CliUtilTest.java
@@ -17,8 +17,16 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.commons.io.FileUtils;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
+import org.junit.rules.TemporaryFolder;
 
 import org.apache.geode.test.junit.categories.UnitTest;
 
@@ -26,6 +34,9 @@
 @Category(UnitTest.class)
 public class CliUtilTest {
 
+  @Rule
+  public TemporaryFolder temporaryFolder = new TemporaryFolder();
+
   @Test
   public void arrayToString() throws Exception {
     assertThat(CliUtil.arrayToString(null)).isEqualTo("null");
@@ -36,4 +47,23 @@ public void arrayToString() throws Exception {
     String[] array3 = {null};
     assertThat(CliUtil.arrayToString(array3)).isEqualTo("null");
   }
+
+  @Test
+  public void filesToBytesAndThenBytesToFiles() throws IOException {
+    File file1 = new File(temporaryFolder.getRoot(), "file1.txt");
+    File file2 = new File(temporaryFolder.getRoot(), "file2.txt");
+
+    FileUtils.write(file1, "file1-content", "UTF-8");
+    FileUtils.write(file2, "file2-content", "UTF-8");
+
+    List<String> fileNames = Arrays.asList(file1.getAbsolutePath(), file2.getAbsolutePath());
+    Byte[][] bytes = CliUtil.filesToBytes(fileNames);
+
+    File dir = temporaryFolder.newFolder("temp");
+    List<String> filePaths = CliUtil.bytesToFiles(bytes, dir.getAbsolutePath());
+
+    assertThat(filePaths).hasSize(2);
+    assertThat(new File(filePaths.get(0))).hasContent("file1-content");
+    assertThat(new File(filePaths.get(1))).hasContent("file2-content");
+  }
 }


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 78438f8586610f084c3eec462bc69abe05e1e1b7 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=78438f8 ]

GEODE-4131: add the deprecated API in MemberMXBean (#1231)

* GEODE-4131: add the deprecated API back in MemberMXBean


Commit 78438f8586610f084c3eec462bc69abe05e1e1b7 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=78438f8 ]

GEODE-4131: add the deprecated API in MemberMXBean (#1231)

* GEODE-4131: add the deprecated API back in MemberMXBean


Commit 21d243d950270bb9f265f3a47c4d2ddd8be15cec in geode's branch refs/heads/release/1.4.0 from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=21d243d ]

GEODE-4131: add the deprecated API in MemberMXBean (#1231)

(cherry picked from commit 78438f8)


Part of 1.4 release branch

jinmeiliao opened a new pull request #1247: GEODE-4131: reduce flakiness of the added acceptance test
URL: https://github.com/apache/geode/pull/1247
 
 
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, you check travis-ci for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


jinmeiliao closed pull request #1247: GEODE-4131: reduce flakiness of the added acceptance test
URL: https://github.com/apache/geode/pull/1247
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/DeployWithLargeJarTest.java b/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/DeployWithLargeJarTest.java
index d683226b4e..82d09004ea 100644
--- a/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/DeployWithLargeJarTest.java
+++ b/geode-assembly/src/test/java/org/apache/geode/management/internal/cli/commands/DeployWithLargeJarTest.java
@@ -37,12 +37,10 @@
   @Test
   public void deployLargeSetOfJars() throws Exception {
     File libDir = gfsh.getGfshPath().getParent().getParent().resolve("lib").toFile();
-    String commonLibs = Arrays
-        .stream(libDir
-            .listFiles(x -> x.getName().startsWith("commons") || x.getName().startsWith("spring")))
+    String commonLibs = Arrays.stream(libDir.listFiles(x -> x.getName().startsWith("commons")))
         .map(File::getAbsolutePath).collect(Collectors.joining(","));
-    GfshExecution execution = GfshScript.of("start locator --name=locator --max-heap=64m",
-        "start server --name=server --max-heap=64m", "sleep --time=1",
+    GfshExecution execution = GfshScript.of("start locator --name=locator --max-heap=128m",
+        "start server --name=server --max-heap=128m", "sleep --time=1",
         "deploy --jars=" + commonLibs).execute(gfsh);
   }
 


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 977e16b5665105d2e82ec6621da43de52ac056b2 in geode's branch refs/heads/develop from [~jinmeiliao]
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=977e16b ]

GEODE-4131: reduce flakiness of the added acceptance test (#1247)



