Investigating approach on this.

Leaning towards:

{code}

  template <class Rep, class Period>
  void setEntryIdleTimeout(
      ExpirationAction::Action action,
      const std::chrono::duration<Rep, Period>& idleTimeout);

{code}


Which allows for the caller to do:
{code}
// C++11
o.setEntryIdleTimeout(a, std::chrono::minutes(1));

// C++14
o.setEntryIdleTimeout(a, 1min);
{code}

Also investigating a string parser that would convert to std::chrono::duration for handling timeouts from configuration files (xml, properties, etc.).

"1min" -> std::chrono::minutes(1)
"300s" -> std::chrono::seconds(300)

You get the picture.

Work in progress can be found here https://github.com/pivotal-jbarrett/geode-native/tree/feature/GEODE-3136.

pivotal-jbarrett opened a new pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144
 
 
   - Adds duration utilities.
   - XML Schema changes.
   - Convert CLI time values to TimeSpan.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on issue #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#issuecomment-342504135
 
 
   Hah! The one platform I didn't explicitly test on because it so closely follows the clang builds it the GCC builds on Linux. Looks like there is some sort of issue with ACE and C++11 on the Travis build. I am going to check explicitly with our images produced from our build guid. Please continue to review for other issues.
   
   Compiled and tested on: Solaris x86 (Solaris Studio), MacOS (clang), Windows (VS 2015).

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149397780
 
 

 ##########
 File path: clicache/integration-test/ThinClientAppDomainFunctionExecutionTests.cs
 ##########
 @@ -52,43 +52,45 @@ public void AddResult(TResult result)
     }
     public ICollection<TResult> GetResult()
     {
-      return GetResult(50);
+      return GetResult(TimeSpan.FromSeconds(50));
     }
 
-    public ICollection<TResult> GetResult(UInt32 timeout)
+    public ICollection<TResult> GetResult(TimeSpan timeout)
     {
       m_getResultCount++;
-      if (m_resultReady == true)
-      {
-        return m_results;
-      }
-      else
-      {
-        for (int i = 0; i < timeout; i++)
-        {
-          Thread.Sleep(1000);
-          if (m_resultReady == true)
-          {
-            return m_results;
-          }
 
+      lock (this) {
+        if (!m_resultReady) {
+          if (timeout > TimeSpan.Zero) {
+            if (!Monitor.Wait(this, timeout)) {
 
 Review comment:
   This is so much nicer!

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149398210
 
 

 ##########
 File path: clicache/integration-test/ThinClientAppDomainFunctionExecutionTests.cs
 ##########
 @@ -52,43 +52,45 @@ public void AddResult(TResult result)
     }
     public ICollection<TResult> GetResult()
     {
-      return GetResult(50);
+      return GetResult(TimeSpan.FromSeconds(50));
     }
 
-    public ICollection<TResult> GetResult(UInt32 timeout)
+    public ICollection<TResult> GetResult(TimeSpan timeout)
     {
       m_getResultCount++;
 
 Review comment:
   I see that you're adding a lock around bottom code. What is it locking and why don't you need to protect this count too?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149404730
 
 

 ##########
 File path: clicache/src/impl/PdxInstanceImpl.cpp
 ##########
 @@ -55,7 +55,7 @@ namespace Apache
           m_bufferLength = 0;
           m_pdxType = pdxType;
           m_cache = cache;
-          m_cachePerfStats = &CacheRegionHelper::getCacheImpl(cache->GetNative().get())->getCachePerfStats();
+          //m_cachePerfStats = &CacheRegionHelper::getCacheImpl(cache->GetNative().get())->getCachePerfStats();
 
 Review comment:
   Is this going to be a TODO?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149401240
 
 

 ##########
 File path: clicache/src/CMakeLists.txt
 ##########
 @@ -48,7 +48,7 @@ target_link_libraries(Apache.Geode
 
 string(REPLACE "/EHsc" "/EHa" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
 string(REPLACE "/RTC1" "" CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG}")
-set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /clr /wd4947 /wd4251 /doc")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /clr /wd4947 /wd4251 /wd4635 /doc /we4488")
 
 Review comment:
   What do these flags do and why are they needed now?  Maybe comments would be helpful.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149405933
 
 

 ##########
 File path: cppcache/include/geode/DefaultResultCollector.hpp
 ##########
 @@ -0,0 +1,69 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#ifndef GEODE_DEFAULTRESULTCOLLECTOR_H_
+#define GEODE_DEFAULTRESULTCOLLECTOR_H_
+
+#include <memory>
+#include <chrono>
+#include <mutex>
+#include <condition_variable>
+
+#include "geode_globals.hpp"
+#include "geode_types.hpp"
+
+#include "VectorT.hpp"
+#include "CacheableBuiltins.hpp"
+#include "ResultCollector.hpp"
+
+/**
+ * @file
+ */
+
+namespace apache {
+namespace geode {
+namespace client {
+
+class CPPCACHE_EXPORT DefaultResultCollector : public ResultCollector {
 
 Review comment:
   Why is this class now needed?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149403509
 
 

 ##########
 File path: cppcache/include/geode/util/chrono/duration.hpp
 ##########
 @@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#ifndef GEODE_UTIL_CHRONO_DURATION_H_
+#define GEODE_UTIL_CHRONO_DURATION_H_
+
+#include <string>
+#include <chrono>
+#include <type_traits>
+#include <stdexcept>
+
+namespace apache {
+namespace geode {
+namespace util {
+namespace chrono {
+namespace duration {
+
+template <class Duration>
+struct _suffix {
+  static constexpr char const* value = nullptr;
+};
+template <>
+struct _suffix<std::chrono::hours> {
+  static constexpr char const* value = "h";
+};
+template <>
+struct _suffix<std::chrono::minutes> {
+  static constexpr char const* value = "min";
+};
+template <>
+struct _suffix<std::chrono::seconds> {
+  static constexpr char const* value = "s";
+};
+template <>
+struct _suffix<std::chrono::milliseconds> {
+  static constexpr char const* value = "ms";
+};
+template <>
+struct _suffix<std::chrono::microseconds> {
+  static constexpr char const* value = "us";
+};
+template <>
+struct _suffix<std::chrono::nanoseconds> {
+  static constexpr char const* value = "ns";
+};
+
+template <class T>
+struct _is_duration : std::false_type {};
+
+template <class Rep, class Period>
+struct _is_duration<std::chrono::duration<Rep, Period>> : std::true_type {};
+
+template <class Rep, class Period>
+struct _is_duration<const std::chrono::duration<Rep, Period>> : std::true_type {
+};
+
+template <class Rep, class Period>
+struct _is_duration<volatile std::chrono::duration<Rep, Period>>
+    : std::true_type {};
+
+template <class Rep, class Period>
+struct _is_duration<const volatile std::chrono::duration<Rep, Period>>
+    : std::true_type {};
+
+/**
+ * Converts std::chrono:duration from givene unit to other where other duration
 
 Review comment:
   s/givene/given

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149406472
 
 

 ##########
 File path: cppcache/include/geode/ExceptionTypes.hpp
 ##########
 @@ -31,30 +31,27 @@ namespace apache {
 namespace geode {
 namespace client {
 
-#define _GF_EXCEPTION_DEF(x)                                                 \
-  const char _exception_name_##x[] = "apache::geode::client::" #x;           \
-  class x;                                                                   \
-  typedef std::shared_ptr<x> x##Ptr;                                         \
-  class CPPCACHE_EXPORT x : public apache::geode::client::Exception {        \
-   public:                                                                   \
-    x(const char* msg1, const char* msg2 = nullptr, bool forceStack = false, \
-      const ExceptionPtr& cause = nullptr)                                   \
-        : Exception(msg1, msg2, forceStack, cause) {}                        \
-    x(const x& other) : Exception(other) {}                                  \
-    virtual Exception* clone() const {                                       \
-      return new x(m_message, m_stack, m_cause);                             \
-    }                                                                        \
-    virtual ~x() {}                                                          \
-    virtual const char* getName() const { return _exception_name_##x; }      \
-    virtual void raise() { throw * this; }                                   \
-                                                                             \
-   protected:                                                                \
-    x(const CacheableStringPtr& message, const StackTracePtr& stack,         \
-      const ExceptionPtr& cause)                                             \
-        : Exception(message, stack, cause) {}                                \
-                                                                             \
-   private:                                                                  \
-    const x& operator=(const x&);                                            \
+#define _GF_EXCEPTION_DEF(x)                                            \
+  const char _exception_name_##x[] = "apache::geode::client::" #x;      \
+  class x;                                                              \
+  typedef std::shared_ptr<x> x##Ptr;                                    \
+  class CPPCACHE_EXPORT x : public apache::geode::client::Exception {   \
+   public:                                                              \
+    using Exception::Exception;                                         \
+    virtual Exception* clone() const {                                  \
+      return new x(m_message, m_stack, m_cause);                        \
+    }                                                                   \
+    virtual ~x() {}                                                     \
+    virtual const char* getName() const { return _exception_name_##x; } \
+    virtual void raise() { throw * this; }                              \
+                                                                        \
+   protected:                                                           \
+    x(const CacheableStringPtr& message, const StackTracePtr& stack,    \
+      const ExceptionPtr& cause)                                        \
+        : Exception(message, stack, cause) {}                           \
+                                                                        \
+   private:                                                             \
+    const x& operator=(const x&);                                       \
 
 Review comment:
   Is this an =` delete;`?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149412642
 
 

 ##########
 File path: cppcache/integration-test/testThinClientLRUExpiration.cpp
 ##########
 @@ -655,29 +692,8 @@ DUNIT_TASK(CLIENT2, StepFourCase6)
   {
     doRgnOperations(regionNames[0], 10, 5);
     auto n = getNumOfEntries(regionNames[0]);
-    ASSERT(n == 10,
-           "Ex"
-           "pe"
-           "ct"
-           "ed"
-           " 1"
-           "0 "
-           "en"
-           "tr"
-           "ie"
-           "s");
-    LOG("St"
 
 Review comment:
   Wtf?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149407524
 
 

 ##########
 File path: cppcache/include/geode/RegionFactory.hpp
 ##########
 @@ -249,14 +253,6 @@ class CPPCACHE_EXPORT RegionFactory {
    */
   RegionFactory& setConcurrencyChecksEnabled(bool enable);
 
-  /**
-   * Sets time out for tombstones
-   * @since 7.0
-   * @param tombstoneTimeoutInMSec tombstone timeout in milli second
-   * @return a reference to <code>this</code>
-   */
-  RegionFactory& setTombstoneTimeout(uint32_t tombstoneTimeoutInMSec);
 
 Review comment:
   Is this method deprecated?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149415671
 
 

 ##########
 File path: cppcache/integration-test/testThinClientPdxTests.cpp
 ##########
 @@ -2346,7 +2346,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, generateJavaPdxType)
 
     ResultCollectorPtr collector = funcExec->withArgs(args)
                                        ->withFilter(routingObj)
-                                       ->execute("ComparePdxTypes", true);
 
 Review comment:
   Uhh.. was the boolean implicitly converted to uint32_t?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149421611
 
 

 ##########
 File path: cppcache/src/ExpiryTaskManager.cpp
 ##########
 @@ -58,7 +58,20 @@ long ExpiryTaskManager::scheduleExpiryTask(ACE_Event_Handler* handler,
 
   ACE_Time_Value expTimeValue(expTime);
   ACE_Time_Value intervalValue(interval);
-  LOGFINER("Scheduled expiration ... in %d seconds.", expTime);
+  return m_reactor->schedule_timer(handler, 0, expTimeValue, intervalValue);
+}
+
+long ExpiryTaskManager::scheduleExpiryTask(
 
 Review comment:
   I assume this one is still in-progress?  The old method above still takes uint32_t

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149404384
 
 

 ##########
 File path: clicache/src/TimeSpanUtils.hpp
 ##########
 @@ -0,0 +1,58 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "begin_native.hpp"
+#include <chrono>
+#include <geode/util/chrono/duration.hpp>
+#include "end_native.hpp"
+
+namespace Apache
+{
+  namespace Geode
+  {
+    namespace Client
+    {
+      using namespace System;
+      using namespace apache::geode::util::chrono::duration;
+
+      using ticks = std::chrono::duration<long long, std::ratio<1, 10000000>>;
+      
+      class TimeSpanUtils
+      {
+      public:
+        template <class _Duration>
+        inline static _Duration TimeSpanToDurationCeil(TimeSpan timeSpan)
+        {
+          return _ceil<_Duration>(TimeSpanToDuration(timeSpan));
 
 Review comment:
   What was your naming convention here for _ceil? I'm not used to seeing underscore in front of name of function used by other classes

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149431360
 
 

 ##########
 File path: dependencies/ACE/config.h.in
 ##########
 @@ -14,9 +14,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+ 
 #define ACE_LACKS_IOSTREAM_TOTALLY 1
 #define ACE_HAS_VERSIONED_NAMESPACE 1
 
+#if __cplusplus >= 201103L
+// Force ACE to use C++11 since it fails to autodetect in all cases.
 
 Review comment:
   Hmm.. seems odd

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149424596
 
 

 ##########
 File path: cppcache/src/TcrConnection.cpp
 ##########
 @@ -672,65 +643,33 @@ inline ConnErrType TcrConnection::receiveData(char* buffer, int32_t length,
                       : (length == startLen ? CONN_NODATA : CONN_TIMEOUT));
 }
 
-inline ConnErrType TcrConnection::sendData(const char* buffer, int32_t length,
-                                           uint32_t sendTimeoutSec,
-                                           bool checkConnected) {
-  uint32_t dummy = 0;
-  return sendData(dummy, buffer, length, sendTimeoutSec, checkConnected);
+inline ConnErrType TcrConnection::sendData(
+    const char* buffer, int32_t length, std::chrono::microseconds sendTimeout,
+    bool checkConnected) {
+  std::chrono::microseconds dummy{0};
+  return sendData(dummy, buffer, length, sendTimeout, checkConnected);
 }
 
-inline ConnErrType TcrConnection::sendData(uint32_t& timeSpent,
-                                           const char* buffer, int32_t length,
-                                           uint32_t sendTimeoutSec,
-                                           bool checkConnected,
-                                           int32_t notPublicApiWithTimeout) {
+inline ConnErrType TcrConnection::sendData(
+    std::chrono::microseconds& timeSpent, const char* buffer, int32_t length,
+    std::chrono::microseconds sendTimeout, bool checkConnected) {
   GF_DEV_ASSERT(buffer != nullptr);
   GF_DEV_ASSERT(m_conn != nullptr);
-  bool isPublicApiTimeout = false;
-  // if gfcpp property unit set then sendTimeoutSec will be in millisecond
-  // otherwise it will be in second
-  if (m_poolDM->getConnectionManager()
-          .getCacheImpl()
-          ->getDistributedSystem()
-          .getSystemProperties()
-          .readTimeoutUnitInMillis()) {
-    LOGFINER("sendData %d  %d", sendTimeoutSec, notPublicApiWithTimeout);
-    if (notPublicApiWithTimeout == TcrMessage::QUERY ||
 
 Review comment:
   What happened to all this code? Was it not needed?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149405518
 
 

 ##########
 File path: cppcache/include/geode/AttributesMutator.hpp
 ##########
 @@ -64,13 +68,13 @@ class CPPCACHE_EXPORT AttributesMutator {
   virtual ~AttributesMutator();
 
   /** Sets the idleTimeout duration for region entries.
-   * @param idleTimeout the idleTimeout in seconds for entries in this region.
+   * @param idleTimeout the idleTimeout for entries in this region.
    * @return the previous value.
    * @throw IllegalStateException if the new idleTimeout changes entry
    * expiration from
    *   disabled to enabled or enabled to disabled.
    */
-  int32_t setEntryIdleTimeout(int32_t idleTimeout);
+  std::chrono::seconds setEntryIdleTimeout(std::chrono::seconds idleTimeout);
 
 Review comment:
   I like it, self-documenting code!

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149408979
 
 

 ##########
 File path: cppcache/include/geode/util/chrono/duration.hpp
 ##########
 @@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#ifndef GEODE_UTIL_CHRONO_DURATION_H_
+#define GEODE_UTIL_CHRONO_DURATION_H_
+
+#include <string>
+#include <chrono>
+#include <type_traits>
+#include <stdexcept>
+
+namespace apache {
+namespace geode {
+namespace util {
+namespace chrono {
+namespace duration {
+
+template <class Duration>
+struct _suffix {
+  static constexpr char const* value = nullptr;
+};
+template <>
+struct _suffix<std::chrono::hours> {
+  static constexpr char const* value = "h";
+};
+template <>
+struct _suffix<std::chrono::minutes> {
+  static constexpr char const* value = "min";
+};
+template <>
+struct _suffix<std::chrono::seconds> {
+  static constexpr char const* value = "s";
+};
+template <>
+struct _suffix<std::chrono::milliseconds> {
+  static constexpr char const* value = "ms";
+};
+template <>
+struct _suffix<std::chrono::microseconds> {
+  static constexpr char const* value = "us";
+};
+template <>
+struct _suffix<std::chrono::nanoseconds> {
+  static constexpr char const* value = "ns";
+};
+
+template <class T>
+struct _is_duration : std::false_type {};
+
+template <class Rep, class Period>
+struct _is_duration<std::chrono::duration<Rep, Period>> : std::true_type {};
+
+template <class Rep, class Period>
+struct _is_duration<const std::chrono::duration<Rep, Period>> : std::true_type {
+};
+
+template <class Rep, class Period>
+struct _is_duration<volatile std::chrono::duration<Rep, Period>>
 
 Review comment:
   Can you explain why we need volatile here?  Are all these specializations needed and used?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149422169
 
 

 ##########
 File path: cppcache/src/LocalRegion.cpp
 ##########
 @@ -346,15 +348,16 @@ void LocalRegion::localPut(const CacheableKeyPtr& key,
   GfErrTypeToException("Region::localPut", err);
 }
 
-void LocalRegion::putAll(const HashMapOfCacheable& map, uint32_t timeout,
+void LocalRegion::putAll(const HashMapOfCacheable& map,
+                         std::chrono::milliseconds timeout,
                          const SerializablePtr& aCallbackArgument) {
-  if ((timeout * 1000) >= 0x7fffffff) {
-    throw IllegalArgumentException(
-        "Region::putAll: timeout parameter "
-        "greater than maximum allowed (2^31/1000 i.e 2147483).");
-  }
-  int64_t sampleStartNanos = startStatOpTime();
-  GfErrType err = putAllNoThrow(map, timeout, aCallbackArgument);
+  //  if ((timeout * 1000) >= 0x7fffffff) {
 
 Review comment:
   TODO?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149418101
 
 

 ##########
 File path: cppcache/src/CacheTransactionManagerImpl.hpp
 ##########
 @@ -45,20 +39,20 @@ class CacheTransactionManagerImpl
   CacheTransactionManagerImpl(Cache* cache);
   virtual ~CacheTransactionManagerImpl();
 
-  virtual void begin();
-  virtual void commit();
-  virtual void rollback();
-  virtual bool exists();
-  virtual TransactionIdPtr suspend();
-  virtual void resume(TransactionIdPtr transactionId);
-  virtual bool isSuspended(TransactionIdPtr transactionId);
-  virtual bool tryResume(TransactionIdPtr transactionId);
+  virtual void begin() override;
 
 Review comment:
   Woot for override!

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149431901
 
 

 ##########
 File path: cppcache/test/util/chrono/durationTest.cpp
 ##########
 @@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <chrono>
+
+#include <gtest/gtest.h>
+
+#include <geode/util/chrono/duration.hpp>
+
+using namespace apache::geode::util::chrono::duration;
+
+TEST(util_chrono_durationTest, ceil) {
+  EXPECT_EQ(std::chrono::seconds(1),
+            _ceil<std::chrono::seconds>(std::chrono::milliseconds(1)));
+  EXPECT_EQ(std::chrono::milliseconds(1),
+            _ceil<std::chrono::milliseconds>(std::chrono::milliseconds(1)));
+  EXPECT_EQ(std::chrono::microseconds(1000),
+            _ceil<std::chrono::milliseconds>(std::chrono::milliseconds(1)));
+}
+
+TEST(util_chrono_durationTest, to_string) {
+  EXPECT_EQ("42h", to_string(std::chrono::hours(42)));
+  EXPECT_EQ("42min", to_string(std::chrono::minutes(42)));
+  EXPECT_EQ("42s", to_string(std::chrono::seconds(42)));
+  EXPECT_EQ("42ms", to_string(std::chrono::milliseconds(42)));
+  EXPECT_EQ("42us", to_string(std::chrono::microseconds(42)));
+  EXPECT_EQ("42ns", to_string(std::chrono::nanoseconds(42)));
+}
+
+TEST(util_chrono_durationTest, from_string) {
 
 Review comment:
   Nice! Unittests!  What do negative numbers do?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149416585
 
 

 ##########
 File path: cppcache/integration-test/testThinClientRemoteQueryTimeout.cpp
 ##########
 @@ -426,7 +426,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, verifyNegativeValueTimeout)
     try {
       LOG("Task::verifyNegativeValueTimeout - EXECUTE 1 START");
 
-      results = qry->execute(-3);
 
 Review comment:
   We support negatives? Interseting...

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149424284
 
 

 ##########
 File path: cppcache/src/TcrConnection.cpp
 ##########
 @@ -592,56 +593,26 @@ Connector* TcrConnection::createConnection(const char* endpoint,
  *           that is used instead
  *   Body: default timeout
  */
-inline ConnErrType TcrConnection::receiveData(char* buffer, int32_t length,
-                                              uint32_t receiveTimeoutSec,
-                                              bool checkConnected,
-                                              bool isNotificationMessage,
-                                              int32_t notPublicApiWithTimeout) {
+inline ConnErrType TcrConnection::receiveData(
+    char* buffer, int32_t length, std::chrono::microseconds receiveTimeoutSec,
+    bool checkConnected, bool isNotificationMessage) {
   GF_DEV_ASSERT(buffer != nullptr);
   GF_DEV_ASSERT(m_conn != nullptr);
 
-  // if gfcpp property unit set then sendTimeoutSec will be in millisecond
-  // otherwise it will be in second
-  if (m_poolDM->getConnectionManager()
-          .getCacheImpl()
-          ->getDistributedSystem()
-          .getSystemProperties()
-          .readTimeoutUnitInMillis()) {
-    LOGFINER("recieveData %d %d ", receiveTimeoutSec, notPublicApiWithTimeout);
-    if (notPublicApiWithTimeout == TcrMessage::QUERY ||
 
 Review comment:
   What happened to all this code? Was it not needed?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149437438
 
 

 ##########
 File path: clicache/integration-test/ThinClientAppDomainFunctionExecutionTests.cs
 ##########
 @@ -52,43 +52,45 @@ public void AddResult(TResult result)
     }
     public ICollection<TResult> GetResult()
     {
-      return GetResult(50);
+      return GetResult(TimeSpan.FromSeconds(50));
     }
 
-    public ICollection<TResult> GetResult(UInt32 timeout)
+    public ICollection<TResult> GetResult(TimeSpan timeout)
     {
       m_getResultCount++;
 
 Review comment:
   The counter is part of the instrumentation of this test to make sure this method is called. It is never called by more than one thread. In fact the endResult is not called by more than one thread either. Combined though they modify and check the shared ready state with this method waiting on the state change.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149438042
 
 

 ##########
 File path: clicache/integration-test/ThinClientAppDomainFunctionExecutionTests.cs
 ##########
 @@ -52,43 +52,45 @@ public void AddResult(TResult result)
     }
     public ICollection<TResult> GetResult()
     {
-      return GetResult(50);
+      return GetResult(TimeSpan.FromSeconds(50));
     }
 
-    public ICollection<TResult> GetResult(UInt32 timeout)
+    public ICollection<TResult> GetResult(TimeSpan timeout)
     {
       m_getResultCount++;
-      if (m_resultReady == true)
-      {
-        return m_results;
-      }
-      else
-      {
-        for (int i = 0; i < timeout; i++)
-        {
-          Thread.Sleep(1000);
-          if (m_resultReady == true)
-          {
-            return m_results;
-          }
 
+      lock (this) {
+        if (!m_resultReady) {
+          if (timeout > TimeSpan.Zero) {
+            if (!Monitor.Wait(this, timeout)) {
 
 Review comment:
   Yeah and this is still the lazy way to do it in C# (and Java). I am not sure what they though the original code was doing but it wasn’t really correct. There was no barrier to synchronize the ready state across threads. The original also introduced 1s latency.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149438238
 
 

 ##########
 File path: clicache/src/CMakeLists.txt
 ##########
 @@ -48,7 +48,7 @@ target_link_libraries(Apache.Geode
 
 string(REPLACE "/EHsc" "/EHa" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
 string(REPLACE "/RTC1" "" CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG}")
-set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /clr /wd4947 /wd4251 /doc")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /clr /wd4947 /wd4251 /wd4635 /doc /we4488")
 
 Review comment:
   One hides an annoying warning and the other makes a warning about override an error.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149438646
 
 

 ##########
 File path: clicache/src/TimeSpanUtils.hpp
 ##########
 @@ -0,0 +1,58 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "begin_native.hpp"
+#include <chrono>
+#include <geode/util/chrono/duration.hpp>
+#include "end_native.hpp"
+
+namespace Apache
+{
+  namespace Geode
+  {
+    namespace Client
+    {
+      using namespace System;
+      using namespace apache::geode::util::chrono::duration;
+
+      using ticks = std::chrono::duration<long long, std::ratio<1, 10000000>>;
+      
+      class TimeSpanUtils
+      {
+      public:
+        template <class _Duration>
+        inline static _Duration TimeSpanToDurationCeil(TimeSpan timeSpan)
+        {
+          return _ceil<_Duration>(TimeSpanToDuration(timeSpan));
 
 Review comment:
   It’s to denote internal use only. I should probably document it. I think we can actually move the whole header internal too. Originally I had some code in public headers that needed these but didn’t want general consumption.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149438917
 
 

 ##########
 File path: clicache/src/impl/PdxInstanceImpl.cpp
 ##########
 @@ -55,7 +55,7 @@ namespace Apache
           m_bufferLength = 0;
           m_pdxType = pdxType;
           m_cache = cache;
-          m_cachePerfStats = &CacheRegionHelper::getCacheImpl(cache->GetNative().get())->getCachePerfStats();
+          //m_cachePerfStats = &CacheRegionHelper::getCacheImpl(cache->GetNative().get())->getCachePerfStats();
 
 Review comment:
   CRAP! Thanks for this catch.  I was having some strange issues in this class and commented out some bits to track it down.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149439055
 
 

 ##########
 File path: cppcache/include/geode/AttributesMutator.hpp
 ##########
 @@ -64,13 +68,13 @@ class CPPCACHE_EXPORT AttributesMutator {
   virtual ~AttributesMutator();
 
   /** Sets the idleTimeout duration for region entries.
-   * @param idleTimeout the idleTimeout in seconds for entries in this region.
+   * @param idleTimeout the idleTimeout for entries in this region.
    * @return the previous value.
    * @throw IllegalStateException if the new idleTimeout changes entry
    * expiration from
    *   disabled to enabled or enabled to disabled.
    */
-  int32_t setEntryIdleTimeout(int32_t idleTimeout);
+  std::chrono::seconds setEntryIdleTimeout(std::chrono::seconds idleTimeout);
 
 Review comment:
   I know right. Go figure!

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149439586
 
 

 ##########
 File path: cppcache/include/geode/DefaultResultCollector.hpp
 ##########
 @@ -0,0 +1,69 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#ifndef GEODE_DEFAULTRESULTCOLLECTOR_H_
+#define GEODE_DEFAULTRESULTCOLLECTOR_H_
+
+#include <memory>
+#include <chrono>
+#include <mutex>
+#include <condition_variable>
+
+#include "geode_globals.hpp"
+#include "geode_types.hpp"
+
+#include "VectorT.hpp"
+#include "CacheableBuiltins.hpp"
+#include "ResultCollector.hpp"
+
+/**
+ * @file
+ */
+
+namespace apache {
+namespace geode {
+namespace client {
+
+class CPPCACHE_EXPORT DefaultResultCollector : public ResultCollector {
 
 Review comment:
   Had to extract a pure virtual interface out of the original header to avoid needing mutex in header which causes compiler failure in /clr mode for .NET. The internal result collect uses this and the integration tests result collectors extend it.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149439933
 
 

 ##########
 File path: cppcache/include/geode/ExceptionTypes.hpp
 ##########
 @@ -31,30 +31,27 @@ namespace apache {
 namespace geode {
 namespace client {
 
-#define _GF_EXCEPTION_DEF(x)                                                 \
-  const char _exception_name_##x[] = "apache::geode::client::" #x;           \
-  class x;                                                                   \
-  typedef std::shared_ptr<x> x##Ptr;                                         \
-  class CPPCACHE_EXPORT x : public apache::geode::client::Exception {        \
-   public:                                                                   \
-    x(const char* msg1, const char* msg2 = nullptr, bool forceStack = false, \
-      const ExceptionPtr& cause = nullptr)                                   \
-        : Exception(msg1, msg2, forceStack, cause) {}                        \
-    x(const x& other) : Exception(other) {}                                  \
-    virtual Exception* clone() const {                                       \
-      return new x(m_message, m_stack, m_cause);                             \
-    }                                                                        \
-    virtual ~x() {}                                                          \
-    virtual const char* getName() const { return _exception_name_##x; }      \
-    virtual void raise() { throw * this; }                                   \
-                                                                             \
-   protected:                                                                \
-    x(const CacheableStringPtr& message, const StackTracePtr& stack,         \
-      const ExceptionPtr& cause)                                             \
-        : Exception(message, stack, cause) {}                                \
-                                                                             \
-   private:                                                                  \
-    const x& operator=(const x&);                                            \
+#define _GF_EXCEPTION_DEF(x)                                            \
+  const char _exception_name_##x[] = "apache::geode::client::" #x;      \
+  class x;                                                              \
+  typedef std::shared_ptr<x> x##Ptr;                                    \
+  class CPPCACHE_EXPORT x : public apache::geode::client::Exception {   \
+   public:                                                              \
+    using Exception::Exception;                                         \
+    virtual Exception* clone() const {                                  \
+      return new x(m_message, m_stack, m_cause);                        \
+    }                                                                   \
+    virtual ~x() {}                                                     \
+    virtual const char* getName() const { return _exception_name_##x; } \
+    virtual void raise() { throw * this; }                              \
+                                                                        \
+   protected:                                                           \
+    x(const CacheableStringPtr& message, const StackTracePtr& stack,    \
+      const ExceptionPtr& cause)                                        \
+        : Exception(message, stack, cause) {}                           \
+                                                                        \
+   private:                                                             \
+    const x& operator=(const x&);                                       \
 
 Review comment:
   I can’t remeber what this change was for. I’ll have to dig into more detail.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149440512
 
 

 ##########
 File path: cppcache/include/geode/RegionFactory.hpp
 ##########
 @@ -249,14 +253,6 @@ class CPPCACHE_EXPORT RegionFactory {
    */
   RegionFactory& setConcurrencyChecksEnabled(bool enable);
 
-  /**
-   * Sets time out for tombstones
-   * @since 7.0
-   * @param tombstoneTimeoutInMSec tombstone timeout in milli second
-   * @return a reference to <code>this</code>
-   */
-  RegionFactory& setTombstoneTimeout(uint32_t tombstoneTimeoutInMSec);
 
 Review comment:
   I think I found that it was never implemented in  any file and since nothing tested it the compiler and linker never complained it was unimplemented.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149440995
 
 

 ##########
 File path: cppcache/include/geode/util/chrono/duration.hpp
 ##########
 @@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#ifndef GEODE_UTIL_CHRONO_DURATION_H_
+#define GEODE_UTIL_CHRONO_DURATION_H_
+
+#include <string>
+#include <chrono>
+#include <type_traits>
+#include <stdexcept>
+
+namespace apache {
+namespace geode {
+namespace util {
+namespace chrono {
+namespace duration {
+
+template <class Duration>
+struct _suffix {
+  static constexpr char const* value = nullptr;
+};
+template <>
+struct _suffix<std::chrono::hours> {
+  static constexpr char const* value = "h";
+};
+template <>
+struct _suffix<std::chrono::minutes> {
+  static constexpr char const* value = "min";
+};
+template <>
+struct _suffix<std::chrono::seconds> {
+  static constexpr char const* value = "s";
+};
+template <>
+struct _suffix<std::chrono::milliseconds> {
+  static constexpr char const* value = "ms";
+};
+template <>
+struct _suffix<std::chrono::microseconds> {
+  static constexpr char const* value = "us";
+};
+template <>
+struct _suffix<std::chrono::nanoseconds> {
+  static constexpr char const* value = "ns";
+};
+
+template <class T>
+struct _is_duration : std::false_type {};
+
+template <class Rep, class Period>
+struct _is_duration<std::chrono::duration<Rep, Period>> : std::true_type {};
+
+template <class Rep, class Period>
+struct _is_duration<const std::chrono::duration<Rep, Period>> : std::true_type {
+};
+
+template <class Rep, class Period>
+struct _is_duration<volatile std::chrono::duration<Rep, Period>>
 
 Review comment:
   I copied this trait check template. I think it’s based on the same template in clang. I think it’s just for completeness. We could toss that line.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149441217
 
 

 ##########
 File path: cppcache/integration-test/testThinClientLRUExpiration.cpp
 ##########
 @@ -655,29 +692,8 @@ DUNIT_TASK(CLIENT2, StepFourCase6)
   {
     doRgnOperations(regionNames[0], 10, 5);
     auto n = getNumOfEntries(regionNames[0]);
-    ASSERT(n == 10,
-           "Ex"
-           "pe"
-           "ct"
-           "ed"
-           " 1"
-           "0 "
-           "en"
-           "tr"
-           "ie"
-           "s");
-    LOG("St"
 
 Review comment:
   Yeah, formatted fail?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149441571
 
 

 ##########
 File path: cppcache/integration-test/testThinClientPdxTests.cpp
 ##########
 @@ -2346,7 +2346,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, generateJavaPdxType)
 
     ResultCollectorPtr collector = funcExec->withArgs(args)
                                        ->withFilter(routingObj)
-                                       ->execute("ComparePdxTypes", true);
 
 Review comment:
   We removed some deprecated parameters months ago where this would have matched a different method with defaults. Now it’s closest match was an implicit conversation to int. Fixed it.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149441734
 
 

 ##########
 File path: cppcache/integration-test/testThinClientRemoteQueryTimeout.cpp
 ##########
 @@ -426,7 +426,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, verifyNegativeValueTimeout)
     try {
       LOG("Task::verifyNegativeValueTimeout - EXECUTE 1 START");
 
-      results = qry->execute(-3);
 
 Review comment:
   This test should have been testing an illegal argument exception.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149441953
 
 

 ##########
 File path: cppcache/src/ExpiryTaskManager.cpp
 ##########
 @@ -58,7 +58,20 @@ long ExpiryTaskManager::scheduleExpiryTask(ACE_Event_Handler* handler,
 
   ACE_Time_Value expTimeValue(expTime);
   ACE_Time_Value intervalValue(interval);
-  LOGFINER("Scheduled expiration ... in %d seconds.", expTime);
+  return m_reactor->schedule_timer(handler, 0, expTimeValue, intervalValue);
+}
+
+long ExpiryTaskManager::scheduleExpiryTask(
 
 Review comment:
   Its used internal still. There is another ticket for all internal time.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149442070
 
 

 ##########
 File path: cppcache/src/LocalRegion.cpp
 ##########
 @@ -346,15 +348,16 @@ void LocalRegion::localPut(const CacheableKeyPtr& key,
   GfErrTypeToException("Region::localPut", err);
 }
 
-void LocalRegion::putAll(const HashMapOfCacheable& map, uint32_t timeout,
+void LocalRegion::putAll(const HashMapOfCacheable& map,
+                         std::chrono::milliseconds timeout,
                          const SerializablePtr& aCallbackArgument) {
-  if ((timeout * 1000) >= 0x7fffffff) {
-    throw IllegalArgumentException(
-        "Region::putAll: timeout parameter "
-        "greater than maximum allowed (2^31/1000 i.e 2147483).");
-  }
-  int64_t sampleStartNanos = startStatOpTime();
-  GfErrType err = putAllNoThrow(map, timeout, aCallbackArgument);
+  //  if ((timeout * 1000) >= 0x7fffffff) {
 
 Review comment:
   Shoot, yes!

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149442961
 
 

 ##########
 File path: cppcache/src/TcrConnection.cpp
 ##########
 @@ -592,56 +593,26 @@ Connector* TcrConnection::createConnection(const char* endpoint,
  *           that is used instead
  *   Body: default timeout
  */
-inline ConnErrType TcrConnection::receiveData(char* buffer, int32_t length,
-                                              uint32_t receiveTimeoutSec,
-                                              bool checkConnected,
-                                              bool isNotificationMessage,
-                                              int32_t notPublicApiWithTimeout) {
+inline ConnErrType TcrConnection::receiveData(
+    char* buffer, int32_t length, std::chrono::microseconds receiveTimeoutSec,
+    bool checkConnected, bool isNotificationMessage) {
   GF_DEV_ASSERT(buffer != nullptr);
   GF_DEV_ASSERT(m_conn != nullptr);
 
-  // if gfcpp property unit set then sendTimeoutSec will be in millisecond
-  // otherwise it will be in second
-  if (m_poolDM->getConnectionManager()
-          .getCacheImpl()
-          ->getDistributedSystem()
-          .getSystemProperties()
-          .readTimeoutUnitInMillis()) {
-    LOGFINER("recieveData %d %d ", receiveTimeoutSec, notPublicApiWithTimeout);
-    if (notPublicApiWithTimeout == TcrMessage::QUERY ||
 
 Review comment:
   Correct. All this code was figuring out if that “treat time as milliseconds” flag as set and if message was of any of these types then treat a milliseconds otherwise seconds. All goes away with strongly typed time units.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149442764
 
 

 ##########
 File path: cppcache/src/TcrConnection.cpp
 ##########
 @@ -592,56 +593,26 @@ Connector* TcrConnection::createConnection(const char* endpoint,
  *           that is used instead
  *   Body: default timeout
  */
-inline ConnErrType TcrConnection::receiveData(char* buffer, int32_t length,
-                                              uint32_t receiveTimeoutSec,
-                                              bool checkConnected,
-                                              bool isNotificationMessage,
-                                              int32_t notPublicApiWithTimeout) {
+inline ConnErrType TcrConnection::receiveData(
+    char* buffer, int32_t length, std::chrono::microseconds receiveTimeoutSec,
+    bool checkConnected, bool isNotificationMessage) {
   GF_DEV_ASSERT(buffer != nullptr);
   GF_DEV_ASSERT(m_conn != nullptr);
 
-  // if gfcpp property unit set then sendTimeoutSec will be in millisecond
-  // otherwise it will be in second
-  if (m_poolDM->getConnectionManager()
-          .getCacheImpl()
-          ->getDistributedSystem()
-          .getSystemProperties()
-          .readTimeoutUnitInMillis()) {
-    LOGFINER("recieveData %d %d ", receiveTimeoutSec, notPublicApiWithTimeout);
-    if (notPublicApiWithTimeout == TcrMessage::QUERY ||
 
 Review comment:
   Correct. All this code was figuring out if that “treat time as milliseconds” flag as set and if message was of any of these types then treat a milliseconds otherwise seconds. All goes away with strongly typed time units.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149443032
 
 

 ##########
 File path: cppcache/src/TcrConnection.cpp
 ##########
 @@ -672,65 +643,33 @@ inline ConnErrType TcrConnection::receiveData(char* buffer, int32_t length,
                       : (length == startLen ? CONN_NODATA : CONN_TIMEOUT));
 }
 
-inline ConnErrType TcrConnection::sendData(const char* buffer, int32_t length,
-                                           uint32_t sendTimeoutSec,
-                                           bool checkConnected) {
-  uint32_t dummy = 0;
-  return sendData(dummy, buffer, length, sendTimeoutSec, checkConnected);
+inline ConnErrType TcrConnection::sendData(
+    const char* buffer, int32_t length, std::chrono::microseconds sendTimeout,
+    bool checkConnected) {
+  std::chrono::microseconds dummy{0};
+  return sendData(dummy, buffer, length, sendTimeout, checkConnected);
 }
 
-inline ConnErrType TcrConnection::sendData(uint32_t& timeSpent,
-                                           const char* buffer, int32_t length,
-                                           uint32_t sendTimeoutSec,
-                                           bool checkConnected,
-                                           int32_t notPublicApiWithTimeout) {
+inline ConnErrType TcrConnection::sendData(
+    std::chrono::microseconds& timeSpent, const char* buffer, int32_t length,
+    std::chrono::microseconds sendTimeout, bool checkConnected) {
   GF_DEV_ASSERT(buffer != nullptr);
   GF_DEV_ASSERT(m_conn != nullptr);
-  bool isPublicApiTimeout = false;
-  // if gfcpp property unit set then sendTimeoutSec will be in millisecond
-  // otherwise it will be in second
-  if (m_poolDM->getConnectionManager()
-          .getCacheImpl()
-          ->getDistributedSystem()
-          .getSystemProperties()
-          .readTimeoutUnitInMillis()) {
-    LOGFINER("sendData %d  %d", sendTimeoutSec, notPublicApiWithTimeout);
-    if (notPublicApiWithTimeout == TcrMessage::QUERY ||
 
 Review comment:
   Correct. All this code was figuring out if that “treat time as milliseconds” flag as set and if message was of any of these types then treat a milliseconds otherwise seconds. All goes away with strongly typed time units.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149443175
 
 

 ##########
 File path: cppcache/test/util/chrono/durationTest.cpp
 ##########
 @@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <chrono>
+
+#include <gtest/gtest.h>
+
+#include <geode/util/chrono/duration.hpp>
+
+using namespace apache::geode::util::chrono::duration;
+
+TEST(util_chrono_durationTest, ceil) {
+  EXPECT_EQ(std::chrono::seconds(1),
+            _ceil<std::chrono::seconds>(std::chrono::milliseconds(1)));
+  EXPECT_EQ(std::chrono::milliseconds(1),
+            _ceil<std::chrono::milliseconds>(std::chrono::milliseconds(1)));
+  EXPECT_EQ(std::chrono::microseconds(1000),
+            _ceil<std::chrono::milliseconds>(std::chrono::milliseconds(1)));
+}
+
+TEST(util_chrono_durationTest, to_string) {
+  EXPECT_EQ("42h", to_string(std::chrono::hours(42)));
+  EXPECT_EQ("42min", to_string(std::chrono::minutes(42)));
+  EXPECT_EQ("42s", to_string(std::chrono::seconds(42)));
+  EXPECT_EQ("42ms", to_string(std::chrono::milliseconds(42)));
+  EXPECT_EQ("42us", to_string(std::chrono::microseconds(42)));
+  EXPECT_EQ("42ns", to_string(std::chrono::nanoseconds(42)));
+}
+
+TEST(util_chrono_durationTest, from_string) {
 
 Review comment:
   Good idea. Should give negative durations.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149443300
 
 

 ##########
 File path: dependencies/ACE/config.h.in
 ##########
 @@ -14,9 +14,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+ 
 #define ACE_LACKS_IOSTREAM_TOTALLY 1
 #define ACE_HAS_VERSIONED_NAMESPACE 1
 
+#if __cplusplus >= 201103L
+// Force ACE to use C++11 since it fails to autodetect in all cases.
 
 Review comment:
   Yeah, and it breaks Linux. I’m investigating.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149442764
 
 

 ##########
 File path: cppcache/src/TcrConnection.cpp
 ##########
 @@ -592,56 +593,26 @@ Connector* TcrConnection::createConnection(const char* endpoint,
  *           that is used instead
  *   Body: default timeout
  */
-inline ConnErrType TcrConnection::receiveData(char* buffer, int32_t length,
-                                              uint32_t receiveTimeoutSec,
-                                              bool checkConnected,
-                                              bool isNotificationMessage,
-                                              int32_t notPublicApiWithTimeout) {
+inline ConnErrType TcrConnection::receiveData(
+    char* buffer, int32_t length, std::chrono::microseconds receiveTimeoutSec,
+    bool checkConnected, bool isNotificationMessage) {
   GF_DEV_ASSERT(buffer != nullptr);
   GF_DEV_ASSERT(m_conn != nullptr);
 
-  // if gfcpp property unit set then sendTimeoutSec will be in millisecond
-  // otherwise it will be in second
-  if (m_poolDM->getConnectionManager()
-          .getCacheImpl()
-          ->getDistributedSystem()
-          .getSystemProperties()
-          .readTimeoutUnitInMillis()) {
-    LOGFINER("recieveData %d %d ", receiveTimeoutSec, notPublicApiWithTimeout);
-    if (notPublicApiWithTimeout == TcrMessage::QUERY ||
 
 Review comment:
   Correct. All this code was figuring out if that “treat time as milliseconds” flag as set and if message was of any of these types then treat a milliseconds otherwise seconds. All goes away with strongly typed time units.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149865272
 
 

 ##########
 File path: cppcache/include/geode/ExceptionTypes.hpp
 ##########
 @@ -31,30 +31,27 @@ namespace apache {
 namespace geode {
 namespace client {
 
-#define _GF_EXCEPTION_DEF(x)                                                 \
-  const char _exception_name_##x[] = "apache::geode::client::" #x;           \
-  class x;                                                                   \
-  typedef std::shared_ptr<x> x##Ptr;                                         \
-  class CPPCACHE_EXPORT x : public apache::geode::client::Exception {        \
-   public:                                                                   \
-    x(const char* msg1, const char* msg2 = nullptr, bool forceStack = false, \
-      const ExceptionPtr& cause = nullptr)                                   \
-        : Exception(msg1, msg2, forceStack, cause) {}                        \
-    x(const x& other) : Exception(other) {}                                  \
-    virtual Exception* clone() const {                                       \
-      return new x(m_message, m_stack, m_cause);                             \
-    }                                                                        \
-    virtual ~x() {}                                                          \
-    virtual const char* getName() const { return _exception_name_##x; }      \
-    virtual void raise() { throw * this; }                                   \
-                                                                             \
-   protected:                                                                \
-    x(const CacheableStringPtr& message, const StackTracePtr& stack,         \
-      const ExceptionPtr& cause)                                             \
-        : Exception(message, stack, cause) {}                                \
-                                                                             \
-   private:                                                                  \
-    const x& operator=(const x&);                                            \
+#define _GF_EXCEPTION_DEF(x)                                            \
+  const char _exception_name_##x[] = "apache::geode::client::" #x;      \
+  class x;                                                              \
+  typedef std::shared_ptr<x> x##Ptr;                                    \
+  class CPPCACHE_EXPORT x : public apache::geode::client::Exception {   \
+   public:                                                              \
+    using Exception::Exception;                                         \
+    virtual Exception* clone() const {                                  \
+      return new x(m_message, m_stack, m_cause);                        \
+    }                                                                   \
+    virtual ~x() {}                                                     \
+    virtual const char* getName() const { return _exception_name_##x; } \
+    virtual void raise() { throw * this; }                              \
+                                                                        \
+   protected:                                                           \
+    x(const CacheableStringPtr& message, const StackTracePtr& stack,    \
+      const ExceptionPtr& cause)                                        \
+        : Exception(message, stack, cause) {}                           \
+                                                                        \
+   private:                                                             \
+    const x& operator=(const x&);                                       \
 
 Review comment:
   Yes, this particular line could be replaced with a delete attribute, though this is not the change I made to the file. The changes I made were at line 40 to use C++11's constructor inheritance. This was in conjunction with the changes to the base class Exception to take std::string and noexcept on the copy constructor as required for exceptions.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149990627
 
 

 ##########
 File path: clicache/integration-test/ThinClientAppDomainFunctionExecutionTests.cs
 ##########
 @@ -52,43 +52,45 @@ public void AddResult(TResult result)
     }
     public ICollection<TResult> GetResult()
     {
-      return GetResult(50);
+      return GetResult(TimeSpan.FromSeconds(50));
     }
 
-    public ICollection<TResult> GetResult(UInt32 timeout)
+    public ICollection<TResult> GetResult(TimeSpan timeout)
     {
       m_getResultCount++;
 
 Review comment:
   Got it. Thanks for explanation.  If only there was a language construct that expressed the intent of a lock.  Until then, maybe a comment would be helpful for the next person?

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149991453
 
 

 ##########
 File path: clicache/src/TimeSpanUtils.hpp
 ##########
 @@ -0,0 +1,58 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "begin_native.hpp"
+#include <chrono>
+#include <geode/util/chrono/duration.hpp>
+#include "end_native.hpp"
+
+namespace Apache
+{
+  namespace Geode
+  {
+    namespace Client
+    {
+      using namespace System;
+      using namespace apache::geode::util::chrono::duration;
+
+      using ticks = std::chrono::duration<long long, std::ratio<1, 10000000>>;
+      
+      class TimeSpanUtils
+      {
+      public:
+        template <class _Duration>
+        inline static _Duration TimeSpanToDurationCeil(TimeSpan timeSpan)
+        {
+          return _ceil<_Duration>(TimeSpanToDuration(timeSpan));
 
 Review comment:
   I like the idea of moving internal rather than relying on convention.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149991851
 
 

 ##########
 File path: cppcache/include/geode/util/chrono/duration.hpp
 ##########
 @@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#ifndef GEODE_UTIL_CHRONO_DURATION_H_
+#define GEODE_UTIL_CHRONO_DURATION_H_
+
+#include <string>
+#include <chrono>
+#include <type_traits>
+#include <stdexcept>
+
+namespace apache {
+namespace geode {
+namespace util {
+namespace chrono {
+namespace duration {
+
+template <class Duration>
+struct _suffix {
+  static constexpr char const* value = nullptr;
+};
+template <>
+struct _suffix<std::chrono::hours> {
+  static constexpr char const* value = "h";
+};
+template <>
+struct _suffix<std::chrono::minutes> {
+  static constexpr char const* value = "min";
+};
+template <>
+struct _suffix<std::chrono::seconds> {
+  static constexpr char const* value = "s";
+};
+template <>
+struct _suffix<std::chrono::milliseconds> {
+  static constexpr char const* value = "ms";
+};
+template <>
+struct _suffix<std::chrono::microseconds> {
+  static constexpr char const* value = "us";
+};
+template <>
+struct _suffix<std::chrono::nanoseconds> {
+  static constexpr char const* value = "ns";
+};
+
+template <class T>
+struct _is_duration : std::false_type {};
+
+template <class Rep, class Period>
+struct _is_duration<std::chrono::duration<Rep, Period>> : std::true_type {};
+
+template <class Rep, class Period>
+struct _is_duration<const std::chrono::duration<Rep, Period>> : std::true_type {
+};
+
+template <class Rep, class Period>
+struct _is_duration<volatile std::chrono::duration<Rep, Period>>
 
 Review comment:
   If not needed, I'd favor tossing until it is.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149991981
 
 

 ##########
 File path: cppcache/integration-test/testThinClientPdxTests.cpp
 ##########
 @@ -2346,7 +2346,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, generateJavaPdxType)
 
     ResultCollectorPtr collector = funcExec->withArgs(args)
                                        ->withFilter(routingObj)
-                                       ->execute("ComparePdxTypes", true);
 
 Review comment:
   Ah, now that rings a bell.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149992860
 
 

 ##########
 File path: cppcache/integration-test/testThinClientRemoteQueryTimeout.cpp
 ##########
 @@ -426,7 +426,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, verifyNegativeValueTimeout)
     try {
       LOG("Task::verifyNegativeValueTimeout - EXECUTE 1 START");
 
-      results = qry->execute(-3);
 
 Review comment:
   Ah, I think I got confused by multiple log statements afterwards which don't get run unless it fails.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


dgkimura commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r149993012
 
 

 ##########
 File path: cppcache/src/ExpiryTaskManager.cpp
 ##########
 @@ -58,7 +58,20 @@ long ExpiryTaskManager::scheduleExpiryTask(ACE_Event_Handler* handler,
 
   ACE_Time_Value expTimeValue(expTime);
   ACE_Time_Value intervalValue(interval);
-  LOGFINER("Scheduled expiration ... in %d seconds.", expTime);
+  return m_reactor->schedule_timer(handler, 0, expTimeValue, intervalValue);
+}
+
+long ExpiryTaskManager::scheduleExpiryTask(
 
 Review comment:
   Okay, cool.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


mhansonp commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r150118929
 
 

 ##########
 File path: clicache/integration-test/ThinClientAppDomainFunctionExecutionTests.cs
 ##########
 @@ -52,43 +52,45 @@ public void AddResult(TResult result)
     }
     public ICollection<TResult> GetResult()
     {
-      return GetResult(50);
+      return GetResult(TimeSpan.FromSeconds(50));
     }
 
-    public ICollection<TResult> GetResult(UInt32 timeout)
+    public ICollection<TResult> GetResult(TimeSpan timeout)
     {
       m_getResultCount++;
-      if (m_resultReady == true)
-      {
-        return m_results;
-      }
-      else
-      {
-        for (int i = 0; i < timeout; i++)
-        {
-          Thread.Sleep(1000);
-          if (m_resultReady == true)
-          {
-            return m_results;
-          }
 
+      lock (this) {
+        if (!m_resultReady) {
+          if (timeout > TimeSpan.Zero) {
+            if (!Monitor.Wait(this, timeout)) {
+              throw new FunctionExecutionException("Timeout waiting for result.");
+            }
+          } else {
+            throw new FunctionExecutionException("Results not ready.");
+          }
         }
-        throw new FunctionExecutionException(
-                   "Result is not ready, endResults callback is called before invoking getResult() method");
-
       }
+
+      return m_results;
     }
+
     public void EndResults()
     {
       m_endResultCount++;
-      m_resultReady = true;
+
+      lock (this) {
+        m_resultReady = true;
+        Monitor.Pulse(this);
+      }
     }
+
     public void ClearResults(/*bool unused*/)
 
 Review comment:
   When does ClearResults get called? I noticed you didn't lock m_resultReady in here. I presume it is at initialization when there is only one thread.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


mhansonp commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r150118929
 
 

 ##########
 File path: clicache/integration-test/ThinClientAppDomainFunctionExecutionTests.cs
 ##########
 @@ -52,43 +52,45 @@ public void AddResult(TResult result)
     }
     public ICollection<TResult> GetResult()
     {
-      return GetResult(50);
+      return GetResult(TimeSpan.FromSeconds(50));
     }
 
-    public ICollection<TResult> GetResult(UInt32 timeout)
+    public ICollection<TResult> GetResult(TimeSpan timeout)
     {
       m_getResultCount++;
-      if (m_resultReady == true)
-      {
-        return m_results;
-      }
-      else
-      {
-        for (int i = 0; i < timeout; i++)
-        {
-          Thread.Sleep(1000);
-          if (m_resultReady == true)
-          {
-            return m_results;
-          }
 
+      lock (this) {
+        if (!m_resultReady) {
+          if (timeout > TimeSpan.Zero) {
+            if (!Monitor.Wait(this, timeout)) {
+              throw new FunctionExecutionException("Timeout waiting for result.");
+            }
+          } else {
+            throw new FunctionExecutionException("Results not ready.");
+          }
         }
-        throw new FunctionExecutionException(
-                   "Result is not ready, endResults callback is called before invoking getResult() method");
-
       }
+
+      return m_results;
     }
+
     public void EndResults()
     {
       m_endResultCount++;
-      m_resultReady = true;
+
+      lock (this) {
+        m_resultReady = true;
+        Monitor.Pulse(this);
+      }
     }
+
     public void ClearResults(/*bool unused*/)
 
 Review comment:
   When does ClearResults get called? I noticed you didn't lock m_resultReady in here. I presume it is at initialization when there is only one thread.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


mhansonp commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r150119107
 
 

 ##########
 File path: clicache/integration-test/ThinClientFunctionExecutionTestsN.cs
 ##########
 @@ -61,43 +61,44 @@ public void AddResult(TResult result)
     }
     public ICollection<TResult> GetResult()
     {
-      return GetResult(50);
+      return GetResult(TimeSpan.FromSeconds(50));
     }
-
-    public ICollection<TResult> GetResult(UInt32 timeout) 
+    public ICollection<TResult> GetResult(TimeSpan timeout)
     {
       m_getResultCount++;
-      if (m_resultReady == true)
-      {
-        return m_results;
-      }
-      else
-      {
-        for (int i = 0; i < timeout; i++)
-        {
-          Thread.Sleep(1000);
-          if (m_resultReady == true)
-          {
-            return m_results;
-          }
 
+      lock (this) {
+        if (!m_resultReady) {
+          if (timeout > TimeSpan.Zero) {
+            if (!Monitor.Wait(this, timeout)) {
+              throw new FunctionExecutionException("Timeout waiting for result.");
+            }
+          } else {
+            throw new FunctionExecutionException("Results not ready.");
+          }
         }
-        throw new FunctionExecutionException(
-                   "Result is not ready, endResults callback is called before invoking getResult() method");
-
       }
+
+      return m_results;
     }
+
     public void EndResults()
     {
       m_endResultCount++;
-      m_resultReady = true;
+
+      lock (this) {
+        m_resultReady = true;
+        Monitor.Pulse(this);
+      }
     }
+
     public void ClearResults(/*bool unused*/)
 
 Review comment:
   When does ClearResults get called? I noticed you didn't lock m_resultReady in here. I presume it is at initialization when there is only one thread.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


mhansonp commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r150120496
 
 

 ##########
 File path: cppcache/include/geode/Pool.hpp
 ##########
 @@ -20,8 +15,16 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_POOL_H_
+#define GEODE_POOL_H_
+
 
 Review comment:
   Technically I believe #pragma once and #ifndef GEODE_POOL_H_, but the #ifndef GEODE_POOL_H_  is more widely supported. Why are we  doubling up everywhere? 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


mhansonp commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r150120669
 
 

 ##########
 File path: cppcache/include/geode/ResultCollector.hpp
 ##########
 @@ -20,10 +15,17 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_RESULTCOLLECTOR_H_
+#define GEODE_RESULTCOLLECTOR_H_
+
+#include <memory>
 
 Review comment:
   For the moment global_types.h already includes <memory>

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


mhansonp commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r150121269
 
 

 ##########
 File path: tests/cli/NewFwkLib/FunctionExecution/MyResultCollector.cs
 ##########
 @@ -52,48 +52,47 @@ public MyResultCollector()
     public void AddResult(TResult result)
     {
       m_addResultCount++;
-      //CacheableArrayList rs = result as CacheableArrayList;
-      //List<Object> rs = result as List<Object>;
-      //for (int i = 0; i < rs.Count; i++)
-      //{
-      //  m_results.Add(rs[i]);
-      //}
       m_results.Add(result);
     }
     public ICollection<TResult> GetResult()
     {
-      return GetResult(50);
+      return GetResult(TimeSpan.FromSeconds(50));
     }
-    public ICollection<TResult> GetResult(UInt32 timeout)
+    public ICollection<TResult> GetResult(TimeSpan timeout)
     {
       m_getResultCount++;
-      if (m_resultReady == true)
-      {
-        return m_results;
-      }
-      else
+
+      lock(this)
       {
-        for (int i = 0; i < timeout; i++)
+        if (!m_resultReady)
         {
-          Thread.Sleep(1000);
-          if (m_resultReady == true)
-          {
-            return m_results;
+          if (timeout > TimeSpan.Zero) {
+            if (!Monitor.Wait(this, timeout)) {
+              throw new FunctionExecutionException("Timeout waiting for result.");
+            }
+          } else {
+            throw new FunctionExecutionException("Results not ready.");
           }
         }
-        throw new FunctionExecutionException(
-                   "Result is not ready, endResults callback is called before invoking getResult() method");
-
       }
+
+      return m_results;
     }
+
     public void EndResults()
     {
       m_endResultCount++;
-      m_resultReady = true;
+
+      lock (this) {
+        m_resultReady = true;
+        Monitor.Pulse(this);
+      }
     }
+
     public void ClearResults(/*bool unused*/)
     {
       m_results.Clear();
+      m_resultReady = false;
 
 Review comment:
   Is the lock here an intentional omission? I presume so.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r150263661
 
 

 ##########
 File path: clicache/src/TimeSpanUtils.hpp
 ##########
 @@ -0,0 +1,58 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "begin_native.hpp"
+#include <chrono>
+#include <geode/util/chrono/duration.hpp>
+#include "end_native.hpp"
+
+namespace Apache
+{
+  namespace Geode
+  {
+    namespace Client
+    {
+      using namespace System;
+      using namespace apache::geode::util::chrono::duration;
+
+      using ticks = std::chrono::duration<long long, std::ratio<1, 10000000>>;
+      
+      class TimeSpanUtils
+      {
+      public:
+        template <class _Duration>
+        inline static _Duration TimeSpanToDurationCeil(TimeSpan timeSpan)
+        {
+          return _ceil<_Duration>(TimeSpanToDuration(timeSpan));
 
 Review comment:
   @dgkimura There are places in the public headers that we use some of the methods in here. We would either need to split the header to move the `_` methods internal only. I am still in favor of the `_`convention as it is consistent with public headers in C++ std library that use `__` (double `_`) convention to denote internal methods/types/etc. Splitting isn't that bad either just means more work. ;)

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r150272880
 
 

 ##########
 File path: cppcache/src/LocalRegion.cpp
 ##########
 @@ -346,15 +348,16 @@ void LocalRegion::localPut(const CacheableKeyPtr& key,
   GfErrTypeToException("Region::localPut", err);
 }
 
-void LocalRegion::putAll(const HashMapOfCacheable& map, uint32_t timeout,
+void LocalRegion::putAll(const HashMapOfCacheable& map,
+                         std::chrono::milliseconds timeout,
                          const SerializablePtr& aCallbackArgument) {
-  if ((timeout * 1000) >= 0x7fffffff) {
-    throw IllegalArgumentException(
-        "Region::putAll: timeout parameter "
-        "greater than maximum allowed (2^31/1000 i.e 2147483).");
-  }
-  int64_t sampleStartNanos = startStatOpTime();
-  GfErrType err = putAllNoThrow(map, timeout, aCallbackArgument);
+  //  if ((timeout * 1000) >= 0x7fffffff) {
 
 Review comment:
   @dgkimura I had really hoped that redefining the parameter as `std::chrono::duration<int32_t, std::milli> timeout` would have solved it compile time but strangely it doesn't. I was able to compile a call at passed in64_t max seconds, which is WAY over the limit. I feel like this is compiler bug but we will just have to check at runtime now.
   

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r150358900
 
 

 ##########
 File path: cppcache/include/geode/ResultCollector.hpp
 ##########
 @@ -20,10 +15,17 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_RESULTCOLLECTOR_H_
+#define GEODE_RESULTCOLLECTOR_H_
+
+#include <memory>
 
 Review comment:
   I am not sure what mean here.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r150359042
 
 

 ##########
 File path: cppcache/include/geode/Pool.hpp
 ##########
 @@ -20,8 +15,16 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_POOL_H_
+#define GEODE_POOL_H_
+
 
 Review comment:
   `#pragma once` is not a C++ standard and is not supported in all compilers.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


mhansonp commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r150359110
 
 

 ##########
 File path: cppcache/include/geode/ResultCollector.hpp
 ##########
 @@ -20,10 +15,17 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_RESULTCOLLECTOR_H_
+#define GEODE_RESULTCOLLECTOR_H_
+
+#include <memory>
 
 Review comment:
   global_types.h includes <memory>

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r150359570
 
 

 ##########
 File path: clicache/integration-test/ThinClientFunctionExecutionTestsN.cs
 ##########
 @@ -61,43 +61,44 @@ public void AddResult(TResult result)
     }
     public ICollection<TResult> GetResult()
     {
-      return GetResult(50);
+      return GetResult(TimeSpan.FromSeconds(50));
     }
-
-    public ICollection<TResult> GetResult(UInt32 timeout) 
+    public ICollection<TResult> GetResult(TimeSpan timeout)
     {
       m_getResultCount++;
-      if (m_resultReady == true)
-      {
-        return m_results;
-      }
-      else
-      {
-        for (int i = 0; i < timeout; i++)
-        {
-          Thread.Sleep(1000);
-          if (m_resultReady == true)
-          {
-            return m_results;
-          }
 
+      lock (this) {
+        if (!m_resultReady) {
+          if (timeout > TimeSpan.Zero) {
+            if (!Monitor.Wait(this, timeout)) {
+              throw new FunctionExecutionException("Timeout waiting for result.");
+            }
+          } else {
+            throw new FunctionExecutionException("Results not ready.");
+          }
         }
-        throw new FunctionExecutionException(
-                   "Result is not ready, endResults callback is called before invoking getResult() method");
-
       }
+
+      return m_results;
     }
+
     public void EndResults()
     {
       m_endResultCount++;
-      m_resultReady = true;
+
+      lock (this) {
+        m_resultReady = true;
+        Monitor.Pulse(this);
+      }
     }
+
     public void ClearResults(/*bool unused*/)
 
 Review comment:
   Called only by tests as far as I can see. Not sure the intent outside of what the docs say about it being called by client users before subsequent calls to execute using the same collector.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r150359809
 
 

 ##########
 File path: tests/cli/NewFwkLib/FunctionExecution/MyResultCollector.cs
 ##########
 @@ -52,48 +52,47 @@ public MyResultCollector()
     public void AddResult(TResult result)
     {
       m_addResultCount++;
-      //CacheableArrayList rs = result as CacheableArrayList;
-      //List<Object> rs = result as List<Object>;
-      //for (int i = 0; i < rs.Count; i++)
-      //{
-      //  m_results.Add(rs[i]);
-      //}
       m_results.Add(result);
     }
     public ICollection<TResult> GetResult()
     {
-      return GetResult(50);
+      return GetResult(TimeSpan.FromSeconds(50));
     }
-    public ICollection<TResult> GetResult(UInt32 timeout)
+    public ICollection<TResult> GetResult(TimeSpan timeout)
     {
       m_getResultCount++;
-      if (m_resultReady == true)
-      {
-        return m_results;
-      }
-      else
+
+      lock(this)
       {
-        for (int i = 0; i < timeout; i++)
+        if (!m_resultReady)
         {
-          Thread.Sleep(1000);
-          if (m_resultReady == true)
-          {
-            return m_results;
+          if (timeout > TimeSpan.Zero) {
+            if (!Monitor.Wait(this, timeout)) {
+              throw new FunctionExecutionException("Timeout waiting for result.");
+            }
+          } else {
+            throw new FunctionExecutionException("Results not ready.");
           }
         }
-        throw new FunctionExecutionException(
-                   "Result is not ready, endResults callback is called before invoking getResult() method");
-
       }
+
+      return m_results;
     }
+
     public void EndResults()
     {
       m_endResultCount++;
-      m_resultReady = true;
+
+      lock (this) {
+        m_resultReady = true;
+        Monitor.Pulse(this);
+      }
     }
+
     public void ClearResults(/*bool unused*/)
     {
       m_results.Clear();
+      m_resultReady = false;
 
 Review comment:
   Original code doesn't even reset the ready flag. Synching on the flag isn't necessary because the same thread resetting here will be the same thread checking it later if the collector is reused. For completeness we could sync.

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


pivotal-jbarrett commented on a change in pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144#discussion_r150359976
 
 

 ##########
 File path: cppcache/src/LocalRegion.cpp
 ##########
 @@ -346,15 +348,16 @@ void LocalRegion::localPut(const CacheableKeyPtr& key,
   GfErrTypeToException("Region::localPut", err);
 }
 
-void LocalRegion::putAll(const HashMapOfCacheable& map, uint32_t timeout,
+void LocalRegion::putAll(const HashMapOfCacheable& map,
+                         std::chrono::milliseconds timeout,
                          const SerializablePtr& aCallbackArgument) {
-  if ((timeout * 1000) >= 0x7fffffff) {
-    throw IllegalArgumentException(
-        "Region::putAll: timeout parameter "
-        "greater than maximum allowed (2^31/1000 i.e 2147483).");
-  }
-  int64_t sampleStartNanos = startStatOpTime();
-  GfErrType err = putAllNoThrow(map, timeout, aCallbackArgument);
+  //  if ((timeout * 1000) >= 0x7fffffff) {
 
 Review comment:
   @dgkimura Fixed in https://github.com/apache/geode-native/pull/144/commits/91a47a9f898921932ec037704bde43edf3ba04b4

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 9fe0782f47f0f58ec98f3873b208437df3e93b32 in geode-native's branch refs/heads/develop from Jacob Barrett
[ https://gitbox.apache.org/repos/asf?p=geode-native.git;h=9fe0782 ]

GEODE-3136: Convert time values to std::chrono::duration. (#144)

* GEODE-3136: Convert time values to std::chrono::duration.

- Adds duration utilities.
- XML Schema changes.
- Convert CLI time values to TimeSpan.



pivotal-jbarrett closed pull request #144: GEODE-3136: Convert time values to std::chrono::duration.
URL: https://github.com/apache/geode-native/pull/144
 
 
   

This is a PR merged from a forked repository.
As GitHub hides the original diff on merge, it is displayed below for
the sake of provenance:

As this is a foreign pull request (from a fork), the diff is supplied
below (as it won't show otherwise due to GitHub magic):

diff --git a/.gitignore b/.gitignore
index 9943edac..c85fc49a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,3 +4,4 @@
 /.settings/
 /.cproject
 /.project
+/.idea/
diff --git a/clicache/integration-test/AttributesMutatorTestsN.cs b/clicache/integration-test/AttributesMutatorTestsN.cs
index dbd23270..9b1565a1 100644
--- a/clicache/integration-test/AttributesMutatorTestsN.cs
+++ b/clicache/integration-test/AttributesMutatorTestsN.cs
@@ -56,7 +56,7 @@ public class AttributesMutatorTests : ThinClientRegionSteps
     private UnitProcess m_client1, m_client2;
     private const string Key = "one";
     private const int Val = 1;
-    private const int TimeToLive = 5;
+    private static TimeSpan TimeToLive = TimeSpan.FromSeconds(5);
     private const string PeerRegionName = "PEER1";
     TallyListener<string, string> m_reg1Listener1, m_reg1Listener2;
     TallyListener<string, string> m_reg2Listener1, m_reg2Listener2;
@@ -264,11 +264,11 @@ public void CreateAndVerifyExpiry()
     {
       try
       {
-        IRegion<string, int> region = CacheHelper.CreateLocalRegionWithETTL<string, int>(RegionName,
+        var region = CacheHelper.CreateLocalRegionWithETTL<string, int>(RegionName,
           ExpirationAction.LocalInvalidate, TimeToLive);
 
-        Apache.Geode.Client.RegionAttributes<string, int> newAttrs = region.Attributes;
-        int ttl = newAttrs.EntryTimeToLive;
+        var newAttrs = region.Attributes;
+        var ttl = newAttrs.EntryTimeToLive;
         Assert.AreEqual(TimeToLive, ttl);
 
         region[Key] = Val;
diff --git a/clicache/integration-test/CacheHelperN.cs b/clicache/integration-test/CacheHelperN.cs
index 3785754f..6347647d 100644
--- a/clicache/integration-test/CacheHelperN.cs
+++ b/clicache/integration-test/CacheHelperN.cs
@@ -496,39 +496,39 @@ public static void InitConfig(Properties<string, string> config)
     }
 
     public static void InitConfigForDurable_Pool(string locators, int redundancyLevel,
-      string durableClientId, int durableTimeout)
+      string durableClientId, TimeSpan durableTimeout)
     {
-      InitConfigForDurable_Pool(locators, redundancyLevel, durableClientId, durableTimeout, 1);
+      InitConfigForDurable_Pool(locators, redundancyLevel, durableClientId, durableTimeout, TimeSpan.FromSeconds(1));
     }
 
     public static void InitConfigForDurable_Pool(string locators, int redundancyLevel,
-      string durableClientId, int durableTimeout, int ackInterval)
+      string durableClientId, TimeSpan durableTimeout, TimeSpan ackInterval)
     {
       Properties<string, string> config = new Properties<string, string>();
       config.Insert("durable-client-id", durableClientId);
-      config.Insert("durable-timeout", durableTimeout.ToString());
+      config.Insert("durable-timeout", durableTimeout.TotalSeconds + "s");
       InitConfig(config, null);
       CreatePool<object, object>("__TESTPOOL1_", locators, (string)null, redundancyLevel, true,
-        ackInterval, 300);
+        ackInterval, TimeSpan.FromSeconds(300));
     }
 
     public static void InitConfigForDurable_Pool2(string locators, int redundancyLevel,
-      string durableClientId, int durableTimeout, int ackInterval, string poolName)
+      string durableClientId, TimeSpan durableTimeout, TimeSpan ackInterval, string poolName)
     {
       Properties<string, string> config = new Properties<string, string>();
       config.Insert("durable-client-id", durableClientId);
-      config.Insert("durable-timeout", durableTimeout.ToString());
+      config.Insert("durable-timeout", durableTimeout.TotalSeconds + "s");
       InitConfig(config, null);
       CreatePool<object, object>(poolName, locators, (string)null, redundancyLevel, true,
-        ackInterval, 300);
+        ackInterval, TimeSpan.FromSeconds(300));
     }
 
     public static void InitConfigForConflation(string durableClientId, string conflation)
     {
       Properties<string, string> config = new Properties<string, string>();
       config.Insert("durable-client-id", durableClientId);
-      config.Insert("durable-timeout", "300");
-      config.Insert("notify-ack-interval", "1");
+      config.Insert("durable-timeout", "300s");
+      config.Insert("notify-ack-interval", "1s");
       if (conflation != null && conflation.Length > 0)
       {
         config.Insert("conflate-events", conflation);
@@ -555,8 +555,8 @@ static public void UnsetHeapLimit()
     {
       Properties<string, string> config = new Properties<string, string>();
       config.Insert("durable-client-id", durableClientId);
-      config.Insert("durable-timeout", "300");
-      config.Insert("notify-ack-interval", "1");
+      config.Insert("durable-timeout", "300s");
+      config.Insert("notify-ack-interval", "1s");
       if (conflation != null && conflation.Length > 0)
       {
         config.Insert("conflate-events", conflation);
@@ -720,7 +720,7 @@ public static void ReadyForEvents()
 
 
     public static IRegion<TKey, TValue> CreateExpirationRegion<TKey, TValue>(
-      string name, string poolname, ExpirationAction action, int entryTimeToLive)
+      string name, string poolname, ExpirationAction action, TimeSpan entryTimeToLive)
     {
       Init();
       IRegion<TKey, TValue> region = GetRegion<TKey, TValue>(name);
@@ -731,14 +731,14 @@ public static void ReadyForEvents()
       }
 
       region = m_cache.CreateRegionFactory(RegionShortcut.CACHING_PROXY)
-        .SetEntryTimeToLive(action, (uint)entryTimeToLive).SetPoolName(poolname).Create<TKey, TValue>(name);
+        .SetEntryTimeToLive(action, entryTimeToLive).SetPoolName(poolname).Create<TKey, TValue>(name);
       Assert.IsNotNull(region, "IRegion<object, object> was not created.");
       m_currRegion = region as IRegion<object, object>;
       return region;
     }
 
     public static IRegion<TKey, TValue> CreateLocalRegionWithETTL<TKey, TValue>(
-      string name, ExpirationAction action, int entryTimeToLive)
+      string name, ExpirationAction action, TimeSpan entryTimeToLive)
     {
       Init();
       IRegion<TKey, TValue> region = GetRegion<TKey, TValue>(name);
@@ -749,7 +749,7 @@ public static void ReadyForEvents()
       }
 
       region = m_cache.CreateRegionFactory(RegionShortcut.LOCAL)
-        .SetEntryTimeToLive(action, (uint)entryTimeToLive).Create<TKey, TValue>(name);
+        .SetEntryTimeToLive(action, entryTimeToLive).Create<TKey, TValue>(name);
       Assert.IsNotNull(region, "IRegion<object, object> was not created.");
       m_currRegion = region as IRegion<object, object>;
       return region;
@@ -948,42 +948,42 @@ public static void ReadyForEvents()
     public static Pool/*<TKey, TValue>*/ CreatePool<TKey, TValue>(string name, string locators, string serverGroup,
       int redundancy, bool subscription)
     {
-      return CreatePool<TKey, TValue>(name, locators, serverGroup, redundancy, subscription, 5, 1, 300);
+      return CreatePool<TKey, TValue>(name, locators, serverGroup, redundancy, subscription, 5, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(300));
     }
 
     public static Pool/*<TKey, TValue>*/ CreatePool<TKey, TValue>(string name, string locators, string serverGroup,
       int redundancy, bool subscription, bool prSingleHop, bool threadLocal = false)
     {
-      return CreatePool<TKey, TValue>(name, locators, serverGroup, redundancy, subscription, -1, 1, 300, false, prSingleHop, threadLocal);
+      return CreatePool<TKey, TValue>(name, locators, serverGroup, redundancy, subscription, -1, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(300), false, prSingleHop, threadLocal);
     }
 
     public static Pool/*<TKey, TValue>*/ CreatePool<TKey, TValue>(string name, string locators, string serverGroup,
       int redundancy, bool subscription, int numConnections, bool isMultiuserMode)
     {
-      return CreatePool<TKey, TValue>(name, locators, serverGroup, redundancy, subscription, numConnections, 1, 300, isMultiuserMode);
+      return CreatePool<TKey, TValue>(name, locators, serverGroup, redundancy, subscription, numConnections, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(300), isMultiuserMode);
     }
 
     public static Pool/*<TKey, TValue>*/ CreatePool<TKey, TValue>(string name, string locators, string serverGroup,
       int redundancy, bool subscription, int numConnections)
     {
-      return CreatePool<TKey, TValue>(name, locators, serverGroup, redundancy, subscription, numConnections, 1, 300);
+      return CreatePool<TKey, TValue>(name, locators, serverGroup, redundancy, subscription, numConnections, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(300));
     }
 
     public static Pool/*<TKey, TValue>*/ CreatePool<TKey, TValue>(string name, string locators, string serverGroup,
-      int redundancy, bool subscription, int ackInterval, int dupCheckLife)
+      int redundancy, bool subscription, TimeSpan ackInterval, TimeSpan dupCheckLife)
     {
       return CreatePool<TKey, TValue>(name, locators, serverGroup, redundancy, subscription,
         5, ackInterval, dupCheckLife);
     }
 
     public static Pool/*<TKey, TValue>*/ CreatePool<TKey, TValue>(string name, string locators, string serverGroup,
-      int redundancy, bool subscription, int numConnections, int ackInterval, int dupCheckLife)
+      int redundancy, bool subscription, int numConnections, TimeSpan ackInterval, TimeSpan dupCheckLife)
     {
-      return CreatePool<TKey, TValue>(name, locators, serverGroup, redundancy, subscription, numConnections, ackInterval, 300, false);
+      return CreatePool<TKey, TValue>(name, locators, serverGroup, redundancy, subscription, numConnections, ackInterval, dupCheckLife, false);
     }
 
     public static Pool/*<TKey, TValue>*/ CreatePool<TKey, TValue>(string name, string locators, string serverGroup,
-      int redundancy, bool subscription, int numConnections, int ackInterval, int dupCheckLife, bool isMultiuserMode, bool prSingleHop = true, bool threadLocal = false)
+      int redundancy, bool subscription, int numConnections, TimeSpan ackInterval, TimeSpan dupCheckLife, bool isMultiuserMode, bool prSingleHop = true, bool threadLocal = false)
     {
       Init();
 
diff --git a/clicache/integration-test/ExpirationTestsN.cs b/clicache/integration-test/ExpirationTestsN.cs
index 419a43e4..92e25b04 100644
--- a/clicache/integration-test/ExpirationTestsN.cs
+++ b/clicache/integration-test/ExpirationTestsN.cs
@@ -112,10 +112,10 @@ private void Do1Put()
 
       RegionFactory rf = CacheHelper.DCache.CreateRegionFactory(RegionShortcut.LOCAL);
 
-      rf.SetEntryTimeToLive(action, entryTTL);
-      rf.SetEntryIdleTimeout(action, entryIdleTimeout);
-      rf.SetRegionTimeToLive(action, regionTTL);
-      rf.SetRegionIdleTimeout(action, regionIdleTimeout);
+      rf.SetEntryTimeToLive(action, TimeSpan.FromSeconds(entryTTL));
+      rf.SetEntryIdleTimeout(action, TimeSpan.FromSeconds(entryIdleTimeout));
+      rf.SetRegionTimeToLive(action, TimeSpan.FromSeconds(regionTTL));
+      rf.SetRegionIdleTimeout(action, TimeSpan.FromSeconds(regionIdleTimeout));
 
       CacheHelper.Init();
       IRegion<object, object> region = CacheHelper.GetRegion<object, object>(m_regionName);
diff --git a/clicache/integration-test/OverflowTestsN.cs b/clicache/integration-test/OverflowTestsN.cs
index 8980ab6b..34fd7041 100644
--- a/clicache/integration-test/OverflowTestsN.cs
+++ b/clicache/integration-test/OverflowTestsN.cs
@@ -505,7 +505,7 @@ public void XmlCacheCreationWithOverflow()
         int initialCapacity = attrs.InitialCapacity;
         Assert.AreEqual(25, initialCapacity);
 
-        int regionIdleTO = attrs.RegionIdleTimeout;
+        var regionIdleTO = attrs.RegionIdleTimeout;
         Assert.AreEqual(20, regionIdleTO);
 
         ExpirationAction action1 = attrs.RegionIdleTimeoutAction;
diff --git a/clicache/integration-test/ThinClientAppDomainFunctionExecutionTests.cs b/clicache/integration-test/ThinClientAppDomainFunctionExecutionTests.cs
index 0d9129c7..dd548117 100644
--- a/clicache/integration-test/ThinClientAppDomainFunctionExecutionTests.cs
+++ b/clicache/integration-test/ThinClientAppDomainFunctionExecutionTests.cs
@@ -52,43 +52,45 @@ public void AddResult(TResult result)
     }
     public ICollection<TResult> GetResult()
     {
-      return GetResult(50);
+      return GetResult(TimeSpan.FromSeconds(50));
     }
 
-    public ICollection<TResult> GetResult(UInt32 timeout)
+    public ICollection<TResult> GetResult(TimeSpan timeout)
     {
       m_getResultCount++;
-      if (m_resultReady == true)
-      {
-        return m_results;
-      }
-      else
-      {
-        for (int i = 0; i < timeout; i++)
-        {
-          Thread.Sleep(1000);
-          if (m_resultReady == true)
-          {
-            return m_results;
-          }
 
+      lock (this) {
+        if (!m_resultReady) {
+          if (timeout > TimeSpan.Zero) {
+            if (!Monitor.Wait(this, timeout)) {
+              throw new FunctionExecutionException("Timeout waiting for result.");
+            }
+          } else {
+            throw new FunctionExecutionException("Results not ready.");
+          }
         }
-        throw new FunctionExecutionException(
-                   "Result is not ready, endResults callback is called before invoking getResult() method");
-
       }
+
+      return m_results;
     }
+
     public void EndResults()
     {
       m_endResultCount++;
-      m_resultReady = true;
+
+      lock (this) {
+        m_resultReady = true;
+        Monitor.Pulse(this);
+      }
     }
+
     public void ClearResults(/*bool unused*/)
     {
       m_results.Clear();
       m_addResultCount = 0;
       m_getResultCount = 0;
       m_endResultCount = 0;
+      m_resultReady = false;
     }
   }
 
@@ -186,7 +188,7 @@ public void OnServerHAStepOne()
       Apache.Geode.Client.Execution<object> exc = FunctionService<object>.OnServer(pool);
       Assert.IsTrue(exc != null, "onServer Returned NULL");
 
-      IResultCollector<object> rc = exc.WithArgs<ArrayList>(args1).Execute(OnServerHAExceptionFunction, 15);
+      IResultCollector<object> rc = exc.WithArgs<ArrayList>(args1).Execute(OnServerHAExceptionFunction, TimeSpan.FromSeconds(15));
 
       ICollection<object> executeFunctionResult = rc.GetResult();
 
@@ -210,7 +212,7 @@ public void OnServerHAStepOne()
         Assert.IsTrue(((string)resultList[i]) != null, "onServer Returned NULL");
       }
 
-      rc = exc.WithArgs<ArrayList>(args1).Execute(OnServerHAShutdownFunction, 15);
+      rc = exc.WithArgs<ArrayList>(args1).Execute(OnServerHAShutdownFunction, TimeSpan.FromSeconds(15));
 
       ICollection<object> executeFunctionResult1 = rc.GetResult();
 
diff --git a/clicache/integration-test/ThinClientCSTXN.cs b/clicache/integration-test/ThinClientCSTXN.cs
index 211a52ce..775ab2e0 100644
--- a/clicache/integration-test/ThinClientCSTXN.cs
+++ b/clicache/integration-test/ThinClientCSTXN.cs
@@ -279,7 +279,7 @@ public void SuspendResumeRollback()
       Assert.AreEqual(CacheHelper.CSTXManager.IsSuspended(tid), false, "Transaction should not be suspended");
       Assert.AreEqual(CacheHelper.CSTXManager.Exists(tid), false, "Transaction should NOT exist");
       Assert.AreEqual(CacheHelper.CSTXManager.TryResume(tid), false, "Transaction should not be resumed");
-      Assert.AreEqual(CacheHelper.CSTXManager.TryResume(tid, 3000), false, "Transaction should not be resumed");
+      Assert.AreEqual(CacheHelper.CSTXManager.TryResume(tid, TimeSpan.FromMilliseconds(3000)), false, "Transaction should not be resumed");
       Assert.AreEqual(0, o_region1.Region.Keys.Count, "There should be 0 values in the region after rollback");
       Assert.AreEqual(0, o_region2.Region.Keys.Count, "There should be 0 values in the region after rollback");
       bool resumeEx = false;
@@ -394,7 +394,7 @@ public void SuspendResumeCommit()
       Assert.AreEqual(CacheHelper.CSTXManager.IsSuspended(tid), false, "Transaction should not be suspended");
       Assert.AreEqual(CacheHelper.CSTXManager.Exists(tid), false, "Transaction should NOT exist");
       Assert.AreEqual(CacheHelper.CSTXManager.TryResume(tid), false, "Transaction should not be resumed");
-      Assert.AreEqual(CacheHelper.CSTXManager.TryResume(tid, 3000), false, "Transaction should not be resumed");
+      Assert.AreEqual(CacheHelper.CSTXManager.TryResume(tid, TimeSpan.FromMilliseconds(3000)), false, "Transaction should not be resumed");
       Assert.AreEqual(2, o_region1.Region.Keys.Count, "There should be four values in the region after commit");
       Assert.AreEqual(4, o_region2.Region.Keys.Count, "There should be four values in the region after commit");
       o_region1.DestroyOpWithPdxValue(1, null);
@@ -687,7 +687,7 @@ public void ThreadStart()
         if (m_tryResumeWithSleep)
         {
           m_txevent.Set();
-          CacheHelper.CSTXManager.TryResume(m_tid, 30000);
+          CacheHelper.CSTXManager.TryResume(m_tid, TimeSpan.FromMilliseconds(30000));
         }
         else
           CacheHelper.CSTXManager.Resume(m_tid);
@@ -712,7 +712,7 @@ public void ThreadStart()
             return;
           if (AssertCheckFail(CacheHelper.CSTXManager.TryResume(m_tid) == false, "Transaction should not be resumed"))
             return;
-          if (AssertCheckFail(CacheHelper.CSTXManager.TryResume(m_tid, 3000) == false, "Transaction should not be resumed"))
+          if (AssertCheckFail(CacheHelper.CSTXManager.TryResume(m_tid, TimeSpan.FromMilliseconds(3000)) == false, "Transaction should not be resumed"))
             return;
           if (AssertCheckFail(2 == o_region1.Region.Keys.Count, "There should be four values in the region after commit"))
             return;
@@ -730,7 +730,7 @@ public void ThreadStart()
             return;
           if (AssertCheckFail(CacheHelper.CSTXManager.TryResume(m_tid) == false, "Transaction should not be resumed"))
             return;
-          if (AssertCheckFail(CacheHelper.CSTXManager.TryResume(m_tid, 3000) == false, "Transaction should not be resumed"))
+          if (AssertCheckFail(CacheHelper.CSTXManager.TryResume(m_tid, TimeSpan.FromMilliseconds(3000)) == false, "Transaction should not be resumed"))
             return;
           if (AssertCheckFail(0 == o_region1.Region.Keys.Count, "There should be 0 values in the region after rollback"))
             return;
diff --git a/clicache/integration-test/ThinClientCallbackArgN.cs b/clicache/integration-test/ThinClientCallbackArgN.cs
index 745689ad..33c26623 100644
--- a/clicache/integration-test/ThinClientCallbackArgN.cs
+++ b/clicache/integration-test/ThinClientCallbackArgN.cs
@@ -566,7 +566,7 @@ public void TestPutAll()
         string value = item.ToString();
         entryMap.Add(K, value);
       }
-      o_region.Region.PutAll(entryMap, 15, m_callbackarg);
+      o_region.Region.PutAll(entryMap, TimeSpan.FromSeconds(15), m_callbackarg);
     }
 
     public void TestGetAll()
diff --git a/clicache/integration-test/ThinClientDeltaTestN.cs b/clicache/integration-test/ThinClientDeltaTestN.cs
index 73846a97..81232ef5 100644
--- a/clicache/integration-test/ThinClientDeltaTestN.cs
+++ b/clicache/integration-test/ThinClientDeltaTestN.cs
@@ -224,7 +224,7 @@ public void createRegionAndAttachPool(string regionName, string poolName, bool c
     public void createExpirationRegion(string name, string poolName)
     {
       IRegion<object, object> region = CacheHelper.CreateExpirationRegion<object, object>(name,
-          poolName, ExpirationAction.LocalInvalidate, 5);
+          poolName, ExpirationAction.LocalInvalidate, TimeSpan.FromSeconds(5));
     }
 
     public void createExpirationRegion(string name)
diff --git a/clicache/integration-test/ThinClientDurableCqTestsN.cs b/clicache/integration-test/ThinClientDurableCqTestsN.cs
index b6b0a01b..604261a2 100644
--- a/clicache/integration-test/ThinClientDurableCqTestsN.cs
+++ b/clicache/integration-test/ThinClientDurableCqTestsN.cs
@@ -49,7 +49,7 @@ protected override ClientBase[] GetClients()
     }
 
     public void InitDurableClient(string locators, int redundancyLevel,
-     string durableClientId, int durableTimeout)
+     string durableClientId, TimeSpan durableTimeout)
     {
       CacheHelper.InitConfigForDurable_Pool(locators, redundancyLevel, durableClientId, durableTimeout);
       CacheHelper.CreateTCRegion_Pool(QueryRegionNames[0], true, true, (ICacheListener<object, object>)null, CacheHelper.Locators, "__TESTPOOL1_", true);
@@ -200,8 +200,8 @@ private void RunTestGetDurableCqsFromServer()
         CacheHelper.StartJavaServerWithLocators(1, "GFECS1", 1);
         Util.Log("Cache server 1 started");
 
-        m_client1.Call(InitDurableClient, CacheHelper.Locators, 0, "DurableClient1", 300);
-        m_client2.Call(InitDurableClient, CacheHelper.Locators, 0, "DurableClient2", 300);
+        m_client1.Call(InitDurableClient, CacheHelper.Locators, 0, "DurableClient1", TimeSpan.FromSeconds(300));
+        m_client2.Call(InitDurableClient, CacheHelper.Locators, 0, "DurableClient2", TimeSpan.FromSeconds(300));
         Util.Log("client initialization done.");
 
         m_client1.Call(RegisterCqsClient1, false);
@@ -233,8 +233,8 @@ private void RunTestGetDurableCqsFromServerCyclicClients()
         CacheHelper.StartJavaServerWithLocators(1, "GFECS1", 1);
         Util.Log("Cache server 1 started");
 
-        m_client1.Call(InitDurableClient, CacheHelper.Locators, 0, "DurableClient1", 300);
-        m_client2.Call(InitDurableClient, CacheHelper.Locators, 0, "DurableClient2", 300);
+        m_client1.Call(InitDurableClient, CacheHelper.Locators, 0, "DurableClient1", TimeSpan.FromSeconds(300));
+        m_client2.Call(InitDurableClient, CacheHelper.Locators, 0, "DurableClient2", TimeSpan.FromSeconds(300));
         Util.Log("client initialization done.");
 
         m_client1.Call(RegisterCqsClient1, false);
@@ -250,8 +250,8 @@ private void RunTestGetDurableCqsFromServerCyclicClients()
         m_client2.Call(CacheHelper.CloseKeepAlive);
 
 
-        m_client1.Call(InitDurableClient, CacheHelper.Locators, 0, "DurableClient1", 300);
-        m_client2.Call(InitDurableClient, CacheHelper.Locators, 0, "DurableClient2", 300);
+        m_client1.Call(InitDurableClient, CacheHelper.Locators, 0, "DurableClient1", TimeSpan.FromSeconds(300));
+        m_client2.Call(InitDurableClient, CacheHelper.Locators, 0, "DurableClient2", TimeSpan.FromSeconds(300));
         Util.Log("client re-initialization done.");
 
         m_client1.Call(RegisterCqsClient1, true);
diff --git a/clicache/integration-test/ThinClientDurableTestsN.cs b/clicache/integration-test/ThinClientDurableTestsN.cs
index e75856eb..3bf8a198 100644
--- a/clicache/integration-test/ThinClientDurableTestsN.cs
+++ b/clicache/integration-test/ThinClientDurableTestsN.cs
@@ -101,16 +101,16 @@ public void InitFeeder2(string locators, int redundancyLevel)
     }
 
     public void InitDurableClientWithTwoPools(string locators,
-    int redundancyLevel, string durableClientId, int durableTimeout, int expectedQ0, int expectedQ1)
+    int redundancyLevel, string durableClientId, TimeSpan durableTimeout, int expectedQ0, int expectedQ1)
     {
       DurableListener<object, object> checker = null;
       CacheHelper.InitConfigForDurable_Pool2(locators, redundancyLevel,
-          durableClientId, durableTimeout, 35000, "__TESTPOOL1_");
+          durableClientId, durableTimeout, TimeSpan.FromSeconds(35), "__TESTPOOL1_");
       CacheHelper.CreateTCRegion_Pool(RegionNames[0], false, true, checker,
           CacheHelper.Locators, "__TESTPOOL1_", true);
 
       CacheHelper.InitConfigForDurable_Pool2(locators, redundancyLevel,
-          durableClientId, durableTimeout, 35000, "__TESTPOOL2_");
+          durableClientId, durableTimeout, TimeSpan.FromSeconds(35), "__TESTPOOL2_");
       CacheHelper.CreateTCRegion_Pool(RegionNames[1], false, true, checker,
           CacheHelper.Locators, "__TESTPOOL2_", true);
 
@@ -158,7 +158,7 @@ public void ClearChecker(int client)
     }
 
     public void InitDurableClient(int client, string locators, int redundancyLevel,
-      string durableClientId, int durableTimeout)
+      string durableClientId, TimeSpan durableTimeout)
     {
       // Create DurableListener for first time and use same afterward.
       DurableListener<object, object> checker = null;
@@ -389,8 +389,8 @@ void runDurableAndNonDurableBasic()
             m_client1.Call(ClearChecker, 1);
             m_client2.Call(ClearChecker, 2);
 
-            m_client1.Call(InitDurableClient, 1, CacheHelper.Locators, redundancy, DurableClientId1, 300);
-            m_client2.Call(InitDurableClient, 2, CacheHelper.Locators, redundancy, DurableClientId2, 3);
+            m_client1.Call(InitDurableClient, 1, CacheHelper.Locators, redundancy, DurableClientId1, TimeSpan.FromSeconds(300));
+            m_client2.Call(InitDurableClient, 2, CacheHelper.Locators, redundancy, DurableClientId2, TimeSpan.FromSeconds(3));
 
             Util.Log("Clients initialized.");
 
@@ -435,12 +435,12 @@ void runDurableAndNonDurableBasic()
               Thread.Sleep(20000); // wait for HA Q to drain and notify ack to go out.
             }
 
-            m_client1.Call(InitDurableClient, 1, CacheHelper.Locators, redundancy, DurableClientId1, 300);
+            m_client1.Call(InitDurableClient, 1, CacheHelper.Locators, redundancy, DurableClientId1, TimeSpan.FromSeconds(300));
 
             // Sleep for 45 seconds since durable timeout is 30 seconds so that client2 times out
             Thread.Sleep(45000);
 
-            m_client2.Call(InitDurableClient, 2, CacheHelper.Locators, redundancy, DurableClientId2, 30);
+            m_client2.Call(InitDurableClient, 2, CacheHelper.Locators, redundancy, DurableClientId2, TimeSpan.FromSeconds(30));
 
             Util.Log("Clients brought back up.");
 
@@ -501,7 +501,7 @@ public void DurableAndNonDurableBasic()
     #region Durable Intrest Test
 
     public void InitDurableClientRemoveInterest(int client, string locators,
-      int redundancyLevel, string durableClientId, int durableTimeout)
+      int redundancyLevel, string durableClientId, TimeSpan durableTimeout)
     {
       // Client Registered Durable Intrest on two keys. We need to unregister them all here.
 
@@ -541,7 +541,7 @@ public void DurableAndNonDurableBasic()
     }
 
     public void InitDurableClientNoInterest(int client, string locators,
-      int redundancyLevel, string durableClientId, int durableTimeout)
+      int redundancyLevel, string durableClientId, TimeSpan durableTimeout)
     {
       // we use "client" to either create a DurableListener or use the existing ones
       // if the clients are initialized for the second time
@@ -583,9 +583,9 @@ void runDurableInterest()
       m_client1.Call(ClearChecker, 1);
       m_client2.Call(ClearChecker, 2);
       m_client1.Call(InitDurableClient, 1, CacheHelper.Locators,
-        0, DurableClientId1, 60);
+        0, DurableClientId1, TimeSpan.FromSeconds(60));
       m_client2.Call(InitDurableClient, 2, CacheHelper.Locators,
-        0, DurableClientId2, 60);
+        0, DurableClientId2, TimeSpan.FromSeconds(60));
       Util.Log("Clients started.");
 
       m_feeder.Call(FeederUpdate, 1, 10);
@@ -598,11 +598,11 @@ void runDurableInterest()
       Util.Log("Clients downed with keepalive true.");
 
       m_client1.Call(InitDurableClientNoInterest, 1, CacheHelper.Locators,
-        0, DurableClientId1, 60);
+        0, DurableClientId1, TimeSpan.FromSeconds(60));
       Util.Log("Client 1 started with no interest.");
 
       m_client2.Call(InitDurableClientRemoveInterest, 2, CacheHelper.Locators,
-        0, DurableClientId2, 60);
+        0, DurableClientId2, TimeSpan.FromSeconds(60));
       Util.Log("Client 2 started with remove interest.");
 
       m_feeder.Call(FeederUpdate, 2, 10);
@@ -646,7 +646,7 @@ public void DurableInterest()
 
 
     public void InitDurableClientForFailover(int client, string locators,
-      int redundancyLevel, string durableClientId, int durableTimeout)
+      int redundancyLevel, string durableClientId, TimeSpan durableTimeout)
     {
       // we use "client" to either create a DurableListener or use the existing ones
       // if the clients are initialized for the second time
@@ -668,7 +668,7 @@ public void DurableInterest()
         checker = ThinClientDurableTests.m_checker2;
       }
       CacheHelper.InitConfigForDurable_Pool(locators, redundancyLevel,
-        durableClientId, durableTimeout, 35000);
+        durableClientId, durableTimeout, TimeSpan.FromSeconds(35));
       CacheHelper.CreateTCRegion_Pool(RegionNames[0], false, true, checker,
         CacheHelper.Locators, "__TESTPOOL1_", true);
       CacheHelper.DCache.ReadyForEvents();
@@ -719,7 +719,7 @@ void runDurableFailover()
 
           m_client1.Call(ClearChecker, 1);
           m_client1.Call(InitDurableClientForFailover, 1, CacheHelper.Locators,
-            redundancy, DurableClientId1, 300);
+            redundancy, DurableClientId1, TimeSpan.FromSeconds(300));
           Util.Log("Client started with redundancy level as {0}.", redundancy);
 
           m_feeder.Call(FeederUpdateForFailover, RegionNames[0], 1, 10);
@@ -749,7 +749,7 @@ void runDurableFailover()
           if (clientDown == 1)
           {
             m_client1.Call(InitDurableClientForFailover, 1, CacheHelper.Locators,
-              redundancy, DurableClientId1, 300);
+              redundancy, DurableClientId1, TimeSpan.FromSeconds(300));
             Util.Log("Client Restarted with redundancy level as {0}.", redundancy);
           }
 
@@ -793,13 +793,13 @@ void RunDurableClient(int expectedPendingQSize)
     {
       Properties<string, string> pp = Properties<string, string>.Create<string, string>();
       pp.Insert("durable-client-id", "DurableClientId");
-      pp.Insert("durable-timeout", "30");
+      pp.Insert("durable-timeout", "30s");
 
       CacheFactory cacheFactory = CacheFactory.CreateCacheFactory(pp);
       Cache cache = cacheFactory.Create();
       cache.GetPoolFactory().SetSubscriptionEnabled(true);
-      cache.GetPoolFactory().SetSubscriptionAckInterval(5000);
-      cache.GetPoolFactory().SetSubscriptionMessageTrackingTimeout(5000);
+      cache.GetPoolFactory().SetSubscriptionAckInterval(TimeSpan.FromMilliseconds(5000));
+      cache.GetPoolFactory().SetSubscriptionMessageTrackingTimeout(TimeSpan.FromMilliseconds(5000));
       Util.Log("Created the Geode Cache Programmatically");
 
       RegionFactory regionFactory = cache.CreateRegionFactory(RegionShortcut.CACHING_PROXY);
@@ -851,25 +851,25 @@ void runDurableClientWithTwoPools()
       m_feeder.Call(InitFeeder2, CacheHelper.Locators, 0);
       Util.Log("Feeder started.");
 
-      m_client1.Call(InitDurableClientWithTwoPools, CacheHelper.Locators, 0, DurableClientId1, 30, -2, -2);
+      m_client1.Call(InitDurableClientWithTwoPools, CacheHelper.Locators, 0, DurableClientId1, TimeSpan.FromSeconds(30), -2, -2);
       Util.Log("DurableClient with Two Pools Initialized");
 
       m_feeder.Call(FeederUpdate2, 5, 10);
       Util.Log("Feeder performed first update.");
       Thread.Sleep(15000);
 
-      m_client1.Call(InitDurableClientWithTwoPools, CacheHelper.Locators, 0, DurableClientId1, 30, 6, 11); //+1 for marker, so 5+1, 10+1 etc
+      m_client1.Call(InitDurableClientWithTwoPools, CacheHelper.Locators, 0, DurableClientId1, TimeSpan.FromSeconds(30), 6, 11); //+1 for marker, so 5+1, 10+1 etc
       Util.Log("DurableClient with Two Pools after first update");
 
       m_feeder.Call(FeederUpdate2, 10, 5);
       Util.Log("Feeder performed second update.");
       Thread.Sleep(15000);
 
-      m_client1.Call(InitDurableClientWithTwoPools, CacheHelper.Locators, 0, DurableClientId1, 30, 16, 16);
+      m_client1.Call(InitDurableClientWithTwoPools, CacheHelper.Locators, 0, DurableClientId1, TimeSpan.FromSeconds(30), 16, 16);
       Util.Log("DurableClient with Two Pools after second update");
 
       Thread.Sleep(45000); //45 > 30 secs.
-      m_client1.Call(InitDurableClientWithTwoPools, CacheHelper.Locators, 0, DurableClientId1, 30, -1, -1);
+      m_client1.Call(InitDurableClientWithTwoPools, CacheHelper.Locators, 0, DurableClientId1, TimeSpan.FromSeconds(30), -1, -1);
       Util.Log("DurableClient with Two Pools after timeout");
 
       m_feeder.Call(ClientDown, false);
diff --git a/clicache/integration-test/ThinClientFunctionExecutionTestsN.cs b/clicache/integration-test/ThinClientFunctionExecutionTestsN.cs
index 8ce4f8e0..8a472bf5 100644
--- a/clicache/integration-test/ThinClientFunctionExecutionTestsN.cs
+++ b/clicache/integration-test/ThinClientFunctionExecutionTestsN.cs
@@ -61,43 +61,44 @@ public void AddResult(TResult result)
     }
     public ICollection<TResult> GetResult()
     {
-      return GetResult(50);
+      return GetResult(TimeSpan.FromSeconds(50));
     }
-
-    public ICollection<TResult> GetResult(UInt32 timeout) 
+    public ICollection<TResult> GetResult(TimeSpan timeout)
     {
       m_getResultCount++;
-      if (m_resultReady == true)
-      {
-        return m_results;
-      }
-      else
-      {
-        for (int i = 0; i < timeout; i++)
-        {
-          Thread.Sleep(1000);
-          if (m_resultReady == true)
-          {
-            return m_results;
-          }
 
+      lock (this) {
+        if (!m_resultReady) {
+          if (timeout > TimeSpan.Zero) {
+            if (!Monitor.Wait(this, timeout)) {
+              throw new FunctionExecutionException("Timeout waiting for result.");
+            }
+          } else {
+            throw new FunctionExecutionException("Results not ready.");
+          }
         }
-        throw new FunctionExecutionException(
-                   "Result is not ready, endResults callback is called before invoking getResult() method");
-
       }
+
+      return m_results;
     }
+
     public void EndResults()
     {
       m_endResultCount++;
-      m_resultReady = true;
+
+      lock (this) {
+        m_resultReady = true;
+        Monitor.Pulse(this);
+      }
     }
+
     public void ClearResults(/*bool unused*/)
     {
       m_results.Clear();
       m_addResultCount = 0;
       m_getResultCount = 0;
       m_endResultCount = 0;
+      m_resultReady = false;
     }
   }
 
@@ -688,7 +689,7 @@ public void OnRegionHA()
 
       Assert.IsTrue(exc != null, "onRegion Returned NULL");
 
-      Client.IResultCollector<object> rc = exc.WithArgs<ArrayList>(args1).Execute(RegionOperationsHAFunctionPrSHOP, 15);
+      Client.IResultCollector<object> rc = exc.WithArgs<ArrayList>(args1).Execute(RegionOperationsHAFunctionPrSHOP, TimeSpan.FromSeconds(15));
 
       ICollection<object> executeFunctionResult = rc.GetResult();
       List<Object> resultList = new List<Object>();
@@ -743,7 +744,7 @@ public void OnRegionHAStepOne()
 
       Assert.IsTrue(exc != null, "onRegion Returned NULL");
 
-      Client.IResultCollector<object> rc = exc.WithArgs<ArrayList>(args1).Execute(RegionOperationsHAFunction, 15);
+      Client.IResultCollector<object> rc = exc.WithArgs<ArrayList>(args1).Execute(RegionOperationsHAFunction, TimeSpan.FromSeconds(15));
 
       ICollection<object> executeFunctionResult = rc.GetResult();
       List<Object> resultList = new List<Object>();
@@ -769,7 +770,7 @@ public void OnRegionHAStepOne()
 
       Object[] filter = new Object[1];
       filter[0] = "KEY--" + 10;
-      rc = exc.WithArgs<ArrayList>(args1).WithFilter<Object>(filter).Execute(RegionOperationsHAFunction, 15);
+      rc = exc.WithArgs<ArrayList>(args1).WithFilter<Object>(filter).Execute(RegionOperationsHAFunction, TimeSpan.FromSeconds(15));
 
       executeFunctionResult = rc.GetResult();
       resultList = new List<Object>();
@@ -973,7 +974,7 @@ public void ExecuteFETimeOut()
         Util.Log("filter count= {0}.", filter.Length);
 
         Execution<object> exc = Client.FunctionService<object>.OnRegion<object, object>(region);
-        IResultCollector<object> rc = exc.WithArgs<Object>(args).WithFilter<object>(filter).Execute(FuncTimeOutName, 5000 * 1000);
+        IResultCollector<object> rc = exc.WithArgs<Object>(args).WithFilter<object>(filter).Execute(FuncTimeOutName, TimeSpan.FromSeconds(5000));
         ICollection<object> FunctionResult = rc.GetResult();
         Util.Log("ExecuteFETimeOut onRegion FunctionResult.Count = {0} ", FunctionResult.Count);        
         foreach (Boolean item in FunctionResult)
@@ -987,7 +988,7 @@ public void ExecuteFETimeOut()
 
       Pool pool = CacheHelper.DCache.GetPoolManager().Find(poolName);
       Execution<object> excs = Client.FunctionService<object>.OnServer(pool);
-      IResultCollector<object> rcs = excs.WithArgs<Object>(args).Execute(FuncTimeOutName, 5000 * 1000);
+      IResultCollector<object> rcs = excs.WithArgs<Object>(args).Execute(FuncTimeOutName, TimeSpan.FromSeconds(5000));
       ICollection<object> ServerFunctionResult = rcs.GetResult();
       Util.Log("ExecuteFETimeOut onServer FunctionResult.Count = {0} ", ServerFunctionResult.Count);
       foreach (Boolean item in ServerFunctionResult)
@@ -999,7 +1000,7 @@ public void ExecuteFETimeOut()
 
 
       Execution<object> excss = Client.FunctionService<object>.OnServers(pool);
-      IResultCollector<object> rcss = excss.WithArgs<Object>(args).Execute(FuncTimeOutName, 5000 * 1000);
+      IResultCollector<object> rcss = excss.WithArgs<Object>(args).Execute(FuncTimeOutName, TimeSpan.FromSeconds(5000));
       ICollection<object> ServerFunctionResults = rcss.GetResult();
       Util.Log("ExecuteFETimeOut onServer FunctionResult.Count = {0} ", ServerFunctionResults.Count);
       foreach (Boolean item in ServerFunctionResults)
@@ -1324,7 +1325,7 @@ public void OnServerHAStepOne()
       Apache.Geode.Client.Execution<object> exc = Client.FunctionService<object>.OnServer(pool);
       Assert.IsTrue(exc != null, "onServer Returned NULL");
 
-      Client.IResultCollector<object> rc = exc.WithArgs<ArrayList>(args1).Execute(OnServerHAExceptionFunction, 15);
+      Client.IResultCollector<object> rc = exc.WithArgs<ArrayList>(args1).Execute(OnServerHAExceptionFunction, TimeSpan.FromSeconds(15));
 
       ICollection<object> executeFunctionResult = rc.GetResult();
 
@@ -1348,7 +1349,7 @@ public void OnServerHAStepOne()
         Assert.IsTrue(((string)resultList[i]) != null, "onServer Returned NULL");
       }
 
-      rc = exc.WithArgs<ArrayList>(args1).Execute(OnServerHAShutdownFunction, 15);
+      rc = exc.WithArgs<ArrayList>(args1).Execute(OnServerHAShutdownFunction, TimeSpan.FromSeconds(15));
 
       ICollection<object> executeFunctionResult1 = rc.GetResult();
 
diff --git a/clicache/integration-test/ThinClientHARegionTestsN.cs b/clicache/integration-test/ThinClientHARegionTestsN.cs
index 5a003676..2a9d9688 100644
--- a/clicache/integration-test/ThinClientHARegionTestsN.cs
+++ b/clicache/integration-test/ThinClientHARegionTestsN.cs
@@ -84,7 +84,7 @@ public void InitClient_Pool(string locators, int redundancyLevel)
     }
 
     public void InitClientForEventId_Pool(string locators, bool notification,
-      int redundancyLevel, int ackInterval, int dupCheckLife)
+      int redundancyLevel, TimeSpan ackInterval, TimeSpan dupCheckLife)
     {
       CacheHelper.Init();
       CacheHelper.CreatePool<object, object>("__TESTPOOL1_", locators, null,
@@ -847,13 +847,13 @@ void runPeriodicAck()
       CacheHelper.StartJavaServerWithLocators(2, "GFECS2", 1);
       Util.Log("Cacheserver 2 started.");
 
-      m_client1.Call(InitClientForEventId_Pool, CacheHelper.Locators, false, 1, 10, 30);
+      m_client1.Call(InitClientForEventId_Pool, CacheHelper.Locators, false, 1, TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30));
 
       m_client1.Call(CreateHATCRegions, RegionNames, false,
         (string)null, false, true);
       Util.Log("StepOne complete.");
 
-      m_client2.Call(InitClientForEventId_Pool, CacheHelper.Locators, true, 1, 10, 30);
+      m_client2.Call(InitClientForEventId_Pool, CacheHelper.Locators, true, 1, TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30));
       m_client2.Call(CreateHATCRegions, RegionNames, false,
         (string)null, true, true);
       m_client2.Call(InitDupListeners);
@@ -892,12 +892,12 @@ void runEventIDMap()
       CacheHelper.StartJavaServerWithLocators(1, "GFECS1", 1);
       Util.Log("Cacheserver 1 started.");
 
-      m_client1.Call(InitClientForEventId_Pool, CacheHelper.Locators, false, 1, 3600, 3600);
+      m_client1.Call(InitClientForEventId_Pool, CacheHelper.Locators, false, 1, TimeSpan.FromSeconds(3600), TimeSpan.FromSeconds(3600));
       m_client1.Call(CreateHATCRegions, RegionNames, false,
        (string)null, false, true);
       Util.Log("StepOne complete.");
 
-      m_client2.Call(InitClientForEventId_Pool, CacheHelper.Locators, true, 1, 3600, 3600);
+      m_client2.Call(InitClientForEventId_Pool, CacheHelper.Locators, true, 1, TimeSpan.FromSeconds(3600), TimeSpan.FromSeconds(3600));
       m_client2.Call(CreateHATCRegions, RegionNames, false,
         (string)null, true, true);
       m_client2.Call(InitDupListeners);
diff --git a/clicache/integration-test/ThinClientPoolTestsN.cs b/clicache/integration-test/ThinClientPoolTestsN.cs
index 726302a2..a65e7b62 100644
--- a/clicache/integration-test/ThinClientPoolTestsN.cs
+++ b/clicache/integration-test/ThinClientPoolTestsN.cs
@@ -74,25 +74,25 @@ bool checkPoolAttributes
       Client.Pool pool,
       string[] locators,
       string[] servers,
-      int freeConnectionTimeout,
-      int loadConditioningInterval,
+      TimeSpan freeConnectionTimeout,
+      TimeSpan loadConditioningInterval,
       int minConnections,
       int maxConnections,
       int retryAttempts,
-      int idleTimeout,
-      int pingInterval,
+      TimeSpan idleTimeout,
+      TimeSpan pingInterval,
       string name,
-      int readTimeout,
+      TimeSpan readTimeout,
       string serverGroup,
       int socketBufferSize,
       bool subscriptionEnabled,
-      int subscriptionMessageTrackingTimeout,
-      int subscriptionAckInterval,
+      TimeSpan subscriptionMessageTrackingTimeout,
+      TimeSpan subscriptionAckInterval,
       int subscriptionRedundancy,
-      int statisticInterval,
+      TimeSpan statisticInterval,
       int threadLocalConnections,
       bool prSingleHopEnabled,
-      int updateLocatorListInterval
+      TimeSpan updateLocatorListInterval
     )
     {
       if (pool == null)
@@ -272,14 +272,14 @@ public void runPoolXmlCreation()
 
       // ARB:
       // TODO: check if server list contains the two endpoints (currently using null argument for servers list)
-      bool check1 = checkPoolAttributes(poolOfRegion1, locators, null, 12345, 23456, 3, 7, 3, 5555, 12345,
-        "test_pool_1", 23456, "ServerGroup1", 32768, true, 900123, 567, 0, 10123, 5, true, 250001);
+      bool check1 = checkPoolAttributes(poolOfRegion1, locators, null, TimeSpan.FromMilliseconds(12345), TimeSpan.FromMilliseconds(23456), 3, 7, 3, TimeSpan.FromMilliseconds(5555), TimeSpan.FromMilliseconds(12345),
+        "test_pool_1", TimeSpan.FromMilliseconds(23456), "ServerGroup1", 32768, true, TimeSpan.FromMilliseconds(900123), TimeSpan.FromMilliseconds(567), 0, TimeSpan.FromMilliseconds(10123), 5, true, TimeSpan.FromMilliseconds(250001));
 
-      bool check2 = checkPoolAttributes(poolOfRegion2, null, servers, 23456, 34567, 2, 8, 5, 6666, 23456,
-        "test_pool_2", 34567, "ServerGroup2", 65536, false, 800222, 678, 1, 20345, 3, false, 5000);
+      bool check2 = checkPoolAttributes(poolOfRegion2, null, servers, TimeSpan.FromMilliseconds(23456), TimeSpan.FromMilliseconds(34567), 2, 8, 5, TimeSpan.FromMilliseconds(6666), TimeSpan.FromMilliseconds(23456),
+        "test_pool_2", TimeSpan.FromMilliseconds(34567), "ServerGroup2", 65536, false, TimeSpan.FromMilliseconds(800222), TimeSpan.FromMilliseconds(678), 1, TimeSpan.FromMilliseconds(20345), 3, false, TimeSpan.FromMilliseconds(5000));
 
-      bool check3 = checkPoolAttributes(poolOfSubRegion, null, servers, 23456, 34567, 2, 8, 5, 6666, 23456,
-        "test_pool_2", 34567, "ServerGroup2", 65536, false, 800222, 678, 1, 20345, 3, false, 5000);
+      bool check3 = checkPoolAttributes(poolOfSubRegion, null, servers, TimeSpan.FromMilliseconds(23456), TimeSpan.FromMilliseconds(34567), 2, 8, 5, TimeSpan.FromMilliseconds(6666), TimeSpan.FromMilliseconds(23456),
+        "test_pool_2", TimeSpan.FromMilliseconds(34567), "ServerGroup2", 65536, false, TimeSpan.FromMilliseconds(800222), TimeSpan.FromMilliseconds(678), 1, TimeSpan.FromMilliseconds(20345), 3, false, TimeSpan.FromMilliseconds(5000));
 
       Assert.IsTrue(check1, "Attribute check 1 failed");
       Assert.IsTrue(check2, "Attribute check 2 failed");
@@ -361,43 +361,43 @@ public void createPoolAndTestAttrs(string poolName)
       CacheHelper.Init();
 
       PoolFactory factory = CacheHelper.DCache.GetPoolManager().CreateFactory();
-      factory.SetFreeConnectionTimeout(10000);
-      factory.SetLoadConditioningInterval(1);
+      factory.SetFreeConnectionTimeout(TimeSpan.FromSeconds(10000));
+      factory.SetLoadConditioningInterval(TimeSpan.FromSeconds(1));
       factory.SetSocketBufferSize(1024);
-      factory.SetReadTimeout(10);
+      factory.SetReadTimeout(TimeSpan.FromSeconds(10));
       factory.SetMinConnections(2);
       factory.SetMaxConnections(5);
-      factory.SetIdleTimeout(5);
+      factory.SetIdleTimeout(TimeSpan.FromSeconds(5));
       factory.SetRetryAttempts(5);
-      factory.SetPingInterval(1);
-      factory.SetUpdateLocatorListInterval(122000);
-      factory.SetStatisticInterval(1);
+      factory.SetPingInterval(TimeSpan.FromSeconds(1));
+      factory.SetUpdateLocatorListInterval(TimeSpan.FromMilliseconds(122000));
+      factory.SetStatisticInterval(TimeSpan.FromSeconds(1));
       factory.SetServerGroup("ServerGroup1");
       factory.SetSubscriptionEnabled(true);
       factory.SetSubscriptionRedundancy(1);
-      factory.SetSubscriptionMessageTrackingTimeout(5);
-      factory.SetSubscriptionAckInterval(1);
+      factory.SetSubscriptionMessageTrackingTimeout(TimeSpan.FromSeconds(5));
+      factory.SetSubscriptionAckInterval(TimeSpan.FromSeconds(1));
       factory.AddLocator("localhost", CacheHelper.LOCATOR_PORT_1);
       factory.SetPRSingleHopEnabled(false);
 
       Pool pool = factory.Create(poolName, CacheHelper.DCache);
 
-      Assert.AreEqual(10000, pool.FreeConnectionTimeout, "FreeConnectionTimeout");
-      Assert.AreEqual(1, pool.LoadConditioningInterval, "LoadConditioningInterval");
+      Assert.AreEqual(TimeSpan.FromSeconds(10000), pool.FreeConnectionTimeout, "FreeConnectionTimeout");
+      Assert.AreEqual(TimeSpan.FromSeconds(1), pool.LoadConditioningInterval, "LoadConditioningInterval");
       Assert.AreEqual(1024, pool.SocketBufferSize, "SocketBufferSize");
-      Assert.AreEqual(10, pool.ReadTimeout, "ReadTimeout");
+      Assert.AreEqual(TimeSpan.FromSeconds(10), pool.ReadTimeout, "ReadTimeout");
       Assert.AreEqual(2, pool.MinConnections, "MinConnections");
       Assert.AreEqual(5, pool.MaxConnections, "MaxConnections");
-      Assert.AreEqual(5, pool.IdleTimeout, "IdleTimeout");
+      Assert.AreEqual(TimeSpan.FromSeconds(5), pool.IdleTimeout, "IdleTimeout");
       Assert.AreEqual(5, pool.RetryAttempts, "RetryAttempts");
-      Assert.AreEqual(1, pool.PingInterval, "PingInterval");
-      Assert.AreEqual(122000, pool.UpdateLocatorListInterval, "UpdateLocatorListInterval");
-      Assert.AreEqual(1, pool.StatisticInterval, "StatisticInterval");
+      Assert.AreEqual(TimeSpan.FromSeconds(1), pool.PingInterval, "PingInterval");
+      Assert.AreEqual(TimeSpan.FromMilliseconds(122000), pool.UpdateLocatorListInterval, "UpdateLocatorListInterval");
+      Assert.AreEqual(TimeSpan.FromSeconds(1), pool.StatisticInterval, "StatisticInterval");
       Assert.AreEqual("ServerGroup1", pool.ServerGroup, "ServerGroup");
       Assert.AreEqual(true, pool.SubscriptionEnabled, "SubscriptionEnabled");
       Assert.AreEqual(1, pool.SubscriptionRedundancy, "SubscriptionRedundancy");
-      Assert.AreEqual(5, pool.SubscriptionMessageTrackingTimeout, "SubscriptionMessageTrackingTimeout");
-      Assert.AreEqual(1, pool.SubscriptionAckInterval, "SubscriptionAckInterval");
+      Assert.AreEqual(TimeSpan.FromSeconds(5), pool.SubscriptionMessageTrackingTimeout, "SubscriptionMessageTrackingTimeout");
+      Assert.AreEqual(TimeSpan.FromSeconds(1), pool.SubscriptionAckInterval, "SubscriptionAckInterval");
       Assert.AreEqual(false, pool.PRSingleHopEnabled, "PRSingleHopEnabled");
     }
 
@@ -414,22 +414,22 @@ public void testPoolAttrs(string poolName)
       Pool pool = CacheHelper.DCache.GetPoolManager().Find(poolName);
 
       Assert.AreEqual("clientPool", pool.Name, "Pool Name");
-      Assert.AreEqual(10000, pool.FreeConnectionTimeout, "FreeConnectionTimeout");
-      Assert.AreEqual(1, pool.LoadConditioningInterval, "LoadConditioningInterval");
+      Assert.AreEqual(TimeSpan.FromSeconds(10000), pool.FreeConnectionTimeout, "FreeConnectionTimeout");
+      Assert.AreEqual(TimeSpan.FromSeconds(1), pool.LoadConditioningInterval, "LoadConditioningInterval");
       Assert.AreEqual(1024, pool.SocketBufferSize, "SocketBufferSize");
-      Assert.AreEqual(10, pool.ReadTimeout, "ReadTimeout");
+      Assert.AreEqual(TimeSpan.FromSeconds(10), pool.ReadTimeout, "ReadTimeout");
       Assert.AreEqual(2, pool.MinConnections, "MinConnections");
       Assert.AreEqual(5, pool.MaxConnections, "MaxConnections");
-      Assert.AreEqual(5, pool.IdleTimeout, "IdleTimeout");
+      Assert.AreEqual(TimeSpan.FromSeconds(5), pool.IdleTimeout, "IdleTimeout");
       Assert.AreEqual(5, pool.RetryAttempts, "RetryAttempts");
-      Assert.AreEqual(1, pool.PingInterval, "PingInterval");
-      Assert.AreEqual(25000, pool.UpdateLocatorListInterval, "UpdateLocatorListInterval");
-      Assert.AreEqual(1, pool.StatisticInterval, "StatisticInterval");
+      Assert.AreEqual(TimeSpan.FromSeconds(1), pool.PingInterval, "PingInterval");
+      Assert.AreEqual(TimeSpan.FromMilliseconds(25000), pool.UpdateLocatorListInterval, "UpdateLocatorListInterval");
+      Assert.AreEqual(TimeSpan.FromSeconds(1), pool.StatisticInterval, "StatisticInterval");
       Assert.AreEqual("ServerGroup1", pool.ServerGroup, "ServerGroup");
       Assert.AreEqual(true, pool.SubscriptionEnabled, "SubscriptionEnabled");
       Assert.AreEqual(1, pool.SubscriptionRedundancy, "SubscriptionRedundancy");
-      Assert.AreEqual(5, pool.SubscriptionMessageTrackingTimeout, "SubscriptionMessageTrackingTimeout");
-      Assert.AreEqual(1, pool.SubscriptionAckInterval, "SubscriptionAckInterval");
+      Assert.AreEqual(TimeSpan.FromSeconds(5), pool.SubscriptionMessageTrackingTimeout, "SubscriptionMessageTrackingTimeout");
+      Assert.AreEqual(TimeSpan.FromSeconds(1), pool.SubscriptionAckInterval, "SubscriptionAckInterval");
       Assert.AreEqual(false, pool.PRSingleHopEnabled, "PRSingleHopEnabled");
     }
 
diff --git a/clicache/integration-test/ThinClientQueryTestsN.cs b/clicache/integration-test/ThinClientQueryTestsN.cs
index 63d8e8a6..0f7ea101 100644
--- a/clicache/integration-test/ThinClientQueryTestsN.cs
+++ b/clicache/integration-test/ThinClientQueryTestsN.cs
@@ -1021,7 +1021,7 @@ public void StepThreeQT()
       try
       {
         Util.Log("EXECUTE 1 START for query: ", query.QueryString);
-        ISelectResults<object> results = query.Execute(3);
+        ISelectResults<object> results = query.Execute(TimeSpan.FromSeconds(3));
         Util.Log("EXECUTE 1 STOP");
         Util.Log("Result size is {0}", results.Size);
         Assert.Fail("Didnt get expected timeout exception for first execute");
@@ -1043,7 +1043,7 @@ public void StepFourQT()
       try
       {
         Util.Log("EXECUTE 2 START for query: ", query.QueryString);
-        ISelectResults<object> results = query.Execute(850);
+        ISelectResults<object> results = query.Execute(TimeSpan.FromSeconds(850));
         Util.Log("EXECUTE 2 STOP");
         Util.Log("Result size is {0}", results.Size);
       }
@@ -1064,7 +1064,7 @@ public void StepFiveQT()
       try
       {
         Util.Log("EXECUTE 3 START for query: ", query.QueryString);
-        ISelectResults<object> results = query.Execute(2);
+        ISelectResults<object> results = query.Execute(TimeSpan.FromSeconds(2));
         Util.Log("EXECUTE 3 STOP");
         Util.Log("Result size is {0}", results.Size);
         Assert.Fail("Didnt get expected timeout exception for third execute");
@@ -1085,7 +1085,7 @@ public void StepSixQT()
       try
       {
         Util.Log("EXECUTE 4 START for query: ", query.QueryString);
-        ISelectResults<object> results = query.Execute(850);
+        ISelectResults<object> results = query.Execute(TimeSpan.FromSeconds(850));
         Util.Log("EXECUTE 4 STOP");
         Util.Log("Result size is {0}", results.Size);
       }
@@ -1127,7 +1127,7 @@ public void StepThreePQT()
           }
         }
 
-        ISelectResults<object> results = query.Execute(paramList, 1);
+        ISelectResults<object> results = query.Execute(paramList, TimeSpan.FromSeconds(1));
         Util.Log("EXECUTE 5 STOP");
         Util.Log("Result size is {0}", results.Size);
         Assert.Fail("Didnt get expected timeout exception for Fifth execute");
@@ -1169,7 +1169,7 @@ public void StepFourPQT()
           }
         }
 
-        ISelectResults<object> results = query.Execute(paramList, 850);
+        ISelectResults<object> results = query.Execute(paramList, TimeSpan.FromSeconds(850));
         Util.Log("EXECUTE 6 STOP");
         Util.Log("Result size is {0}", results.Size);
       }
@@ -1237,7 +1237,7 @@ public void StepThreeRQ()
 
       try
       {
-        ISelectResults<object> results = region.Query<object>(QueryStatics.RegionQueries[0].Query, 2200000);
+        ISelectResults<object> results = region.Query<object>(QueryStatics.RegionQueries[0].Query, TimeSpan.FromSeconds(2200000));
         Assert.Fail("Expected IllegalArgumentException exception for invalid timeout");
       }
       catch (IllegalArgumentException ex)
@@ -1308,7 +1308,7 @@ public void StepFourRQ()
 
       try
       {
-        bool existsValue = region.ExistsValue(QueryStatics.RegionQueries[0].Query, 2200000);
+        bool existsValue = region.ExistsValue(QueryStatics.RegionQueries[0].Query, TimeSpan.FromSeconds(2200000));
         Assert.Fail("Expected IllegalArgumentException exception for invalid timeout");
       }
       catch (IllegalArgumentException ex)
@@ -1400,7 +1400,7 @@ public void StepFiveRQ()
 
       try
       {
-        Object result = region.SelectValue(QueryStatics.RegionQueries[0].Query, 2200000);
+        Object result = region.SelectValue(QueryStatics.RegionQueries[0].Query, TimeSpan.FromSeconds(2200000));
         Assert.Fail("Expected IllegalArgumentException exception for invalid timeout");
       }
       catch (IllegalArgumentException ex)
diff --git a/clicache/integration-test/ThinClientRegionQueryTests.cs b/clicache/integration-test/ThinClientRegionQueryTests.cs
index 0dc7b64d..df33634a 100644
--- a/clicache/integration-test/ThinClientRegionQueryTests.cs
+++ b/clicache/integration-test/ThinClientRegionQueryTests.cs
@@ -209,7 +209,7 @@ public void StepThreeRQ()
 
       try
       {
-        ISelectResults<object> results = region.Query<object>(QueryStatics.RegionQueries[0].Query, 2200000);
+        ISelectResults<object> results = region.Query<object>(QueryStatics.RegionQueries[0].Query, TimeSpan.FromSeconds(2200000));
         Assert.Fail("Expected IllegalArgumentException exception for invalid timeout");
       }
       catch (IllegalArgumentException ex)
@@ -280,7 +280,7 @@ public void StepFourRQ()
 
       try
       {
-        bool existsValue = region.ExistsValue(QueryStatics.RegionQueries[0].Query, 2200000);
+        bool existsValue = region.ExistsValue(QueryStatics.RegionQueries[0].Query, TimeSpan.FromSeconds(2200000));
         Assert.Fail("Expected IllegalArgumentException exception for invalid timeout");
       }
       catch (IllegalArgumentException ex)
@@ -372,7 +372,7 @@ public void StepFiveRQ()
 
       try
       {
-        Object result = region.SelectValue(QueryStatics.RegionQueries[0].Query, 2200000);
+        Object result = region.SelectValue(QueryStatics.RegionQueries[0].Query, TimeSpan.FromSeconds(2200000));
         Assert.Fail("Expected IllegalArgumentException exception for invalid timeout");
       }
       catch (IllegalArgumentException ex)
diff --git a/clicache/integration-test/cacheserver_pool_client.xml b/clicache/integration-test/cacheserver_pool_client.xml
index 08e6776a..64917484 100644
--- a/clicache/integration-test/cacheserver_pool_client.xml
+++ b/clicache/integration-test/cacheserver_pool_client.xml
@@ -26,21 +26,21 @@
 	<pool
     name="clientPool"
     subscription-enabled="true"
-    free-connection-timeout="10000"
-    load-conditioning-interval="1"
+    free-connection-timeout="10000s"
+    load-conditioning-interval="1s"
     min-connections="2"
     max-connections="5"
     retry-attempts="5"
-    idle-timeout="5"
-    ping-interval="1"
-    read-timeout="10"
+    idle-timeout="5s"
+    ping-interval="1s"
+    read-timeout="10s"
     server-group ="ServerGroup1"
     socket-buffer-size ="1024"
-    subscription-message-tracking-timeout="5"
-    subscription-ack-interval="1"
+    subscription-message-tracking-timeout="5s"
+    subscription-ack-interval="1s"
     subscription-redundancy="1"
-    statistic-interval="1"
-    update-locator-list-interval="25000"       
+    statistic-interval="1s"
+    update-locator-list-interval="25000ms"       
     pr-single-hop-enabled="false"
   >
     <locator host="localhost" port="LOC_PORT1" />    
diff --git a/clicache/integration-test/test.bat.in b/clicache/integration-test/test.bat.in
index 172dfc08..92e3e01f 100644
--- a/clicache/integration-test/test.bat.in
+++ b/clicache/integration-test/test.bat.in
@@ -56,7 +56,7 @@ if %errorlevel% neq 0 exit /b %errorlevel%
 rem In Windows, pipes to tee return tee's exit code instead of executable's
 rem exit code. As a workaround we write exit codes to files.
 
-(${NUNIT_CONSOLE} /run:${NAMESPACE}.${TESTCLASS} ..\..\$<CONFIG>\UnitTests.dll 2>&1 && echo 0 >${TEST}.errorlevel || echo 1 >${TEST}.errorlevel) | tee %LOG%
+(${NUNIT_CONSOLE} /labels /run:${NAMESPACE}.${TESTCLASS} ..\..\$<CONFIG>\UnitTests.dll 2>&1 && echo 0 >${TEST}.errorlevel || echo 1 >${TEST}.errorlevel) | tee %LOG%
 
 rem Our testing framework sometimes leaves lingering server/locator processes.
 rem Let's clean up after ourselves so that we do not affect subsequent runs.
diff --git a/clicache/integration-test/valid_cache_pool.xml b/clicache/integration-test/valid_cache_pool.xml
index ae847540..a2da0d01 100644
--- a/clicache/integration-test/valid_cache_pool.xml
+++ b/clicache/integration-test/valid_cache_pool.xml
@@ -20,11 +20,12 @@
 
 <!-- Well-formed and valid xml file -->
 <client-cache
-    xmlns="http://schema.pivotal.io/gemfire/gfcpp-cache"
+    xmlns="http://geode.apache.org/schema/cpp-cache"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://schema.pivotal.io/gemfire/gfcpp-cache
-                        http://schema.pivotal.io/gemfire/gfcpp-cache/gfcpp-cache-9.0.xsd"
-    version="9.0">
+    xsi:schemaLocation="http://geode.apache.org/schema/cpp-cache
+                        http://geode.apache.org/schema/cpp-cache/cpp-cache-1.0.xsd"
+    version="1.0">
+
   <pdx ignore-unread-fields="true" />
   <root-region name = "Root1" >
     <region-attributes caching-enabled="true" pool-name="test_pool_1" />
@@ -40,22 +41,22 @@
   </root-region>
 
   <pool
-    free-connection-timeout = "12345"    
-    idle-timeout = "5555"
-    load-conditioning-interval = "23456"
+    free-connection-timeout = "12345ms"
+    idle-timeout = "5555ms"
+    load-conditioning-interval = "23456ms"
     max-connections = "7"
     min-connections = "3"
     name = "test_pool_1"
-    ping-interval = "12345"
-	  update-locator-list-interval="250001"
-    read-timeout = "23456"
+    ping-interval = "12345ms"
+	  update-locator-list-interval="250001ms"
+    read-timeout = "23456ms"
     retry-attempts = "3"
     server-group = "ServerGroup1"
     socket-buffer-size = "32768"
-    statistic-interval = "10123"
-    subscription-ack-interval = "567"
+    statistic-interval = "10123ms"
+    subscription-ack-interval = "567ms"
     subscription-enabled = "true"
-    subscription-message-tracking-timeout = "900123"    
+    subscription-message-tracking-timeout = "900123ms"    
     subscription-redundancy = "0"    
     thread-local-connections = "5"
     pr-single-hop-enabled="true"
@@ -65,21 +66,21 @@
   </pool>
   
   <pool
-    free-connection-timeout = "23456"    
-    idle-timeout = "6666"
-    load-conditioning-interval = "34567"
+    free-connection-timeout = "23456ms"
+    idle-timeout = "6666ms"
+    load-conditioning-interval = "34567ms"
     max-connections = "8"
     min-connections = "2"
     name = "test_pool_2"
-    ping-interval = "23456"
-    read-timeout = "34567"
+    ping-interval = "23456ms"
+    read-timeout = "34567ms"
     retry-attempts = "5"
     server-group = "ServerGroup2"
     socket-buffer-size = "65536"
-    statistic-interval = "20345"
-    subscription-ack-interval = "678"
+    statistic-interval = "20345ms"
+    subscription-ack-interval = "678ms"
     subscription-enabled = "false"
-    subscription-message-tracking-timeout = "800222"    
+    subscription-message-tracking-timeout = "800222ms"    
     subscription-redundancy = "1"
     thread-local-connections = "3"
     pr-single-hop-enabled="false"
diff --git a/clicache/src/AttributesFactory.cpp b/clicache/src/AttributesFactory.cpp
index 33f84eac..05559a7c 100644
--- a/clicache/src/AttributesFactory.cpp
+++ b/clicache/src/AttributesFactory.cpp
@@ -36,6 +36,7 @@
 #include "IFixedPartitionResolver.hpp"
 #include "impl/SafeConvert.hpp"
 #include "ExceptionTypes.hpp"
+#include "TimeSpanUtils.hpp"
 
 #include "begin_native.hpp"
 #include <memory>
@@ -222,11 +223,11 @@ namespace Apache
       // EXPIRATION ATTRIBUTES
 
       generic<class TKey, class TValue>
-      void AttributesFactory<TKey, TValue>::SetEntryIdleTimeout( ExpirationAction action, System::UInt32 idleTimeout )
+      void AttributesFactory<TKey, TValue>::SetEntryIdleTimeout( ExpirationAction action, TimeSpan idleTimeout )
       {
         try
         {
-          m_nativeptr->get()->setEntryIdleTimeout(static_cast<native::ExpirationAction::Action>( action ), idleTimeout );
+          m_nativeptr->get()->setEntryIdleTimeout(static_cast<native::ExpirationAction::Action>( action ), TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::seconds>(idleTimeout) );
         }
         finally
         {
@@ -235,11 +236,11 @@ namespace Apache
       }
 
       generic<class TKey, class TValue>
-      void AttributesFactory<TKey, TValue>::SetEntryTimeToLive( ExpirationAction action, System::UInt32 timeToLive )
+      void AttributesFactory<TKey, TValue>::SetEntryTimeToLive( ExpirationAction action, TimeSpan timeToLive )
       {
         try
         {
-          m_nativeptr->get()->setEntryTimeToLive( static_cast<native::ExpirationAction::Action>( action ), timeToLive );
+          m_nativeptr->get()->setEntryTimeToLive( static_cast<native::ExpirationAction::Action>( action ), TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::seconds>(timeToLive) );
         }
         finally
         {
@@ -248,11 +249,11 @@ namespace Apache
       }
 
       generic<class TKey, class TValue>
-      void AttributesFactory<TKey, TValue>::SetRegionIdleTimeout( ExpirationAction action, System::UInt32 idleTimeout )
+      void AttributesFactory<TKey, TValue>::SetRegionIdleTimeout( ExpirationAction action, TimeSpan idleTimeout )
       {
         try
         {
-          m_nativeptr->get()->setRegionIdleTimeout( static_cast<native::ExpirationAction::Action>( action ), idleTimeout );
+          m_nativeptr->get()->setRegionIdleTimeout( static_cast<native::ExpirationAction::Action>( action ), TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::seconds>(idleTimeout) );
         }
         finally
         {
@@ -261,11 +262,11 @@ namespace Apache
       }
 
       generic<class TKey, class TValue>
-      void AttributesFactory<TKey, TValue>::SetRegionTimeToLive( ExpirationAction action, System::UInt32 timeToLive )
+      void AttributesFactory<TKey, TValue>::SetRegionTimeToLive( ExpirationAction action, TimeSpan timeToLive )
       {
         try
         {
-          m_nativeptr->get()->setRegionTimeToLive( static_cast<native::ExpirationAction::Action>( action ), timeToLive );
+          m_nativeptr->get()->setRegionTimeToLive( static_cast<native::ExpirationAction::Action>( action ), TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::seconds>(timeToLive) );
         }
         finally
         {
diff --git a/clicache/src/AttributesFactory.hpp b/clicache/src/AttributesFactory.hpp
index 608c372b..01311b3a 100644
--- a/clicache/src/AttributesFactory.hpp
+++ b/clicache/src/AttributesFactory.hpp
@@ -36,15 +36,15 @@
 #include "native_unique_ptr.hpp"
 
 
-using namespace System;
-using namespace System::Collections::Generic;
-
 namespace Apache
 {
   namespace Geode
   {
     namespace Client
     {
+      using namespace System;
+      using namespace System::Collections::Generic;
+
       namespace native = apache::geode::client;
 
       /// <summary>
@@ -286,7 +286,7 @@ namespace Apache
         /// <param name="idleTimeout">
         /// the idleTimeout in seconds for entries in this region.
         /// </param>
-        void SetEntryIdleTimeout( ExpirationAction action, System::UInt32 idleTimeout );
+        void SetEntryIdleTimeout( ExpirationAction action, TimeSpan idleTimeout );
 
         /// <summary>
         /// Sets the timeToLive expiration attributes for region entries for the next
@@ -298,7 +298,7 @@ namespace Apache
         /// <param name="timeToLive">
         /// the timeToLive in seconds for entries in this region.
         /// </param>
-        void SetEntryTimeToLive( ExpirationAction action, System::UInt32 timeToLive );
+        void SetEntryTimeToLive( ExpirationAction action, TimeSpan timeToLive );
 
         /// <summary>
         /// Sets the idleTimeout expiration attributes for the region itself for the
@@ -310,7 +310,7 @@ namespace Apache
         /// <param name="idleTimeout">
         /// the idleTimeout in seconds for the region as a whole.
         /// </param>
-        void SetRegionIdleTimeout( ExpirationAction action, System::UInt32 idleTimeout );
+        void SetRegionIdleTimeout( ExpirationAction action, TimeSpan idleTimeout );
 
         /// <summary>
         /// Sets the timeToLive expiration attributes for the region itself for the
@@ -322,7 +322,7 @@ namespace Apache
         /// <param name="timeToLive">
         /// the timeToLive in seconds for the region as a whole.
         /// </param>
-        void SetRegionTimeToLive( ExpirationAction action, System::UInt32 timeToLive );
+        void SetRegionTimeToLive( ExpirationAction action, TimeSpan timeToLive );
 
 
         // PERSISTENCE
diff --git a/clicache/src/AttributesMutator.cpp b/clicache/src/AttributesMutator.cpp
index 9702ae3f..92a16053 100644
--- a/clicache/src/AttributesMutator.cpp
+++ b/clicache/src/AttributesMutator.cpp
@@ -23,8 +23,7 @@
 #include "impl/CacheLoader.hpp"
 #include "impl/CacheWriter.hpp"
 #include "impl/CacheListener.hpp"
-
-using namespace System;
+#include "TimeSpanUtils.hpp"
 
 namespace Apache
 {
@@ -32,14 +31,16 @@ namespace Apache
   {
     namespace Client
     {
+      using namespace System;
+
       namespace native = apache::geode::client;
 
       generic<class TKey, class TValue>
-      System::Int32 AttributesMutator<TKey, TValue>::SetEntryIdleTimeout( System::Int32 idleTimeout )
+      TimeSpan AttributesMutator<TKey, TValue>::SetEntryIdleTimeout( TimeSpan idleTimeout )
       {
         try
         {
-          return m_nativeptr->get()->setEntryIdleTimeout( idleTimeout );
+          return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->get()->setEntryIdleTimeout( TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::seconds>(idleTimeout) ));
         }
         finally
         {
@@ -64,11 +65,11 @@ namespace Apache
       }
 
       generic<class TKey, class TValue>
-      System::Int32 AttributesMutator<TKey, TValue>::SetEntryTimeToLive( System::Int32 timeToLive )
+      TimeSpan AttributesMutator<TKey, TValue>::SetEntryTimeToLive( TimeSpan timeToLive )
       {
         try
         {
-          return m_nativeptr->get()->setEntryTimeToLive( timeToLive );
+          return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->get()->setEntryTimeToLive( TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::seconds>(timeToLive) ));
         }
         finally
         {
@@ -93,11 +94,11 @@ namespace Apache
      }
 
       generic<class TKey, class TValue>
-      System::Int32 AttributesMutator<TKey, TValue>::SetRegionIdleTimeout( System::Int32 idleTimeout )
+      TimeSpan AttributesMutator<TKey, TValue>::SetRegionIdleTimeout( TimeSpan idleTimeout )
       {
         try
         {
-          return m_nativeptr->get()->setRegionIdleTimeout( idleTimeout );
+          return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->get()->setRegionIdleTimeout( TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::seconds>(idleTimeout) ));
         }
         finally
         {
@@ -122,11 +123,11 @@ namespace Apache
       }
 
       generic<class TKey, class TValue>
-      System::Int32 AttributesMutator<TKey, TValue>::SetRegionTimeToLive( System::Int32 timeToLive )
+      TimeSpan AttributesMutator<TKey, TValue>::SetRegionTimeToLive( TimeSpan timeToLive )
       {
         try
         {
-          return m_nativeptr->get()->setRegionTimeToLive( timeToLive );
+          return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->get()->setRegionTimeToLive( TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::seconds>(timeToLive) ));
         }
         finally
         {
diff --git a/clicache/src/AttributesMutator.hpp b/clicache/src/AttributesMutator.hpp
index db0bd62b..3421ef72 100644
--- a/clicache/src/AttributesMutator.hpp
+++ b/clicache/src/AttributesMutator.hpp
@@ -28,15 +28,14 @@
 #include "ICacheLoader.hpp"
 #include "ICacheWriter.hpp"
 
-
-using namespace System;
-
 namespace Apache
 {
   namespace Geode
   {
     namespace Client
     {
+      using namespace System;
+
       namespace native = apache::geode::client;
 
       /// <summary>
@@ -72,7 +71,7 @@ namespace Apache
         /// if the new idleTimeout changes entry expiration from
         /// disabled to enabled or enabled to disabled.
         /// </exception>
-        System::Int32 SetEntryIdleTimeout( System::Int32 idleTimeout );
+        TimeSpan SetEntryIdleTimeout( TimeSpan idleTimeout );
 
         /// <summary>
         /// Sets the idleTimeout action for region entries.
@@ -94,7 +93,7 @@ namespace Apache
         /// if the new timeToLive changes entry expiration from
         /// disabled to enabled or enabled to disabled
         /// </exception>
-        System::Int32 SetEntryTimeToLive( System::Int32 timeToLive );
+        TimeSpan SetEntryTimeToLive( TimeSpan timeToLive );
 
         /// <summary>
         /// Set the timeToLive action for region entries.
@@ -116,7 +115,7 @@ namespace Apache
         /// if the new idleTimeout changes region expiration from
         /// disabled to enabled or enabled to disabled.
         /// </exception>
-        System::Int32 SetRegionIdleTimeout( System::Int32 idleTimeout );
+        TimeSpan SetRegionIdleTimeout( TimeSpan idleTimeout );
 
         /// <summary>
         /// Sets the idleTimeout action for the region itself.
@@ -138,7 +137,7 @@ namespace Apache
         /// if the new timeToLive changes region expiration from
         /// disabled to enabled or enabled to disabled.
         /// </exception>
-        System::Int32 SetRegionTimeToLive( System::Int32 timeToLive );
+        TimeSpan SetRegionTimeToLive( TimeSpan timeToLive );
 
         /// <summary>
         /// Sets the timeToLive action for the region itself.
diff --git a/clicache/src/CMakeLists.txt b/clicache/src/CMakeLists.txt
index ec43bee1..fa92c687 100644
--- a/clicache/src/CMakeLists.txt
+++ b/clicache/src/CMakeLists.txt
@@ -48,7 +48,7 @@ target_link_libraries(Apache.Geode
 
 string(REPLACE "/EHsc" "/EHa" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
 string(REPLACE "/RTC1" "" CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG}")
-set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /clr /wd4947 /wd4251 /doc")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /clr /wd4947 /wd4251 /wd4635 /doc /we4488")
 set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} ${SHARED_LINKER_FLAGS_STRONG_KEY}")
 
 include_directories(${CMAKE_SOURCE_DIR}/clicache/include)
diff --git a/clicache/src/CacheTransactionManager.cpp b/clicache/src/CacheTransactionManager.cpp
index 68c1ddbc..e812c43d 100644
--- a/clicache/src/CacheTransactionManager.cpp
+++ b/clicache/src/CacheTransactionManager.cpp
@@ -19,8 +19,7 @@
 #include "impl/ManagedTransactionListener.hpp"
 #include "impl/ManagedTransactionWriter.hpp"
 #include "CacheTransactionManager.hpp"
-
-using namespace System;
+#include "TimeSpanUtils.hpp"
 
 namespace Apache
 {
@@ -29,6 +28,8 @@ namespace Apache
     namespace Client
     {
 
+      using namespace System;
+
       void CacheTransactionManager::Begin( )
       {
         _GF_MG_EXCEPTION_TRY2
@@ -180,13 +181,13 @@ namespace Apache
 
         _GF_MG_EXCEPTION_CATCH_ALL2
       }
-      bool CacheTransactionManager::TryResume(Apache::Geode::Client::TransactionId^ transactionId, System::Int32 waitTimeInMilliSec)
+      bool CacheTransactionManager::TryResume(Apache::Geode::Client::TransactionId^ transactionId, TimeSpan waitTime)
       {
         _GF_MG_EXCEPTION_TRY2
 
           try
           {
-            return m_nativeptr->get()->tryResume(transactionId->GetNative(), waitTimeInMilliSec);
+            return m_nativeptr->get()->tryResume(transactionId->GetNative(), TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::milliseconds>(waitTime));
           }
           finally
           {
diff --git a/clicache/src/CacheTransactionManager.hpp b/clicache/src/CacheTransactionManager.hpp
index 5c435a4f..8638bae1 100644
--- a/clicache/src/CacheTransactionManager.hpp
+++ b/clicache/src/CacheTransactionManager.hpp
@@ -168,9 +168,9 @@ namespace Apache
         /// </para>
         /// </summary>
         /// <param name="transactionId">the transaction to resume</param>
-        /// <param name="waitTimeInMilliSec">the maximum milliseconds to wait </param>
+        /// <param name="waitTime">the maximum time to wait </param>
         /// <returns>true if the transaction was resumed, false otherwise</returns>
-        bool TryResume(Apache::Geode::Client::TransactionId^ transactionId, System::Int32 waitTimeInMilliSec);
+        bool TryResume(Apache::Geode::Client::TransactionId^ transactionId, TimeSpan waitTime);
 
 
 
diff --git a/clicache/src/CqQuery.cpp b/clicache/src/CqQuery.cpp
index 25c93d95..bf156c98 100644
--- a/clicache/src/CqQuery.cpp
+++ b/clicache/src/CqQuery.cpp
@@ -25,8 +25,7 @@
 #include "ResultSet.hpp"
 #include "StructSet.hpp"
 #include "ExceptionTypes.hpp"
-
-using namespace System;
+#include "TimeSpanUtils.hpp"
 
 namespace Apache
 {
@@ -34,21 +33,23 @@ namespace Apache
   {
     namespace Client
     {
+      using namespace System;
+
       namespace native = apache::geode::client;
 
       generic<class TKey, class TResult>
       ICqResults<TResult>^ CqQuery<TKey, TResult>::ExecuteWithInitialResults()
       {
-        return ExecuteWithInitialResults(DEFAULT_QUERY_RESPONSE_TIMEOUT);
+        return ExecuteWithInitialResults(TimeSpanUtils::DurationToTimeSpan(native::DEFAULT_QUERY_RESPONSE_TIMEOUT));
       }
 
       generic<class TKey, class TResult>
-      ICqResults<TResult>^ CqQuery<TKey, TResult>::ExecuteWithInitialResults(System::UInt32 timeout)
+      ICqResults<TResult>^ CqQuery<TKey, TResult>::ExecuteWithInitialResults(TimeSpan timeout)
       {
         _GF_MG_EXCEPTION_TRY2/* due to auto replace */
           try
           {
-            auto nativeptr = m_nativeptr->get()->executeWithInitialResults(timeout);
+            auto nativeptr = m_nativeptr->get()->executeWithInitialResults(TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::milliseconds>(timeout));
  
             if (auto structptr = std::dynamic_pointer_cast<native::StructSet>(nativeptr))
             {
diff --git a/clicache/src/CqQuery.hpp b/clicache/src/CqQuery.hpp
index 8cbf9f82..957cb05a 100644
--- a/clicache/src/CqQuery.hpp
+++ b/clicache/src/CqQuery.hpp
@@ -24,15 +24,14 @@
 #include "end_native.hpp"
 #include "native_shared_ptr.hpp"
 
-
-using namespace System;
-
 namespace Apache
 {
   namespace Geode
   {
     namespace Client
     {
+      using namespace System;
+
       namespace native = apache::geode::client;
 
       generic<class TResult>
@@ -84,13 +83,9 @@ namespace Apache
         /// Executes the Cq Query on the cache server
         /// with the specified timeout and returns the results.
         /// </summary>
-        /// <param name="timeout">The time (in seconds) to wait for query response.
-        /// This should be less than or equal to 2^31/1000 i.e. 2147483.
+        /// <param name="timeout">The time to wait for query response.
         /// </param>
-        /// <exception cref="IllegalArgumentException">
-        /// if timeout parameter is greater than 2^31/1000.
-        /// </exception>
-        ICqResults<TResult>^ ExecuteWithInitialResults(System::UInt32 timeout);
+        ICqResults<TResult>^ ExecuteWithInitialResults(TimeSpan timeout);
 
         /// <summary>
         /// Get the string for this cq query.
diff --git a/clicache/src/ExceptionTypes.cpp b/clicache/src/ExceptionTypes.cpp
index e8eeb0c7..3c91e427 100644
--- a/clicache/src/ExceptionTypes.cpp
+++ b/clicache/src/ExceptionTypes.cpp
@@ -18,6 +18,9 @@
 #include "ExceptionTypes.hpp"
 #include <cstdlib>
 
+#define _GF_MG_EXCEPTION_ADD3(x) { "apache::geode::client::" #x, gcnew CreateException2( x::Create ) }
+#define _GF_MG_EXCEPTION_ADD4(x,y) { "apache::geode::client::" #y, gcnew CreateException2( x::Create ) }
+
 using namespace System;
 
 namespace Apache
@@ -27,9 +30,6 @@ namespace Apache
     namespace Client
     {
 
-#define _GF_MG_EXCEPTION_ADD3(x) { "apache::geode::client::" #x, gcnew CreateException2( x::Create ) }
-#define _GF_MG_EXCEPTION_ADD4(x,y) { "apache::geode::client::" #y, gcnew CreateException2( x::Create ) }
-
       Dictionary<String^, CreateException2^>^ GeodeException::Init( )
       {
         if (Native2ManagedExMap != nullptr)
@@ -96,8 +96,8 @@ namespace Apache
           _GF_MG_EXCEPTION_ADD3( InvalidDeltaException ),
           _GF_MG_EXCEPTION_ADD3( KeyNotFoundException ),
           _GF_MG_EXCEPTION_ADD3( CommitConflictException ),
-		  _GF_MG_EXCEPTION_ADD3( TransactionDataNodeHasDepartedException ),
-		  _GF_MG_EXCEPTION_ADD3( TransactionDataRebalancedException )
+          _GF_MG_EXCEPTION_ADD3( TransactionDataNodeHasDepartedException ),
+          _GF_MG_EXCEPTION_ADD3( TransactionDataRebalancedException )
         };
 
         Native2ManagedExMap = gcnew Dictionary<String^, CreateException2^>( );
@@ -112,7 +112,7 @@ namespace Apache
       System::Exception^ GeodeException::Get(const apache::geode::client::Exception& nativeEx)
       {
         Exception^ innerException = nullptr;
-        const apache::geode::client::ExceptionPtr& cause = nativeEx.getCause();
+        const auto cause = nativeEx.getCause();
         if (cause != nullptr) {
           innerException = GeodeException::Get(*cause);
         }
@@ -140,20 +140,21 @@ namespace Apache
                       gcnew array<Object^>{ mgMsg, innerException }));
                 if ( mgEx != nullptr ) {
                   return mgEx;
-    }  // namespace Client
-  }  // namespace Geode
-}  // namespace Apache
+                }
+              }
+            }
 
-        }
-        if (innerException == nullptr) {
-          return gcnew GeodeException(exName + ": " + exMsg,
-              gcnew GeodeException(GetStackTrace(nativeEx)));
-        }
-        else {
-          return gcnew GeodeException(exName + ": " + exMsg, innerException);
+          }
+          if (innerException == nullptr) {
+            return gcnew GeodeException(exName + ": " + exMsg,
+                gcnew GeodeException(GetStackTrace(nativeEx)));
+          }
+          else {
+            return gcnew GeodeException(exName + ": " + exMsg, innerException);
+          }
         }
       }
-      } // end namespace generic
-    }
-  }
-}
+
+    }  // namespace Client
+  }  // namespace Geode
+}  // namespace Apache
diff --git a/clicache/src/Execution.cpp b/clicache/src/Execution.cpp
index 0a43e9ba..3b41d098 100644
--- a/clicache/src/Execution.cpp
+++ b/clicache/src/Execution.cpp
@@ -24,10 +24,10 @@
 
 #include "ResultCollector.hpp"
 #include "impl/ManagedResultCollector.hpp"
-
 #include "impl/ManagedString.hpp"
 #include "ExceptionTypes.hpp"
 #include "impl/SafeConvert.hpp"
+#include "TimeSpanUtils.hpp"
 
 using namespace System;
 
@@ -106,13 +106,13 @@ namespace Apache
       }
 
       generic<class TResult>
-      IResultCollector<TResult>^ Execution<TResult>::Execute(String^ func, UInt32 timeout)
+      IResultCollector<TResult>^ Execution<TResult>::Execute(String^ func, TimeSpan timeout)
       {
         _GF_MG_EXCEPTION_TRY2/* due to auto replace */
         try
         {
           ManagedString mg_function(func);
-          auto rc = m_nativeptr->get()->execute(mg_function.CharPtr, timeout);
+          auto rc = m_nativeptr->get()->execute(mg_function.CharPtr, TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::milliseconds>(timeout));
           if (m_rc == nullptr)
             return gcnew ResultCollector<TResult>(rc);
           else
@@ -128,7 +128,7 @@ namespace Apache
       generic<class TResult>
       IResultCollector<TResult>^ Execution<TResult>::Execute(String^ func)
       {
-        return Execute(func, DEFAULT_QUERY_RESPONSE_TIMEOUT);
+        return Execute(func, TimeSpanUtils::DurationToTimeSpan(native::DEFAULT_QUERY_RESPONSE_TIMEOUT));
       }
     }  // namespace Client
   }  // namespace Geode
diff --git a/clicache/src/Execution.hpp b/clicache/src/Execution.hpp
index 44fcf44a..a1f27b8f 100644
--- a/clicache/src/Execution.hpp
+++ b/clicache/src/Execution.hpp
@@ -48,31 +48,31 @@ namespace Apache
       {
       public:
         /// <summary>
-		/// Add a routing object, 
+		    /// Add a routing object, 
         /// Return self.
         /// </summary>
-		generic<class TFilter>
-    Execution<TResult>^ WithFilter(System::Collections::Generic::ICollection<TFilter>^ routingObj);
+		    generic<class TFilter>
+        Execution<TResult>^ WithFilter(System::Collections::Generic::ICollection<TFilter>^ routingObj);
 
         /// <summary>
-		/// Add an argument, 
+		    /// Add an argument, 
         /// Return self.
         /// </summary>
-    generic<class TArgs>
-		Execution<TResult>^ WithArgs(TArgs args);
+        generic<class TArgs>
+		    Execution<TResult>^ WithArgs(TArgs args);
 
         /// <summary>
-		/// Add a result collector, 
+		    /// Add a result collector, 
         /// Return self.
         /// </summary>
-		Execution<TResult>^ WithCollector(IResultCollector<TResult>^ rc);
+		    Execution<TResult>^ WithCollector(IResultCollector<TResult>^ rc);
 
         /// <summary>
         /// Execute a function, 
         /// Return resultCollector.
         /// </summary>
-		/// <param name="timeout"> Value to wait for the operation to finish before timing out.</param> 
-        IResultCollector<TResult>^ Execute(String^ func, UInt32 timeout);
+		    /// <param name="timeout"> Value to wait for the operation to finish before timing out.</param> 
+        IResultCollector<TResult>^ Execute(String^ func, TimeSpan timeout);
 
         /// <summary>
         /// Execute a function, 
diff --git a/clicache/src/IPdxInstance.hpp b/clicache/src/IPdxInstance.hpp
index dee3cd0d..56895174 100755
--- a/clicache/src/IPdxInstance.hpp
+++ b/clicache/src/IPdxInstance.hpp
@@ -16,169 +16,168 @@
  */
 
 #pragma once
-#include "IWritablePdxInstance.hpp"
-using namespace System;
-using namespace System::Collections::Generic;
+
 namespace Apache
 {
   namespace Geode
   {
     namespace Client
     {
+      using namespace System;
+      using namespace System::Collections::Generic;
+
+      interface class IWritablePdxInstance;
+
+      /// <summary>
+      ///PdxInstance provides run time access to the fields of a PDX without 
+      ///deserializing the PDX. Preventing deserialization saves time
+      ///and memory and does not require the domain class.
+      ///This interface is implemented by NativeClient. The PdxInstance implementation 
+      ///is a light weight wrapper that simply refers to the raw bytes of the PDX 
+      ///that are kept in the cache.
+      ///Applications can choose to access PdxInstances instead of .NET objects by 
+      ///configuring the Cache to prefer PDX instances during deserialization. 
+      ///This can be done in <c>cache.xml</c> by setting the attribute <c>read-serialized</c> 
+      ///to true on the <c>pdx</c> element. Or it can be done programmatically using
+      ///the <see cref="CacheFactory.SetPdxReadSerialized" /> 
+      ///method. Once this preference is configured, then any time deserialization of a 
+      ///PDX is done it will deserialize into a PdxInstance.
+      ///PdxInstance are immutable. If you want to change one call
+      ///<see cref="IPdxInstance.CreateWriter"/>.
+      ///
+      /// </summary>
+      public interface class IPdxInstance : public IDisposable
+      {
+      public:
+
+        /// <summary> 
+        ///Return the full name of the class that this pdx instance represents.          
+        /// </summary>
+        ///<returns> the name of the class that this pdx instance represents.</returns>
+        String^ GetClassName();
 
-         /// <summary>
-         ///PdxInstance provides run time access to the fields of a PDX without 
-         ///deserializing the PDX. Preventing deserialization saves time
-         ///and memory and does not require the domain class.
-         ///This interface is implemented by NativeClient. The PdxInstance implementation 
-         ///is a light weight wrapper that simply refers to the raw bytes of the PDX 
-         ///that are kept in the cache.
-         ///Applications can choose to access PdxInstances instead of .NET objects by 
-         ///configuring the Cache to prefer PDX instances during deserialization. 
-         ///This can be done in <c>cache.xml</c> by setting the attribute <c>read-serialized</c> 
-         ///to true on the <c>pdx</c> element. Or it can be done programmatically using
-         ///the <see cref="CacheFactory.SetPdxReadSerialized" /> 
-         ///method. Once this preference is configured, then any time deserialization of a 
-         ///PDX is done it will deserialize into a PdxInstance.
-         ///PdxInstance are immutable. If you want to change one call
-        ///<see cref="IPdxInstance.CreateWriter"/>.
-         ///
-         /// </summary>
-        public interface class IPdxInstance : IDisposable
-        {
-          public:
-           /// <summary> 
-           ///Return the full name of the class that this pdx instance represents.          
-           /// </summary>
-            ///<returns> the name of the class that this pdx instance represents.</returns>
-           String^ GetClassName();
-           /// <summary> 
-           ///Deserializes and returns the domain object that this instance represents.           
-           /// </summary>
-            ///<returns> the deserialized domain object.</returns>
-          Object^ GetObject();
+        /// <summary> 
+        ///Deserializes and returns the domain object that this instance represents.           
+        /// </summary>
+        ///<returns> the deserialized domain object.</returns>
+        Object^ GetObject();
 
-           /// <summary>
-           ///Checks if the named field exists and returns the result.
-           ///This can be useful when writing code that handles more than one version of
-           ///a PDX class.
-           /// </summary>
-          ///<param> fieldName the name of the field to check</param>
-          ///<returns> <code>true</code> if the named field exists; otherwise <code>false</code></returns>
-           
-          bool HasField(String^ fieldName);
+        /// <summary>
+        ///Checks if the named field exists and returns the result.
+        ///This can be useful when writing code that handles more than one version of
+        ///a PDX class.
+        /// </summary>
+        ///<param> fieldName the name of the field to check</param>
+        ///<returns> <code>true</code> if the named field exists; otherwise <code>false</code></returns>
+        bool HasField(String^ fieldName);
           
-            /// <summary>
-            ///Return an list of the field names on this PdxInstance.            
-            /// </summary>
-          ///<returns> an list of the field names on this PdxInstance</returns>
-          IList<String^>^ GetFieldNames();
+        /// <summary>
+        ///Return an list of the field names on this PdxInstance.            
+        /// </summary>
+        ///<returns> an list of the field names on this PdxInstance</returns>
+        IList<String^>^ GetFieldNames();
           
-          /// <summary>
-          ///Checks if the named field was <see cref="IPdxWriter.MarkIdentityField" /> marked as an identity field.
-          ///Note that if no fields have been marked then all the fields are used as identity fields even though
-          ///this method will return <code>false</code> since none of them have been marked.
-          /// </summary>
-          ///<param name="fieldName">  the name of the field to check</param>
-          ///<returns> <code>true</code> if the named field exists and was marked as an identify field; otherwise <code>false</code></returns> 
-           
-          bool IsIdentityField(String^ fieldName);
+        /// <summary>
+        ///Checks if the named field was <see cref="IPdxWriter.MarkIdentityField" /> marked as an identity field.
+        ///Note that if no fields have been marked then all the fields are used as identity fields even though
+        ///this method will return <code>false</code> since none of them have been marked.
+        /// </summary>
+        ///<param name="fieldName">  the name of the field to check</param>
+        ///<returns> <code>true</code> if the named field exists and was marked as an identify field; otherwise <code>false</code></returns>           
+        bool IsIdentityField(String^ fieldName);
 
-           /// <summary>
-           ///Reads the named field and returns its value. If the field does
-           ///not exist <code>null</code> is returned.
-           ///A <code>null</code> result indicates that the field does not exist
-           ///or that it exists and its value is currently <code>null</code>.
-          ///The <see cref="HasField" /> method can be used to figure out
-           ///which if these two cases is true.
-           ///If an Object[] is deserialized by this call then that array's component
-           ///type will be <code>Object</code> instead of the original class that
-           ///the array had when it was serialized. This is done so that PdxInstance objects
-           ///can be added to the array.
-           /// </summary>
-           /// 
-           ///<param name="fieldName">  name of the field to read</param>
-           ///         
-           ///
-           ///<returns> If this instance has the named field then the field's value is returned,
-           ///otherwise <code>null</code> is returned.</returns> 
-           
-            Object^ GetField(String^ fieldName);
+        /// <summary>
+        ///Reads the named field and returns its value. If the field does
+        ///not exist <code>null</code> is returned.
+        ///A <code>null</code> result indicates that the field does not exist
+        ///or that it exists and its value is currently <code>null</code>.
+        ///The <see cref="HasField" /> method can be used to figure out
+        ///which if these two cases is true.
+        ///If an Object[] is deserialized by this call then that array's component
+        ///type will be <code>Object</code> instead of the original class that
+        ///the array had when it was serialized. This is done so that PdxInstance objects
+        ///can be added to the array.
+        /// </summary>
+        /// 
+        ///<param name="fieldName">  name of the field to read</param>
+        ///         
+        ///
+        ///<returns> If this instance has the named field then the field's value is returned,
+        ///otherwise <code>null</code> is returned.</returns> 
+        Object^ GetField(String^ fieldName);
 
-           /// <summary>
-           ///Returns true if the given object is equals to this instance.
-           ///If <code>other</code> is not a PdxInstance then it is not equal to this instance.
-            ///NOTE: Even if <code>other</code> is the result of calling <see cref="GetObject" /> it will not
-           ///be equal to this instance.
-           ///Otherwise equality of two PdxInstances is determined as follows:
-           /// <list type="bullet">
-           /// <item>
-           ///<description>The domain class name must be equal for both PdxInstances</description>
-            /// </item>
-           /// <item>
-           ///<description>Each identity field must be equal.</description>
-            /// </item>
-           /// </list>
-           ///If one of the instances does not have a field that the other one does then equals will assume it
-           ///has the field with a default value.
-            ///If a PdxInstance has marked identity fields using <see cref="IPdxWriter.MarkIdentityField" /> 
-           ///then only the marked identity fields are its identity fields.
-           ///Otherwise all its fields are identity fields.
-           ///An identity field is equal if all the following are true:
-           /// <list type="bullet">
-            /// <item>
-           ///<description>The field name is equal.</description>
-            /// </item>
-            /// <item>
-           ///<description>The field type is equal.</description>
-            /// </item>
-            /// <item>
-           ///<description>The field value is equal.</description>
-            /// </item>
-           /// </list>
-           ///If a field's type is <code>OBJECT</code> then its value must be deserialized to determine if it is equals. If the deserialized object is an array then all the array element is used to determine equality. Otherwise <see cref="Object.Equals" /> is used.
-           ///If a field's type is <code>OBJECT[]</code> then its value must be deserialized and all the array element is used to determine equality.
-           ///For all other field types then the value does not need to be deserialized. Instead the serialized raw bytes are compared and used to determine equality.
-           ///Note that any fields that have objects that do not override <see cref="Object.Equals" /> will cause equals to return false when you might have expected it to return true.
-            /// </summary>
-            ///<param name="other"> the other instance to compare to this.</param>
-            ///<returns> <code>true</code> if this instance is equal to <code>other</code>.</returns>
-           
-           bool Equals(Object^ other);
+        /// <summary>
+        ///Returns true if the given object is equals to this instance.
+        ///If <code>other</code> is not a PdxInstance then it is not equal to this instance.
+        ///NOTE: Even if <code>other</code> is the result of calling <see cref="GetObject" /> it will not
+        ///be equal to this instance.
+        ///Otherwise equality of two PdxInstances is determined as follows:
+        /// <list type="bullet">
+        /// <item>
+        ///<description>The domain class name must be equal for both PdxInstances</description>
+        /// </item>
+        /// <item>
+        ///<description>Each identity field must be equal.</description>
+        /// </item>
+        /// </list>
+        ///If one of the instances does not have a field that the other one does then equals will assume it
+        ///has the field with a default value.
+        ///If a PdxInstance has marked identity fields using <see cref="IPdxWriter.MarkIdentityField" /> 
+        ///then only the marked identity fields are its identity fields.
+        ///Otherwise all its fields are identity fields.
+        ///An identity field is equal if all the following are true:
+        /// <list type="bullet">
+        /// <item>
+        ///<description>The field name is equal.</description>
+        /// </item>
+        /// <item>
+        ///<description>The field type is equal.</description>
+        /// </item>
+        /// <item>
+        ///<description>The field value is equal.</description>
+        /// </item>
+        /// </list>
+        ///If a field's type is <code>OBJECT</code> then its value must be deserialized to determine if it is equals. If the deserialized object is an array then all the array element is used to determine equality. Otherwise <see cref="Object.Equals" /> is used.
+        ///If a field's type is <code>OBJECT[]</code> then its value must be deserialized and all the array element is used to determine equality.
+        ///For all other field types then the value does not need to be deserialized. Instead the serialized raw bytes are compared and used to determine equality.
+        ///Note that any fields that have objects that do not override <see cref="Object.Equals" /> will cause equals to return false when you might have expected it to return true.
+        /// </summary>
+        ///<param name="other"> the other instance to compare to this.</param>
+        ///<returns> <code>true</code> if this instance is equal to <code>other</code>.</returns>
+        bool Equals(Object^ other);
 
-           /// <summary>
-           ///Generates a hashCode based on the identity fields of
-           ///this PdxInstance. 
-           ///If a PdxInstance has marked identity fields using <see cref="IPdxWriter.MarkIdentityField" />
-           ///then only the marked identity fields are its identity fields.
-           ///Otherwise all its fields are identity fields.
-           ///
-           ///If an identity field is of type <code>OBJECT</code> then it is deserialized. If the deserialized object is an array then all the array element is used. Otherwise <see cref="Object.GetHashCode" /> is used.
-           ///If an identity field is of type <code>OBJECT[]</code> this it is deserialized and all the array element is used.
-           ///Otherwise the field is not deserialized and the raw bytes of its value are used to compute the hash code.
-           /// </summary>
-           int GetHashCode();
+        /// <summary>
+        ///Generates a hashCode based on the identity fields of
+        ///this PdxInstance. 
+        ///If a PdxInstance has marked identity fields using <see cref="IPdxWriter.MarkIdentityField" />
+        ///then only the marked identity fields are its identity fields.
+        ///Otherwise all its fields are identity fields.
+        ///
+        ///If an identity field is of type <code>OBJECT</code> then it is deserialized. If the deserialized object is an array then all the array element is used. Otherwise <see cref="Object.GetHashCode" /> is used.
+        ///If an identity field is of type <code>OBJECT[]</code> this it is deserialized and all the array element is used.
+        ///Otherwise the field is not deserialized and the raw bytes of its value are used to compute the hash code.
+        /// </summary>
+        int GetHashCode();
 
-           /// <summary>
-           ///Prints out all of the identity fields of this PdxInstance.
-           ///If a PdxInstance has marked identity fields using <see cref="IPdxWriter.MarkIdentityField" />
-           ///then only the marked identity fields are its identity fields.
-           ///Otherwise all its fields are identity fields.
-           /// </summary>
-           String^ ToString();
+        /// <summary>
+        ///Prints out all of the identity fields of this PdxInstance.
+        ///If a PdxInstance has marked identity fields using <see cref="IPdxWriter.MarkIdentityField" />
+        ///then only the marked identity fields are its identity fields.
+        ///Otherwise all its fields are identity fields.
+        /// </summary>
+        String^ ToString();
           
-           /// <summary>
-           ///Creates and returns a <see cref="IWritablePdxInstance"/> whose initial
-           ///values are those of this PdxInstance.
-           ///This call returns a copy of the current field values so modifications
-           ///made to the returned value will not modify this PdxInstance.
-           /// </summary>
-           ///
-           ///<returns> a <see cref="IWritablePdxInstance"/></returns>
-           
-           IWritablePdxInstance^ CreateWriter();
+        /// <summary>
+        ///Creates and returns a <see cref="IWritablePdxInstance"/> whose initial
+        ///values are those of this PdxInstance.
+        ///This call returns a copy of the current field values so modifications
+        ///made to the returned value will not modify this PdxInstance.
+        /// </summary>
+        ///
+        ///<returns> a <see cref="IWritablePdxInstance"/></returns>  
+        IWritablePdxInstance^ CreateWriter();
 
-        };
+      };
     }  // namespace Client
   }  // namespace Geode
 }  // namespace Apache
diff --git a/clicache/src/IPdxInstanceFactory.hpp b/clicache/src/IPdxInstanceFactory.hpp
index 64f9d180..487a1b61 100644
--- a/clicache/src/IPdxInstanceFactory.hpp
+++ b/clicache/src/IPdxInstanceFactory.hpp
@@ -16,9 +16,9 @@
  */
 
 #pragma once
+
 #include "IPdxInstance.hpp"
-using namespace System;
-using namespace System::Collections::Generic;
+
 namespace Apache
 {
   namespace Geode
@@ -26,320 +26,319 @@ namespace Apache
     namespace Client
     {
 
+      using namespace System;
+      using namespace System::Collections::Generic;
+
+      /// <summary>
+      /// PdxInstanceFactory gives you a way to create PdxInstances.
+      /// Call the write methods to populate the field data and then call <see cref="Create"/>
+      /// to produce an actual instance that contains the data.
+      /// To create a factory call <see cref="IRegionService.CreatePdxInstanceFactory"/>.
+      /// A factory can only create a single instance. To create multiple instances create
+      /// multiple factories or use <see cref="IPdxInstance.CreateWriter" /> to create subsequent instances.
+      /// 
+      /// </summary>
+      public interface class IPdxInstanceFactory 
+      {
+      public:
+
         /// <summary>
-        /// PdxInstanceFactory gives you a way to create PdxInstances.
-        /// Call the write methods to populate the field data and then call <see cref="Create"/>
-        /// to produce an actual instance that contains the data.
-        /// To create a factory call <see cref="IRegionService.CreatePdxInstanceFactory"/>.
-        /// A factory can only create a single instance. To create multiple instances create
-        /// multiple factories or use <see cref="IPdxInstance.CreateWriter" /> to create subsequent instances.
-        /// 
+        /// Create a <see cref="IPdxInstance" /> . The instance
+        /// will contain any data written to this factory
+        /// using the write methods.
         /// </summary>
-        public interface class IPdxInstanceFactory 
-        {
-        public:
-         /// <summary>
-         /// Create a <see cref="IPdxInstance" /> . The instance
-         /// will contain any data written to this factory
-         /// using the write methods.
-          /// </summary>
-          /// <returns> the created instance</returns>
-         /// <exception cref="IllegalStateException"/> if called more than once </exception>
-         
+        /// <returns> the created instance</returns>
+        /// <exception cref="IllegalStateException"/> if called more than once </exception>        
         IPdxInstance^ Create();
 
-         /// <summary>   
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>char</code>.
+        /// <summary>   
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>char</code>.
         /// <para>Java char is mapped to .NET System.Char.</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
          
-         IPdxInstanceFactory^ WriteChar(String^ fieldName, Char value);
+        IPdxInstanceFactory^ WriteChar(String^ fieldName, Char value);
    
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>boolean</code>.
-         /// <para>Java boolean is mapped to .NET System.Boolean.</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>boolean</code>.
+        /// <para>Java boolean is mapped to .NET System.Boolean.</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
          
-         IPdxInstanceFactory^ WriteBoolean(String^ fieldName, Boolean value);
+        IPdxInstanceFactory^ WriteBoolean(String^ fieldName, Boolean value);
     
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>sbyte</code>.
-         /// <para>Java byte is mapped to .NET System.SByte.</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>sbyte</code>.
+        /// <para>Java byte is mapped to .NET System.SByte.</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
           
-         IPdxInstanceFactory^ WriteByte(String^ fieldName, SByte value);
+        IPdxInstanceFactory^ WriteByte(String^ fieldName, SByte value);
   
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>short</code>.
-         /// <para>Java short is mapped to .NET System.Int16.</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
-         IPdxInstanceFactory^ WriteShort(String^ fieldName, Int16 value);
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>short</code>.
+        /// <para>Java short is mapped to .NET System.Int16.</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        IPdxInstanceFactory^ WriteShort(String^ fieldName, Int16 value);
   
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>int</code>.
-         /// <para>Java int is mapped to .NET System.Int32.</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
-         IPdxInstanceFactory^ WriteInt(String^ fieldName, Int32 value);
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>int</code>.
+        /// <para>Java int is mapped to .NET System.Int32.</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        IPdxInstanceFactory^ WriteInt(String^ fieldName, Int32 value);
   
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>long</code>.
-         /// <para>Java long is mapped to .NET System.Int64.</para>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
-         /// </summary> 
-         IPdxInstanceFactory^ WriteLong(String^ fieldName, Int64 value);
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>long</code>.
+        /// <para>Java long is mapped to .NET System.Int64.</para>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        /// </summary> 
+        IPdxInstanceFactory^ WriteLong(String^ fieldName, Int64 value);
   
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>float</code>.
-         /// <para>Java float is mapped to .NET System.Single(float).</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>float</code>.
+        /// <para>Java float is mapped to .NET System.Single(float).</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
          
-         IPdxInstanceFactory^ WriteFloat(String^ fieldName, float value);
+        IPdxInstanceFactory^ WriteFloat(String^ fieldName, float value);
   
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>double</code>.
-         /// <para>Java double is mapped to .NET System.Double.</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
-         IPdxInstanceFactory^ WriteDouble(String^ fieldName, double value);
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>double</code>.
+        /// <para>Java double is mapped to .NET System.Double.</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        IPdxInstanceFactory^ WriteDouble(String^ fieldName, double value);
   
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>Date</code>.
-         /// <para>Java Date is mapped to .NET System.DateTime.</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>Date</code>.
+        /// <para>Java Date is mapped to .NET System.DateTime.</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
          
-         IPdxInstanceFactory^ WriteDate(String^ fieldName, System::DateTime value);
+        IPdxInstanceFactory^ WriteDate(String^ fieldName, System::DateTime value);
   
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>String</code>.
-         /// <para>Java String is mapped to .NET System.String.</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
-         IPdxInstanceFactory^ WriteString(String^ fieldName, String^ value);
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>String</code>.
+        /// <para>Java String is mapped to .NET System.String.</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        IPdxInstanceFactory^ WriteString(String^ fieldName, String^ value);
         
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>Object</code>.
-         /// 
-         /// It is best to use one of the other writeXXX methods if your field type
-         /// will always be XXX. This method allows the field value to be anything
-         /// that is an instance of Object. This gives you more flexibility but more
-         /// space is used to store the serialized field.
-         /// </summary>
-         /// 
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
-         
-         IPdxInstanceFactory^ WriteObject(String^ fieldName, Object^ value);
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>Object</code>.
+        /// 
+        /// It is best to use one of the other writeXXX methods if your field type
+        /// will always be XXX. This method allows the field value to be anything
+        /// that is an instance of Object. This gives you more flexibility but more
+        /// space is used to store the serialized field.
+        /// </summary>
+        /// 
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        IPdxInstanceFactory^ WriteObject(String^ fieldName, Object^ value);
   
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>boolean[]</code>.
-         /// <para>Java boolean[] is mapped to .NET System.Boolean[].</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
-         
-         IPdxInstanceFactory^ WriteBooleanArray(String^ fieldName, array<Boolean>^ value);
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>boolean[]</code>.
+        /// <para>Java boolean[] is mapped to .NET System.Boolean[].</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        IPdxInstanceFactory^ WriteBooleanArray(String^ fieldName, array<Boolean>^ value);
   
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>char[]</code>.
-         /// <para>Java char[] is mapped to .NET System.Char[].</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
-         IPdxInstanceFactory^ WriteCharArray(String^ fieldName, array<Char>^ value);
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>char[]</code>.
+        /// <para>Java char[] is mapped to .NET System.Char[].</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        IPdxInstanceFactory^ WriteCharArray(String^ fieldName, array<Char>^ value);
         
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>byte[]</code>.
-         /// <para>Java byte[] is mapped to .NET System.Byte[].</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
-         IPdxInstanceFactory^ WriteByteArray(String^ fieldName, array<Byte>^ value);
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>byte[]</code>.
+        /// <para>Java byte[] is mapped to .NET System.Byte[].</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        IPdxInstanceFactory^ WriteByteArray(String^ fieldName, array<Byte>^ value);
         
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>short[]</code>.
-         /// <para>Java short[] is mapped to .NET System.Int16[].</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
-         IPdxInstanceFactory^ WriteShortArray(String^ fieldName, array<Int16>^ value);
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>short[]</code>.
+        /// <para>Java short[] is mapped to .NET System.Int16[].</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        IPdxInstanceFactory^ WriteShortArray(String^ fieldName, array<Int16>^ value);
         
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>int[]</code>.
-         /// <para>Java int[] is mapped to .NET System.Int32[].</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
-         IPdxInstanceFactory^ WriteIntArray(String^ fieldName, array<Int32>^ value);
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>int[]</code>.
+        /// <para>Java int[] is mapped to .NET System.Int32[].</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        IPdxInstanceFactory^ WriteIntArray(String^ fieldName, array<Int32>^ value);
         
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>long[]</code>.
-         /// <para>Java long[] is mapped to .NET System.Int64[].</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
-         IPdxInstanceFactory^ WriteLongArray(String^ fieldName, array<Int64>^ value);
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>long[]</code>.
+        /// <para>Java long[] is mapped to .NET System.Int64[].</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        IPdxInstanceFactory^ WriteLongArray(String^ fieldName, array<Int64>^ value);
         
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>float[]</code>.
-         /// <para>Java float[] is mapped to .NET System.Single[] or float[].</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
-         /// </summary>
-         IPdxInstanceFactory^ WriteFloatArray(String^ fieldName, array<float>^ value);
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>float[]</code>.
+        /// <para>Java float[] is mapped to .NET System.Single[] or float[].</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        /// </summary>
+        IPdxInstanceFactory^ WriteFloatArray(String^ fieldName, array<float>^ value);
         
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>double[]</code>.
-         /// <para>Java double[] is mapped to .NET System.Double[].</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
-         IPdxInstanceFactory^ WriteDoubleArray(String^ fieldName, array<double>^ value);
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>double[]</code>.
+        /// <para>Java double[] is mapped to .NET System.Double[].</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        IPdxInstanceFactory^ WriteDoubleArray(String^ fieldName, array<double>^ value);
         
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>String[]</code>.
-         /// <para>Java String[] is mapped to .NET System.String[].</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
-         IPdxInstanceFactory^ WriteStringArray(String^ fieldName, array<String^>^ value);
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>String[]</code>.
+        /// <para>Java String[] is mapped to .NET System.String[].</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        IPdxInstanceFactory^ WriteStringArray(String^ fieldName, array<String^>^ value);
         
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>Object[]</code>.
-         /// Java Object[] is mapped to .NET System.Collections.Generic.List<Object>.
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
-         
-         IPdxInstanceFactory^ WriteObjectArray(String^ fieldName, System::Collections::Generic::List<Object^>^ value);
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>Object[]</code>.
+        /// Java Object[] is mapped to .NET System.Collections.Generic.List<Object>.
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        IPdxInstanceFactory^ WriteObjectArray(String^ fieldName, System::Collections::Generic::List<Object^>^ value);
   
-         /// <summary>
-         /// Writes the named field with the given value to the serialized form.
-         /// The fields type is <code>byte[][]</code>.
-         /// <para>Java byte[][] is mapped to .NET System.Byte[][].</para>
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <param name="value"> the value of the field to write</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
-         IPdxInstanceFactory^ WriteArrayOfByteArrays(String^ fieldName, array<array<Byte>^>^ value);
+        /// <summary>
+        /// Writes the named field with the given value to the serialized form.
+        /// The fields type is <code>byte[][]</code>.
+        /// <para>Java byte[][] is mapped to .NET System.Byte[][].</para>
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <param name="value"> the value of the field to write</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        IPdxInstanceFactory^ WriteArrayOfByteArrays(String^ fieldName, array<array<Byte>^>^ value);
         
-         /// <summary>
-         /// Writes the named field with the given value and type to the serialized form.
-         /// This method uses the <code>fieldType</code> to determine which writeXXX method it should call.
-         /// If it can not find a specific match to a writeXXX method it will call <see cref="WriteObject" />.
-         /// This method may serialize objects that are not portable to non-java languages.
-         /// <para>The fieldTypes maps to a specific method.</para>
-         /// <param name="fieldName"> the name of the field to write</param>
-         /// <summary>
-         /// @param fieldValue the value of the field to write; this parameter's class must extend the <code>fieldType</code>
-         /// @param fieldType the type of the field to write
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
+        /// <summary>
+        /// Writes the named field with the given value and type to the serialized form.
+        /// This method uses the <code>fieldType</code> to determine which writeXXX method it should call.
+        /// If it can not find a specific match to a writeXXX method it will call <see cref="WriteObject" />.
+        /// This method may serialize objects that are not portable to non-java languages.
+        /// <para>The fieldTypes maps to a specific method.</para>
+        /// <param name="fieldName"> the name of the field to write</param>
+        /// <summary>
+        /// @param fieldValue the value of the field to write; this parameter's class must extend the <code>fieldType</code>
+        /// @param fieldType the type of the field to write
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has already been written</exception>
          
-         IPdxInstanceFactory^ WriteField(String^ fieldName, Object^ fieldValue, Type^ fieldType);        
+        IPdxInstanceFactory^ WriteField(String^ fieldName, Object^ fieldValue, Type^ fieldType);        
 
-         /// <summary>
-         /// Indicate that the named field should be included in hashCode and equals checks
-         /// of this object on a server that is accessing <see cref="IPdxInstance" />
-         /// or when a client executes a query on a server.
-         /// 
-         /// The fields that are marked as identity fields are used to generate the hashCode and
-         /// equals methods of {@link PdxInstance}. Because of this, the identity fields should themselves
-         /// either be primitives, or implement hashCode and equals.
-         /// 
-         /// If no fields are set as identity fields, then all fields will be used in hashCode and equals
-         /// checks.
-         /// 
-         /// The identity fields should make marked after they are written using a write/// method.
-         /// </summary>
-         /// <param name="fieldName"> the name of the field to mark as an identity field.</param>
-         /// <returns> this PdxInstanceFactory</returns>
-         /// <exception cref="IllegalStateException"/> if the named field has not already been written.</exception>
-         
-         IPdxInstanceFactory^ MarkIdentityField(String^ fieldName);
+        /// <summary>
+        /// Indicate that the named field should be included in hashCode and equals checks
+        /// of this object on a server that is accessing <see cref="IPdxInstance" />
+        /// or when a client executes a query on a server.
+        /// 
+        /// The fields that are marked as identity fields are used to generate the hashCode and
+        /// equals methods of {@link PdxInstance}. Because of this, the identity fields should themselves
+        /// either be primitives, or implement hashCode and equals.
+        /// 
+        /// If no fields are set as identity fields, then all fields will be used in hashCode and equals
+        /// checks.
+        /// 
+        /// The identity fields should make marked after they are written using a write/// method.
+        /// </summary>
+        /// <param name="fieldName"> the name of the field to mark as an identity field.</param>
+        /// <returns> this PdxInstanceFactory</returns>
+        /// <exception cref="IllegalStateException"/> if the named field has not already been written.</exception>
+        IPdxInstanceFactory^ MarkIdentityField(String^ fieldName);
 
-        };
+      };
     }  // namespace Client
   }  // namespace Geode
 }  // namespace Apache
diff --git a/clicache/src/IRegion.hpp b/clicache/src/IRegion.hpp
index 01bbb920..78e8a308 100644
--- a/clicache/src/IRegion.hpp
+++ b/clicache/src/IRegion.hpp
@@ -1281,7 +1281,7 @@ namespace Apache
           /// if it is called by local region instance <see cref="Region.GetLocalView" />
           /// </exception>
           /// <seealso cref="Put" />
-          void PutAll(IDictionary<TKey, TValue>^ map, int timeout);
+          void PutAll(IDictionary<TKey, TValue>^ map, TimeSpan timeout);
 
           /// <summary>
           /// Puts a (IDictionary) generic collection of key/value pairs in this region.
@@ -1336,7 +1336,7 @@ namespace Apache
           /// if it is called by local region instance <see cref="Region.GetLocalView" />
           /// </exception>
           /// <seealso cref="Put" />
-          void PutAll(IDictionary<TKey, TValue>^ map, int timeout, Object^ callbackArg);
+          void PutAll(IDictionary<TKey, TValue>^ map, TimeSpan timeout, Object^ callbackArg);
 
           /// <summary>
           /// Removes all of the entries for the specified keys from this region.
@@ -1870,7 +1870,7 @@ namespace Apache
           /// The SelectResults which can either be a ResultSet or a StructSet.
           /// </returns>
           generic<class TResult>
-          ISelectResults<TResult>^ Query( String^ predicate, System::UInt32 timeout );
+          ISelectResults<TResult>^ Query( String^ predicate, TimeSpan timeout );
 
           /// <summary>
           /// Executes the query on the server based on the predicate
@@ -1967,7 +1967,7 @@ namespace Apache
           /// <returns>
           /// true if the result size is non-zero, false otherwise.
           /// </returns>
-          bool ExistsValue( String^ predicate, System::UInt32 timeout );
+          bool ExistsValue( String^ predicate, TimeSpan timeout );
 
           /// <summary>
           /// Executes the query on the server based on the predicate
@@ -2068,7 +2068,7 @@ namespace Apache
           /// The single ResultSet or StructSet item,
           /// or NULL of no results are available.
           /// </returns>
-          Object^ SelectValue( String^ predicate, System::UInt32 timeout );
+          Object^ SelectValue( String^ predicate, TimeSpan timeout );
 
       };
     }  // namespace Client
diff --git a/clicache/src/IResultCollector.hpp b/clicache/src/IResultCollector.hpp
index f4d6417c..0ead6419 100644
--- a/clicache/src/IResultCollector.hpp
+++ b/clicache/src/IResultCollector.hpp
@@ -55,7 +55,7 @@ namespace Apache
         /// <summary>
         /// get result 
         /// </summary>
-        System::Collections::Generic::ICollection<TResult>^  GetResult(UInt32 timeout);
+        System::Collections::Generic::ICollection<TResult>^  GetResult(TimeSpan timeout);
 
         /// <summary>
         ///Call back provided to caller, which is called after function execution is
diff --git a/clicache/src/IWritablePdxInstance.hpp b/clicache/src/IWritablePdxInstance.hpp
index 160ffb8e..2d7f0363 100755
--- a/clicache/src/IWritablePdxInstance.hpp
+++ b/clicache/src/IWritablePdxInstance.hpp
@@ -17,36 +17,36 @@
 
 #pragma once
 
-using namespace System;
 namespace Apache
 {
   namespace Geode
   {
     namespace Client
     {
+      using namespace System;
 
-				/// <summary>
-	      /// WritablePdxInstance is a <see cref="IPdxInstance" /> that also supports field modification 
-        /// using the <see cref="SetField" />method. 
-        /// To get a WritablePdxInstance call <see cref="IPdxInstance.CreateWriter" />.
- 				/// </summary>
-				public interface class IWritablePdxInstance
-				{
-        public:
-          /// <summary>
-          ///Set the existing named field to the given value.
-          ///The setField method has copy-on-write semantics.
-          /// So for the modifications to be stored in the cache the WritablePdxInstance 
-          ///must be put into a region after setField has been called one or more times.
-          /// </summary>
-          ///
-          ///<param name="fieldName"> name of the field whose value will be set </param>
-          ///<param name="value"> value that will be assigned to the field </param>
-          ///<exception cref="IllegalStateException"/> if the named field does not exist
-          ///or if the type of the value is not compatible with the field </exception>
+			/// <summary>
+	    /// WritablePdxInstance is a <see cref="IPdxInstance" /> that also supports field modification 
+      /// using the <see cref="SetField" />method. 
+      /// To get a WritablePdxInstance call <see cref="IPdxInstance.CreateWriter" />.
+ 			/// </summary>
+			public interface class IWritablePdxInstance
+			{
+      public:
+        /// <summary>
+        ///Set the existing named field to the given value.
+        ///The setField method has copy-on-write semantics.
+        /// So for the modifications to be stored in the cache the WritablePdxInstance 
+        ///must be put into a region after setField has been called one or more times.
+        /// </summary>
+        ///
+        ///<param name="fieldName"> name of the field whose value will be set </param>
+        ///<param name="value"> value that will be assigned to the field </param>
+        ///<exception cref="IllegalStateException"/> if the named field does not exist
+        ///or if the type of the value is not compatible with the field </exception>
           
-          void SetField(String^ fieldName, Object^ value);
-				};
+        void SetField(String^ fieldName, Object^ value);
+			};
     }  // namespace Client
   }  // namespace Geode
 }  // namespace Apache
diff --git a/clicache/src/LocalRegion.cpp b/clicache/src/LocalRegion.cpp
index a84568a6..67b92b5a 100644
--- a/clicache/src/LocalRegion.cpp
+++ b/clicache/src/LocalRegion.cpp
@@ -553,13 +553,13 @@ namespace Apache
       }
 
       generic<class TKey, class TValue>
-      void LocalRegion<TKey, TValue>::PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map, int timeout)
+      void LocalRegion<TKey, TValue>::PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map, TimeSpan timeout)
       {
         throw gcnew System::NotSupportedException;
       }
 
       generic<class TKey, class TValue>
-      void LocalRegion<TKey, TValue>::PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map, int timeout, Object^ callbackArg)
+      void LocalRegion<TKey, TValue>::PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map, TimeSpan timeout, Object^ callbackArg)
       {
         throw gcnew System::NotSupportedException;
       }
@@ -942,7 +942,7 @@ namespace Apache
 
       generic<class TKey, class TValue>
       generic<class TResult>
-      ISelectResults<TResult>^ LocalRegion<TKey, TValue>::Query( String^ predicate, System::UInt32 timeout )
+      ISelectResults<TResult>^ LocalRegion<TKey, TValue>::Query( String^ predicate, TimeSpan timeout )
       {
         throw gcnew System::NotSupportedException;
       }
@@ -954,7 +954,7 @@ namespace Apache
       }
 
       generic<class TKey, class TValue>
-      bool LocalRegion<TKey, TValue>::ExistsValue( String^ predicate, System::UInt32 timeout )
+      bool LocalRegion<TKey, TValue>::ExistsValue( String^ predicate, TimeSpan timeout )
       {
         throw gcnew System::NotSupportedException;
       }
@@ -966,7 +966,7 @@ namespace Apache
       }
 
       generic<class TKey, class TValue>
-      Object^ LocalRegion<TKey, TValue>::SelectValue( String^ predicate, System::UInt32 timeout )
+      Object^ LocalRegion<TKey, TValue>::SelectValue( String^ predicate, TimeSpan timeout )
       {
         throw gcnew System::NotSupportedException;
       }
diff --git a/clicache/src/LocalRegion.hpp b/clicache/src/LocalRegion.hpp
index aa9679da..4955e498 100644
--- a/clicache/src/LocalRegion.hpp
+++ b/clicache/src/LocalRegion.hpp
@@ -126,9 +126,9 @@ namespace Apache
 
           virtual void PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map);
 
-          virtual void PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map, int timeout);
+          virtual void PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map, TimeSpan timeout);
 
-          virtual void PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map, int timeout, Object^ callbackArg);
+          virtual void PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map, TimeSpan timeout, Object^ callbackArg);
 
           virtual void GetAll(System::Collections::Generic::ICollection<TKey>^ keys, 
             System::Collections::Generic::IDictionary<TKey, TValue>^ values, 
@@ -206,15 +206,15 @@ namespace Apache
           virtual ISelectResults<TResult>^ Query( String^ predicate );
 
           generic<class TResult>
-          virtual ISelectResults<TResult>^ Query( String^ predicate, System::UInt32 timeout );
+          virtual ISelectResults<TResult>^ Query( String^ predicate, TimeSpan timeout );
 
           virtual bool ExistsValue( String^ predicate );
 
-          virtual bool ExistsValue( String^ predicate, System::UInt32 timeout );
+          virtual bool ExistsValue( String^ predicate, TimeSpan timeout );
 
           virtual Object^ SelectValue( String^ predicate );
 
-          virtual Object^ SelectValue( String^ predicate, System::UInt32 timeout );
+          virtual Object^ SelectValue( String^ predicate, TimeSpan timeout );
 
           virtual ISubscriptionService<TKey>^ GetSubscriptionService();
 
diff --git a/clicache/src/Pool.cpp b/clicache/src/Pool.cpp
index 6bb1f915..025af314 100644
--- a/clicache/src/Pool.cpp
+++ b/clicache/src/Pool.cpp
@@ -15,19 +15,16 @@
  * limitations under the License.
  */
 
-//#include "geode_includes.hpp"
 #include "Pool.hpp"
 #include "QueryService.hpp"
 #include "CacheableString.hpp"
 #include "Cache.hpp"
-//#include "Properties.hpp"
 #include "impl/ManagedString.hpp"
 #include "ExceptionTypes.hpp"
 #include "impl/SafeConvert.hpp"
+#include "TimeSpanUtils.hpp"
 
 
-using namespace System;
-
 namespace Apache
 {
   namespace Geode
@@ -35,6 +32,7 @@ namespace Apache
     namespace Client
     {
 
+      using namespace System;
 
       String^ Pool::Name::get( )
       {
@@ -50,11 +48,11 @@ namespace Apache
       }
 
 
-      Int32 Pool::FreeConnectionTimeout::get()
+      TimeSpan Pool::FreeConnectionTimeout::get()
       {
         try
         {
-          return m_nativeptr->get()->getFreeConnectionTimeout();
+          return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->get()->getFreeConnectionTimeout());
         }
         finally
         {
@@ -64,11 +62,11 @@ namespace Apache
       }
 
 
-      Int32 Pool::LoadConditioningInterval::get()
+      TimeSpan Pool::LoadConditioningInterval::get()
       {
         try
         {
-          return m_nativeptr->get()->getLoadConditioningInterval();
+          return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->get()->getLoadConditioningInterval());
         }
         finally
         {
@@ -92,11 +90,11 @@ namespace Apache
       }
 
 
-      Int32 Pool::ReadTimeout::get()
+      TimeSpan Pool::ReadTimeout::get()
       {
         try
         {
-          return m_nativeptr->get()->getReadTimeout();
+          return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->get()->getReadTimeout());
         }
         finally
         {
@@ -134,11 +132,11 @@ namespace Apache
       }
 
 
-      Int32 Pool::IdleTimeout::get()
+      TimeSpan Pool::IdleTimeout::get()
       {
         try
         {
-          return m_nativeptr->get()->getIdleTimeout();
+          return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->get()->getIdleTimeout());
         }
         finally
         {
@@ -148,11 +146,11 @@ namespace Apache
       }
 
 
-      Int32 Pool::PingInterval::get()
+      TimeSpan Pool::PingInterval::get()
       {
         try
         {
-          return m_nativeptr->get()->getPingInterval();
+          return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->get()->getPingInterval());
         }
         finally
         {
@@ -162,11 +160,11 @@ namespace Apache
       }
 
 
-      Int32 Pool::UpdateLocatorListInterval::get()
+      TimeSpan Pool::UpdateLocatorListInterval::get()
       {
         try
         {
-          return m_nativeptr->get()->getUpdateLocatorListInterval();
+          return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->get()->getUpdateLocatorListInterval());
         }
         finally
         {
@@ -176,11 +174,11 @@ namespace Apache
       }
 
 
-      Int32 Pool::StatisticInterval::get()
+      TimeSpan Pool::StatisticInterval::get()
       {
         try
         {
-          return m_nativeptr->get()->getStatisticInterval();
+          return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->get()->getStatisticInterval());
         }
         finally
         {
@@ -246,11 +244,11 @@ namespace Apache
       }
 
 
-      Int32 Pool::SubscriptionMessageTrackingTimeout::get()
+      TimeSpan Pool::SubscriptionMessageTrackingTimeout::get()
       {
         try
         {
-          return m_nativeptr->get()->getSubscriptionMessageTrackingTimeout();
+          return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->get()->getSubscriptionMessageTrackingTimeout());
         }
         finally
         {
@@ -260,11 +258,11 @@ namespace Apache
       }
 
 
-      Int32 Pool::SubscriptionAckInterval::get()
+      TimeSpan Pool::SubscriptionAckInterval::get()
       {
         try
         {
-          return m_nativeptr->get()->getSubscriptionAckInterval();
+          return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->get()->getSubscriptionAckInterval());
         }
         finally
         {
diff --git a/clicache/src/Pool.hpp b/clicache/src/Pool.hpp
index 5be1cd34..9dc7e8e1 100644
--- a/clicache/src/Pool.hpp
+++ b/clicache/src/Pool.hpp
@@ -24,15 +24,14 @@
 
 #include "native_shared_ptr.hpp"
 
-
-using namespace System;
-
 namespace Apache
 {
   namespace Geode
   {
     namespace Client
     {
+      using namespace System;
+
       namespace native = apache::geode::client;
 
       generic<class TKey, class TResult>
@@ -62,17 +61,17 @@ namespace Apache
         /// <summary>
         /// Returns the connection timeout of this pool.
         /// </summary>
-        property Int32 FreeConnectionTimeout
+        property TimeSpan FreeConnectionTimeout
         {
-          Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
         /// Returns the load conditioning interval of this pool.
         /// </summary>
-        property Int32 LoadConditioningInterval
+        property TimeSpan LoadConditioningInterval
         {
-          Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
@@ -86,9 +85,9 @@ namespace Apache
         /// <summary>
         /// Returns the read timeout of this pool.
         /// </summary>
-        property Int32 ReadTimeout
+        property TimeSpan ReadTimeout
         {
-          Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
@@ -110,33 +109,33 @@ namespace Apache
         /// <summary>
         /// Get the Idle connection timeout for this pool.
         /// </summary>
-        property Int32 IdleTimeout
+        property TimeSpan IdleTimeout
         {
-          Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
         /// Get the ping interval for this pool.
         /// </summary>
-        property Int32 PingInterval
+        property TimeSpan PingInterval
         {
-          Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
         /// Get the update locator list interval for this pool.
         /// </summary>
-        property Int32 UpdateLocatorListInterval
+        property TimeSpan UpdateLocatorListInterval
         {
-          Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
         /// Get the statistic interval for this pool.
         /// </summary>
-        property Int32 StatisticInterval
+        property TimeSpan StatisticInterval
         {
-          Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
@@ -174,17 +173,17 @@ namespace Apache
         /// <summary>
         /// Returns the subscription message tracking timeout of this pool.
         /// </summary>
-        property Int32 SubscriptionMessageTrackingTimeout
+        property TimeSpan SubscriptionMessageTrackingTimeout
         {
-          Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
         /// Returns the subscription ack interval of this pool.
         /// </summary>
-        property Int32 SubscriptionAckInterval
+        property TimeSpan SubscriptionAckInterval
         {
-          Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
diff --git a/clicache/src/PoolFactory.cpp b/clicache/src/PoolFactory.cpp
index bf3c0b10..26b03cd3 100644
--- a/clicache/src/PoolFactory.cpp
+++ b/clicache/src/PoolFactory.cpp
@@ -22,10 +22,8 @@
 
 #include "impl/ManagedString.hpp"
 #include "ExceptionTypes.hpp"
-
 #include "Cache.hpp"
-
-using namespace System;
+#include "TimeSpanUtils.hpp"
 
 namespace Apache
 {
@@ -34,14 +32,15 @@ namespace Apache
     namespace Client
     {
 
+      using namespace System;
 
-      PoolFactory^ PoolFactory::SetFreeConnectionTimeout( Int32 connectionTimeout )
+      PoolFactory^ PoolFactory::SetFreeConnectionTimeout( TimeSpan connectionTimeout )
 		  {
 			  _GF_MG_EXCEPTION_TRY2/* due to auto replace */
 
 			  try
 			  {
-			    m_nativeptr->get()->setFreeConnectionTimeout( connectionTimeout );
+			    m_nativeptr->get()->setFreeConnectionTimeout( TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::milliseconds>(connectionTimeout) );
 			  }
 			  finally
 			  {
@@ -53,13 +52,13 @@ namespace Apache
 		  }
 
 
-		  PoolFactory^ PoolFactory::SetLoadConditioningInterval( Int32 loadConditioningInterval )
+		  PoolFactory^ PoolFactory::SetLoadConditioningInterval( TimeSpan loadConditioningInterval )
 		  {
 			  _GF_MG_EXCEPTION_TRY2/* due to auto replace */
 
 			  try
 			  {
-			    m_nativeptr->get()->setLoadConditioningInterval( loadConditioningInterval );
+			    m_nativeptr->get()->setLoadConditioningInterval( TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::milliseconds>(loadConditioningInterval) );
 			  }
 			  finally
 			  {
@@ -89,13 +88,13 @@ namespace Apache
 		  }
 
 
-		  PoolFactory^ PoolFactory::SetReadTimeout( Int32 timeout )
+		  PoolFactory^ PoolFactory::SetReadTimeout( TimeSpan timeout )
       {
 			  _GF_MG_EXCEPTION_TRY2/* due to auto replace */
 
 			  try
 			  {
-			    m_nativeptr->get()->setReadTimeout( timeout );
+			    m_nativeptr->get()->setReadTimeout( TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::milliseconds>(timeout) );
 			  }
 			  finally
 			  {
@@ -143,13 +142,13 @@ namespace Apache
 		  }
 
 
-		  PoolFactory^ PoolFactory::SetIdleTimeout( Int32 idleTimeout )
+		  PoolFactory^ PoolFactory::SetIdleTimeout( TimeSpan idleTimeout )
       {
 			  _GF_MG_EXCEPTION_TRY2/* due to auto replace */
 
 			  try
 			  {
-			    m_nativeptr->get()->setIdleTimeout( idleTimeout );
+			    m_nativeptr->get()->setIdleTimeout( TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::milliseconds>(idleTimeout) );
 			  }
 			  finally
 			  {
@@ -179,13 +178,13 @@ namespace Apache
 		  }
 
 
-		  PoolFactory^ PoolFactory::SetPingInterval( Int32 pingInterval )
+		  PoolFactory^ PoolFactory::SetPingInterval( TimeSpan pingInterval )
       {
 			  _GF_MG_EXCEPTION_TRY2/* due to auto replace */
 
 			  try
 			  {
-			    m_nativeptr->get()->setPingInterval( pingInterval );
+			    m_nativeptr->get()->setPingInterval( TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::milliseconds>(pingInterval) );
 			  }
 			  finally
 			  {
@@ -197,13 +196,13 @@ namespace Apache
 		  }
 
 
-		  PoolFactory^ PoolFactory::SetUpdateLocatorListInterval( Int32 updateLocatorListInterval )
+		  PoolFactory^ PoolFactory::SetUpdateLocatorListInterval( TimeSpan updateLocatorListInterval )
       {
 			  _GF_MG_EXCEPTION_TRY2/* due to auto replace */
 
 			  try
 			  {
-			    m_nativeptr->get()->setUpdateLocatorListInterval( updateLocatorListInterval );
+			    m_nativeptr->get()->setUpdateLocatorListInterval( TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::milliseconds>(updateLocatorListInterval) );
 			  }
 			  finally
 			  {
@@ -215,13 +214,13 @@ namespace Apache
 		  }
 
 
-      PoolFactory^ PoolFactory::SetStatisticInterval( Int32 statisticInterval )
+      PoolFactory^ PoolFactory::SetStatisticInterval( TimeSpan statisticInterval )
       {
 			  _GF_MG_EXCEPTION_TRY2/* due to auto replace */
 
 			  try
 			  {
-			    m_nativeptr->get()->setStatisticInterval( statisticInterval );
+			    m_nativeptr->get()->setStatisticInterval( TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::milliseconds>(statisticInterval) );
 			  }
 			  finally
 			  {
@@ -344,13 +343,13 @@ namespace Apache
 		  }
 
 
-		  PoolFactory^ PoolFactory::SetSubscriptionMessageTrackingTimeout( Int32 messageTrackingTimeout )
+		  PoolFactory^ PoolFactory::SetSubscriptionMessageTrackingTimeout( TimeSpan messageTrackingTimeout )
       {
 			  _GF_MG_EXCEPTION_TRY2/* due to auto replace */
 
 			  try
 			  {
-			    m_nativeptr->get()->setSubscriptionMessageTrackingTimeout( messageTrackingTimeout );
+			    m_nativeptr->get()->setSubscriptionMessageTrackingTimeout( TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::milliseconds>(messageTrackingTimeout) );
 			  }
 			  finally
 			  {
@@ -362,13 +361,13 @@ namespace Apache
 		  }
 
 
-		  PoolFactory^ PoolFactory::SetSubscriptionAckInterval( Int32 ackInterval )
+		  PoolFactory^ PoolFactory::SetSubscriptionAckInterval( TimeSpan ackInterval )
       {
 			  _GF_MG_EXCEPTION_TRY2/* due to auto replace */
 
 			  try
 			  {
-			    m_nativeptr->get()->setSubscriptionAckInterval( ackInterval );
+			    m_nativeptr->get()->setSubscriptionAckInterval( TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::milliseconds>(ackInterval) );
 			  }
 			  finally
 			  {
diff --git a/clicache/src/PoolFactory.hpp b/clicache/src/PoolFactory.hpp
index cf169068..8f299650 100644
--- a/clicache/src/PoolFactory.hpp
+++ b/clicache/src/PoolFactory.hpp
@@ -24,14 +24,14 @@
 
 #include "native_shared_ptr.hpp"
 
-using namespace System;
-
 namespace Apache
 {
   namespace Geode
   {
     namespace Client
     {
+      using namespace System;
+
       namespace native = apache::geode::client;
 
 
@@ -56,13 +56,13 @@ namespace Apache
         /// If max connections is not set this setting has no effect.
         /// </remarks>
         /// <param>
-        /// connectionTimeout the connection timeout in milliseconds
+        /// connectionTimeout the connection timeout
         /// </param>
         /// <exception>
         /// IllegalArgumentException if connectionTimeout 
         /// is less than or equal to 0.
         /// </exception>
-        PoolFactory^ SetFreeConnectionTimeout(Int32 connectionTimeout);
+        PoolFactory^ SetFreeConnectionTimeout(TimeSpan connectionTimeout);
 
         /// <summary>
         /// Sets the load conditioning interval for this pool.
@@ -73,14 +73,14 @@ namespace Apache
         /// server to improve the load balance.
         /// </remarks>
         /// <param>
-        /// loadConditioningInterval the connection lifetime in milliseconds
+        /// loadConditioningInterval the connection lifetime
         /// A value of -1 disables load conditioning.
         /// </param>
         /// <exception>
         /// throws IllegalArgumentException if connectionLifetime
         /// is less than -1.
         /// </exception>
-        PoolFactory^ SetLoadConditioningInterval(Int32 loadConditioningInterval);
+        PoolFactory^ SetLoadConditioningInterval(TimeSpan loadConditioningInterval);
 
         /// <summary>
         /// Sets the socket buffer size for each connection made in this pool.
@@ -101,17 +101,17 @@ namespace Apache
         PoolFactory^ SetSocketBufferSize(Int32 bufferSize);
 
         /// <summary>
-        /// Sets the number of milliseconds to wait for a response from a server before
+        /// Sets the time to wait for a response from a server before
         /// timing out the operation and trying another server (if any are available).
         /// </summary>
         /// <param>
-        /// timeout number of milliseconds to wait for a response from a server
+        /// timeout to wait for a response from a server
         /// </param>
         /// <exception>
         /// throws IllegalArgumentException if timeout
         /// is less than or equal to 0.
         /// </exception>
-        PoolFactory^ SetReadTimeout(Int32 timeout);
+        PoolFactory^ SetReadTimeout(TimeSpan timeout);
 
         /// <summary>
         /// Set the minimum number of connections to keep available at all times.
@@ -154,13 +154,13 @@ namespace Apache
         /// been idle for longer than the idleTimeout will be closed.
         /// </remarks>
         /// <param>
-        /// idleTimeout The amount of time in milliseconds that an idle connection
+        /// idleTimeout The amount of time that an idle connection
         /// should live before expiring. -1 indicates that connections should never expire.
         /// </param>
         /// <exception>
         /// throws IllegalArgumentException if idleTimout is less than 0.
         /// </exception>
-        PoolFactory^ SetIdleTimeout(Int32 idleTimeout);
+        PoolFactory^ SetIdleTimeout(TimeSpan idleTimeout);
 
         /// <summary>
         /// Set the number of times to retry a request after timeout/exception.
@@ -187,25 +187,25 @@ namespace Apache
         /// see in CacheServer: setMaximumTimeBetweenPings(int)
         /// </remarks>
         /// <param>
-        /// pingInterval The amount of time in milliseconds between pings.
+        /// pingInterval The amount of time between pings.
         /// </param>
         /// <exception>
         /// throws IllegalArgumentException if pingInterval is less than 0.
         /// </exception>
-        PoolFactory^ SetPingInterval(Int32 pingInterval);
+        PoolFactory^ SetPingInterval(TimeSpan pingInterval);
 
         /// <summary>
         /// Set how often to update locator list from locator
         /// </summary>
         /// <param>
-        /// updateLocatorListInterval The amount of time in milliseconds between
+        /// updateLocatorListInterval The amount of time between
         /// updating locator list. If its set to 0 then client will not update
         /// the locator list.
         /// </param>
         /// <returns>
         /// a instance of <c>CacheFactory</c> 
         /// </returns>
-        PoolFactory^ SetUpdateLocatorListInterval(Int32 updateLocatorListInterval);
+        PoolFactory^ SetUpdateLocatorListInterval(TimeSpan updateLocatorListInterval);
 
         /// <summary>
         /// Set how often to send client statistics to the server.
@@ -216,14 +216,14 @@ namespace Apache
         /// to the server.
         /// </remarks>
         /// <param>
-        /// statisticInterval The amount of time in milliseconds between
+        /// statisticInterval The amount of time between
         /// sends of client statistics to the server.
         /// </param>
         /// <exception>
         /// throws IllegalArgumentException if statisticInterval
         /// is less than -1.
         /// </exception>
-        PoolFactory^ SetStatisticInterval(Int32 statisticInterval);
+        PoolFactory^ SetStatisticInterval(TimeSpan statisticInterval);
 
         /// <summary>
         /// Configures the group that all servers this pool connects to must belong to.
@@ -329,24 +329,24 @@ namespace Apache
         /// for this amount of time are expired from the list.
         /// </remarks>
         /// <param>
-        /// messageTrackingTimeout number of milliseconds to set the timeout to.
+        /// messageTrackingTimeout
         /// </param>
         /// <exception>
         /// throws IllegalArgumentException if messageTrackingTimeout is less than or equal to 0.
         /// </exception>
-        PoolFactory^ SetSubscriptionMessageTrackingTimeout(Int32 messageTrackingTimeout);
+        PoolFactory^ SetSubscriptionMessageTrackingTimeout(TimeSpan messageTrackingTimeout);
 
         /// <summary>
         /// Sets the is the interval in milliseconds to wait before sending
         /// acknowledgements to the bridge server for events received from the server subscriptions.
         /// </summary>
         /// <param>
-        /// ackInterval number of milliseconds to wait before sending event acknowledgements.
+        /// ackInterval wait before sending event acknowledgements.
         /// </param>
         /// <exception>
         /// throws IllegalArgumentException if ackInterval is less than or equal to 0.
         /// </exception>
-        PoolFactory^ SetSubscriptionAckInterval(Int32 ackInterval);
+        PoolFactory^ SetSubscriptionAckInterval(TimeSpan ackInterval);
 
         /// <summary>
         /// Enable ThreadLocalConnection.
diff --git a/clicache/src/Query.cpp b/clicache/src/Query.cpp
index f1041f80..f5593735 100644
--- a/clicache/src/Query.cpp
+++ b/clicache/src/Query.cpp
@@ -15,16 +15,13 @@
  * limitations under the License.
  */
 
-//#include "geode_includes.hpp"
 #include "Query.hpp"
 #include "ISelectResults.hpp"
 #include "ResultSet.hpp"
 #include "StructSet.hpp"
 #include "ExceptionTypes.hpp"
-//#include "Serializable.hpp"
 #include "impl/SafeConvert.hpp"
-
-using namespace System;
+#include "TimeSpanUtils.hpp"
 
 namespace Apache
 {
@@ -33,20 +30,23 @@ namespace Apache
     namespace Client
     {
 
+      using namespace System;
+      namespace native = apache::geode::client;
+
       generic<class TResult>
       ISelectResults<TResult>^ Query<TResult>::Execute(  )
       {
-        return Execute( DEFAULT_QUERY_RESPONSE_TIMEOUT );
+        return Execute( TimeSpanUtils::DurationToTimeSpan(native::DEFAULT_QUERY_RESPONSE_TIMEOUT) );
       }
 
       generic<class TResult>
-      ISelectResults<TResult>^ Query<TResult>::Execute( System::UInt32 timeout )
+      ISelectResults<TResult>^ Query<TResult>::Execute( TimeSpan timeout )
       {
         _GF_MG_EXCEPTION_TRY2/* due to auto replace */
 
           try
           {
-            return WrapResults( m_nativeptr->get()->execute( timeout ));
+            return WrapResults( m_nativeptr->get()->execute( TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::milliseconds>(timeout) ));
           }
           finally
           {
@@ -59,11 +59,11 @@ namespace Apache
       generic<class TResult>
       ISelectResults<TResult>^ Query<TResult>::Execute( array<Object^>^ paramList)
       {
-        return Execute(paramList, DEFAULT_QUERY_RESPONSE_TIMEOUT);
+        return Execute(paramList, TimeSpanUtils::DurationToTimeSpan(native::DEFAULT_QUERY_RESPONSE_TIMEOUT));
       }
 
       generic<class TResult>
-      ISelectResults<TResult>^ Query<TResult>::Execute( array<Object^>^ paramList, System::UInt32 timeout )
+      ISelectResults<TResult>^ Query<TResult>::Execute( array<Object^>^ paramList, TimeSpan timeout )
       {
         _GF_MG_EXCEPTION_TRY2/* due to auto replace */
 
@@ -76,7 +76,7 @@ namespace Apache
 
           try
           {
-            return WrapResults( m_nativeptr->get()->execute(rsptr, timeout ));
+            return WrapResults( m_nativeptr->get()->execute(rsptr, TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::milliseconds>(timeout) ));
           }
           finally
           {
diff --git a/clicache/src/Query.hpp b/clicache/src/Query.hpp
index 951cd2cf..2294b915 100644
--- a/clicache/src/Query.hpp
+++ b/clicache/src/Query.hpp
@@ -26,7 +26,6 @@
 
 #include "IGeodeSerializable.hpp"
 
-using namespace System;
 
 namespace Apache
 {
@@ -34,6 +33,8 @@ namespace Apache
   {
     namespace Client
     {
+      using namespace System;
+
       namespace native = apache::geode::client;
 
       generic<class TResult>
@@ -82,8 +83,7 @@ namespace Apache
         /// Executes the OQL Query on the cache server with the specified
         /// timeout and returns the results.
         /// </summary>
-        /// <param name="timeout">The time (in seconds) to wait for query response.
-        /// This should be less than or equal to 2^31/1000 i.e. 2147483.
+        /// <param name="timeout">The time to wait for query response.
         /// </param>
         /// <exception cref="IllegalArgumentException">
         /// if timeout parameter is greater than 2^31/1000.
@@ -103,7 +103,7 @@ namespace Apache
         /// An <see cref="ISelectResults"/> object which can either be a
         /// <see cref="ResultSet"/> or a <see cref="StructSet"/>.
         /// </returns>
-        ISelectResults<TResult>^ Execute( System::UInt32 timeout );
+        ISelectResults<TResult>^ Execute( TimeSpan timeout );
 
 		/// <summary>
         /// Executes the OQL Parameterized Query on the cache server with the specified
@@ -111,11 +111,10 @@ namespace Apache
         /// </summary>
 		/// <param name="paramList">The Parameter List for the specified Query.
         /// </param>
-        /// <param name="timeout">The time (in seconds) to wait for query response.
-        /// This should be less than or equal to 2^31/1000 i.e. 2147483.
+        /// <param name="timeout">The time to wait for query response.
         /// </param>
         /// <exception cref="IllegalArgumentException">
-        /// if timeout parameter is greater than 2^31/1000.
+        /// if timeout parameter is too long.
         /// </exception>
         /// <exception cref="QueryException">
         /// if some query error occurred at the server.
@@ -132,7 +131,7 @@ namespace Apache
         /// An <see cref="ISelectResults"/> object which can either be a
         /// <see cref="ResultSet"/> or a <see cref="StructSet"/>.
         /// </returns>
-        ISelectResults<TResult>^ Execute( array<Object^>^ paramList, System::UInt32 timeout );
+        ISelectResults<TResult>^ Execute( array<Object^>^ paramList, TimeSpan timeout );
 
         /// <summary>
         /// Executes the OQL Parameterized Query on the cache server with the specified
diff --git a/clicache/src/Region.cpp b/clicache/src/Region.cpp
index 67a831f9..289517ba 100644
--- a/clicache/src/Region.cpp
+++ b/clicache/src/Region.cpp
@@ -38,6 +38,7 @@
 #include "PoolManager.hpp"
 #include "SystemProperties.hpp"
 #include "impl/CacheResolver.hpp"
+#include "TimeSpanUtils.hpp"
 
 namespace Apache
 {
@@ -592,14 +593,14 @@ namespace Apache
       {
         _GF_MG_EXCEPTION_TRY2/* due to auto replace */
 
-          return PutAll(map, DEFAULT_RESPONSE_TIMEOUT);
+          return PutAll(map, TimeSpanUtils::DurationToTimeSpan(native::DEFAULT_RESPONSE_TIMEOUT));
 
         _GF_MG_EXCEPTION_CATCH_ALL2/* due to auto replace */
 
       }
 
       generic<class TKey, class TValue>
-      void Region<TKey, TValue>::PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map, int timeout)
+      void Region<TKey, TValue>::PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map, TimeSpan timeout)
       {
         _GF_MG_EXCEPTION_TRY2/* due to auto replace */
 
@@ -612,7 +613,7 @@ namespace Apache
         }
         try
         {
-          m_nativeptr->get()->putAll(nativeMap, timeout);
+          m_nativeptr->get()->putAll(nativeMap, TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::seconds>(timeout));
         }
         finally
         {
@@ -624,7 +625,7 @@ namespace Apache
       }
 
       generic<class TKey, class TValue>
-      void Region<TKey, TValue>::PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map, int timeout, Object^ callbackArg)
+      void Region<TKey, TValue>::PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map, TimeSpan timeout, Object^ callbackArg)
       {
         _GF_MG_EXCEPTION_TRY2/* due to auto replace */
 
@@ -638,7 +639,7 @@ namespace Apache
         native::SerializablePtr callbackptr = Serializable::GetUnmanagedValueGeneric<Object^>(callbackArg);
         try
         {
-          m_nativeptr->get()->putAll(nativeMap, timeout, callbackptr);
+          m_nativeptr->get()->putAll(nativeMap, TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::seconds>(timeout), callbackptr);
         }
         finally
         {
@@ -1354,12 +1355,12 @@ namespace Apache
       generic<class TResult>
       ISelectResults<TResult>^ Region<TKey, TValue>::Query(String^ predicate)
       {
-        return Query<TResult>( predicate, DEFAULT_QUERY_RESPONSE_TIMEOUT );
+        return Query<TResult>( predicate, TimeSpanUtils::DurationToTimeSpan(native::DEFAULT_QUERY_RESPONSE_TIMEOUT ));
       }
 
       generic<class TKey, class TValue>
       generic<class TResult>
-      ISelectResults<TResult>^ Region<TKey, TValue>::Query(String^ predicate, System::UInt32 timeout)
+      ISelectResults<TResult>^ Region<TKey, TValue>::Query(String^ predicate, TimeSpan timeout)
       {
         ManagedString mg_predicate(predicate);
 
@@ -1367,7 +1368,7 @@ namespace Apache
 
           try
           {
-            auto selectResults = m_nativeptr->get()->query(mg_predicate.CharPtr, timeout);
+            auto selectResults = m_nativeptr->get()->query(mg_predicate.CharPtr, TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::seconds>(timeout));
             if (auto resultptr = std::dynamic_pointer_cast<native::ResultSet>(selectResults))
             {
               return ResultSet<TResult>::Create(resultptr);
@@ -1389,11 +1390,11 @@ namespace Apache
       generic<class TKey, class TValue>
       bool Region<TKey, TValue>::ExistsValue(String^ predicate)
       {
-        return ExistsValue(predicate, DEFAULT_QUERY_RESPONSE_TIMEOUT);
+        return ExistsValue(predicate, TimeSpanUtils::DurationToTimeSpan(native::DEFAULT_QUERY_RESPONSE_TIMEOUT));
       }
 
       generic<class TKey, class TValue>
-      bool Region<TKey, TValue>::ExistsValue(String^ predicate, System::UInt32 timeout)
+      bool Region<TKey, TValue>::ExistsValue(String^ predicate, TimeSpan timeout)
       {
         ManagedString mg_predicate(predicate);
 
@@ -1401,7 +1402,7 @@ namespace Apache
 
           try
           {
-            return m_nativeptr->get()->existsValue(mg_predicate.CharPtr, timeout);
+            return m_nativeptr->get()->existsValue(mg_predicate.CharPtr, TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::seconds>(timeout));
           }
           finally
           {
@@ -1415,11 +1416,11 @@ namespace Apache
       generic<class TKey, class TValue>
       Object^ Region<TKey, TValue>::SelectValue(String^ predicate)
       {
-        return SelectValue(predicate, DEFAULT_QUERY_RESPONSE_TIMEOUT);
+        return SelectValue(predicate, TimeSpanUtils::DurationToTimeSpan(native::DEFAULT_QUERY_RESPONSE_TIMEOUT));
       }
 
       generic<class TKey, class TValue>
-      Object^ Region<TKey, TValue>::SelectValue(String^ predicate, System::UInt32 timeout)
+      Object^ Region<TKey, TValue>::SelectValue(String^ predicate, TimeSpan timeout)
       {
         ManagedString mg_predicate(predicate);
 
@@ -1427,7 +1428,7 @@ namespace Apache
 
         try
         {
-          auto nativeptr = m_nativeptr->get()->selectValue(mg_predicate.CharPtr, timeout);
+          auto nativeptr = m_nativeptr->get()->selectValue(mg_predicate.CharPtr, TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::seconds>(timeout));
           return Serializable::GetManagedValueGeneric<Object^>(nativeptr);
         }
         finally
diff --git a/clicache/src/Region.hpp b/clicache/src/Region.hpp
index e6ffd37a..03a9ad6f 100644
--- a/clicache/src/Region.hpp
+++ b/clicache/src/Region.hpp
@@ -27,14 +27,13 @@
 #include "ISubscriptionService.hpp"
 #include "native_shared_ptr.hpp"
 
-using namespace System;
-
 namespace Apache
 {
   namespace Geode
   {
     namespace Client
     {
+      using namespace System;
 
       namespace native = apache::geode::client;
 
@@ -120,9 +119,9 @@ namespace Apache
 
           virtual void PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map);
 
-          virtual void PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map, int timeout);
+          virtual void PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map, TimeSpan timeout);
 
-          virtual void PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map, int timeout, Object^ callbackArg);
+          virtual void PutAll(System::Collections::Generic::IDictionary<TKey, TValue>^ map, TimeSpan timeout, Object^ callbackArg);
 
           virtual void GetAll(System::Collections::Generic::ICollection<TKey>^ keys, 
             System::Collections::Generic::IDictionary<TKey, TValue>^ values, 
@@ -243,15 +242,15 @@ namespace Apache
           virtual ISelectResults<TResult>^ Query( String^ predicate );
 
           generic<class TResult>
-          virtual ISelectResults<TResult>^ Query( String^ predicate, System::UInt32 timeout );
+          virtual ISelectResults<TResult>^ Query( String^ predicate, TimeSpan timeout );
 
           virtual bool ExistsValue( String^ predicate );
 
-          virtual bool ExistsValue( String^ predicate, System::UInt32 timeout );
+          virtual bool ExistsValue( String^ predicate, TimeSpan timeout );
 
           virtual Object^ SelectValue( String^ predicate );
 
-          virtual Object^ SelectValue( String^ predicate, System::UInt32 timeout );
+          virtual Object^ SelectValue( String^ predicate, TimeSpan timeout );
 
 
       internal:
diff --git a/clicache/src/RegionAttributes.cpp b/clicache/src/RegionAttributes.cpp
index f0b99d93..e9ddd8f6 100644
--- a/clicache/src/RegionAttributes.cpp
+++ b/clicache/src/RegionAttributes.cpp
@@ -33,8 +33,7 @@
 #include "CacheListenerAdapter.hpp"
 #include "CacheWriterAdapter.hpp"
 #include "impl/SafeConvert.hpp"
-
-using namespace System;
+#include "TimeSpanUtils.hpp"
 
 namespace Apache
 {
@@ -42,6 +41,8 @@ namespace Apache
   {
     namespace Client
     {
+      using namespace System;
+
       namespace native = apache::geode::client;
 
       generic <class TKey, class TValue>
@@ -159,11 +160,11 @@ namespace Apache
       }
 
       generic <class TKey, class TValue>
-      System::Int32 Client::RegionAttributes<TKey, TValue>::RegionTimeToLive::get()
+      TimeSpan Client::RegionAttributes<TKey, TValue>::RegionTimeToLive::get()
       {
         try
         {
-          return m_nativeptr->get()->getRegionTimeToLive( );
+          return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->get()->getRegionTimeToLive( ));
         }
         finally
         {
@@ -185,11 +186,11 @@ namespace Apache
       }
 
       generic <class TKey, class TValue>
-      System::Int32 Client::RegionAttributes<TKey, TValue>::RegionIdleTimeout::get()
+      TimeSpan Client::RegionAttributes<TKey, TValue>::RegionIdleTimeout::get()
       {
         try
         {
-          return m_nativeptr->get()->getRegionIdleTimeout( );
+          return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->get()->getRegionIdleTimeout( ));
         }
         finally
         {
@@ -211,11 +212,11 @@ namespace Apache
       }
 
       generic <class TKey, class TValue>
-      System::Int32 Client::RegionAttributes<TKey, TValue>::EntryTimeToLive::get()
+      TimeSpan Client::RegionAttributes<TKey, TValue>::EntryTimeToLive::get()
       {
         try
         {
-          return m_nativeptr->get()->getEntryTimeToLive( );
+          return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->get()->getEntryTimeToLive( ));
         }
         finally
         {
@@ -237,11 +238,11 @@ namespace Apache
       }
 
       generic <class TKey, class TValue>
-      System::Int32 Client::RegionAttributes<TKey, TValue>::EntryIdleTimeout::get()
+      TimeSpan Client::RegionAttributes<TKey, TValue>::EntryIdleTimeout::get()
       {
         try
         {
-          return m_nativeptr->get()->getEntryIdleTimeout( );
+          return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->get()->getEntryIdleTimeout( ));
         }
         finally
         {
diff --git a/clicache/src/RegionAttributes.hpp b/clicache/src/RegionAttributes.hpp
index 5faa76bc..db7e6b3f 100644
--- a/clicache/src/RegionAttributes.hpp
+++ b/clicache/src/RegionAttributes.hpp
@@ -118,10 +118,10 @@ namespace Apache
         /// <summary>
         /// Gets the <c>timeToLive</c> value for the region as a whole.
         /// </summary>
-        /// <returns>the timeToLive duration for this region, in seconds</returns>
-        property System::Int32 RegionTimeToLive
+        /// <returns>the timeToLive duration for this region</returns>
+        property TimeSpan RegionTimeToLive
         {
-          System::Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
@@ -136,10 +136,10 @@ namespace Apache
         /// <summary>
         /// Gets the <c>idleTimeout</c> value for the region as a whole.
         /// </summary>
-        /// <returns>the IdleTimeout duration for this region, in seconds</returns>
-        property System::Int32 RegionIdleTimeout
+        /// <returns>the IdleTimeout duration for this region</returns>
+        property TimeSpan RegionIdleTimeout
         {
-          System::Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
@@ -154,10 +154,10 @@ namespace Apache
         /// <summary>
         /// Gets the <c>timeToLive</c> value for entries in this region.
         /// </summary>
-        /// <returns>the timeToLive duration for entries in this region, in seconds</returns>
-        property System::Int32 EntryTimeToLive
+        /// <returns>the timeToLive duration for entries in this region</returns>
+        property TimeSpan EntryTimeToLive
         {
-          System::Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
@@ -172,10 +172,10 @@ namespace Apache
         /// <summary>
         /// Gets the <c>idleTimeout</c> value for entries in this region.
         /// </summary>
-        /// <returns>the idleTimeout duration for entries in this region, in seconds</returns>
-        property System::Int32 EntryIdleTimeout
+        /// <returns>the idleTimeout duration for entries in this region</returns>
+        property TimeSpan EntryIdleTimeout
         {
-          System::Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
diff --git a/clicache/src/RegionFactory.cpp b/clicache/src/RegionFactory.cpp
index f662a7c1..61839024 100644
--- a/clicache/src/RegionFactory.cpp
+++ b/clicache/src/RegionFactory.cpp
@@ -20,7 +20,6 @@
 #include "RegionFactory.hpp"
 #include "RegionAttributes.hpp"
 #include "impl/SafeConvert.hpp"
-
 #include "impl/ManagedCacheLoader.hpp"
 #include "impl/ManagedCacheWriter.hpp"
 #include "impl/ManagedCacheListener.hpp"
@@ -28,7 +27,6 @@
 #include "impl/ManagedFixedPartitionResolver.hpp"
 #include "impl/ManagedFixedPartitionResolver.hpp"
 #include "impl/ManagedPersistenceManager.hpp"
-
 #include "impl/CacheLoader.hpp"
 #include "impl/CacheWriter.hpp"
 #include "impl/CacheListener.hpp"
@@ -36,10 +34,7 @@
 #include "impl/FixedPartitionResolver.hpp"
 #include "impl/FixedPartitionResolver.hpp"
 #include "impl/PersistenceManagerProxy.hpp"
-
-using namespace System;
-using namespace System::Collections::Generic;
-
+#include "TimeSpanUtils.hpp"
 
 namespace Apache
 {
@@ -47,6 +42,9 @@ namespace Apache
   {
     namespace Client
     {
+      using namespace System;
+      using namespace System::Collections::Generic;
+
       namespace native = apache::geode::client;
 
       RegionFactory^ RegionFactory::SetCacheLoader( String^ libPath, String^ factoryFunctionName )
@@ -119,11 +117,11 @@ namespace Apache
 
       // EXPIRATION ATTRIBUTES
 
-      RegionFactory^ RegionFactory::SetEntryIdleTimeout( ExpirationAction action, System::UInt32 idleTimeout )
+      RegionFactory^ RegionFactory::SetEntryIdleTimeout( ExpirationAction action, TimeSpan idleTimeout )
       {
         try
         {
-          m_nativeptr->get()->setEntryIdleTimeout( static_cast<native::ExpirationAction::Action>( action ), idleTimeout );
+          m_nativeptr->get()->setEntryIdleTimeout( static_cast<native::ExpirationAction::Action>( action ), TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::seconds>(idleTimeout) );
         }
         finally
         {
@@ -132,11 +130,11 @@ namespace Apache
         return this;
       }
 
-      RegionFactory^ RegionFactory::SetEntryTimeToLive( ExpirationAction action, System::UInt32 timeToLive )
+      RegionFactory^ RegionFactory::SetEntryTimeToLive( ExpirationAction action, TimeSpan timeToLive )
       {
         try
         {
-          m_nativeptr->get()->setEntryTimeToLive(static_cast<native::ExpirationAction::Action>( action ), timeToLive );
+          m_nativeptr->get()->setEntryTimeToLive(static_cast<native::ExpirationAction::Action>( action ), TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::seconds>(timeToLive) );
         }
         finally
         {
@@ -145,11 +143,11 @@ namespace Apache
         return this;
       }
 
-      RegionFactory^ RegionFactory::SetRegionIdleTimeout( ExpirationAction action, System::UInt32 idleTimeout )
+      RegionFactory^ RegionFactory::SetRegionIdleTimeout( ExpirationAction action, TimeSpan idleTimeout )
       {
         try
         {
-          m_nativeptr->get()->setRegionIdleTimeout(static_cast<native::ExpirationAction::Action>( action ), idleTimeout );
+          m_nativeptr->get()->setRegionIdleTimeout(static_cast<native::ExpirationAction::Action>( action ), TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::seconds>(idleTimeout) );
         }
         finally
         {
@@ -158,11 +156,11 @@ namespace Apache
         return this;
       }
 
-      RegionFactory^ RegionFactory::SetRegionTimeToLive( ExpirationAction action, System::UInt32 timeToLive )
+      RegionFactory^ RegionFactory::SetRegionTimeToLive( ExpirationAction action, TimeSpan timeToLive )
       {
         try
         {
-          m_nativeptr->get()->setRegionTimeToLive(static_cast<native::ExpirationAction::Action>( action ), timeToLive );
+          m_nativeptr->get()->setRegionTimeToLive(static_cast<native::ExpirationAction::Action>( action ), TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::seconds>(timeToLive) );
         }
         finally
         {
diff --git a/clicache/src/RegionFactory.hpp b/clicache/src/RegionFactory.hpp
index 0c15cab6..411c606f 100644
--- a/clicache/src/RegionFactory.hpp
+++ b/clicache/src/RegionFactory.hpp
@@ -36,15 +36,15 @@
 #include "Properties.hpp"
 #include "Region.hpp"
 
-using namespace System;
-using namespace System::Collections::Generic;
-
 namespace Apache
 {
   namespace Geode
   {
     namespace Client
     {
+      using namespace System;
+      using namespace System::Collections::Generic;
+
       namespace native = apache::geode::client;
 
 			/// <summary>
@@ -125,7 +125,7 @@ namespace Apache
         /// the idleTimeout in seconds for entries in this region.
         /// </param>
         /// <returns>the instance of RegionFactory</returns>
-        RegionFactory^ SetEntryIdleTimeout( ExpirationAction action, System::UInt32 idleTimeout );
+        RegionFactory^ SetEntryIdleTimeout( ExpirationAction action, TimeSpan idleTimeout );
 
         /// <summary>
         /// Sets the timeToLive expiration attributes for region entries for the next
@@ -138,7 +138,7 @@ namespace Apache
         /// the timeToLive in seconds for entries in this region.
         /// </param>
         /// <returns>the instance of RegionFactory</returns>
-        RegionFactory^ SetEntryTimeToLive( ExpirationAction action, System::UInt32 timeToLive );
+        RegionFactory^ SetEntryTimeToLive( ExpirationAction action, TimeSpan timeToLive );
 
         /// <summary>
         /// Sets the idleTimeout expiration attributes for the region itself for the
@@ -151,7 +151,7 @@ namespace Apache
         /// the idleTimeout in seconds for the region as a whole.
         /// </param>
         /// <returns>the instance of RegionFactory</returns>
-        RegionFactory^ SetRegionIdleTimeout( ExpirationAction action, System::UInt32 idleTimeout );
+        RegionFactory^ SetRegionIdleTimeout( ExpirationAction action, TimeSpan idleTimeout );
 
         /// <summary>
         /// Sets the timeToLive expiration attributes for the region itself for the
@@ -164,7 +164,7 @@ namespace Apache
         /// the timeToLive in seconds for the region as a whole.
         /// </param>
         /// <returns>the instance of RegionFactory</returns>
-        RegionFactory^ SetRegionTimeToLive( ExpirationAction action, System::UInt32 timeToLive );
+        RegionFactory^ SetRegionTimeToLive( ExpirationAction action, TimeSpan timeToLive );
 
 
         // PERSISTENCE
diff --git a/clicache/src/ResultCollector.cpp b/clicache/src/ResultCollector.cpp
index c0785c41..3904cfce 100644
--- a/clicache/src/ResultCollector.cpp
+++ b/clicache/src/ResultCollector.cpp
@@ -16,11 +16,11 @@
  */
 
 
-//#include "geode_includes.hpp"
 #include "ResultCollector.hpp"
 #include "impl/ManagedString.hpp"
 #include "ExceptionTypes.hpp"
 #include "impl/SafeConvert.hpp"
+#include "TimeSpanUtils.hpp"
 
 using namespace System;
 
@@ -54,16 +54,16 @@ namespace Apache
       generic<class TResult>
       System::Collections::Generic::ICollection<TResult>^  ResultCollector<TResult>::GetResult()
       {
-        return GetResult( DEFAULT_QUERY_RESPONSE_TIMEOUT );
+        return GetResult( TimeSpanUtils::DurationToTimeSpan(DEFAULT_QUERY_RESPONSE_TIMEOUT) );
       }
 
       generic<class TResult>
-      System::Collections::Generic::ICollection<TResult>^  ResultCollector<TResult>::GetResult(UInt32 timeout)
+      System::Collections::Generic::ICollection<TResult>^  ResultCollector<TResult>::GetResult(TimeSpan timeout)
       {
         _GF_MG_EXCEPTION_TRY2/* due to auto replace */
           try
           {
-            auto results = m_nativeptr->get()->getResult(timeout);
+            auto results = m_nativeptr->get()->getResult(TimeSpanUtils::TimeSpanToDurationCeil<std::chrono::milliseconds>(timeout));
             auto rs = gcnew array<TResult>(results->size());
             for (System::Int32 index = 0; index < results->size(); index++)
             {
diff --git a/clicache/src/ResultCollector.hpp b/clicache/src/ResultCollector.hpp
index f07a886f..27d628e2 100644
--- a/clicache/src/ResultCollector.hpp
+++ b/clicache/src/ResultCollector.hpp
@@ -63,17 +63,17 @@ namespace Apache
         /// <summary>
         /// get result 
         /// </summary>
-        virtual System::Collections::Generic::ICollection<TResult>^  GetResult(UInt32 timeout); 
+        virtual System::Collections::Generic::ICollection<TResult>^  GetResult(TimeSpan timeout); 
 
         /// <summary>
         ///Call back provided to caller, which is called after function execution is
         ///complete and caller can retrieve results using getResult()
         /// </summary>
-  //generic<class TKey>
-	virtual void EndResults(); 
+        //generic<class TKey>
+	      virtual void EndResults(); 
 
-  //generic<class TKey>
-  virtual void ClearResults();
+        //generic<class TKey>
+        virtual void ClearResults();
 
       internal:
 
diff --git a/clicache/src/SystemProperties.cpp b/clicache/src/SystemProperties.cpp
index e90b97d8..099fd49b 100644
--- a/clicache/src/SystemProperties.cpp
+++ b/clicache/src/SystemProperties.cpp
@@ -17,8 +17,7 @@
 
 #include "SystemProperties.hpp"
 #include "impl/SafeConvert.hpp"
-
-using namespace System;
+#include "TimeSpanUtils.hpp"
 
 namespace Apache
 {
@@ -26,6 +25,8 @@ namespace Apache
   {
     namespace Client
     {
+      using namespace System;
+
       namespace native = apache::geode::client;
 
       void SystemProperties::LogSettings( )
@@ -33,9 +34,9 @@ namespace Apache
         m_nativeptr->logSettings( );
       }
 
-      System::Int32 SystemProperties::StatisticsSampleInterval::get( )
+      TimeSpan SystemProperties::StatisticsSampleInterval::get( )
       {
-        return m_nativeptr->statisticsSampleInterval( );
+        return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->statisticsSampleInterval( ));
       }
 
       bool SystemProperties::StatisticsEnabled::get( )
@@ -78,24 +79,24 @@ namespace Apache
         return m_nativeptr->maxSocketBufferSize( );
       }
       
-      System::Int32 SystemProperties::PingInterval::get( )
+      TimeSpan SystemProperties::PingInterval::get( )
       {
-        return m_nativeptr->pingInterval( );
+        return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->pingInterval( ));
       }
       
-      System::Int32 SystemProperties::RedundancyMonitorInterval::get( )
+      TimeSpan SystemProperties::RedundancyMonitorInterval::get( )
       {
-        return m_nativeptr->redundancyMonitorInterval( );
+        return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->redundancyMonitorInterval( ));
       }
       
-      System::Int32 SystemProperties::NotifyAckInterval::get( )
+      TimeSpan SystemProperties::NotifyAckInterval::get( )
       {
-        return m_nativeptr->notifyAckInterval( );
+        return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->notifyAckInterval( ));
       }
       
-      System::Int32 SystemProperties::NotifyDupCheckLife::get( )
+      TimeSpan SystemProperties::NotifyDupCheckLife::get( )
       {
-        return m_nativeptr->notifyDupCheckLife( );
+        return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->notifyDupCheckLife( ));
       }
       
       bool SystemProperties::DebugStackTraceEnabled::get( )
@@ -180,14 +181,14 @@ namespace Apache
         return ManagedString::Get( m_nativeptr->durableClientId( ) );
       }
 
-      System::UInt32 SystemProperties::DurableTimeout::get( )
+      TimeSpan SystemProperties::DurableTimeout::get( )
       {
-        return m_nativeptr->durableTimeout( );
+        return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->durableTimeout( ));
       }
 
-      System::UInt32 SystemProperties::ConnectTimeout::get( )
+      TimeSpan SystemProperties::ConnectTimeout::get( )
       {
-        return m_nativeptr->connectTimeout( );
+        return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->connectTimeout( ));
       }
 
       String^ SystemProperties::ConflateEvents::get( )
@@ -195,21 +196,15 @@ namespace Apache
         return ManagedString::Get( m_nativeptr->conflateEvents( ) );
       }
 
-      System::UInt32 SystemProperties::SuspendedTxTimeout::get( )
+      TimeSpan SystemProperties::SuspendedTxTimeout::get( )
       {
-        return m_nativeptr->suspendedTxTimeout( );
-      }
-
-      bool SystemProperties::ReadTimeoutUnitInMillis::get( )
-      {
-        return m_nativeptr->readTimeoutUnitInMillis( );
+        return TimeSpanUtils::DurationToTimeSpan(m_nativeptr->suspendedTxTimeout( ));
       }
 
        bool SystemProperties::OnClientDisconnectClearPdxTypeIds::get( )
       {
         return m_nativeptr->onClientDisconnectClearPdxTypeIds( );
+      }
     }  // namespace Client
   }  // namespace Geode
 }  // namespace Apache
-
-}
diff --git a/clicache/src/SystemProperties.hpp b/clicache/src/SystemProperties.hpp
index 18790d06..672806f1 100644
--- a/clicache/src/SystemProperties.hpp
+++ b/clicache/src/SystemProperties.hpp
@@ -25,14 +25,14 @@
 #include "Log.hpp"
 #include "Properties.hpp"
 
-using namespace System;
-
 namespace Apache
 {
   namespace Geode
   {
     namespace Client
     {
+      using namespace System;
+
       namespace native = apache::geode::client;
 
       /// <summary>
@@ -54,9 +54,9 @@ namespace Apache
         /// how often the statistics thread writes to disk, in seconds.
         /// </summary>
         /// <returns>the statistics sampling interval</returns>
-        property System::Int32 StatisticsSampleInterval
+        property TimeSpan StatisticsSampleInterval
         {
-          System::Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
@@ -144,36 +144,36 @@ namespace Apache
         /// Returns  the time between two consecutive ping to servers
         /// </summary>
         /// <returns>the PingInterval value</returns>
-        property System::Int32 PingInterval
+        property TimeSpan PingInterval
         {
-          System::Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
         /// Returns  the time between two consecutive checks for redundancy for HA
         /// </summary>
         /// <returns>the RedundancyMonitorInterval value</returns>
-        property System::Int32 RedundancyMonitorInterval
+        property TimeSpan RedundancyMonitorInterval
         {
-          System::Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
         /// Returns the periodic notify ack interval
         /// </summary>
         /// <returns>the NotifyAckInterval value</returns>
-        property System::Int32 NotifyAckInterval
+        property TimeSpan NotifyAckInterval
         {
-          System::Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
         /// Returns the expiry time of an idle event id map entry for duplicate notification checking
         /// </summary>
         /// <returns>the NotifyDupCheckLife value</returns>
-        property System::Int32 NotifyDupCheckLife
+        property TimeSpan NotifyDupCheckLife
         {
-          System::Int32 get();
+          TimeSpan get();
         }
 
         /// <summary>
@@ -333,18 +333,18 @@ namespace Apache
         /// Returns the durable client's timeout.
         /// </summary>
         /// <returns>the durable client timeout</returns>
-        property System::UInt32 DurableTimeout
+        property TimeSpan DurableTimeout
         {
-          System::UInt32 get();
+          TimeSpan get();
         }
 
         /// <summary>
         /// Returns the connect timeout used for server and locator handshakes.
         /// </summary>
         /// <returns>the connect timeout used for server and locator handshakes</returns>
-        property System::UInt32 ConnectTimeout
+        property TimeSpan ConnectTimeout
         {
-          System::UInt32 get();
+          TimeSpan get();
         }
 
         /// <summary>
@@ -360,20 +360,12 @@ namespace Apache
         /// Returns the timeout after which suspended transactions are rolled back.
         /// </summary>
         /// <returns>the timeout for suspended transactions</returns>
-        property System::UInt32 SuspendedTxTimeout
+        property TimeSpan SuspendedTxTimeout
         {
-          System::UInt32 get();
+          TimeSpan get();
         }
 
         /// <summary>
-        /// This can be called to know whether read timeout unit is in milli second.
-        /// </summary>
-        /// <returns>true if enabled or false by default.</returns>
-        property bool ReadTimeoutUnitInMillis
-        {
-          bool get();
-        }
-        /// <summary>
         /// True if app want to clear pdx types ids on client disconnect
         /// </summary>
         /// <returns>true if enabled</returns>
diff --git a/clicache/src/TimeSpanUtils.hpp b/clicache/src/TimeSpanUtils.hpp
new file mode 100644
index 00000000..1afc5285
--- /dev/null
+++ b/clicache/src/TimeSpanUtils.hpp
@@ -0,0 +1,58 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include "begin_native.hpp"
+#include <chrono>
+#include <geode/util/chrono/duration.hpp>
+#include "end_native.hpp"
+
+namespace Apache
+{
+  namespace Geode
+  {
+    namespace Client
+    {
+      using namespace System;
+      using namespace apache::geode::util::chrono::duration;
+
+      using ticks = std::chrono::duration<long long, std::ratio<1, 10000000>>;
+      
+      class TimeSpanUtils
+      {
+      public:
+        template <class _Duration>
+        inline static _Duration TimeSpanToDurationCeil(TimeSpan timeSpan)
+        {
+          return _ceil<_Duration>(TimeSpanToDuration(timeSpan));
+        }
+      
+        inline static ticks TimeSpanToDuration(TimeSpan timespan)
+        {
+          return ticks(timespan.Ticks);
+        }
+
+        inline static TimeSpan DurationToTimeSpan(ticks duration)
+        {
+          return TimeSpan::FromTicks(duration.count());
+        }      
+      };
+    }  // namespace Client
+  }  // namespace Geode
+}  // namespace Apache
+
diff --git a/clicache/src/begin_native.hpp b/clicache/src/begin_native.hpp
index 5ee58778..36bf7159 100644
--- a/clicache/src/begin_native.hpp
+++ b/clicache/src/begin_native.hpp
@@ -38,4 +38,10 @@
 // Disable native code generation warning
 #pragma warning(disable: 4793)
 
+// Disable /clr warnings
+#pragma warning(disable: 4575)
+
+//#pragma pack(push)
+
 #pragma managed(push, off)
+
diff --git a/clicache/src/end_native.hpp b/clicache/src/end_native.hpp
index 8a8a4aee..996b31d0 100644
--- a/clicache/src/end_native.hpp
+++ b/clicache/src/end_native.hpp
@@ -17,6 +17,8 @@
 
 #pragma managed(pop)
 
+//#pragma pack(pop)
+
 #pragma warning(pop)
 
 #pragma pop_macro("nullptr")
diff --git a/clicache/src/impl/ManagedResultCollector.cpp b/clicache/src/impl/ManagedResultCollector.cpp
index fd66aa5e..49a9cb8e 100644
--- a/clicache/src/impl/ManagedResultCollector.cpp
+++ b/clicache/src/impl/ManagedResultCollector.cpp
@@ -164,7 +164,7 @@ namespace apache
         }
       }
 
-      CacheableVectorPtr ManagedResultCollectorGeneric::getResult(System::UInt32 timeout)
+      CacheableVectorPtr ManagedResultCollectorGeneric::getResult(std::chrono::milliseconds timeout)
       {
         try {
           //array<IGeodeSerializable^>^ rs = m_managedptr->GetResult(timeout);
diff --git a/clicache/src/impl/ManagedResultCollector.hpp b/clicache/src/impl/ManagedResultCollector.hpp
index 545ec29b..3706b724 100644
--- a/clicache/src/impl/ManagedResultCollector.hpp
+++ b/clicache/src/impl/ManagedResultCollector.hpp
@@ -19,6 +19,7 @@
 #include "../geode_defs.hpp"
 #include <vcclr.h>
 #include "begin_native.hpp"
+#include <chrono>
 #include <geode/ResultCollector.hpp>
 #include "end_native.hpp"
 
@@ -73,10 +74,11 @@ namespace apache {
         /// </summary>
         virtual ~ManagedResultCollectorGeneric() { }
 
-        CacheableVectorPtr getResult(System::UInt32 timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
-        void addResult(const CacheablePtr& result);
-        void endResults();
-        void clearResults();
+        CacheableVectorPtr getResult(std::chrono::milliseconds timeout = native::DEFAULT_QUERY_RESPONSE_TIMEOUT) override;
+        void addResult(const CacheablePtr& result) override;
+        void endResults() override;
+        void clearResults() override;
+
         /// <summary>
         /// Returns the wrapped managed object reference.
         /// </summary>
diff --git a/clicache/src/impl/PdxInstanceImpl.cpp b/clicache/src/impl/PdxInstanceImpl.cpp
index 5fc85983..3fbbf300 100755
--- a/clicache/src/impl/PdxInstanceImpl.cpp
+++ b/clicache/src/impl/PdxInstanceImpl.cpp
@@ -18,9 +18,10 @@
 #pragma once
 
 #include "begin_native.hpp"
-#include <CacheRegionHelper.hpp>
 #include <geode/Cache.hpp>
+#include <CacheRegionHelper.hpp>
 #include <CacheImpl.hpp>
+#include <CachePerfStats.hpp>
 #include "end_native.hpp"
 
 #include "PdxInstanceImpl.hpp"
@@ -34,17 +35,17 @@
 #include "PdxType.hpp"
 #include "Cache.hpp"
 
-using namespace System::Text;
-
 namespace Apache
 {
   namespace Geode
   {
     namespace Client
     {
-
       namespace Internal
       {
+        using namespace System;
+        using namespace System::Text;
+
         //this is for PdxInstanceFactory
         PdxInstanceImpl::PdxInstanceImpl(Dictionary<String^, Object^>^ fieldVsValue, PdxType^ pdxType, Apache::Geode::Client::Cache^ cache)
         {
@@ -77,6 +78,7 @@ namespace Apache
           //will it ever happen
           throw gcnew IllegalStateException("PdxInstance typeid is not defined yet, to get classname.");
         }
+
         Object^ PdxInstanceImpl::GetObject()
         {
           DataInput^ dataInput = gcnew DataInput(m_buffer, m_bufferLength, m_cache);
@@ -1418,13 +1420,10 @@ namespace Apache
             default:
             {
               writer->WriteObject(fieldName, value);
-              //throw gcnew IllegalStateException("ReadField unable to de-serialize  " 
-              //																	+ fieldName + " of " + type); 
-            }  // namespace Client
-            }  // namespace Geode
-          }  // namespace Apache
-
-      }
-    }
-  }
-}
+            }
+          }
+        }
+      }  // namespace Internal
+    }  // namespace Client
+  }  // namespace Geode
+}  // namespace Apache
diff --git a/clicache/src/impl/PdxInstanceImpl.hpp b/clicache/src/impl/PdxInstanceImpl.hpp
index ac302eca..a8c7610d 100755
--- a/clicache/src/impl/PdxInstanceImpl.hpp
+++ b/clicache/src/impl/PdxInstanceImpl.hpp
@@ -17,14 +17,21 @@
 
 #pragma once
 
-#include "begin_native.hpp"
-#include <CachePerfStats.hpp>
-#include "end_native.hpp"
-
 #include "../IPdxInstance.hpp"
 #include "../IPdxSerializable.hpp"
 #include "../DataInput.hpp"
 #include "PdxLocalWriter.hpp"
+#include "IWritablePdxInstance.hpp"
+
+namespace apache {
+namespace geode {
+namespace client {
+
+  class CachePerfStats;
+
+}  // namespace client
+}  // nanespace geode
+}  // namespace apache
 
 namespace Apache
 {
@@ -36,13 +43,18 @@ namespace Apache
 
       namespace Internal
       {
+        using namespace System;
+
+        namespace native = apache::geode::client;
+
         ref class PdxType;
+
         /// <summary>
         /// Serialize the data in geode Portable Data eXchange(Pdx) Format.
         /// This format provides class versioning(forward and backward compability of types) in cache.
         /// This provides ability to query .NET domian objects.
         /// </summary>
-        ref class PdxInstanceImpl : IWritablePdxInstance, IPdxInstance, IPdxSerializable
+        ref class PdxInstanceImpl : public IWritablePdxInstance, public IPdxInstance, public IPdxSerializable
         {
         private:
           static array<SByte>^ Boolean_DefaultBytes = gcnew array<SByte>{0};
@@ -68,7 +80,7 @@ namespace Apache
           void cleanup();
 
 
-          CachePerfStats* m_cachePerfStats;
+          native::CachePerfStats* m_cachePerfStats;
           System::Byte* m_buffer;
           int m_bufferLength;
           int m_typeId;
@@ -154,135 +166,24 @@ namespace Apache
 
           virtual String^ GetClassName();
 
-          /// <summary> 
-          ///Deserializes and returns the domain object that this instance represents.
-          ///
-          ///@return the deserialized domain object.
-          ///@throws PdxSerializationException if the instance could not be deserialized
-          /// </summary>
           virtual Object^ GetObject();
 
-          /// <summary>
-          ///Checks if the named field exists and returns the result.
-          ///This can be useful when writing code that handles more than one version of
-          ///a PDX class.
-          ///@param fieldName the name of the field to check
-          ///@return <code>true</code> if the named field exists; otherwise <code>false</code>
-          /// </summary>
           virtual bool HasField(String^ fieldName);
 
-          /// <summary>
-          ///Return an unmodifiable list of the field names on this PdxInstance.
-          ///@return an unmodifiable list of the field names on this PdxInstance
-          /// </summary>
           virtual IList<String^>^ GetFieldNames();
 
-          /// <summary>
-          ///Checks if the named field was {@link PdxWriter#markIdentityField(String) marked} as an identity field.
-          ///Note that if no fields have been marked then all the fields are used as identity fields even though
-          ///this method will return <code>false</code> since none of them have been <em>marked</em>.
-          ///@param fieldName the name of the field to check
-          ///@return <code>true</code> if the named field exists and was marked as an identify field; otherwise <code>false</code>
-          /// </summary>
           virtual bool IsIdentityField(String^ fieldName);
 
-          /// <summary>
-          ///Reads the named field and returns its value. If the field does
-          ///not exist <code>null</code> is returned.
-          ///A <code>null</code> result indicates that the field does not exist
-          ///or that it exists and its value is currently <code>null</code>.
-          ///The {@link #hasField(String) hasField} method can be used to figure out
-          ///which if these two cases is true.
-          ///If an Object[] is deserialized by this call then that array's component
-          ///type will be <code>Object.class</code> instead of the original class that
-          ///the array had when it was serialized. This is done so that PdxInstance objects
-          ///can be added to the array.
-          /// 
-          ///@param fieldName
-          ///         name of the field to read
-          ///
-          ///@return If this instance has the named field then the field's value is returned,
-          ///otherwise <code>null</code> is returned.
-          ///@throws PdxSerializationException if the field could not be deserialized
-          /// </summary>
           virtual  Object^ GetField(String^ fieldName);
 
-          /// <summary>
-          ///Returns true if the given object is equals to this instance.
-          ///If <code>other</code> is not a PdxInstance then it is not equal to this instance.
-          ///NOTE: Even if <code>other</code> is the result of calling {@link #getObject()} it will not
-          ///be equal to this instance.
-          ///Otherwise equality of two PdxInstances is determined as follows:
-          ///<ol>
-          ///<li>The domain class name must be equal for both PdxInstances</li>
-          ///<li>Each identity field must be equal.</li>
-          ///</ol>
-          ///If one of the instances does not have a field that the other one does then equals will assume it
-          ///has the field with a default value.
-          ///If a PdxInstance has marked identity fields using {@link PdxWriter#markIdentityField(String) markIdentityField}
-          ///then only the marked identity fields are its identity fields.
-          ///Otherwise all its fields are identity fields.
-          ///An identity field is equal if all the following are true:
-          ///<ol>
-          ///<li>The field name is equal.</li>
-          ///<li>The field type is equal.</li>
-          ///<li>The field value is equal.</li>
-          ///</ol>
-          ///If a field's type is <code>OBJECT</code> then its value must be deserialized to determine if it is equals. If the deserialized object is an array then {@link java.util.Arrays#deepEquals(Object[], Object[]) deepEquals} is used to determine equality. Otherwise {@link Object#equals(Object) equals} is used.
-          ///If a field's type is <code>OBJECT[]</code> then its value must be deserialized and {@link java.util.Arrays#deepEquals(Object[], Object[]) deepEquals} is used to determine equality.
-          ///For all other field types then the value does not need to be deserialized. Instead the serialized raw bytes are compared and used to determine equality.
-          ///Note that any fields that have objects that do not override {@link Object#equals(Object) equals} will cause equals to return false when you might have expected it to return true.
-          ///The only exceptions to this are those that call {@link java.util.Arrays#deepEquals(Object[], Object[]) deepEquals} as noted above. You should either override equals and hashCode in these cases
-          ///or mark other fields as your identity fields.  
-          ///@param other the other instance to compare to this.
-          ///@return <code>true</code> if this instance is equal to <code>other</code>.
-          /// </summary>
           virtual bool Equals(Object^ other) override;
 
-          /// <summary>
-          ///Generates a hashCode based on the identity fields of
-          ///this PdxInstance. 
-          ///If a PdxInstance has marked identity fields using {@link PdxWriter#markIdentityField(String) markIdentityField}
-          ///then only the marked identity fields are its identity fields.
-          ///Otherwise all its fields are identity fields.
-          ///
-          ///If an identity field is of type <code>OBJECT</code> then it is deserialized. If the deserialized object is an array then {@link java.util.Arrays#deepHashCode(Object[]) deepHashCode} is used. Otherwise {@link Object#hashCode() hashCode} is used.
-          ///If an identity field is of type <code>OBJECT[]</code> this it is deserialized and {@link java.util.Arrays#deepHashCode(Object[]) deepHashCode} is used.
-          ///Otherwise the field is not deserialized and the raw bytes of its value are used to compute the hash code.
-          /// </summary>
-          virtual int GetHashCode()  override;
-
-          /// <summary>
-          ///Prints out all of the identity fields of this PdxInstance.
-          ///If a PdxInstance has marked identity fields using {@link PdxWriter#markIdentityField(String) markIdentityField}
-          ///then only the marked identity fields are its identity fields.
-          ///Otherwise all its fields are identity fields.
-          /// </summary>
-          virtual String^ ToString()  override;
-
-          /// <summary>
-          ///Creates and returns a {@link WritablePdxInstance} whose initial
-          ///values are those of this PdxInstance.
-          ///This call returns a copy of the current field values so modifications
-          ///made to the returned value will not modify this PdxInstance.
-          ///
-          ///@return a {@link WritablePdxInstance}
-          /// </summary>
+          virtual int GetHashCode() override;
+
+          virtual String^ ToString() override;
+
           virtual IWritablePdxInstance^ CreateWriter();
 
-          /// <summary>
-          ///Set the existing named field to the given value.
-          ///The setField method has copy-on-write semantics.
-          /// So for the modifications to be stored in the cache the WritablePdxInstance 
-          ///must be put into a region after setField has been called one or more times.
-          ///
-          ///@param fieldName
-          ///         name of the field whose value will be set
-          ///@param value
-          ///         value that will be assigned to the field
-          ///@throws PdxFieldDoesNotExistException if the named field does not exist
-          ///@throws PdxFieldTypeMismatchException if the type of the value is not compatible with the field
-          /// </summary>
           virtual void SetField(String^ fieldName, Object^ value);
 
           virtual void ToData(IPdxWriter^ writer);
@@ -290,7 +191,7 @@ namespace Apache
           virtual void FromData(IPdxReader^ reader);
 
         };
-      }
+      }  // namespace Internal
     }  // namespace Client
   }  // namespace Geode
 }  // namespace Apache
diff --git a/cppcache/include/geode/AttributesFactory.hpp b/cppcache/include/geode/AttributesFactory.hpp
index fe5363c1..ef05e20e 100644
--- a/cppcache/include/geode/AttributesFactory.hpp
+++ b/cppcache/include/geode/AttributesFactory.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_ATTRIBUTESFACTORY_H_
-#define GEODE_ATTRIBUTESFACTORY_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,6 +15,13 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_ATTRIBUTESFACTORY_H_
+#define GEODE_ATTRIBUTESFACTORY_H_
+
+#include <chrono>
+
 #include "geode_globals.hpp"
 #include "geode_types.hpp"
 #include "ExceptionTypes.hpp"
@@ -31,6 +33,7 @@
 #include "RegionAttributes.hpp"
 #include "DiskPolicyType.hpp"
 #include "Pool.hpp"
+#include "util/chrono/duration.hpp"
 
 /**
  * @file
@@ -151,8 +154,8 @@ namespace client {
 
 class CPPCACHE_EXPORT AttributesFactory {
   /**
-    * @brief public methods
-    */
+   * @brief public methods
+   */
  public:
   /**
    *@brief constructor
@@ -227,34 +230,48 @@ class CPPCACHE_EXPORT AttributesFactory {
   // EXPIRATION ATTRIBUTES
 
   /** Sets the idleTimeout expiration attributes for region entries for the next
-   * <code>RegionAttributes</code> created.
+   * <code>RegionAttributes</code> created. Will expire in no less than
+   * <code>idleTimeout</code>. Actual time may be longer depending on clock
+   * resolution.
+   *
    * @param action the expiration action for entries in this region.
-   * @param idleTimeout the idleTimeout in seconds for entries in this region.
+   * @param idleTimeout the idleTimeout for entries in this region.
    */
   void setEntryIdleTimeout(ExpirationAction::Action action,
-                           int32_t idleTimeout);
+                           std::chrono::seconds idleTimeout);
 
   /** Sets the timeToLive expiration attributes for region entries for the next
-   * <code>RegionAttributes</code> created.
+   * <code>RegionAttributes</code> created. Will expire in no less than
+   * <code>timeToLive</code>, actual time may be longer depending on clock
+   * resolution.
+   *
    * @param action the expiration action for entries in this region.
-   * @param timeToLive the timeToLive in seconds for entries in this region.
+   * @param timeToLive the timeToLive for entries in this region.
    */
-  void setEntryTimeToLive(ExpirationAction::Action action, int32_t timeToLive);
+  void setEntryTimeToLive(ExpirationAction::Action action,
+                          std::chrono::seconds timeToLive);
 
   /** Sets the idleTimeout expiration attributes for the region itself for the
-   * next <code>RegionAttributes</code> created.
+   * next <code>RegionAttributes</code> created. Will expire in no less than
+   * <code>idleTimeout</code>, actual time may be longer depending on clock
+   * resolution.
+   *
    * @param action the expiration action for entries in this region.
-   * @param idleTimeout the idleTimeout in seconds for the region as a whole.
+   * @param idleTimeout the idleTimeout for the region as a whole.
    */
   void setRegionIdleTimeout(ExpirationAction::Action action,
-                            int32_t idleTimeout);
+                            std::chrono::seconds idleTimeout);
 
   /** Sets the timeToLive expiration attributes for the region itself for the
-   * next <code>RegionAttributes</code> created.
+   * next <code>RegionAttributes</code> created. Will expire in no less than
+   * <code>timeToLive</code>, actual time may be longer depending on clock
+   * resolution.
+   *
    * @param action the expiration action for entries in this region.
-   * @param timeToLive the timeToLive in seconds for the region as a whole.
+   * @param timeToLive the timeToLive for the region as a whole.
    */
-  void setRegionTimeToLive(ExpirationAction::Action action, int32_t timeToLive);
+  void setRegionTimeToLive(ExpirationAction::Action action,
+                           std::chrono::seconds timeToLive);
 
   // PERSISTENCE
   /**
@@ -268,10 +285,10 @@ class CPPCACHE_EXPORT AttributesFactory {
                              const PropertiesPtr& config = nullptr);
 
   /** Sets the PersistenceManager for the next <code>RegionAttributes</code>
-  * created.
-  * @param persistenceManager a user defined PersistenceManager, nullptr if no
-  * resolver
-  */
+   * created.
+   * @param persistenceManager a user defined PersistenceManager, nullptr if no
+   * resolver
+   */
   void setPersistenceManager(const PersistenceManagerPtr& persistenceManager,
                              const PropertiesPtr& config = nullptr);
 
@@ -329,37 +346,37 @@ class CPPCACHE_EXPORT AttributesFactory {
   void setCachingEnabled(bool cachingEnabled);
 
   /**
-  * Sets the pool name attribute.
-  * This causes regions that use these attributes
-  * to be a client region which communicates with the
-  * servers that the connection pool communicates with.
-  * <p>If this attribute is set to <code>null</code> or <code>""</code>
-  * then the connection pool is disabled causing regions that use these
-  * attributes
-  * to be communicate with peers instead of servers.
-  * <p>The named connection pool must exist on the cache at the time these
-  * attributes are used to create a region. See {@link
-  * PoolManager#createFactory}
-  * for how to create a connection pool.
-  * @param name the name of the connection pool to use; if <code>null</code>
-  * or <code>""</code> then the connection pool is disabled for regions
-  * using these attributes.
-  */
+   * Sets the pool name attribute.
+   * This causes regions that use these attributes
+   * to be a client region which communicates with the
+   * servers that the connection pool communicates with.
+   * <p>If this attribute is set to <code>null</code> or <code>""</code>
+   * then the connection pool is disabled causing regions that use these
+   * attributes
+   * to be communicate with peers instead of servers.
+   * <p>The named connection pool must exist on the cache at the time these
+   * attributes are used to create a region. See {@link
+   * PoolManager#createFactory}
+   * for how to create a connection pool.
+   * @param name the name of the connection pool to use; if <code>null</code>
+   * or <code>""</code> then the connection pool is disabled for regions
+   * using these attributes.
+   */
   void setPoolName(const char* name);
 
   /**
-  * Sets cloning on region
-  * @param isClonable
-  * @see RegionAttributes#getCloningEnabled()
-  */
+   * Sets cloning on region
+   * @param isClonable
+   * @see RegionAttributes#getCloningEnabled()
+   */
   void setCloningEnabled(bool isClonable);
 
   /**
-  * Enables or disables concurrent modification checks
-  * @since 7.0
-  * @param concurrencyChecksEnabled whether to perform concurrency checks on
-  * operations
-  */
+   * Enables or disables concurrent modification checks
+   * @since 7.0
+   * @param concurrencyChecksEnabled whether to perform concurrency checks on
+   * operations
+   */
   void setConcurrencyChecksEnabled(bool concurrencyChecksEnabled);
 
   // FACTORY METHOD
@@ -374,7 +391,8 @@ class CPPCACHE_EXPORT AttributesFactory {
  private:
   RegionAttributes m_regionAttributes;
   static void validateAttributes(RegionAttributes& attrs);
-};
+};  // namespace client
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/include/geode/AttributesMutator.hpp b/cppcache/include/geode/AttributesMutator.hpp
index 37c1762f..485f2a8b 100644
--- a/cppcache/include/geode/AttributesMutator.hpp
+++ b/cppcache/include/geode/AttributesMutator.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_ATTRIBUTESMUTATOR_H_
-#define GEODE_ATTRIBUTESMUTATOR_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,9 +15,18 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_ATTRIBUTESMUTATOR_H_
+#define GEODE_ATTRIBUTESMUTATOR_H_
+
+#include <chrono>
+
 #include "geode_globals.hpp"
 #include "geode_types.hpp"
 #include "ExpirationAction.hpp"
+#include "util/chrono/duration.hpp"
+
 /**
  * @file
  */
@@ -64,13 +68,13 @@ class CPPCACHE_EXPORT AttributesMutator {
   virtual ~AttributesMutator();
 
   /** Sets the idleTimeout duration for region entries.
-   * @param idleTimeout the idleTimeout in seconds for entries in this region.
+   * @param idleTimeout the idleTimeout for entries in this region.
    * @return the previous value.
    * @throw IllegalStateException if the new idleTimeout changes entry
    * expiration from
    *   disabled to enabled or enabled to disabled.
    */
-  int32_t setEntryIdleTimeout(int32_t idleTimeout);
+  std::chrono::seconds setEntryIdleTimeout(std::chrono::seconds idleTimeout);
 
   /** Set the idleTimeout Action for region entries.
    * @param action the idleTimeout ExpirationAction::Action for entries in this
@@ -81,13 +85,13 @@ class CPPCACHE_EXPORT AttributesMutator {
       ExpirationAction::Action action);
 
   /** Sets the timeToLive duration for region entries.
-   * @param timeToLive the timeToLive in seconds for entries in this region.
+   * @param timeToLive the timeToLive for entries in this region.
    * @return the previous value.
    * @throw IllegalStateException if the new timeToLive changes entry expiration
    * from
    *   disabled to enabled or enabled to disabled.
    */
-  int32_t setEntryTimeToLive(int32_t timeToLive);
+  std::chrono::seconds setEntryTimeToLive(std::chrono::seconds timeToLive);
 
   /** Set the timeToLive Action for region entries.
    * @param action the timeToLive ExpirationAction::Action for entries in this
@@ -104,7 +108,7 @@ class CPPCACHE_EXPORT AttributesMutator {
    * expiration from
    *   disabled to enabled or enabled to disabled.
    */
-  int32_t setRegionIdleTimeout(int32_t idleTimeout);
+  std::chrono::seconds setRegionIdleTimeout(std::chrono::seconds idleTimeout);
 
   /** Set the idleTimeout Action for the region itself.
    * @param action the idleTimeout ExpirationAction::Action for this region.
@@ -120,7 +124,7 @@ class CPPCACHE_EXPORT AttributesMutator {
    * expiration from
    *   disabled to enabled or enabled to disabled.
    */
-  int32_t setRegionTimeToLive(int32_t timeToLive);
+  std::chrono::seconds setRegionTimeToLive(std::chrono::seconds timeToLive);
 
   /** Set the timeToLive Action for the region itself.
    * @param action the timeToLive ExpirationAction::Action for this region.
@@ -186,6 +190,7 @@ class CPPCACHE_EXPORT AttributesMutator {
    */
   void setCacheWriter(const char* libpath, const char* factoryFuncName);
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/include/geode/CacheFactory.hpp b/cppcache/include/geode/CacheFactory.hpp
index f98ede06..cc8381ec 100644
--- a/cppcache/include/geode/CacheFactory.hpp
+++ b/cppcache/include/geode/CacheFactory.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_CACHEFACTORY_H_
-#define GEODE_CACHEFACTORY_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,12 +15,21 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_CACHEFACTORY_H_
+#define GEODE_CACHEFACTORY_H_
+
+#include <chrono>
+
 #include "geode_globals.hpp"
 #include "geode_types.hpp"
+#include "util/chrono/duration.hpp"
 #include "DistributedSystem.hpp"
 #include "Cache.hpp"
 #include "CacheAttributes.hpp"
 #include "PoolFactory.hpp"
+
 /**
  * @file
  */
@@ -156,6 +160,7 @@ class CPPCACHE_EXPORT CacheFactory
 
   FRIEND_STD_SHARED_PTR(CacheFactory)
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/include/geode/CacheTransactionManager.hpp b/cppcache/include/geode/CacheTransactionManager.hpp
index 5a5e96a6..d7ce9d83 100644
--- a/cppcache/include/geode/CacheTransactionManager.hpp
+++ b/cppcache/include/geode/CacheTransactionManager.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_CACHETRANSACTIONMANAGER_H_
-#define GEODE_CACHETRANSACTIONMANAGER_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,12 +15,14 @@
  * limitations under the License.
  */
 
-/* The specification of function behaviors is found in the corresponding .cpp
- * file.
- */
+#pragma once
+
+#ifndef GEODE_CACHETRANSACTIONMANAGER_H_
+#define GEODE_CACHETRANSACTIONMANAGER_H_
 
 //#### Warning: DO NOT directly include Region.hpp, include Cache.hpp instead.
 
+#include <chrono>
 #include "geode_globals.hpp"
 #include "geode_types.hpp"
 
@@ -155,14 +152,14 @@ class CPPCACHE_EXPORT CacheTransactionManager {
    *
    * @param transactionId
    *          the transaction to resume
-   * @param waitTimeInMilliSec
-   *          the maximum milliseconds to wait
+   * @param waitTime
+   *          the maximum time to wait
    * @return true if the transaction was resumed, false otherwise
    * @since 3.6.2
    * @see #tryResume(TransactionId)
    */
   virtual bool tryResume(TransactionIdPtr transactionId,
-                         int32_t waitTimeInMilliSec) = 0;
+                         std::chrono::milliseconds waitTime) = 0;
 
   /**
    * Reports the existence of a transaction for the given transactionId. This
diff --git a/cppcache/include/geode/CqQuery.hpp b/cppcache/include/geode/CqQuery.hpp
index e95b4270..ccdf97d1 100644
--- a/cppcache/include/geode/CqQuery.hpp
+++ b/cppcache/include/geode/CqQuery.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_CQQUERY_H_
-#define GEODE_CQQUERY_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,6 +15,13 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_CQQUERY_H_
+#define GEODE_CQQUERY_H_
+
+#include <chrono>
+
 #include "geode_globals.hpp"
 #include "geode_types.hpp"
 
@@ -83,6 +85,7 @@ class CPPCACHE_EXPORT CqQuery  {
    * @return CqAttributesMutator, the CqAttributesMutator object.
    */
   virtual const CqAttributesMutatorPtr getCqAttributesMutator() const = 0;
+
   /**
    * Start executing the CQ or if this CQ is stopped earlier, resumes execution
    * of the CQ.
@@ -91,11 +94,9 @@ class CPPCACHE_EXPORT CqQuery  {
    * on all the
    * server then a CqException is thrown.
    *
-   * @param timeout The time (in seconds) to wait for query response, optional.
-   *        This should be less than or equal to 2^31/1000 i.e. 2147483.
+   * @param timeout The time to wait for query response, optional.
    *
-   * @throws IllegalArgumentException if timeout parameter is greater than
-   * 2^31/1000.
+   * @throws IllegalArgumentException If timeout exceeds 2147483647ms.
    * @throws CqClosedException if this CqQuery is closed.
    * @throws RegionNotFoundException if the specified region in the
    *         query string is not found.
@@ -105,7 +106,7 @@ class CPPCACHE_EXPORT CqQuery  {
    * @return CqResults resultset obtained by executing the query.
    */
   virtual CqResultsPtr executeWithInitialResults(
-      uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) = 0;
+      std::chrono::milliseconds timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) = 0;
 
   /**
    * @notsupported_cacheserver
@@ -176,7 +177,9 @@ class CPPCACHE_EXPORT CqQuery  {
    * @since 5.5
    */
   virtual bool isDurable() = 0;
+
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/include/geode/DefaultResultCollector.hpp b/cppcache/include/geode/DefaultResultCollector.hpp
new file mode 100644
index 00000000..a9d93f61
--- /dev/null
+++ b/cppcache/include/geode/DefaultResultCollector.hpp
@@ -0,0 +1,69 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#ifndef GEODE_DEFAULTRESULTCOLLECTOR_H_
+#define GEODE_DEFAULTRESULTCOLLECTOR_H_
+
+#include <memory>
+#include <chrono>
+#include <mutex>
+#include <condition_variable>
+
+#include "geode_globals.hpp"
+#include "geode_types.hpp"
+
+#include "VectorT.hpp"
+#include "CacheableBuiltins.hpp"
+#include "ResultCollector.hpp"
+
+/**
+ * @file
+ */
+
+namespace apache {
+namespace geode {
+namespace client {
+
+class CPPCACHE_EXPORT DefaultResultCollector : public ResultCollector {
+ public:
+  DefaultResultCollector();
+  virtual ~DefaultResultCollector() noexcept;
+
+  virtual CacheableVectorPtr getResult(
+      std::chrono::milliseconds timeout =
+          DEFAULT_QUERY_RESPONSE_TIMEOUT) override;
+
+  virtual void addResult(const CacheablePtr& resultOfSingleExecution) override;
+
+  virtual void endResults() override;
+
+  virtual void clearResults() override;
+
+ private:
+  CacheableVectorPtr resultList;
+  bool ready;
+  std::condition_variable readyCondition;
+  std::mutex readyMutex;
+};
+
+}  // namespace client
+}  // namespace geode
+}  // namespace apache
+
+#endif  // GEODE_DEFAULTRESULTCOLLECTOR_H_
diff --git a/cppcache/include/geode/Exception.hpp b/cppcache/include/geode/Exception.hpp
index 4bb88f71..c94e030c 100644
--- a/cppcache/include/geode/Exception.hpp
+++ b/cppcache/include/geode/Exception.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_EXCEPTION_H_
-#define GEODE_EXCEPTION_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,13 +15,20 @@
  * limitations under the License.
  */
 
-/**
- * @file
- */
+#pragma once
+
+#ifndef GEODE_EXCEPTION_H_
+#define GEODE_EXCEPTION_H_
+
+#include <string>
 
 #include "geode_globals.hpp"
 #include "geode_types.hpp"
 
+/**
+ * @file
+ */
+
 namespace apache {
 namespace geode {
 namespace client {
@@ -58,11 +60,14 @@ class CPPCACHE_EXPORT Exception {
   Exception(const char* msg1, const char* msg2 = nullptr,
             bool forceTrace = false, const ExceptionPtr& cause = nullptr);
 
+  explicit Exception(const std::string& msg1);
+
   /** Creates an exception as a copy of the given other exception.
    * @param  other the original exception.
    *
    **/
-  Exception(const Exception& other);
+  Exception(const Exception& other) noexcept = default;
+  Exception(Exception&& other) noexcept = default;
 
   /** Create a clone of this exception. */
   virtual Exception* clone() const;
@@ -101,7 +106,7 @@ class CPPCACHE_EXPORT Exception {
    * Throw polymorphically; this allows storing an exception object
    * pointer and throwing it later.
    */
-  virtual void raise() { throw * this; }
+  virtual void raise() { throw *this; }
 
   inline ExceptionPtr getCause() const { return m_cause; }
 
diff --git a/cppcache/include/geode/ExceptionTypes.hpp b/cppcache/include/geode/ExceptionTypes.hpp
index 86cdaf41..d7a09898 100644
--- a/cppcache/include/geode/ExceptionTypes.hpp
+++ b/cppcache/include/geode/ExceptionTypes.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_EXCEPTIONTYPES_H_
-#define GEODE_EXCEPTIONTYPES_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,6 +15,11 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_EXCEPTIONTYPES_H_
+#define GEODE_EXCEPTIONTYPES_H_
+
 /**
  * @file
  */
@@ -31,30 +31,27 @@ namespace apache {
 namespace geode {
 namespace client {
 
-#define _GF_EXCEPTION_DEF(x)                                                 \
-  const char _exception_name_##x[] = "apache::geode::client::" #x;           \
-  class x;                                                                   \
-  typedef std::shared_ptr<x> x##Ptr;                                         \
-  class CPPCACHE_EXPORT x : public apache::geode::client::Exception {        \
-   public:                                                                   \
-    x(const char* msg1, const char* msg2 = nullptr, bool forceStack = false, \
-      const ExceptionPtr& cause = nullptr)                                   \
-        : Exception(msg1, msg2, forceStack, cause) {}                        \
-    x(const x& other) : Exception(other) {}                                  \
-    virtual Exception* clone() const {                                       \
-      return new x(m_message, m_stack, m_cause);                             \
-    }                                                                        \
-    virtual ~x() {}                                                          \
-    virtual const char* getName() const { return _exception_name_##x; }      \
-    virtual void raise() { throw * this; }                                   \
-                                                                             \
-   protected:                                                                \
-    x(const CacheableStringPtr& message, const StackTracePtr& stack,         \
-      const ExceptionPtr& cause)                                             \
-        : Exception(message, stack, cause) {}                                \
-                                                                             \
-   private:                                                                  \
-    const x& operator=(const x&);                                            \
+#define _GF_EXCEPTION_DEF(x)                                            \
+  const char _exception_name_##x[] = "apache::geode::client::" #x;      \
+  class x;                                                              \
+  typedef std::shared_ptr<x> x##Ptr;                                    \
+  class CPPCACHE_EXPORT x : public apache::geode::client::Exception {   \
+   public:                                                              \
+    using Exception::Exception;                                         \
+    virtual Exception* clone() const {                                  \
+      return new x(m_message, m_stack, m_cause);                        \
+    }                                                                   \
+    virtual ~x() {}                                                     \
+    virtual const char* getName() const { return _exception_name_##x; } \
+    virtual void raise() { throw *this; }                               \
+                                                                        \
+   protected:                                                           \
+    x(const CacheableStringPtr& message, const StackTracePtr& stack,    \
+      const ExceptionPtr& cause)                                        \
+        : Exception(message, stack, cause) {}                           \
+                                                                        \
+   private:                                                             \
+    const x& operator=(const x&);                                       \
   }
 
 /*
diff --git a/cppcache/include/geode/Execution.hpp b/cppcache/include/geode/Execution.hpp
index 812e39e4..935c6795 100644
--- a/cppcache/include/geode/Execution.hpp
+++ b/cppcache/include/geode/Execution.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_EXECUTION_H_
-#define GEODE_EXECUTION_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,15 +15,17 @@
  * limitations under the License.
  */
 
-/*
- * The specification of function behaviors is found in the corresponding .cpp
- * file.
- */
+#pragma once
+
+#ifndef GEODE_EXECUTION_H_
+#define GEODE_EXECUTION_H_
+
+#include <memory>
+#include <chrono>
 
 #include "geode_globals.hpp"
 #include "geode_types.hpp"
 #include "VectorT.hpp"
-#include <memory>
 #include "CacheableBuiltins.hpp"
 #include "ResultCollector.hpp"
 
@@ -46,6 +43,7 @@ namespace client {
  */
 
 class CPPCACHE_EXPORT Execution {
+
  public:
   /**
    * Specifies a data filter of routing objects for selecting the Geode
@@ -88,7 +86,8 @@ class CPPCACHE_EXPORT Execution {
    * #withCollector(ResultCollector)}
    */
   virtual ResultCollectorPtr execute(
-      const char* func, uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) = 0;
+      const char* func,
+      std::chrono::milliseconds timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) = 0;
 
   /**
    * Executes the function using its name
@@ -108,8 +107,9 @@ class CPPCACHE_EXPORT Execution {
   virtual ResultCollectorPtr execute(const CacheableVectorPtr& routingObj,
                                      const CacheablePtr& args,
                                      const ResultCollectorPtr& rs,
-                                     const char* func, uint32_t timeout) = 0;
+                                     const char* func, std::chrono::milliseconds timeout) = 0;
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/include/geode/ExpirationAttributes.hpp b/cppcache/include/geode/ExpirationAttributes.hpp
index 014f3707..ab618558 100644
--- a/cppcache/include/geode/ExpirationAttributes.hpp
+++ b/cppcache/include/geode/ExpirationAttributes.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_EXPIRATIONATTRIBUTES_H_
-#define GEODE_EXPIRATIONATTRIBUTES_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,6 +15,13 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_EXPIRATIONATTRIBUTES_H_
+#define GEODE_EXPIRATIONATTRIBUTES_H_
+
+#include <chrono>
+
 #include "geode_globals.hpp"
 #include "ExpirationAction.hpp"
 
@@ -63,22 +65,21 @@ class CPPCACHE_EXPORT ExpirationAttributes {
   /** Constructs an <code>ExpirationAttributes</code> with the specified
    * expiration time and
    * expiration action.
-   * @param expirationTime The number of seconds for a value to live before it
-   * expires
+   * @param expirationTime Duration live before it expires
    * @param expirationAction the action to take when the value expires
    * @throws IllegalArgumentException if expirationTime is nonpositive
    */
-  ExpirationAttributes(const int expirationTime,
+  ExpirationAttributes(const std::chrono::seconds& expirationTime,
                        const ExpirationAction::Action expirationAction =
                            ExpirationAction::INVALIDATE);
 
-  /** Returns the number of seconds before a region or value expires.
+  /** Returns the duration before a region or value expires.
    *
-   * @return the relative number of seconds before a region or value expires
-   * or zero if it will never expire
+   * @return the duration before a region or value expires or zero if it will
+   * never expire
    */
-  int getTimeout() const;
-  void setTimeout(int timeout);
+  const std::chrono::seconds& getTimeout() const;
+  void setTimeout(const std::chrono::seconds& timeout);
 
   /** Returns the action that should take place when this value or region
    * expires.
@@ -89,13 +90,10 @@ class CPPCACHE_EXPORT ExpirationAttributes {
   void setAction(const ExpirationAction::Action& action);
 
  private:
-  /** The action that should take place when this object or region expires.
-   */
   ExpirationAction::Action m_action;
-  /** The number of seconds since this value or region was created before it
-   * expires. */
-  int m_timeout;
+  std::chrono::seconds m_timeout;
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/include/geode/Pool.hpp b/cppcache/include/geode/Pool.hpp
index 40ad2478..95fae983 100644
--- a/cppcache/include/geode/Pool.hpp
+++ b/cppcache/include/geode/Pool.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_POOL_H_
-#define GEODE_POOL_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,8 +15,16 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_POOL_H_
+#define GEODE_POOL_H_
+
+#include <chrono>
+
 #include "geode_globals.hpp"
 #include "geode_types.hpp"
+#include "util/chrono/duration.hpp"
 #include "CacheableBuiltins.hpp"
 #include "Cache.hpp"
 #include "CacheFactory.hpp"
@@ -32,9 +35,11 @@
 namespace apache {
 namespace geode {
 namespace client {
+
 class Cache;
 class CacheFactory;
 class PoolAttributes;
+
 /**
  * A pool of connections to connect from a client to a set of Geode Cache
  * Servers.
@@ -62,78 +67,92 @@ class CPPCACHE_EXPORT Pool : public std::enable_shared_from_this<Pool> {
    * Returns the connection timeout of this pool.
    * @see PoolFactory#setFreeConnectionTimeout
    */
-  int getFreeConnectionTimeout() const;
+  std::chrono::milliseconds getFreeConnectionTimeout() const;
+
   /**
    * Returns the load conditioning interval of this pool.
    * @see PoolFactory#setLoadConditioningInterval
    */
-  int getLoadConditioningInterval() const;
+  std::chrono::milliseconds getLoadConditioningInterval() const;
+
   /**
    * Returns the socket buffer size of this pool.
    * @see PoolFactory#setSocketBufferSize
    */
   int getSocketBufferSize() const;
+
   /**
    * Returns the read timeout of this pool.
    * @see PoolFactory#setReadTimeout
    */
-  int getReadTimeout() const;
+  std::chrono::milliseconds getReadTimeout() const;
+
   /**
    * Gets the minimum connections for this pool.
    * @see PoolFactory#setMinConnections(int)
    */
   int getMinConnections() const;
+
   /**
    * Gets the maximum connections for this pool.
    * @see PoolFactory#setMaxConnections(int)
    */
   int getMaxConnections() const;
+
   /**
    * Gets the idle connection timeout for this pool.
    * @see PoolFactory#setIdleTimeout(long)
    */
-  long getIdleTimeout() const;
+  std::chrono::milliseconds getIdleTimeout() const;
+
   /**
    * Gets the ping interval for this pool.
    * @see PoolFactory#setPingInterval(long)
    */
-  long getPingInterval() const;
+  std::chrono::milliseconds getPingInterval() const;
+
   /**
    * Gets the update locator list interval for this pool.
    * @see PoolFactory#setUpdateLocatorListInterval(long)
    */
-  long getUpdateLocatorListInterval() const;
+  std::chrono::milliseconds getUpdateLocatorListInterval() const;
+
   /**
    * Gets the statistic interval for this pool.
    * @see PoolFactory#setStatisticInterval(int)
    */
-  int getStatisticInterval() const;
+  std::chrono::milliseconds getStatisticInterval() const;
+
   /**
    * Gets the retry attempts for this pool.
    * @see PoolFactory#setRetryAttempts(int)
    */
   int getRetryAttempts() const;
+
   /**
    * Returns the true if a server-to-client subscriptions are enabled on this
    * pool.
    * @see PoolFactory#setSubscriptionEnabled
    */
   bool getSubscriptionEnabled() const;
+
   /**
    * Returns the subscription redundancy level of this pool.
    * @see PoolFactory#setSubscriptionRedundancy
    */
   int getSubscriptionRedundancy() const;
+
   /**
    * Returns the subscription message tracking timeout of this pool.
    * @see PoolFactory#setSubscriptionMessageTrackingTimeout
    */
-  int getSubscriptionMessageTrackingTimeout() const;
+  std::chrono::milliseconds getSubscriptionMessageTrackingTimeout() const;
+
   /**
    * Returns the subscription ack interval of this pool.
    * @see PoolFactory#setSubscriptionAckInterval(int)
    */
-  int getSubscriptionAckInterval() const;
+  std::chrono::milliseconds getSubscriptionAckInterval() const;
 
   /**
    * Returns the server group of this pool.
@@ -281,6 +300,7 @@ class CPPCACHE_EXPORT Pool : public std::enable_shared_from_this<Pool> {
   friend class CacheFactory;
   friend class Cache;
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/include/geode/PoolFactory.hpp b/cppcache/include/geode/PoolFactory.hpp
index 5369f97a..98146118 100644
--- a/cppcache/include/geode/PoolFactory.hpp
+++ b/cppcache/include/geode/PoolFactory.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_POOLFACTORY_H_
-#define GEODE_POOLFACTORY_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,8 +15,16 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_POOLFACTORY_H_
+#define GEODE_POOLFACTORY_H_
+
+#include <chrono>
+
 #include "geode_globals.hpp"
 #include "geode_types.hpp"
+#include "util/chrono/duration.hpp"
 #include "Pool.hpp"
 
 /**
@@ -65,19 +68,19 @@ class PoolAttributes;
 class CPPCACHE_EXPORT PoolFactory {
  public:
   /**
-   * The default amount of time, in milliseconds, which we will wait for a free
-   * connection if max connections is set and all of the connections are in use.
-   * <p>Current value: <code>10000</code>.
+   * The default amount of time which we will wait for a free connection if max
+   * connections is set and all of the connections are in use.
+   * <p>Current value: <code>10s</code>.
    */
-  static const int DEFAULT_FREE_CONNECTION_TIMEOUT = 10000;
+  static const std::chrono::milliseconds DEFAULT_FREE_CONNECTION_TIMEOUT;
 
   /**
    * The default interval in which the pool will check to see if
    * a connection to a given server should be moved to a different
    * server to improve the load balance.
-   * <p>Current value: <code>300,000</code> (which is 5 minutes).
+   * <p>Current value: <code>5min</code>
    */
-  static const int DEFAULT_LOAD_CONDITIONING_INTERVAL = 1000 * 60 * 5;
+  static const std::chrono::milliseconds DEFAULT_LOAD_CONDITIONING_INTERVAL;
 
   /**
    * The default size in bytes of the socket buffer on each connection
@@ -87,11 +90,10 @@ class CPPCACHE_EXPORT PoolFactory {
   static const int DEFAULT_SOCKET_BUFFER_SIZE = 32768;
 
   /**
-   * The default amount of time, in milliseconds, to wait for a response from a
-   * server.
-   * <p>Current value: <code>10000</code>.
+   * The default amount of time to wait for a response from a server.
+   * <p>Current value: <code>10s</code>.
    */
-  static const int DEFAULT_READ_TIMEOUT = 10000;
+  static const std::chrono::milliseconds DEFAULT_READ_TIMEOUT;
 
   /**
    * The default number of connections to be created initially.
@@ -106,11 +108,10 @@ class CPPCACHE_EXPORT PoolFactory {
   static const int DEFAULT_MAX_CONNECTIONS = -1;
 
   /**
-   * The default amount of time in milliseconds, to wait for a connection to
-   * become idle.
-   * <p>Current value: <code>5000</code>.
+   * The default amount of time in to wait for a connection to become idle.
+   * <p>Current value: <code>5s</code>.
    */
-  static const long DEFAULT_IDLE_TIMEOUT = 5000;
+  static const std::chrono::milliseconds DEFAULT_IDLE_TIMEOUT;
 
   /**
    * The default number of times to retry an operation after a timeout or
@@ -120,31 +121,22 @@ class CPPCACHE_EXPORT PoolFactory {
   static const int DEFAULT_RETRY_ATTEMPTS = -1;
 
   /**
-   * The default frequency, in milliseconds, to ping servers.
-   * <p>Current value: <code>10000</code>.
+   * The default frequenc, to ping servers.
+   * <p>Current value: <code>10s</code>.
    */
-  static const long DEFAULT_PING_INTERVAL = 10000;
+  static const std::chrono::milliseconds DEFAULT_PING_INTERVAL;
 
   /**
-   * The default frequency, in milliseconds, to update the locator list.
-   * <p>Current value: <code>10000</code>.
-   */
-  static const long DEFAULT_UPDATE_LOCATOR_LIST_INTERVAL = 5000;
-
-  /**
-   * The default frequency, in milliseconds, that client statistics
-   * are sent to the server.
-   * <p>Current value: <code>-1</code>.
+   * The default frequency to update the locator list.
+   * <p>Current value: <code>5s</code>.
    */
-  static const int DEFAULT_STATISTIC_INTERVAL = -1;
+  static const std::chrono::milliseconds DEFAULT_UPDATE_LOCATOR_LIST_INTERVAL;
 
   /**
-   * The default value for whether connections should have affinity to the
-   * thread
-   * that last used them.
-   * <p>Current value: <code>false</code>.
+   * The default frequency that client statistics are sent to the server.
+   * <p>Current value: <code>-1</code> (disabled).
    */
-  // static const bool DEFAULT_THREAD_LOCAL_CONNECTIONS = false;
+  static const std::chrono::milliseconds DEFAULT_STATISTIC_INTERVAL;
 
   /**
    * The default value for whether to establish a server to client subscription.
@@ -161,20 +153,19 @@ class CPPCACHE_EXPORT PoolFactory {
   static const int DEFAULT_SUBSCRIPTION_REDUNDANCY = 0;
 
   /**
-   * The default amount of time, in milliseconds, that messages sent from a
-   * server to a client will be tracked. The tracking is done to minimize
-   * duplicate events.
-   * <p>Current value: <code>900000</code>.
+   * The default amount of time that messages sent from a  server to a client
+   * will be tracked. The tracking is done to minimize duplicate events.
+   * <p>Current value: <code>900s</code>.
    */
-  static const int DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT = 900000;
+  static const std::chrono::milliseconds
+      DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT;
 
   /**
-   * The default amount of time, in milliseconds, to wait before
-   * sending an acknowledgement to the server about events
-   * received from the subscriptions.
-   * <p>Current value: <code>100</code>.
+   * The default amount of time to wait before sending an acknowledgement to the
+   * server about events received from the subscriptions.
+   * <p>Current value: <code>100ms</code>.
    */
-  static const int DEFAULT_SUBSCRIPTION_ACK_INTERVAL = 100;
+  static const std::chrono::milliseconds DEFAULT_SUBSCRIPTION_ACK_INTERVAL;
 
   /**
    * The default server group.
@@ -207,33 +198,40 @@ class CPPCACHE_EXPORT PoolFactory {
    * a free connection before receiving
    * an {@link AllConnectionsInUseException}. If max connections
    * is not set this setting has no effect.
+   *
    * @see #setMaxConnections(int)
-   * @param connectionTimeout is the connection timeout in milliseconds
-   * @return a reference to <code>this</code>
-   * @throws IllegalArgumentException if <code>connectionTimeout</code>
+   *
+   * @param connectionTimeout is the connection timeout
+   *
+   * @throws std::invalid_argument if <code>connectionTimeout</code>
    * is less than or equal to <code>0</code>.
    */
-  void setFreeConnectionTimeout(int connectionTimeout);
+  void setFreeConnectionTimeout(std::chrono::milliseconds connectionTimeout);
+
   /**
    * Sets the load conditioning interval for this pool.
    * This interval controls how frequently the pool will check to see if
    * a connection to a given server should be moved to a different
    * server to improve the load balance.
    * <p>A value of <code>-1</code> disables load conditioning
-   * @param loadConditioningInterval is the connection lifetime in milliseconds
-   * @return a reference to <code>this</code>
-   * @throws IllegalArgumentException if <code>connectionLifetime</code>
+   *
+   * @param loadConditioningInterval is the connection lifetime
+   *
+   * @throws std::invalid_argument if <code>connectionLifetime</code>
    * is less than <code>-1</code>.
    */
-  void setLoadConditioningInterval(int loadConditioningInterval);
+  void setLoadConditioningInterval(
+      std::chrono::milliseconds loadConditioningInterval);
+
   /**
    * Sets the socket buffer size for each connection made in this pool.
    * Large messages can be received and sent faster when this buffer is larger.
    * Larger buffers also optimize the rate at which servers can send events
    * for client subscriptions.
+   *
    * @param bufferSize is the size of the socket buffers used for reading and
    * writing on each connection in this pool.
-   * @return a reference to <code>this</code>
+   *
    * @throws IllegalArgumentException if <code>bufferSize</code>
    * is less than or equal to <code>0</code>.
    */
@@ -252,22 +250,23 @@ class CPPCACHE_EXPORT PoolFactory {
    * as the operation being done with the connection completes. This allows
    * connections to be shared amonst multiple threads keeping the number of
    * connections down.
+   *
    * @param threadLocalConnections if <code>true</code> then enable thread local
    * connections.
-   * @return a reference to <code>this</code>
    */
   void setThreadLocalConnections(bool threadLocalConnections);
 
   /**
-   * Sets the number of milliseconds to wait for a response from a server before
-   * timing out the operation and trying another server (if any are available).
-   * @param timeout is the number of milliseconds to wait for a response from a
+   * Sets the duration to wait for a response from a server before timing out
+   * the operation and trying another server (if any are available).
+   *
+   * @param timeout duration to wait for a response from a
    * server
-   * @return a reference to <code>this</code>
-   * @throws IllegalArgumentException if <code>timeout</code>
+   *
+   * @throws std::invalid_argument if <code>timeout</code>
    * is less than or equal to <code>0</code>.
    */
-  void setReadTimeout(int timeout);
+  void setReadTimeout(std::chrono::milliseconds timeout);
 
   /**
    * Sets the minimum number of connections to keep available at all times.
@@ -275,9 +274,10 @@ class CPPCACHE_EXPORT PoolFactory {
    * If <code>0</code> then connections will not be made until an actual
    * operation
    * is done that requires client-to-server communication.
+   *
    * @param minConnections is the initial number of connections
    * this pool will create.
-   * @return a reference to <code>this</code>
+   *
    * @throws IllegalArgumentException if <code>minConnections</code>
    * is less than <code>0</code>.
    */
@@ -289,10 +289,12 @@ class CPPCACHE_EXPORT PoolFactory {
    * the connections are in use, an operation requiring a client to server
    * connection
    * will block until a connection is available.
+   *
    * @see #setFreeConnectionTimeout(int)
+   *
    * @param maxConnections is the maximum number of connections in the pool.
    * <code>-1</code> indicates that there is no maximum number of connections
-   * @return a reference to <code>this</code>
+   *
    * @throws IllegalArgumentException if <code>maxConnections</code>
    * is less than <code>minConnections</code>.
    */
@@ -300,20 +302,16 @@ class CPPCACHE_EXPORT PoolFactory {
 
   /**
    * Sets the amount of time a connection can be idle before expiring the
-   * connection.
-   * If the pool size is greater than the minimum specified by
+   * connection. If the pool size is greater than the minimum specified by
    * {@link PoolFactory#setMinConnections(int)}, connections which have been
-   * idle
-   * for longer than the idleTimeout will be closed.
-   * @param idleTimeout is the amount of time in milliseconds that an idle
-   * connection
-   * should live before expiring. -1 indicates that connections should never
-   * expire.
-   * @return a reference to <code>this</code>
-   * @throws IllegalArgumentException if <code>idleTimout</code>
-   * is less than <code>0</code>.
+   * idle for longer than the idleTimeout will be closed.
+   *
+   * @param idleTimeout is the duration that an idle connection
+   * should live no less than before expiring, actual time may be longer
+   * depending on clock resolution. A duration less than 0 indicates
+   * that connections should never expire.
    */
-  void setIdleTimeout(long idleTimeout);
+  void setIdleTimeout(std::chrono::milliseconds);
 
   /**
    * Set the number of times to retry a request after timeout/exception.
@@ -336,24 +334,25 @@ class CPPCACHE_EXPORT PoolFactory {
    * These pings are used by the server to monitor the health of
    * the client. Make sure that the <code>pingInterval</code> is less than the
    * maximum time between pings allowed by the bridge server.
-   * @param pingInterval is the amount of time in milliseconds between
-   * pings.
-   * @return a reference to <code>this</code>
-   * @throws IllegalArgumentException if <code>pingInterval</code>
+   *
+   * @param pingInterval is the amount of time  between pings.
+   *
+   * @throws std::invalid_argument if <code>pingInterval</code>
    * is less than <code>0</code>.
+   *
    * @see CacheServer#setMaximumTimeBetweenPings(int)
    */
-  void setPingInterval(long pingInterval);
+  void setPingInterval(std::chrono::milliseconds pingInterval);
 
   /**
    * The frequency with which client updates the locator list. To disable this
-   * set its
-   * value to 0.
-   * @param updateLocatorListInterval is the amount of time in milliseconds
-   * between
-   * checking locator list at locator.
+   * set its value to 0.
+   *
+   * @param updateLocatorListInterval is the amount of time
+   * between checking locator list at locator.
    */
-  void setUpdateLocatorListInterval(long updateLocatorListInterval);
+  void setUpdateLocatorListInterval(
+      std::chrono::milliseconds updateLocatorListInterval);
 
   /**
    * The frequency with which the client statistics must be sent to the server.
@@ -361,13 +360,13 @@ class CPPCACHE_EXPORT PoolFactory {
    * <p>A value of <code>-1</code> disables the sending of client statistics
    * to the server.
    *
-   * @param statisticInterval is the amount of time in milliseconds between
+   * @param statisticInterval is the amount of time between
    * sends of client statistics to the server.
-   * @return a reference to <code>this</code>
-   * @throws IllegalArgumentException if <code>statisticInterval</code>
+   *
+   * @throws std::invalid_argument if <code>statisticInterval</code>
    * is less than <code>-1</code>.
    */
-  void setStatisticInterval(int statisticInterval);
+  void setStatisticInterval(std::chrono::milliseconds statisticInterval);
 
   /**
    * Configures the group which contains all the servers that this pool connects
@@ -424,6 +423,7 @@ class CPPCACHE_EXPORT PoolFactory {
    * @return a reference to <code>this</code>
    */
   void setSubscriptionEnabled(bool enabled);
+
   /**
    * Sets the redundancy level for this pools server-to-client subscriptions.
    * If <code>0</code> then no redundant copies are kept on the servers.
@@ -438,35 +438,32 @@ class CPPCACHE_EXPORT PoolFactory {
    * is less than <code>-1</code>.
    */
   void setSubscriptionRedundancy(int redundancy);
+
   /**
-   * Sets the messageTrackingTimeout attribute which is the time-to-live period,
-   * in
-   * milliseconds, for subscription events the client has received from the
-   * server. It is used
-   * to minimize duplicate events.
-   * Entries that have not been modified for this amount of time
-   * are expired from the list.
-   * @param messageTrackingTimeout is the number of milliseconds to set the
-   * timeout to.
-   * @return a reference to <code>this</code>
-   * @throws IllegalArgumentException if <code>messageTrackingTimeout</code>
+   * Sets the messageTrackingTimeout attribute which is the time-to-live period
+   * for subscription events the client has received from the server. It is used
+   * to minimize duplicate events. Entries that have not been modified for this
+   * amount of time  are expired from the list.
+   *
+   * @param messageTrackingTimeout is the duration to set the timeout to.
+   *
+   * @throws std::invalid_argument if <code>messageTrackingTimeout</code>
    * is less than or equal to <code>0</code>.
    */
-  void setSubscriptionMessageTrackingTimeout(int messageTrackingTimeout);
+  void setSubscriptionMessageTrackingTimeout(
+      std::chrono::milliseconds messageTrackingTimeout);
 
   /**
-   * Sets the is the interval in milliseconds
-   * to wait before sending acknowledgements to the bridge server for
-   * events received from the server subscriptions.
+   * Sets the is the interval to wait before sending acknowledgements to the
+   * bridge server for events received from the server subscriptions.
    *
-   * @param ackInterval is the number of milliseconds to wait before sending
-   * event
+   * @param ackInterval is the duration to wait before sending  event
    * acknowledgements.
-   * @return a reference to <code>this</code>
-   * @throws IllegalArgumentException if <code>ackInterval</code>
+   *
+   * @throws std::invalid_argument if <code>ackInterval</code>
    * is less than or equal to <code>0</code>.
    */
-  void setSubscriptionAckInterval(int ackInterval);
+  void setSubscriptionAckInterval(std::chrono::milliseconds ackInterval);
 
   /**
    * Sets whether Pool is in multi user secure mode.
@@ -533,6 +530,7 @@ class CPPCACHE_EXPORT PoolFactory {
   friend class CacheFactory;
   friend class CacheXmlCreation;
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/include/geode/Properties.hpp b/cppcache/include/geode/Properties.hpp
index 4feaba91..82afa740 100644
--- a/cppcache/include/geode/Properties.hpp
+++ b/cppcache/include/geode/Properties.hpp
@@ -23,6 +23,7 @@
 /**
  * @file
  */
+
 #include "geode_globals.hpp"
 #include "geode_types.hpp"
 #include "Serializable.hpp"
@@ -31,6 +32,7 @@
 #include "Cacheable.hpp"
 #include "CacheableKey.hpp"
 #include "CacheableString.hpp"
+#include "util/chrono/duration.hpp"
 
 namespace apache {
 namespace geode {
@@ -87,6 +89,12 @@ class CPPCACHE_EXPORT Properties : public Serializable {
    */
   void insert(const CacheableKeyPtr& key, const CacheablePtr& value);
 
+  template <class _Rep, class _Period>
+  void insert(const char* key,
+              const std::chrono::duration<_Rep, _Period>& value) {
+    insert(key, util::chrono::duration::to_string(value).c_str());
+  }
+
   /**
    * Remove the key from the collection.
    *
diff --git a/cppcache/include/geode/Query.hpp b/cppcache/include/geode/Query.hpp
index 7b0ea8f9..436d5473 100644
--- a/cppcache/include/geode/Query.hpp
+++ b/cppcache/include/geode/Query.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_QUERY_H_
-#define GEODE_QUERY_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,6 +15,13 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_QUERY_H_
+#define GEODE_QUERY_H_
+
+#include <chrono>
+
 #include "geode_globals.hpp"
 #include "geode_types.hpp"
 
@@ -50,11 +52,9 @@ class CPPCACHE_EXPORT Query {
   /**
    * Executes the OQL Query on the cache server and returns the results.
    *
-   * @param timeout The time (in seconds) to wait for query response, optional.
-   *        This should be less than or equal to 2^31/1000 i.e. 2147483.
+   * @param timeout The time to wait for query response, optional.
    *
-   * @throws IllegalArgumentException if timeout parameter is greater than
-   * 2^31/1000.
+   * @throws IllegalArgumentException If timeout exceeds 2147483647ms.
    * @throws QueryException if some query error occurred at the server.
    * @throws IllegalStateException if some error occurred.
    * @throws NotConnectedException if no java cache server is available.  For
@@ -66,18 +66,16 @@ class CPPCACHE_EXPORT Query {
    * ResultSet or a StructSet.
    */
   virtual SelectResultsPtr execute(
-      uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) = 0;
+      std::chrono::milliseconds timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) = 0;
 
   /**
    * Executes the parameterized OQL Query on the cache server and returns the
    * results.
    *
    * @param paramList The query parameters list
-   * @param timeout The time (in seconds) to wait for query response, optional.
-   *       This should be less than or equal to 2^31/1000 i.e. 2147483.
+   * @param timeout The time to wait for query response, optional.
    *
-   * @throws IllegalArgumentException if timeout parameter is greater than
-   * 2^31/1000.
+   * @throws IllegalArgumentException If timeout exceeds 2147483647ms.
    * @throws QueryException if some query error occurred at the server.
    * @throws IllegalStateException if some error occurred.
    * @throws NotConnectedException if no java cache server is available.  For
@@ -91,7 +89,7 @@ class CPPCACHE_EXPORT Query {
 
   virtual SelectResultsPtr execute(
       CacheableVectorPtr paramList,
-      uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) = 0;
+      std::chrono::milliseconds timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) = 0;
   /**
    * Get the query string provided when a new Query was created from a
    * QueryService.
@@ -117,6 +115,7 @@ class CPPCACHE_EXPORT Query {
    */
   virtual bool isCompiled() = 0;
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/include/geode/Region.hpp b/cppcache/include/geode/Region.hpp
index 03305c54..22c1585a 100644
--- a/cppcache/include/geode/Region.hpp
+++ b/cppcache/include/geode/Region.hpp
@@ -45,11 +45,14 @@
 #include "AttributesFactory.hpp"
 #include "CacheableKey.hpp"
 #include "Query.hpp"
-#define DEFAULT_RESPONSE_TIMEOUT 15
 
 namespace apache {
 namespace geode {
 namespace client {
+
+static constexpr std::chrono::milliseconds DEFAULT_RESPONSE_TIMEOUT =
+    std::chrono::seconds(15);
+
 /**
 * @class Region Region.hpp
 *
@@ -392,20 +395,18 @@ class CPPCACHE_EXPORT Region : public std::enable_shared_from_this<Region> {
    * the entries.
    *
    * @param map: A hashmap containing key-value pairs
-   * @param timeout: The time (in seconds) to wait for the response, optional.
-   *        This should be less than or equal to 2^31/1000 i.e. 2147483.
-   *        Default is 15 (seconds).
-   * @since 8.1
+   * @param timeout: The time to wait for the response, optional.
    * @param aCallbackArgument an argument that is passed to the callback
    * functions.
    * It is ignored if nullptr. It must be serializable if this operation is
    * distributed.
-   * @throws IllegalArgumentException If timeout
-   *         parameter is greater than 2^31/1000, ie 2147483.
+   * @throws IllegalArgumentException If timeout exceeds 2147483647ms.
+   * @since 8.1
    */
-  virtual void putAll(const HashMapOfCacheable& map,
-                      uint32_t timeout = DEFAULT_RESPONSE_TIMEOUT,
-                      const SerializablePtr& aCallbackArgument = nullptr) = 0;
+  virtual void putAll(
+      const HashMapOfCacheable& map,
+      std::chrono::milliseconds timeout = DEFAULT_RESPONSE_TIMEOUT,
+      const SerializablePtr& aCallbackArgument = nullptr) = 0;
 
   /**
    * Places a new value into an entry in this region with the specified key
@@ -1308,12 +1309,9 @@ class CPPCACHE_EXPORT Region : public std::enable_shared_from_this<Region> {
    *
    * @param predicate The query predicate (just the WHERE clause) or the entire
    * query to execute.
-   * @param timeout The time (in seconds) to wait for the query response,
-   * optional.
-   *        This should be less than or equal to 2^31/1000 i.e. 2147483.
+   * @param timeout The time to wait for the query response, optional.
    *
-   * @throws IllegalArgumentException If predicate is empty or timeout
-   *         parameter is greater than 2^31/1000.
+   * @throws IllegalArgumentException If timeout exceeds 2147483647ms.
    * @throws QueryException if some query error occurred at the server.
    * @throws CacheServerException If an exception is received from the Java
    * cache server.
@@ -1333,7 +1331,7 @@ class CPPCACHE_EXPORT Region : public std::enable_shared_from_this<Region> {
    */
   virtual SelectResultsPtr query(
       const char* predicate,
-      uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) = 0;
+      std::chrono::milliseconds timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) = 0;
 
   /**
    * Executes the query on the server based on the predicate and returns whether
@@ -1341,15 +1339,13 @@ class CPPCACHE_EXPORT Region : public std::enable_shared_from_this<Region> {
    * Valid only for a Native Client region.
    * @param predicate The query predicate (just the WHERE clause) or the entire
    * query to execute.
-   * @param timeout The time (in seconds) to wait for the response, optional.
-   *        This should be less than or equal to 2^31/1000 i.e. 2147483.
-   * @throws IllegalArgumentException If predicate is empty or timeout
-   *         parameter is greater than 2^31/1000.
+   * @param timeout The time to wait for the response, optional.
+   * @throws IllegalArgumentException If timeout exceeds 2147483647ms.
    * @throws QueryException if some query error occurred at the server.
    * @throws NotConnectedException if a server connection error occurs.
    *         For pools configured with locators, if no locators are available,
-   * the cause
-   *         of NotConnectedException is set to NoAvailableLocatorsException.
+   *         the cause of NotConnectedException is set to
+   *         NoAvailableLocatorsException.
    * @throws MessageExcepton If the message received from server could not be
    *         handled. This will be the case when the reply is not well formed.
    *         More information can be found in the log.
@@ -1359,17 +1355,15 @@ class CPPCACHE_EXPORT Region : public std::enable_shared_from_this<Region> {
    */
   virtual bool existsValue(
       const char* predicate,
-      uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) = 0;
+      std::chrono::milliseconds timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) = 0;
 
   /**
    * Executes the query on the server based on the predicate and returns a
    * single result value. Valid only for a Native Client region.
    * @param predicate The query predicate (just the WHERE clause) or the entire
    * query to execute.
-   * @param timeout The time (in seconds) to wait for the response, optional.
-   *        This should be less than or equal to 2^31/1000 i.e. 2147483.
-   * @throws IllegalArgumentException If predicate is empty or timeout
-   *         parameter is greater than 2^31/1000.
+   * @param timeout The time to wait for the response, optional.
+   * @throws IllegalArgumentException If timeout exceeds 2147483647ms.
    * @throws QueryException if some query error occurred at the server, or more
    * than one result items are available.
    * @throws NotConnectedException if a server connection error occurs.
@@ -1387,7 +1381,7 @@ class CPPCACHE_EXPORT Region : public std::enable_shared_from_this<Region> {
    */
   virtual SerializablePtr selectValue(
       const char* predicate,
-      uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) = 0;
+      std::chrono::milliseconds timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) = 0;
 
   /**
    * Removes all of the entries for the specified keys from this region.
@@ -1440,6 +1434,7 @@ class CPPCACHE_EXPORT Region : public std::enable_shared_from_this<Region> {
 
   FRIEND_STD_SHARED_PTR(Region)
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/include/geode/RegionAttributes.hpp b/cppcache/include/geode/RegionAttributes.hpp
index f3b78136..18478dc1 100644
--- a/cppcache/include/geode/RegionAttributes.hpp
+++ b/cppcache/include/geode/RegionAttributes.hpp
@@ -24,6 +24,8 @@
  * @file
  */
 
+#include <chrono>
+
 #include "geode_globals.hpp"
 #include "geode_types.hpp"
 #include "CacheLoader.hpp"
@@ -35,6 +37,7 @@
 #include "Serializable.hpp"
 #include "DiskPolicyType.hpp"
 #include "PersistenceManager.hpp"
+#include "util/chrono/duration.hpp"
 
 namespace apache {
 namespace geode {
@@ -108,29 +111,34 @@ class CPPCACHE_EXPORT RegionAttributes : public Serializable {
    * whole.
    * @return the timeToLive expiration attributes for this region
    */
-  int getRegionTimeToLive();
-  ExpirationAction::Action getRegionTimeToLiveAction();
+  std::chrono::seconds getRegionTimeToLive() const;
+
+  ExpirationAction::Action getRegionTimeToLiveAction() const;
 
   /** Gets the idleTimeout expiration attributes for the region as a whole.
    *
    * @return the IdleTimeout expiration attributes for this region
    */
-  int getRegionIdleTimeout();
-  ExpirationAction::Action getRegionIdleTimeoutAction();
+  std::chrono::seconds getRegionIdleTimeout() const;
+
+  ExpirationAction::Action getRegionIdleTimeoutAction() const;
 
   /** Gets the <code>timeToLive</code> expiration attributes for entries in this
    * region.
    * @return the timeToLive expiration attributes for entries in this region
    */
-  int getEntryTimeToLive();
-  ExpirationAction::Action getEntryTimeToLiveAction();
+  std::chrono::seconds getEntryTimeToLive() const;
+
+  ExpirationAction::Action getEntryTimeToLiveAction() const;
 
   /** Gets the <code>idleTimeout</code> expiration attributes for entries in
    * this region.
    * @return the idleTimeout expiration attributes for entries in this region
+   * @tparam Duration std::chrono::duration type to return
    */
-  int getEntryIdleTimeout();
-  ExpirationAction::Action getEntryIdleTimeoutAction();
+  std::chrono::seconds getEntryIdleTimeout() const;
+
+  ExpirationAction::Action getEntryIdleTimeoutAction() const;
 
   /**
    * If true, this region will store data in the current process.
@@ -338,12 +346,14 @@ class CPPCACHE_EXPORT RegionAttributes : public Serializable {
   void setLruEntriesLimit(int limit);
   void setDiskPolicy(DiskPolicyType::PolicyType diskPolicy);
   void setConcurrencyChecksEnabled(bool enable);
+
   inline bool getEntryExpiryEnabled() const {
-    return (m_entryTimeToLive != 0 || m_entryIdleTimeout != 0);
+    return (m_entryTimeToLive.count() != 0 || m_entryIdleTimeout.count() != 0);
   }
 
   inline bool getRegionExpiryEnabled() const {
-    return (m_regionTimeToLive != 0 || m_regionIdleTimeout != 0);
+    return (m_regionTimeToLive.count() != 0 ||
+            m_regionIdleTimeout.count() != 0);
   }
 
   // will be created by the factory
@@ -362,10 +372,10 @@ class CPPCACHE_EXPORT RegionAttributes : public Serializable {
   uint32_t m_lruEntriesLimit;
   bool m_caching;
   uint32_t m_maxValueDistLimit;
-  uint32_t m_entryIdleTimeout;
-  uint32_t m_entryTimeToLive;
-  uint32_t m_regionIdleTimeout;
-  uint32_t m_regionTimeToLive;
+  std::chrono::seconds m_entryIdleTimeout;
+  std::chrono::seconds m_entryTimeToLive;
+  std::chrono::seconds m_regionIdleTimeout;
+  std::chrono::seconds m_regionTimeToLive;
   uint32_t m_initialCapacity;
   float m_loadFactor;
   uint8_t m_concurrencyLevel;
diff --git a/cppcache/include/geode/RegionFactory.hpp b/cppcache/include/geode/RegionFactory.hpp
index 0092c09e..405a8253 100644
--- a/cppcache/include/geode/RegionFactory.hpp
+++ b/cppcache/include/geode/RegionFactory.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_REGIONFACTORY_H_
-#define GEODE_REGIONFACTORY_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,9 +15,18 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_REGIONFACTORY_H_
+#define GEODE_REGIONFACTORY_H_
+
+#include <chrono>
+
 #include "geode_globals.hpp"
 #include "geode_types.hpp"
 #include "AttributesFactory.hpp"
+#include "util/chrono/duration.hpp"
+
 /**
  * @file
  */
@@ -110,38 +114,38 @@ class CPPCACHE_EXPORT RegionFactory {
   /** Sets the idleTimeout expiration attributes for region entries for the next
    * <code>RegionAttributes</code> created.
    * @param action the expiration action for entries in this region.
-   * @param idleTimeout the idleTimeout in seconds for entries in this region.
+   * @param idleTimeout the idleTimeout for entries in this region.
    * @return a reference to <code>this</code>
    */
   RegionFactory& setEntryIdleTimeout(ExpirationAction::Action action,
-                                     int32_t idleTimeout);
+                                     std::chrono::seconds idleTimeout);
 
   /** Sets the timeToLive expiration attributes for region entries for the next
    * <code>RegionAttributes</code> created.
    * @param action the expiration action for entries in this region.
-   * @param timeToLive the timeToLive in seconds for entries in this region.
+   * @param timeToLive the timeToLive for entries in this region.
    * @return a reference to <code>this</code>
    */
   RegionFactory& setEntryTimeToLive(ExpirationAction::Action action,
-                                    int32_t timeToLive);
+                                    std::chrono::seconds timeToLive);
 
   /** Sets the idleTimeout expiration attributes for the region itself for the
    * next <code>RegionAttributes</code> created.
    * @param action the expiration action for entries in this region.
-   * @param idleTimeout the idleTimeout in seconds for the region as a whole.
+   * @param idleTimeout the idleTimeout for the region as a whole.
    * @return a reference to <code>this</code>
    */
   RegionFactory& setRegionIdleTimeout(ExpirationAction::Action action,
-                                      int32_t idleTimeout);
+                                      std::chrono::seconds idleTimeout);
 
   /** Sets the timeToLive expiration attributes for the region itself for the
    * next <code>RegionAttributes</code> created.
    * @param action the expiration action for entries in this region.
-   * @param timeToLive the timeToLive in seconds for the region as a whole.
+   * @param timeToLive the timeToLive for the region as a whole.
    * @return a reference to <code>this</code>
    */
   RegionFactory& setRegionTimeToLive(ExpirationAction::Action action,
-                                     int32_t timeToLive);
+                                     std::chrono::seconds timeToLive);
 
   // PERSISTENCE
   /**
@@ -249,14 +253,6 @@ class CPPCACHE_EXPORT RegionFactory {
    */
   RegionFactory& setConcurrencyChecksEnabled(bool enable);
 
-  /**
-   * Sets time out for tombstones
-   * @since 7.0
-   * @param tombstoneTimeoutInMSec tombstone timeout in milli second
-   * @return a reference to <code>this</code>
-   */
-  RegionFactory& setTombstoneTimeout(uint32_t tombstoneTimeoutInMSec);
-
  private:
   RegionFactory(apache::geode::client::RegionShortcut preDefinedRegion,
                 CacheImpl* cacheImpl);
@@ -271,6 +267,7 @@ class CPPCACHE_EXPORT RegionFactory {
 
   friend class CacheImpl;
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/include/geode/ResultCollector.hpp b/cppcache/include/geode/ResultCollector.hpp
index 35a50a4c..7465b886 100644
--- a/cppcache/include/geode/ResultCollector.hpp
+++ b/cppcache/include/geode/ResultCollector.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_RESULTCOLLECTOR_H_
-#define GEODE_RESULTCOLLECTOR_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,10 +15,17 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_RESULTCOLLECTOR_H_
+#define GEODE_RESULTCOLLECTOR_H_
+
+#include <memory>
+#include <chrono>
+
 #include "geode_globals.hpp"
 #include "geode_types.hpp"
-#include <memory>
-#include "VectorT.hpp"
+
 #include "CacheableBuiltins.hpp"
 
 /**
@@ -33,6 +35,7 @@
 namespace apache {
 namespace geode {
 namespace client {
+
 /**
  * @class ResultCollector ResultCollector.hpp
  * Defines the interface for a container that gathers results from function
@@ -65,8 +68,9 @@ class CPPCACHE_EXPORT ResultCollector {
    * @brief public methods
    */
  public:
-  ResultCollector();
-  virtual ~ResultCollector();
+  ResultCollector() = default;
+  virtual ~ResultCollector() noexcept = default;
+
   /**
    * Returns the result of function execution, potentially blocking until all
    * the results are available.
@@ -74,39 +78,39 @@ class CPPCACHE_EXPORT ResultCollector {
    * will not
    * throw exception but will have exception {@link
    * UserFunctionExecutionException} as a part of results received.
-   * @param timeout in seconds, if result is not ready within this time,
+   * @param timeout if result is not ready within this time,
    * exception will be thrown
    * @return the result
    * @throws FunctionException if result retrieval fails
    * @see UserFunctionExecutionException
    */
   virtual CacheableVectorPtr getResult(
-      uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
+      std::chrono::milliseconds timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) = 0;
+
   /**
    * Adds a single function execution result to the ResultCollector
    *
    * @param resultOfSingleExecution
    * @since 5.8LA
    */
-  virtual void addResult(const CacheablePtr& resultOfSingleExecution);
+  virtual void addResult(const CacheablePtr& resultOfSingleExecution) = 0;
+
   /**
    * Geode will invoke this method when function execution has completed
    * and all results for the execution have been obtained and  added to the
    * ResultCollector}
    */
-  virtual void endResults();
+  virtual void endResults() = 0;
+
   /**
    * Geode will invoke this method before re-executing function (in case of
    * Function Execution HA) This is to clear the previous execution results from
    * the result collector
    * @since 6.5
    */
-  virtual void clearResults();
-
- private:
-  CacheableVectorPtr m_resultList;
-  volatile bool m_isResultReady;
+  virtual void clearResults() = 0;
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/include/geode/SystemProperties.hpp b/cppcache/include/geode/SystemProperties.hpp
index 18b48144..93720339 100644
--- a/cppcache/include/geode/SystemProperties.hpp
+++ b/cppcache/include/geode/SystemProperties.hpp
@@ -67,9 +67,9 @@ class CPPCACHE_EXPORT SystemProperties {
 
   /**
    * Returns the sampling interval of the sampling thread.
-   * This would be how often the statistics thread writes to disk in seconds.
+   * This would be how often the statistics thread writes to disk.
    */
-  const uint32_t statisticsSampleInterval() const {
+  const std::chrono::milliseconds statisticsSampleInterval() const {
     return m_statisticsSampleInterval;
   }
 
@@ -157,24 +157,28 @@ class CPPCACHE_EXPORT SystemProperties {
   /**
    * Returns  the time between two consecutive ping to servers
    */
-  const int32_t pingInterval() const { return m_pingInterval; }
+  const std::chrono::seconds pingInterval() const { return m_pingInterval; }
   /**
    * Returns  the time between two consecutive checks for redundancy for HA
    */
-  const int32_t redundancyMonitorInterval() const {
+  const std::chrono::seconds redundancyMonitorInterval() const {
     return m_redundancyMonitorInterval;
   }
 
   /**
    * Returns the periodic notify ack interval
    */
-  const int32_t notifyAckInterval() const { return m_notifyAckInterval; }
+  const std::chrono::milliseconds notifyAckInterval() const {
+    return m_notifyAckInterval;
+  }
 
   /**
    * Returns the expiry time of an idle event id map entry for duplicate
    * notification checking
    */
-  const int32_t notifyDupCheckLife() const { return m_notifyDupCheckLife; }
+  const std::chrono::milliseconds notifyDupCheckLife() const {
+    return m_notifyDupCheckLife;
+  }
 
   /**
    * Returns the durable client ID
@@ -184,24 +188,30 @@ class CPPCACHE_EXPORT SystemProperties {
   /**
    * Returns the durable timeout
    */
-  const uint32_t durableTimeout() const { return m_durableTimeout; }
+  const std::chrono::seconds durableTimeout() const { return m_durableTimeout; }
 
   /**
    * Returns the connect timeout used for server and locator handshakes
    */
-  const uint32_t connectTimeout() const { return m_connectTimeout; }
+  const std::chrono::milliseconds connectTimeout() const {
+    return m_connectTimeout;
+  }
 
   /**
    * Returns the connect wait timeout(in millis) used for to connect to server
    * This is only applicable for linux
    */
-  const uint32_t connectWaitTimeout() const { return m_connectWaitTimeout; }
+  const std::chrono::milliseconds connectWaitTimeout() const {
+    return m_connectWaitTimeout;
+  }
 
   /**
    * Returns the connect wait timeout(in millis) used for to connect to server
    * This is only applicable for linux
    */
-  const uint32_t bucketWaitTimeout() const { return m_bucketWaitTimeout; }
+  const std::chrono::milliseconds bucketWaitTimeout() const {
+    return m_bucketWaitTimeout;
+  }
 
   /**
    * Returns client Queueconflation option
@@ -264,11 +274,6 @@ class CPPCACHE_EXPORT SystemProperties {
   bool disableChunkHandlerThread() const { return m_disableChunkHandlerThread; }
 
   /**
-   * This can be call to know whether read timeout unit is in milli second
-   */
-  bool readTimeoutUnitInMillis() const { return m_readTimeoutUnitInMillis; }
-
-  /**
    * This can be call multiple time to disable chunkhandler thread for those
    * operations
    */
@@ -367,17 +372,19 @@ class CPPCACHE_EXPORT SystemProperties {
   /**
    * Returns the timeout after which suspended transactions are rolled back.
    */
-  const uint32_t suspendedTxTimeout() const { return m_suspendedTxTimeout; }
+  const std::chrono::seconds suspendedTxTimeout() const {
+    return m_suspendedTxTimeout;
+  }
 
   /**
    * Returns the tombstone timeout .
    */
-  const uint32_t tombstoneTimeoutInMSec() const {
-    return m_tombstoneTimeoutInMSec;
+  const std::chrono::milliseconds tombstoneTimeout() const {
+    return m_tombstoneTimeout;
   }
 
  private:
-  uint32_t m_statisticsSampleInterval;
+  std::chrono::milliseconds m_statisticsSampleInterval;
 
   bool m_statisticsEnabled;
 
@@ -413,11 +420,11 @@ class CPPCACHE_EXPORT SystemProperties {
   int32_t m_heapLRULimit;
   int32_t m_heapLRUDelta;
   int32_t m_maxSocketBufferSize;
-  int32_t m_pingInterval;
-  int32_t m_redundancyMonitorInterval;
+  std::chrono::seconds m_pingInterval;
+  std::chrono::seconds m_redundancyMonitorInterval;
 
-  int32_t m_notifyAckInterval;
-  int32_t m_notifyDupCheckLife;
+  std::chrono::milliseconds m_notifyAckInterval;
+  std::chrono::milliseconds m_notifyDupCheckLife;
 
   PropertiesPtr m_securityPropertiesPtr;
 
@@ -425,11 +432,11 @@ class CPPCACHE_EXPORT SystemProperties {
   CacheableStringPtr m_securityClientKsPath;
 
   char* m_durableClientId;
-  uint32_t m_durableTimeout;
+  std::chrono::seconds m_durableTimeout;
 
-  uint32_t m_connectTimeout;
-  uint32_t m_connectWaitTimeout;
-  uint32_t m_bucketWaitTimeout;
+  std::chrono::milliseconds m_connectTimeout;
+  std::chrono::milliseconds m_connectWaitTimeout;
+  std::chrono::milliseconds m_bucketWaitTimeout;
 
   bool m_gridClient;
 
@@ -445,10 +452,9 @@ class CPPCACHE_EXPORT SystemProperties {
   char* m_conflateEvents;
 
   uint32_t m_threadPoolSize;
-  uint32_t m_suspendedTxTimeout;
-  uint32_t m_tombstoneTimeoutInMSec;
+  std::chrono::seconds m_suspendedTxTimeout;
+  std::chrono::milliseconds m_tombstoneTimeout;
   bool m_disableChunkHandlerThread;
-  bool m_readTimeoutUnitInMillis;
   bool m_onClientDisconnectClearPdxTypeIds;
 
  private:
@@ -457,6 +463,10 @@ class CPPCACHE_EXPORT SystemProperties {
    * the results internally:
    */
   void processProperty(const char* property, const char* value);
+  template <class _Rep, class _Period>
+  void parseDurationProperty(const std::string& property,
+                             const std::string& value,
+                             std::chrono::duration<_Rep, _Period>& duration);
 
  private:
   SystemProperties(const SystemProperties& rhs);  // never defined
diff --git a/cppcache/include/geode/geode_base.hpp b/cppcache/include/geode/geode_base.hpp
index b45b2f8f..4fec9406 100644
--- a/cppcache/include/geode/geode_base.hpp
+++ b/cppcache/include/geode/geode_base.hpp
@@ -172,9 +172,6 @@
  *  Definitions of types and functions supported in the Geode C++ interface
  */
 
-/** default timeout for query response */
-#define DEFAULT_QUERY_RESPONSE_TIMEOUT 15
-
 /**
  * @enum GfErrType
  *Error codes returned by Geode C++ interface functions
@@ -320,4 +317,17 @@ typedef enum {
 #define FRIEND_STD_SHARED_PTR(_T)
 #endif
 
+#include <chrono>
+
+namespace apache {
+namespace geode {
+namespace client {
+
+constexpr static std::chrono::milliseconds DEFAULT_QUERY_RESPONSE_TIMEOUT =
+    std::chrono::seconds{15};
+
+}  // namespace client
+}  // namespace geode
+}  // namespace apache
+
 #endif  // GEODE_BASE_H_
diff --git a/cppcache/include/geode/util/chrono/duration.hpp b/cppcache/include/geode/util/chrono/duration.hpp
new file mode 100644
index 00000000..ed3521ec
--- /dev/null
+++ b/cppcache/include/geode/util/chrono/duration.hpp
@@ -0,0 +1,163 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#ifndef GEODE_UTIL_CHRONO_DURATION_H_
+#define GEODE_UTIL_CHRONO_DURATION_H_
+
+#include <string>
+#include <chrono>
+#include <type_traits>
+#include <stdexcept>
+
+namespace apache {
+namespace geode {
+namespace util {
+namespace chrono {
+namespace duration {
+
+template <class Period>
+struct _suffix {
+  static constexpr char const* value = nullptr;
+};
+template <>
+struct _suffix<std::ratio<3600>> {
+  static constexpr char const* value = "h";
+};
+template <>
+struct _suffix<std::ratio<60>> {
+  static constexpr char const* value = "min";
+};
+template <>
+struct _suffix<std::ratio<1>> {
+  static constexpr char const* value = "s";
+};
+template <>
+struct _suffix<std::milli> {
+  static constexpr char const* value = "ms";
+};
+template <>
+struct _suffix<std::micro> {
+  static constexpr char const* value = "us";
+};
+template <>
+struct _suffix<std::nano> {
+  static constexpr char const* value = "ns";
+};
+
+template <class T>
+struct _is_duration : std::false_type {};
+
+template <class Rep, class Period>
+struct _is_duration<std::chrono::duration<Rep, Period>> : std::true_type {};
+
+template <class Rep, class Period>
+struct _is_duration<const std::chrono::duration<Rep, Period>> : std::true_type {
+};
+
+template <class Rep, class Period>
+struct _is_duration<volatile std::chrono::duration<Rep, Period>>
+    : std::true_type {};
+
+template <class Rep, class Period>
+struct _is_duration<const volatile std::chrono::duration<Rep, Period>>
+    : std::true_type {};
+
+/**
+ * Converts std::chrono:duration from given unit to other where other duration
+ * is no less than the given duration.
+ *
+ * For internal use only.
+ */
+template <class ToDuration, class Rep, class Period>
+inline
+    typename std::enable_if<_is_duration<ToDuration>::value, ToDuration>::type
+    _ceil(const std::chrono::duration<Rep, Period>& duration) {
+  ToDuration other = std::chrono::duration_cast<ToDuration>(duration);
+  if (other < duration) {
+    return other + ToDuration{1};
+  }
+  return other;
+}
+
+/**
+ * Parses std::string into std::chrono::duration expecting same format as that
+ * of C++14 std::chrono::duration literals.
+ *
+ * @returns std::chrono::duration for given input string where the resulting
+ * std::chrono::duration will not be less than the parsed duration if the
+ * units of std::chrono::duration are less the units of the given string.
+ *
+ * @tparam ToDuration std::chrono::duration type to parse into.
+ */
+template <class ToDuration = std::chrono::nanoseconds>
+inline
+    typename std::enable_if<_is_duration<ToDuration>::value, ToDuration>::type
+    from_string(const std::string& string) {
+  const auto& begin = string.begin();
+  auto end = string.end();
+  if (begin != end--) {
+    if ('s' == *end) {
+      if (begin != end--) {
+        if ('m' == *end) {
+          return _ceil<ToDuration>(std::chrono::milliseconds(
+              std::stoll(string.substr(0, std::distance(begin, end)))));
+        } else if ('u' == *end) {
+          return _ceil<ToDuration>(std::chrono::microseconds(
+              std::stoll(string.substr(0, std::distance(begin, end)))));
+        } else if ('n' == *end) {
+          return _ceil<ToDuration>(std::chrono::nanoseconds(
+              std::stoll(string.substr(0, std::distance(begin, end)))));
+        }
+      }
+      return _ceil<ToDuration>(std::chrono::seconds(
+          std::stoll(string.substr(0, std::distance(begin, ++end)))));
+    } else if ('h' == *end) {
+      return std::chrono::hours(
+          std::stoll(string.substr(0, std::distance(begin, end))));
+    } else if ('n' == *end && begin != end-- && 'i' == *end && begin != end-- &&
+               'm' == *end) {
+      return _ceil<ToDuration>(std::chrono::minutes(
+          std::stoll(string.substr(0, std::distance(begin, end)))));
+    }
+  }
+
+  throw std::invalid_argument("Not a valid duration parsing '" + string + "'.");
+}
+
+/**
+ * Converts std::chrono::duration to std::string.
+ *
+ * @tparam Rep
+ * @tparam Period
+ * @param duration to convert to std::string
+ * @return std::string representing the given duration.
+ */
+template <class Rep, class Period>
+inline std::string to_string(
+    const std::chrono::duration<Rep, Period>& duration) {
+  return std::to_string(duration.count()) + _suffix<Period>::value;
+}
+
+}  // namespace duration
+}  // namespace chrono
+}  // namespace util
+}  // namespace geode
+}  // namespace apache
+
+#endif /* GEODE_UTIL_CHRONO_DURATION_H_ */
diff --git a/cppcache/integration-test/CacheHelper.cpp b/cppcache/integration-test/CacheHelper.cpp
index 0d1733fa..27a51e49 100644
--- a/cppcache/integration-test/CacheHelper.cpp
+++ b/cppcache/integration-test/CacheHelper.cpp
@@ -16,16 +16,20 @@
  */
 
 #include <cstdlib>
-#include <ace/OS.h>
-#include <ace/INET_Addr.h>
-#include <ace/SOCK_Acceptor.h>
 #include <fstream>
 #include <regex>
 #include <list>
+
+#include <ace/OS.h>
+#include <ace/INET_Addr.h>
+#include <ace/SOCK_Acceptor.h>
+
 #include <geode/GeodeCppCache.hpp>
 #include <geode/SystemProperties.hpp>
 #include <geode/PoolManager.hpp>
-#include <CacheRegionHelper.hpp>
+#include <geode/util/chrono/duration.hpp>
+
+#include "CacheRegionHelper.hpp"
 #include "DistributedSystemImpl.hpp"
 #include "TimeBomb.hpp"
 #include "Utils.hpp"
@@ -59,6 +63,7 @@
 #endif
 
 using namespace apache::geode::client;
+using namespace apache::geode::util::chrono::duration;
 
 extern ClientCleanup gClientCleanup;
 
@@ -238,7 +243,7 @@ CacheHelper::CacheHelper(const bool isthinClient, const char* poolName,
     poolFactory->setSubscriptionEnabled(clientNotification);
     poolFactory->setMultiuserAuthentication(isMultiuserMode);
     if (loadConditioningInterval > 0) {
-      poolFactory->setLoadConditioningInterval(loadConditioningInterval);
+      poolFactory->setLoadConditioningInterval(std::chrono::milliseconds(loadConditioningInterval));
     }
     printf("Setting connections to %d ", connections);
     if (connections >= 0) {
@@ -246,7 +251,7 @@ CacheHelper::CacheHelper(const bool isthinClient, const char* poolName,
       poolFactory->setMaxConnections(connections);
     }
     if (subscriptionAckInterval != -1) {
-      poolFactory->setSubscriptionAckInterval(subscriptionAckInterval);
+      poolFactory->setSubscriptionAckInterval(std::chrono::milliseconds(subscriptionAckInterval));
     }
 
     poolFactory->create(poolName);
@@ -405,11 +410,11 @@ RegionPtr CacheHelper::createRegion(const char* name, bool ack, bool caching,
   return regionPtr;
 }
 
-RegionPtr CacheHelper::createRegion(const char* name, bool ack, bool caching,
-                                    int ettl, int eit, int rttl, int rit,
-                                    int lel, ExpirationAction::Action action,
-                                    const char* endpoints,
-                                    bool clientNotificationEnabled) {
+RegionPtr CacheHelper::createRegion(
+    const char* name, bool ack, bool caching, const std::chrono::seconds& ettl,
+    const std::chrono::seconds& eit, const std::chrono::seconds& rttl,
+    const std::chrono::seconds& rit, int lel, ExpirationAction::Action action,
+    const char* endpoints, bool clientNotificationEnabled) {
   AttributesFactory af;
   af.setCachingEnabled(caching);
   af.setLruEntriesLimit(lel);
@@ -426,12 +431,11 @@ RegionPtr CacheHelper::createRegion(const char* name, bool ack, bool caching,
   return regionPtr;
 }
 
-PoolPtr CacheHelper::createPool(const char* poolName, const char* locators,
-                                const char* serverGroup, int redundancy,
-                                bool clientNotification,
-                                int subscriptionAckInterval, int connections,
-                                int loadConditioningInterval,
-                                bool isMultiuserMode) {
+PoolPtr CacheHelper::createPool(
+    const char* poolName, const char* locators, const char* serverGroup,
+    int redundancy, bool clientNotification,
+    std::chrono::milliseconds subscriptionAckInterval, int connections,
+    int loadConditioningInterval, bool isMultiuserMode) {
   // printf(" in createPool isMultiuserMode = %d \n", isMultiuserMode);
   PoolFactoryPtr poolFacPtr = getCache()->getPoolManager().createFactory();
 
@@ -445,14 +449,14 @@ PoolPtr CacheHelper::createPool(const char* poolName, const char* locators,
   poolFacPtr->setMultiuserAuthentication(isMultiuserMode);
   // poolFacPtr->setStatisticInterval(1000);
   if (loadConditioningInterval > 0) {
-    poolFacPtr->setLoadConditioningInterval(loadConditioningInterval);
+    poolFacPtr->setLoadConditioningInterval(std::chrono::milliseconds(loadConditioningInterval));
   }
 
   if (connections >= 0) {
     poolFacPtr->setMinConnections(connections);
     poolFacPtr->setMaxConnections(connections);
   }
-  if (subscriptionAckInterval != -1) {
+  if (subscriptionAckInterval > std::chrono::milliseconds::zero()) {
     poolFacPtr->setSubscriptionAckInterval(subscriptionAckInterval);
   }
 
@@ -485,7 +489,7 @@ PoolPtr CacheHelper::createPool2(const char* poolName, const char* locators,
     poolFacPtr->setMaxConnections(connections);
   }
   if (subscriptionAckInterval != -1) {
-    poolFacPtr->setSubscriptionAckInterval(subscriptionAckInterval);
+    poolFacPtr->setSubscriptionAckInterval(std::chrono::milliseconds(subscriptionAckInterval));
   }
 
   return poolFacPtr->create(poolName);
@@ -519,12 +523,11 @@ void CacheHelper::logPoolAttributes(PoolPtr& pool) {
           pool->getPRSingleHopEnabled() ? "true" : "false");
 }
 
-void CacheHelper::createPoolWithLocators(const char* name, const char* locators,
-                                         bool clientNotificationEnabled,
-                                         int subscriptionRedundancy,
-                                         int subscriptionAckInterval,
-                                         int connections, bool isMultiuserMode,
-                                         const char* serverGroup) {
+void CacheHelper::createPoolWithLocators(
+    const char* name, const char* locators, bool clientNotificationEnabled,
+    int subscriptionRedundancy,
+    std::chrono::milliseconds subscriptionAckInterval, int connections,
+    bool isMultiuserMode, const char* serverGroup) {
   LOG("createPool() entered.");
   printf(" in createPoolWithLocators isMultiuserMode = %d\n", isMultiuserMode);
   PoolPtr poolPtr =
@@ -537,8 +540,10 @@ void CacheHelper::createPoolWithLocators(const char* name, const char* locators,
 }
 
 RegionPtr CacheHelper::createRegionAndAttachPool(
-    const char* name, bool ack, const char* poolName, bool caching, int ettl,
-    int eit, int rttl, int rit, int lel, ExpirationAction::Action action) {
+    const char* name, bool ack, const char* poolName, bool caching,
+    const std::chrono::seconds& ettl, const std::chrono::seconds& eit,
+    const std::chrono::seconds& rttl, const std::chrono::seconds& rit, int lel,
+    ExpirationAction::Action action) {
   RegionShortcut preDefRA = PROXY;
   if (caching) {
     preDefRA = CACHING_PROXY;
@@ -560,8 +565,10 @@ RegionPtr CacheHelper::createRegionAndAttachPool(
 
 RegionPtr CacheHelper::createRegionAndAttachPool2(
     const char* name, bool ack, const char* poolName,
-    const PartitionResolverPtr& aResolver, bool caching, int ettl, int eit,
-    int rttl, int rit, int lel, ExpirationAction::Action action) {
+    const PartitionResolverPtr& aResolver, bool caching,
+    const std::chrono::seconds& ettl, const std::chrono::seconds& eit,
+    const std::chrono::seconds& rttl, const std::chrono::seconds& rit, int lel,
+    ExpirationAction::Action action) {
   RegionShortcut preDefRA = PROXY;
   if (caching) {
     preDefRA = CACHING_PROXY;
@@ -625,9 +632,10 @@ void CacheHelper::addServerLocatorEPs(const char* epList, PoolFactoryPtr pfPtr,
 
 RegionPtr CacheHelper::createPooledRegion(
     const char* name, bool ack, const char* locators, const char* poolName,
-    bool caching, bool clientNotificationEnabled, int ettl, int eit, int rttl,
-    int rit, int lel, const CacheListenerPtr& cacheListener,
-    ExpirationAction::Action action) {
+    bool caching, bool clientNotificationEnabled,
+    const std::chrono::seconds& ettl, const std::chrono::seconds& eit,
+    const std::chrono::seconds& rttl, const std::chrono::seconds& rit, int lel,
+    const CacheListenerPtr& cacheListener, ExpirationAction::Action action) {
   PoolFactoryPtr poolFacPtr = getCache()->getPoolManager().createFactory();
   poolFacPtr->setSubscriptionEnabled(clientNotificationEnabled);
 
@@ -664,7 +672,8 @@ RegionPtr CacheHelper::createPooledRegion(
 RegionPtr CacheHelper::createPooledRegionConcurrencyCheckDisabled(
     const char* name, bool ack, const char* locators, const char* poolName,
     bool caching, bool clientNotificationEnabled, bool concurrencyCheckEnabled,
-    int ettl, int eit, int rttl, int rit, int lel,
+    const std::chrono::seconds& ettl, const std::chrono::seconds& eit,
+    const std::chrono::seconds& rttl, const std::chrono::seconds& rit, int lel,
     const CacheListenerPtr& cacheListener, ExpirationAction::Action action) {
   PoolFactoryPtr poolFacPtr = getCache()->getPoolManager().createFactory();
   poolFacPtr->setSubscriptionEnabled(clientNotificationEnabled);
@@ -699,8 +708,10 @@ RegionPtr CacheHelper::createPooledRegionConcurrencyCheckDisabled(
 }
 
 RegionPtr CacheHelper::createRegionDiscOverFlow(
-    const char* name, bool caching, bool clientNotificationEnabled, int ettl,
-    int eit, int rttl, int rit, int lel, ExpirationAction::Action action) {
+    const char* name, bool caching, bool clientNotificationEnabled,
+    const std::chrono::seconds& ettl, const std::chrono::seconds& eit,
+    const std::chrono::seconds& rttl, const std::chrono::seconds& rit, int lel,
+    ExpirationAction::Action action) {
   AttributesFactory af;
   af.setCachingEnabled(caching);
   af.setLruEntriesLimit(lel);
@@ -730,9 +741,10 @@ RegionPtr CacheHelper::createRegionDiscOverFlow(
 
 RegionPtr CacheHelper::createPooledRegionDiscOverFlow(
     const char* name, bool ack, const char* locators, const char* poolName,
-    bool caching, bool clientNotificationEnabled, int ettl, int eit, int rttl,
-    int rit, int lel, const CacheListenerPtr& cacheListener,
-    ExpirationAction::Action action) {
+    bool caching, bool clientNotificationEnabled,
+    const std::chrono::seconds& ettl, const std::chrono::seconds& eit,
+    const std::chrono::seconds& rttl, const std::chrono::seconds& rit, int lel,
+    const CacheListenerPtr& cacheListener, ExpirationAction::Action action) {
   PoolFactoryPtr poolFacPtr = getCache()->getPoolManager().createFactory();
   poolFacPtr->setSubscriptionEnabled(clientNotificationEnabled);
 
@@ -785,9 +797,10 @@ RegionPtr CacheHelper::createPooledRegionDiscOverFlow(
 
 RegionPtr CacheHelper::createPooledRegionSticky(
     const char* name, bool ack, const char* locators, const char* poolName,
-    bool caching, bool clientNotificationEnabled, int ettl, int eit, int rttl,
-    int rit, int lel, const CacheListenerPtr& cacheListener,
-    ExpirationAction::Action action) {
+    bool caching, bool clientNotificationEnabled,
+    const std::chrono::seconds& ettl, const std::chrono::seconds& eit,
+    const std::chrono::seconds& rttl, const std::chrono::seconds& rit, int lel,
+    const CacheListenerPtr& cacheListener, ExpirationAction::Action action) {
   PoolFactoryPtr poolFacPtr = getCache()->getPoolManager().createFactory();
   poolFacPtr->setSubscriptionEnabled(clientNotificationEnabled);
   poolFacPtr->setThreadLocalConnections(true);
@@ -825,9 +838,10 @@ RegionPtr CacheHelper::createPooledRegionSticky(
 
 RegionPtr CacheHelper::createPooledRegionStickySingleHop(
     const char* name, bool ack, const char* locators, const char* poolName,
-    bool caching, bool clientNotificationEnabled, int ettl, int eit, int rttl,
-    int rit, int lel, const CacheListenerPtr& cacheListener,
-    ExpirationAction::Action action) {
+    bool caching, bool clientNotificationEnabled,
+    const std::chrono::seconds& ettl, const std::chrono::seconds& eit,
+    const std::chrono::seconds& rttl, const std::chrono::seconds& rit, int lel,
+    const CacheListenerPtr& cacheListener, ExpirationAction::Action action) {
   LOG("createPooledRegionStickySingleHop");
   PoolFactoryPtr poolFacPtr = getCache()->getPoolManager().createFactory();
   poolFacPtr->setSubscriptionEnabled(clientNotificationEnabled);
@@ -893,10 +907,14 @@ void CacheHelper::showKeys(VectorOfCacheableKey& vecKeys) {
 
 void CacheHelper::showRegionAttributes(RegionAttributes& attributes) {
   printf("caching=%s\n", attributes.getCachingEnabled() ? "true" : "false");
-  printf("Entry Time To Live = %d\n", attributes.getEntryTimeToLive());
-  printf("Entry Idle Timeout = %d\n", attributes.getEntryIdleTimeout());
-  printf("Region Time To Live = %d\n", attributes.getRegionTimeToLive());
-  printf("Region Idle Timeout = %d\n", attributes.getRegionIdleTimeout());
+  printf("Entry Time To Live = %s\n",
+         to_string(attributes.getEntryTimeToLive()).c_str());
+  printf("Entry Idle Timeout = %s\n",
+         to_string(attributes.getEntryIdleTimeout()).c_str());
+  printf("Region Time To Live = %s\n",
+         to_string(attributes.getRegionTimeToLive()).c_str());
+  printf("Region Idle Timeout = %s\n",
+         to_string(attributes.getRegionIdleTimeout()).c_str());
   printf("Initial Capacity = %d\n", attributes.getInitialCapacity());
   printf("Load Factor = %f\n", attributes.getLoadFactor());
   printf("End Points = %s\n",
@@ -1618,8 +1636,8 @@ void CacheHelper::terminate_process_file(
             std::chrono::system_clock::now() - start);
         LOG("CacheHelper::terminate_process_file: process exited. "
             "pidFileName=" +
-            pidFileName + ", pid=" + pid +
-            ", elapsed=" + std::to_string(elapsed.count()) + "ms");
+            pidFileName + ", pid=" + pid + ", elapsed=" +
+            std::to_string(elapsed.count()) + "ms");
         return;
       }
       std::this_thread::yield();
diff --git a/cppcache/integration-test/CacheHelper.hpp b/cppcache/integration-test/CacheHelper.hpp
index ab024d37..556a44e6 100644
--- a/cppcache/integration-test/CacheHelper.hpp
+++ b/cppcache/integration-test/CacheHelper.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_INTEGRATION_TEST_CACHEHELPER_H_
-#define GEODE_INTEGRATION_TEST_CACHEHELPER_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,19 +15,27 @@
  * limitations under the License.
  */
 
-#include <geode/GeodeCppCache.hpp>
+#pragma once
+
+#ifndef GEODE_INTEGRATION_TEST_CACHEHELPER_H_
+#define GEODE_INTEGRATION_TEST_CACHEHELPER_H_
+
+#include <list>
+#include <chrono>
 #include <cstdlib>
-#include <geode/SystemProperties.hpp>
+
 #include <ace/OS.h>
 #include <ace/INET_Addr.h>
 #include <ace/SOCK_Acceptor.h>
 
+#include <geode/GeodeCppCache.hpp>
+#include <geode/SystemProperties.hpp>
+#include <geode/PoolManager.hpp>
+
 #include "TimeBomb.hpp"
-#include <list>
-#include <chrono>
 #include "DistributedSystemImpl.hpp"
 #include "Utils.hpp"
-#include <geode/PoolManager.hpp>
+
 #ifndef ROOT_NAME
 #define ROOT_NAME "Root"
 #endif
@@ -120,16 +123,20 @@ class CacheHelper {
                          int32_t tombstonetimeout = -1);
 
   RegionPtr createRegion(
-      const char* name, bool ack, bool caching = true, int ettl = 0,
-      int eit = 0, int rttl = 0, int rit = 0, int lel = 0,
-      ExpirationAction::Action action = ExpirationAction::DESTROY,
+      const char* name, bool ack, bool caching = true,
+      const std::chrono::seconds& ettl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& eit = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rttl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rit = std::chrono::seconds::zero(),
+      int lel = 0, ExpirationAction::Action action = ExpirationAction::DESTROY,
       const char* endpoints = 0, bool clientNotificationEnabled = false);
 
   PoolPtr createPool(const char* poolName, const char* locators,
                      const char* serverGroup, int redundancy = 0,
                      bool clientNotification = false,
-                     int subscriptionAckInterval = -1, int connections = -1,
-                     int loadConditioningInterval = -1,
+                     std::chrono::milliseconds subscriptionAckInterval =
+                         std::chrono::milliseconds::zero(),
+                     int connections = -1, int loadConditioningInterval = -1,
                      bool isMultiuserMode = false);
 
   // this will create pool even endpoints and locatorhost has been not defined
@@ -140,24 +147,31 @@ class CacheHelper {
 
   void logPoolAttributes(PoolPtr& pool);
 
-  void createPoolWithLocators(const char* name, const char* locators = nullptr,
-                              bool clientNotificationEnabled = false,
-                              int subscriptionRedundancy = -1,
-                              int subscriptionAckInterval = -1,
-                              int connections = -1,
-                              bool isMultiuserMode = false,
-                              const char* serverGroup = nullptr);
+  void createPoolWithLocators(
+      const char* name, const char* locators = nullptr,
+      bool clientNotificationEnabled = false, int subscriptionRedundancy = -1,
+      std::chrono::milliseconds subscriptionAckInterval =
+          std::chrono::milliseconds::zero(),
+      int connections = -1, bool isMultiuserMode = false,
+      const char* serverGroup = nullptr);
 
   RegionPtr createRegionAndAttachPool(
       const char* name, bool ack, const char* poolName = nullptr,
-      bool caching = true, int ettl = 0, int eit = 0, int rttl = 0, int rit = 0,
+      bool caching = true,
+      const std::chrono::seconds& ettl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& eit = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rttl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rit = std::chrono::seconds::zero(),
       int lel = 0, ExpirationAction::Action action = ExpirationAction::DESTROY);
 
   RegionPtr createRegionAndAttachPool2(
       const char* name, bool ack, const char* poolName,
       const PartitionResolverPtr& aResolver = nullptr, bool caching = true,
-      int ettl = 0, int eit = 0, int rttl = 0, int rit = 0, int lel = 0,
-      ExpirationAction::Action action = ExpirationAction::DESTROY);
+      const std::chrono::seconds& ettl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& eit = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rttl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rit = std::chrono::seconds::zero(),
+      int lel = 0, ExpirationAction::Action action = ExpirationAction::DESTROY);
 
   void addServerLocatorEPs(const char* epList, PoolFactoryPtr pfPtr,
                            bool poolLocators = true);
@@ -168,48 +182,66 @@ class CacheHelper {
   RegionPtr createPooledRegion(
       const char* name, bool ack, const char* locators = 0,
       const char* poolName = "__TEST_POOL1__", bool caching = true,
-      bool clientNotificationEnabled = false, int ettl = 0, int eit = 0,
-      int rttl = 0, int rit = 0, int lel = 0,
-      const CacheListenerPtr& cacheListener = nullptr,
+      bool clientNotificationEnabled = false,
+      const std::chrono::seconds& ettl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& eit = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rttl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rit = std::chrono::seconds::zero(),
+      int lel = 0, const CacheListenerPtr& cacheListener = nullptr,
       ExpirationAction::Action action = ExpirationAction::DESTROY);
 
   RegionPtr createPooledRegionConcurrencyCheckDisabled(
       const char* name, bool ack, const char* locators = 0,
       const char* poolName = "__TEST_POOL1__", bool caching = true,
       bool clientNotificationEnabled = false,
-      bool concurrencyCheckEnabled = true, int ettl = 0, int eit = 0,
-      int rttl = 0, int rit = 0, int lel = 0,
-      const CacheListenerPtr& cacheListener = nullptr,
+      bool concurrencyCheckEnabled = true,
+      const std::chrono::seconds& ettl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& eit = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rttl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rit = std::chrono::seconds::zero(),
+      int lel = 0, const CacheListenerPtr& cacheListener = nullptr,
       ExpirationAction::Action action = ExpirationAction::DESTROY);
 
   RegionPtr createRegionDiscOverFlow(
       const char* name, bool caching = true,
-      bool clientNotificationEnabled = false, int ettl = 0, int eit = 0,
-      int rttl = 0, int rit = 0, int lel = 0,
-      ExpirationAction::Action action = ExpirationAction::DESTROY);
+      bool clientNotificationEnabled = false,
+      const std::chrono::seconds& ettl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& eit = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rttl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rit = std::chrono::seconds::zero(),
+      int lel = 0, ExpirationAction::Action action = ExpirationAction::DESTROY);
 
   RegionPtr createPooledRegionDiscOverFlow(
       const char* name, bool ack, const char* locators = 0,
       const char* poolName = "__TEST_POOL1__", bool caching = true,
-      bool clientNotificationEnabled = false, int ettl = 0, int eit = 0,
-      int rttl = 0, int rit = 0, int lel = 0,
-      const CacheListenerPtr& cacheListener = nullptr,
+      bool clientNotificationEnabled = false,
+      const std::chrono::seconds& ettl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& eit = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rttl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rit = std::chrono::seconds::zero(),
+      int lel = 0, const CacheListenerPtr& cacheListener = nullptr,
       ExpirationAction::Action action = ExpirationAction::DESTROY);
 
   RegionPtr createPooledRegionSticky(
       const char* name, bool ack, const char* locators = 0,
       const char* poolName = "__TEST_POOL1__", bool caching = true,
-      bool clientNotificationEnabled = false, int ettl = 0, int eit = 0,
-      int rttl = 0, int rit = 0, int lel = 0,
-      const CacheListenerPtr& cacheListener = nullptr,
+      bool clientNotificationEnabled = false,
+      const std::chrono::seconds& ettl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& eit = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rttl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rit = std::chrono::seconds::zero(),
+      int lel = 0, const CacheListenerPtr& cacheListener = nullptr,
       ExpirationAction::Action action = ExpirationAction::DESTROY);
 
   RegionPtr createPooledRegionStickySingleHop(
       const char* name, bool ack, const char* locators = 0,
       const char* poolName = "__TEST_POOL1__", bool caching = true,
-      bool clientNotificationEnabled = false, int ettl = 0, int eit = 0,
-      int rttl = 0, int rit = 0, int lel = 0,
-      const CacheListenerPtr& cacheListener = nullptr,
+      bool clientNotificationEnabled = false,
+      const std::chrono::seconds& ettl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& eit = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rttl = std::chrono::seconds::zero(),
+      const std::chrono::seconds& rit = std::chrono::seconds::zero(),
+      int lel = 0, const CacheListenerPtr& cacheListener = nullptr,
       ExpirationAction::Action action = ExpirationAction::DESTROY);
 
   RegionPtr createSubregion(RegionPtr& parent, const char* name, bool ack,
diff --git a/cppcache/integration-test/ThinClientCQ.hpp b/cppcache/integration-test/ThinClientCQ.hpp
index b0533f01..027eb1a5 100644
--- a/cppcache/integration-test/ThinClientCQ.hpp
+++ b/cppcache/integration-test/ThinClientCQ.hpp
@@ -43,8 +43,9 @@ void createRegionForCQ(const char* name, bool ackMode,
                        const CacheListenerPtr& listener = nullptr,
                        bool caching = true) {
   // Use region name as pool name to avoid recreating pools with the same name.
-  getHelper()->createPoolWithLocators(
-      name, locatorsG, clientNotificationEnabled, redundancyLevel, 1);
+  getHelper()->createPoolWithLocators(name, locatorsG,
+                                      clientNotificationEnabled,
+                                      redundancyLevel, std::chrono::seconds(1));
   createRegionAndAttachPool(name, ackMode, name, caching);
 }
 
diff --git a/cppcache/integration-test/ThinClientDistOps.hpp b/cppcache/integration-test/ThinClientDistOps.hpp
index aa97a3a9..2cdc986f 100644
--- a/cppcache/integration-test/ThinClientDistOps.hpp
+++ b/cppcache/integration-test/ThinClientDistOps.hpp
@@ -566,8 +566,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, CreatePoolForUpdateLocatorList)
     isMultiuserMode = false, int updateLocatorListInterval = 5000 )
     */
     initClient(true);
-    getHelper()->createPool("__TESTPOOL1_", locatorsG, nullptr, 0, false, -1,
-                            -1, -1, false);
+    getHelper()->createPool("__TESTPOOL1_", locatorsG, nullptr, 0, false,
+                            std::chrono::milliseconds::zero(), -1, -1, false);
     LOG("CreatePoolForUpdateLocatorList complete.");
   }
 END_TASK_DEFINITION
@@ -583,8 +583,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, CreatePoolForDontUpdateLocatorList)
     isMultiuserMode = false, int updateLocatorListInterval = 5000 )
     */
     initClient(true);
-    getHelper()->createPool("__TESTPOOL1_", locatorsG, nullptr, 0, false, -1,
-                            -1, -1, false);
+    getHelper()->createPool("__TESTPOOL1_", locatorsG, nullptr, 0, false,
+                            std::chrono::milliseconds::zero(), -1, -1, false);
     LOG("CreatePoolForDontUpdateLocatorList complete.");
   }
 END_TASK_DEFINITION
@@ -596,7 +596,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, VerifyUpdateLocatorListThread)
 
     PoolPtr pptr =
         getHelper()->getCache()->getPoolManager().find("__TESTPOOL1_");
-    int updateIntervalSeconds = pptr->getUpdateLocatorListInterval() / 1000;
+    int updateIntervalSeconds = pptr->getUpdateLocatorListInterval().count() / 1000;
 
     int numLocatorListUpdates =
         CacheHelper::getNumLocatorListUpdates("Querying locator list at:");
diff --git a/cppcache/integration-test/ThinClientDurable.hpp b/cppcache/integration-test/ThinClientDurable.hpp
index 07c0d015..cbb9f166 100644
--- a/cppcache/integration-test/ThinClientDurable.hpp
+++ b/cppcache/integration-test/ThinClientDurable.hpp
@@ -158,9 +158,9 @@ const char* testRegex[] = {"D-Key-.*", "Key-.*"};
 #include "ThinClientDurableInit.hpp"
 #include "ThinClientTasks_C2S2.hpp"
 
-void initClientCache(int durableIdx, int redundancy, int durableTimeout,
-                     OperMonitorPtr& mon1, OperMonitorPtr& mon2,
-                     int sleepDuration = 0) {
+void initClientCache(int durableIdx, int redundancy,
+                     std::chrono::seconds durableTimeout, OperMonitorPtr& mon1,
+                     OperMonitorPtr& mon2, int sleepDuration = 0) {
   // Sleep before starting , Used for Timeout testing.
   if (sleepDuration) SLEEP(sleepDuration);
 
@@ -240,7 +240,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, InitClient1Timeout300)
     if (mon2C1 == nullptr) {
       mon2C1 = std::make_shared<OperMonitor>(durableIds[0], regionNames[1]);
     }
-    initClientCache(0, 0 /* Redundancy */, 300 /* D Timeout */, mon1C1, mon2C1);
+    initClientCache(0, 0 /* Redundancy */,
+                    std::chrono::seconds(300) /* D Timeout */, mon1C1, mon2C1);
   }
 END_TASK_DEFINITION
 
@@ -252,7 +253,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, InitClient1Timeout30)
     if (mon2C1 == nullptr) {
       mon2C1 = std::make_shared<OperMonitor>(durableIds[0], regionNames[1]);
     }
-    initClientCache(0, 0 /* Redundancy */, 30 /* D Timeout */, mon1C1, mon2C1);
+    initClientCache(0, 0 /* Redundancy */,
+                    std::chrono::seconds(30) /* D Timeout */, mon1C1, mon2C1);
   }
 END_TASK_DEFINITION
 
@@ -264,7 +266,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, InitClient1DelayedStart)
     if (mon2C1 == nullptr) {
       mon2C1 = std::make_shared<OperMonitor>(durableIds[0], regionNames[1]);
     }
-    initClientCache(0, 0 /* Redundancy */, 30 /* D Timeout */, mon1C1, mon2C1,
+    initClientCache(0, 0 /* Redundancy */,
+                    std::chrono::seconds(30) /* D Timeout */, mon1C1, mon2C1,
                     35000 /* Sleep before starting */);
   }
 END_TASK_DEFINITION
@@ -277,7 +280,8 @@ DUNIT_TASK_DEFINITION(CLIENT2, InitClient2Timeout300)
     if (mon2C2 == nullptr) {
       mon2C2 = std::make_shared<OperMonitor>(durableIds[1], regionNames[1]);
     }
-    initClientCache(1, 1 /* Redundancy */, 300 /* D Timeout */, mon1C2, mon2C2);
+    initClientCache(1, 1 /* Redundancy */,
+                    std::chrono::seconds(300) /* D Timeout */, mon1C2, mon2C2);
   }
 END_TASK_DEFINITION
 
@@ -290,7 +294,8 @@ DUNIT_TASK_DEFINITION(CLIENT2, InitClient2Timeout30)
     if (mon2C2 == nullptr) {
       mon2C2 = std::make_shared<OperMonitor>(durableIds[1], regionNames[1]);
     }
-    initClientCache(1, 1 /* Redundancy */, 30 /* D Timeout */, mon1C2, mon2C2);
+    initClientCache(1, 1 /* Redundancy */,
+                    std::chrono::seconds(30) /* D Timeout */, mon1C2, mon2C2);
   }
 END_TASK_DEFINITION
 
diff --git a/cppcache/integration-test/ThinClientDurableFailover.hpp b/cppcache/integration-test/ThinClientDurableFailover.hpp
index 01cf5b9d..e91748ad 100644
--- a/cppcache/integration-test/ThinClientDurableFailover.hpp
+++ b/cppcache/integration-test/ThinClientDurableFailover.hpp
@@ -162,7 +162,8 @@ void initClientCache(int redundancy, int durableTimeout, OperMonitorPtr& mon,
   // after the secondary comes up and is able to receive the QRM
   // otherwise it will get the unacked events from GII causing the
   // client to get 2 extra / replayed events.
-  initClientAndRegion(redundancy, durableIdx, 1, 1, 300);
+  initClientAndRegion(redundancy, durableIdx, std::chrono::seconds(1),
+                      std::chrono::seconds(1), std::chrono::seconds(300));
 
   setCacheListener(regionNames[0], mon);
 
diff --git a/cppcache/integration-test/ThinClientDurableInit.hpp b/cppcache/integration-test/ThinClientDurableInit.hpp
index dd02c2d4..9f3c22af 100644
--- a/cppcache/integration-test/ThinClientDurableInit.hpp
+++ b/cppcache/integration-test/ThinClientDurableInit.hpp
@@ -35,15 +35,17 @@ static int numberOfLocators = 1;
 const char* locatorsG =
     CacheHelper::getLocatorHostPort(isLocator, isLocalServer, numberOfLocators);
 
-void initClientAndRegion(int redundancy, int ClientIdx,
-                         int subscriptionAckInterval = 1,
-                         int redundancyMonitorInterval = -1,
-                         int durableClientTimeout = 60) {
+void initClientAndRegion(
+    int redundancy, int ClientIdx,
+    std::chrono::seconds subscriptionAckInterval = std::chrono::seconds(1),
+    std::chrono::seconds redundancyMonitorInterval =
+        std::chrono::seconds::zero(),
+    std::chrono::seconds durableClientTimeout = std::chrono::seconds(60)) {
   PropertiesPtr pp = Properties::create();
   if (ClientIdx < 2) {
     pp->insert("durable-client-id", durableIds[ClientIdx]);
     pp->insert("durable-timeout", durableClientTimeout);
-    if (redundancyMonitorInterval > 0) {
+    if (redundancyMonitorInterval > std::chrono::seconds::zero()) {
       pp->insert("redundancy-monitor-interval", redundancyMonitorInterval);
     }
 
@@ -54,7 +56,7 @@ void initClientAndRegion(int redundancy, int ClientIdx,
   }
 }
 void initClientAndTwoRegions(int ClientIdx, int redundancy,
-                             int durableClientTimeout,
+                             std::chrono::seconds durableClientTimeout,
                              const char* conflation = nullptr,
                              const char* rNames[] = regionNames) {
   PropertiesPtr pp = Properties::create();
@@ -66,14 +68,13 @@ void initClientAndTwoRegions(int ClientIdx, int redundancy,
 
   initClient(true, pp);
   getHelper()->createPoolWithLocators("__TESTPOOL1_", locatorsG, true,
-                                      redundancy, 1);
+                                      redundancy, std::chrono::seconds(1));
   createRegionAndAttachPool(rNames[0], USE_ACK, "__TESTPOOL1_", true);
   createRegionAndAttachPool(rNames[1], USE_ACK, "__TESTPOOL1_", true);
 }
-void initClientAndTwoRegionsAndTwoPools(int ClientIdx, int redundancy,
-                                        int durableClientTimeout,
-                                        const char* conflation = nullptr,
-                                        const char* rNames[] = regionNames) {
+void initClientAndTwoRegionsAndTwoPools(
+    int ClientIdx, int redundancy, std::chrono::seconds durableClientTimeout,
+    const char* conflation = nullptr, const char* rNames[] = regionNames) {
   PropertiesPtr pp = Properties::create();
   pp->insert("durable-client-id", durableIds[ClientIdx]);
   pp->insert("durable-timeout", durableClientTimeout);
@@ -83,7 +84,7 @@ void initClientAndTwoRegionsAndTwoPools(int ClientIdx, int redundancy,
 
   initClient(true, pp);
   getHelper()->createPoolWithLocators("__TESTPOOL2_", locatorsG, true,
-                                      redundancy, 1);
+                                      redundancy, std::chrono::seconds(1));
   createRegionAndAttachPool(rNames[1], USE_ACK, "__TESTPOOL2_", true);
   // Calling readyForEvents() here instead of below causes duplicate durableId
   // exception reproduced.
@@ -97,7 +98,7 @@ void initClientAndTwoRegionsAndTwoPools(int ClientIdx, int redundancy,
   RegionPtr regPtr1 = getHelper()->getRegion(rNames[1]);
   regPtr1->registerAllKeys(true);
   getHelper()->createPoolWithLocators("__TESTPOOL1_", locatorsG, true,
-                                      redundancy, 1);
+                                      redundancy, std::chrono::seconds(1));
   createRegionAndAttachPool(rNames[0], USE_ACK, "__TESTPOOL1_", true);
   RegionPtr regPtr0 = getHelper()->getRegion(rNames[0]);
   regPtr0->registerAllKeys(true);
diff --git a/cppcache/integration-test/ThinClientDurableInterest.hpp b/cppcache/integration-test/ThinClientDurableInterest.hpp
index bf8d0c75..5b684cfd 100644
--- a/cppcache/integration-test/ThinClientDurableInterest.hpp
+++ b/cppcache/integration-test/ThinClientDurableInterest.hpp
@@ -152,7 +152,7 @@ void initClientWithIntrest(int ClientIdx, OperMonitorPtr& mon) {
 
 void initClientWithIntrest2(int ClientIdx, OperMonitorPtr& monitor1,
                             OperMonitorPtr& monitor2) {
-  initClientAndTwoRegionsAndTwoPools(0, ClientIdx, 60);
+  initClientAndTwoRegionsAndTwoPools(0, ClientIdx, std::chrono::seconds(60));
   if (monitor1 == nullptr) {
     monitor1 = std::make_shared<OperMonitor>(1);
   }
diff --git a/cppcache/integration-test/ThinClientDurableReconnect.hpp b/cppcache/integration-test/ThinClientDurableReconnect.hpp
index 9ec709d3..d1cbb95c 100644
--- a/cppcache/integration-test/ThinClientDurableReconnect.hpp
+++ b/cppcache/integration-test/ThinClientDurableReconnect.hpp
@@ -80,7 +80,8 @@ const char* mixKeys[] = {"D-Key-1"};
 #include "ThinClientTasks_C2S2.hpp"
 
 void initClientCache(int redundancy, OperMonitorPtr& mon) {
-  initClientAndRegion(redundancy, 0, 60000, 1, 300);
+  initClientAndRegion(redundancy, 0, std::chrono::seconds(60000),
+                      std::chrono::seconds(1), std::chrono::seconds(300));
 
   if (mon == nullptr) {
     mon = std::make_shared<OperMonitor>();
diff --git a/cppcache/integration-test/ThinClientHelper.hpp b/cppcache/integration-test/ThinClientHelper.hpp
index a52b50a1..04be7439 100644
--- a/cppcache/integration-test/ThinClientHelper.hpp
+++ b/cppcache/integration-test/ThinClientHelper.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_INTEGRATION_TEST_THINCLIENTHELPER_H_
-#define GEODE_INTEGRATION_TEST_THINCLIENTHELPER_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,6 +15,13 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_INTEGRATION_TEST_THINCLIENTHELPER_H_
+#define GEODE_INTEGRATION_TEST_THINCLIENTHELPER_H_
+
+#include <chrono>
+
 #include <geode/GeodeCppCache.hpp>
 #include <ace/OS.h>
 #include <ace/High_Res_Timer.h>
@@ -420,8 +422,9 @@ RegionPtr createPooledRegion(const char* name, bool ackMode,
 
   // ack, caching
   RegionPtr regPtr = getHelper()->createPooledRegion(
-      name, ackMode, locators, poolname, caching, clientNotificationEnabled, 0,
-      0, 0, 0, 0, listener);
+      name, ackMode, locators, poolname, caching, clientNotificationEnabled,
+      std::chrono::seconds(0), std::chrono::seconds(0), std::chrono::seconds(0),
+      std::chrono::seconds(0), 0, listener);
 
   ASSERT(regPtr != nullptr, "Failed to create region.");
   LOG("Region created.");
@@ -437,8 +440,9 @@ PoolPtr findPool(const char* poolName) {
 PoolPtr createPool(const char* poolName, const char* locators,
                    const char* serverGroup, int redundancy = 0,
                    bool clientNotification = false,
-                   int subscriptionAckInterval = -1, int connections = -1,
-                   int loadConditioningInterval = -1) {
+                   std::chrono::milliseconds subscriptionAckInterval =
+                       std::chrono::milliseconds::zero(),
+                   int connections = -1, int loadConditioningInterval = -1) {
   LOG("createPool() entered.");
 
   PoolPtr poolPtr = getHelper()->createPool(
@@ -452,7 +456,8 @@ PoolPtr createPool(const char* poolName, const char* locators,
 PoolPtr createPoolAndDestroy(const char* poolName, const char* locators,
                              const char* serverGroup, int redundancy = 0,
                              bool clientNotification = false,
-                             int subscriptionAckInterval = -1,
+                             std::chrono::milliseconds subscriptionAckInterval =
+                                 std::chrono::milliseconds::zero(),
                              int connections = -1) {
   LOG("createPoolAndDestroy() entered.");
 
@@ -479,7 +484,10 @@ PoolPtr createPool2(const char* poolName, const char* locators,
 
 RegionPtr createRegionAndAttachPool(
     const char* name, bool ack, const char* poolName, bool caching = true,
-    int ettl = 0, int eit = 0, int rttl = 0, int rit = 0, int lel = 0,
+    const std::chrono::seconds& ettl = std::chrono::seconds::zero(),
+    const std::chrono::seconds& eit = std::chrono::seconds::zero(),
+    const std::chrono::seconds& rttl = std::chrono::seconds::zero(),
+    const std::chrono::seconds& rit = std::chrono::seconds::zero(), int lel = 0,
     ExpirationAction::Action action = ExpirationAction::DESTROY) {
   LOG("createRegionAndAttachPool() entered.");
   RegionPtr regPtr = getHelper()->createRegionAndAttachPool(
diff --git a/cppcache/integration-test/ThinClientPutAll.hpp b/cppcache/integration-test/ThinClientPutAll.hpp
index 5802092d..fd986c01 100644
--- a/cppcache/integration-test/ThinClientPutAll.hpp
+++ b/cppcache/integration-test/ThinClientPutAll.hpp
@@ -566,9 +566,9 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepEight)
       sprintf(val0, "%1000d", i);
       map0.emplace(CacheableKey::create(key0), CacheableString::create(val0));
     }
-    RegionPtr regPtr0 = getHelper()->getRegion(regionNames[0]);
+    auto regPtr0 = getHelper()->getRegion(regionNames[0]);
 
-    regPtr0->putAll(map0, 40000);
+    regPtr0->putAll(map0, std::chrono::seconds(40000));
 
     LOG("StepEight complete.");
     dunit::sleep(10000);
@@ -700,7 +700,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepThirteen)
     try {
       map0.emplace(CacheableInt64::create(345),
                    CacheableInt64::create(3465987));
-      regPtr0->putAll(map0, -1);
+      regPtr0->putAll(map0, std::chrono::seconds(-1));
       auto checkPtr = std::dynamic_pointer_cast<CacheableInt64>(
           regPtr0->get(CacheableInt64::create(345)));
       ASSERT(checkPtr->value() == 3465987,
@@ -718,7 +718,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepThirteen)
     try {
       map0.emplace(CacheableInt64::create(3451),
                    CacheableInt64::create(3465987));
-      regPtr0->putAll(map0, 2147500);
+      regPtr0->putAll(map0, std::chrono::seconds(2147500));
       auto checkPtr = std::dynamic_pointer_cast<CacheableInt64>(
           regPtr0->get(CacheableInt64::create(3451)));
       ASSERT(checkPtr->value() == 3465987,
diff --git a/cppcache/integration-test/ThinClientPutAllTimeout.hpp b/cppcache/integration-test/ThinClientPutAllTimeout.hpp
index 71c07ba9..191a814e 100644
--- a/cppcache/integration-test/ThinClientPutAllTimeout.hpp
+++ b/cppcache/integration-test/ThinClientPutAllTimeout.hpp
@@ -99,7 +99,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, SetupClient1_Pool_Locator)
   }
 END_TASK_DEFINITION
 
-void putAllWithOneEntryTimeout(int timeout, int waitTimeOnServer) {
+void putAllWithOneEntryTimeout(std::chrono::milliseconds timeout,
+                               std::chrono::milliseconds waitTimeOnServer) {
   LOG("Do large PutAll");
   HashMapOfCacheable map0;
   map0.clear();
@@ -112,18 +113,18 @@ void putAllWithOneEntryTimeout(int timeout, int waitTimeOnServer) {
     map0.emplace(CacheableKey::create(key0), CacheableString::create(val0));
   }
 
-  char val[16];
-  sprintf(val, "%d", waitTimeOnServer);
   map0.emplace(CacheableKey::create("timeout-this-entry"),
-               CacheableString::create(val));
+               CacheableString::create(
+                   std::to_string(waitTimeOnServer.count()).c_str()));
 
-  RegionPtr regPtr0 = getHelper()->getRegion(regionNames[0]);
+  auto regPtr0 = getHelper()->getRegion(regionNames[0]);
 
   regPtr0->putAll(map0, timeout);
 }
 
-void putAllWithOneEntryTimeoutWithCallBackArg(int timeout,
-                                              int waitTimeOnServer) {
+void putAllWithOneEntryTimeoutWithCallBackArg(
+    std::chrono::milliseconds timeout,
+    std::chrono::milliseconds waitTimeOnServer) {
   LOG("Do large PutAll putAllWithOneEntryTimeoutWithCallBackArg");
   HashMapOfCacheable map0;
   map0.clear();
@@ -136,12 +137,11 @@ void putAllWithOneEntryTimeoutWithCallBackArg(int timeout,
     map0.emplace(CacheableKey::create(key0), CacheableString::create(val0));
   }
 
-  char val[16];
-  sprintf(val, "%d", waitTimeOnServer);
   map0.emplace(CacheableKey::create("timeout-this-entry"),
-               CacheableString::create(val));
+               CacheableString::create(
+                   std::to_string(waitTimeOnServer.count()).c_str()));
 
-  RegionPtr regPtr0 = getHelper()->getRegion(regionNames[0]);
+  auto regPtr0 = getHelper()->getRegion(regionNames[0]);
 
   regPtr0->putAll(map0, timeout, CacheableInt32::create(1000));
   LOG("Do large PutAll putAllWithOneEntryTimeoutWithCallBackArg complete. ");
@@ -155,7 +155,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, testTimeoutException)
     regPtr->registerAllKeys();
 
     try {
-      putAllWithOneEntryTimeout(20, 30000);
+      putAllWithOneEntryTimeout(std::chrono::seconds(20),
+                                std::chrono::seconds(40));
       FAIL("Didnt get expected timeout exception for putAll");
     } catch (const TimeoutException& excp) {
       std::string logmsg = "";
@@ -168,7 +169,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, testTimeoutException)
     dunit::sleep(30000);
 
     try {
-      putAllWithOneEntryTimeoutWithCallBackArg(20, 30000);
+      putAllWithOneEntryTimeoutWithCallBackArg(std::chrono::seconds(20),
+                                               std::chrono::seconds(40));
       FAIL("Didnt get expected timeout exception for putAllwithCallBackArg");
     } catch (const TimeoutException& excp) {
       std::string logmsg = "";
@@ -192,7 +194,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, testWithoutTimeoutException)
     // regPtr->registerAllKeys();
 
     try {
-      putAllWithOneEntryTimeout(40, 20000);
+      putAllWithOneEntryTimeout(std::chrono::seconds(40),
+                                std::chrono::seconds(20));
       LOG("testWithoutTimeoutException completed");
       return;
     } catch (const TimeoutException& excp) {
@@ -213,7 +216,8 @@ END_TASK_DEFINITION
 DUNIT_TASK_DEFINITION(CLIENT1, testWithoutTimeoutWithCallBackArgException)
   {
     try {
-      putAllWithOneEntryTimeoutWithCallBackArg(40, 20000);
+      putAllWithOneEntryTimeoutWithCallBackArg(std::chrono::seconds(40),
+                                               std::chrono::seconds(20));
       LOG("testWithoutTimeoutException completed");
       return;
     } catch (const TimeoutException& excp) {
diff --git a/cppcache/integration-test/ThinClientPutAllWithCallBack.hpp b/cppcache/integration-test/ThinClientPutAllWithCallBack.hpp
index 767ae64d..5688b871 100644
--- a/cppcache/integration-test/ThinClientPutAllWithCallBack.hpp
+++ b/cppcache/integration-test/ThinClientPutAllWithCallBack.hpp
@@ -462,8 +462,10 @@ DUNIT_TASK_DEFINITION(CLIENT2, RegisterClient2Keys)
     }
     RegionPtr regPtr0 = getHelper()->getRegion(regionNames[0]);
     RegionPtr regPtr1 = getHelper()->getRegion(regionNames[1]);
-    regPtr0->putAll(map0, 15, CacheableInt32::create(1000));
-    regPtr1->putAll(map1, 15, CacheableInt32::create(1000));
+    regPtr0->putAll(map0, std::chrono::seconds(15),
+                    CacheableInt32::create(1000));
+    regPtr1->putAll(map1, std::chrono::seconds(15),
+                    CacheableInt32::create(1000));
     LOG("RegisterClient2Keys complete.");
   }
 END_TASK_DEFINITION
@@ -482,7 +484,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, PutAllOps)
     }
 
     RegionPtr regPtr0 = getHelper()->getRegion(regionNames[0]);
-    regPtr0->putAll(entryMap, 15, CacheableInt32::create(1000));
+    regPtr0->putAll(entryMap, std::chrono::seconds(15),
+                    CacheableInt32::create(1000));
 
     LOG("putAll1 complete");
 
@@ -535,10 +538,12 @@ DUNIT_TASK_DEFINITION(CLIENT2, TriggerAfterUpdateEvents)
       map1.emplace(CacheableKey::create(keys[i]),
                    CacheableString::create(nvals[i]));
     }
-    RegionPtr regPtr0 = getHelper()->getRegion(regionNames[0]);
-    RegionPtr regPtr1 = getHelper()->getRegion(regionNames[1]);
-    regPtr0->putAll(map0, 15, CacheableInt32::create(1000));
-    regPtr1->putAll(map1, 15, CacheableInt32::create(1000));
+    auto regPtr0 = getHelper()->getRegion(regionNames[0]);
+    auto regPtr1 = getHelper()->getRegion(regionNames[1]);
+    regPtr0->putAll(map0, std::chrono::seconds(15),
+                    CacheableInt32::create(1000));
+    regPtr1->putAll(map1, std::chrono::seconds(15),
+                    CacheableInt32::create(1000));
 
     // register all keys for the large putall test case
     regPtr0->registerAllKeys();
@@ -570,9 +575,10 @@ DUNIT_TASK_DEFINITION(CLIENT1, ExecuteLargePutAll)
       sprintf(val0, "%1000d", i);
       map0.emplace(CacheableKey::create(key0), CacheableString::create(val0));
     }
-    RegionPtr regPtr0 = getHelper()->getRegion(regionNames[0]);
+    auto regPtr0 = getHelper()->getRegion(regionNames[0]);
 
-    regPtr0->putAll(map0, 40000, CacheableInt32::create(1000));
+    regPtr0->putAll(map0, std::chrono::seconds(40000),
+                    CacheableInt32::create(1000));
 
     LOG("ExecuteLargePutAll complete.");
     dunit::sleep(10000);
@@ -637,12 +643,13 @@ END_TASK_DEFINITION
 
 DUNIT_TASK_DEFINITION(CLIENT1, VerifyPutAllWithLongKeyAndStringValue)
   {
-    RegionPtr regPtr0 = getHelper()->getRegion(regionNames[0]);
+    auto regPtr0 = getHelper()->getRegion(regionNames[0]);
     HashMapOfCacheable map0;
     for (int i = 0; i < 2; i++) {
       map0.emplace(CacheableInt64::create(i), CacheableInt64::create(i));
     }
-    regPtr0->putAll(map0, 15, CacheableInt32::create(1000));
+    regPtr0->putAll(map0, std::chrono::seconds(15),
+                    CacheableInt32::create(1000));
     for (int i = 0; i < 2; i++) {
       auto checkPtr = std::dynamic_pointer_cast<CacheableInt64>(
           regPtr0->get(CacheableInt64::create(i)));
@@ -656,7 +663,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, VerifyPutAllWithLongKeyAndStringValue)
       map0.emplace(CacheableInt64::create(i),
                    CacheableString::create(vals[i - 80]));
     }
-    regPtr0->putAll(map0, 15, CacheableInt32::create(1000));
+    regPtr0->putAll(map0, std::chrono::seconds(15),
+                    CacheableInt32::create(1000));
     for (int i = 80; i < 82; i++) {
       auto checkPtr = std::dynamic_pointer_cast<CacheableString>(
           regPtr0->get(CacheableInt64::create(i)));
@@ -675,7 +683,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, VerifyPutAllWithLongKeyAndLongValue)
     try {
       map0.emplace(CacheableInt64::create(345),
                    CacheableInt64::create(3465987));
-      regPtr0->putAll(map0, -1, CacheableInt32::create(1000));
+      regPtr0->putAll(map0, std::chrono::seconds(-1),
+                      CacheableInt32::create(1000));
       auto checkPtr = std::dynamic_pointer_cast<CacheableInt64>(
           regPtr0->get(CacheableInt64::create(345)));
       ASSERT(checkPtr->value() == 3465987,
@@ -693,7 +702,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, VerifyPutAllWithLongKeyAndLongValue)
     try {
       map0.emplace(CacheableInt64::create(3451),
                    CacheableInt64::create(3465987));
-      regPtr0->putAll(map0, 2147500, CacheableInt32::create(1000));
+      regPtr0->putAll(map0, std::chrono::seconds(2147500),
+                      CacheableInt32::create(1000));
       auto checkPtr = std::dynamic_pointer_cast<CacheableInt64>(
           regPtr0->get(CacheableInt64::create(3451)));
       ASSERT(checkPtr->value() == 3465987,
@@ -713,11 +723,12 @@ END_TASK_DEFINITION
 
 DUNIT_TASK_DEFINITION(CLIENT1, VerifyPutAllWithObjectKey)
   {
-    RegionPtr regPtr0 = getHelper()->getRegion(regionNames[0]);
+    auto regPtr0 = getHelper()->getRegion(regionNames[0]);
     HashMapOfCacheable map0;
     auto val111 = std::make_shared<PdxTests::PdxTypes1>();
     map0.emplace(CacheableInt32::create(1211), val111);
-    regPtr0->putAll(map0, 15, CacheableInt32::create(1000));
+    regPtr0->putAll(map0, std::chrono::seconds(15),
+                    CacheableInt32::create(1000));
     auto retObj = std::dynamic_pointer_cast<PdxTests::PdxTypes1>(
         regPtr0->get(CacheableInt32::create(1211)));
     ASSERT(val111->equals(retObj) == true, "val111 and retObj should match.");
@@ -725,16 +736,18 @@ DUNIT_TASK_DEFINITION(CLIENT1, VerifyPutAllWithObjectKey)
 
     auto keyObject = std::make_shared<PdxTests::PdxType>();
     map0.emplace(keyObject, CacheableInt32::create(111));
-    regPtr0->putAll(map0, 15, CacheableInt32::create(1000));
-    CacheableInt32Ptr checkPtr =
+    regPtr0->putAll(map0, std::chrono::seconds(15),
+                    CacheableInt32::create(1000));
+    auto checkPtr =
         std::dynamic_pointer_cast<CacheableInt32>(regPtr0->get(keyObject));
     ASSERT(checkPtr->value() == 111,
            "putAll with entry as object key and value as int  Mismatch");
     map0.clear();
     auto keyObject6 = std::make_shared<PdxTests::PdxTypes3>();
     map0.emplace(keyObject6, CacheableString::create("testString"));
-    regPtr0->putAll(map0, 15, CacheableInt32::create(1000));
-    CacheablePtr checkPtr1 = regPtr0->get(keyObject6);
+    regPtr0->putAll(map0, std::chrono::seconds(15),
+                    CacheableInt32::create(1000));
+    auto checkPtr1 = regPtr0->get(keyObject6);
     ASSERT(strcmp(checkPtr1->toString()->asChar(), "testString") == 0,
            "strVal should be testString.");
     map0.clear();
@@ -745,7 +758,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, VerifyPutAllWithObjectKey)
     auto valObject2 = std::make_shared<PdxTests::PdxTypes1>();
     map0.emplace(keyObject7, valObject);
     map0.emplace(keyObject8, valObject2);
-    regPtr0->putAll(map0, 15, CacheableInt32::create(1000));
+    regPtr0->putAll(map0, std::chrono::seconds(15),
+                    CacheableInt32::create(1000));
     auto objVal = std::dynamic_pointer_cast<PdxTests::PdxTypes1>(
         regPtr0->get(keyObject7));
     ASSERT(valObject == objVal, "valObject and objVal should match.");
@@ -760,7 +774,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, VerifyPutAllWithObjectKey)
       char buf[2048];
       for (const auto& iter : values) {
         auto key = std::dynamic_pointer_cast<CacheableKey>(iter.first);
-        CacheablePtr mVal = iter.second;
+        auto mVal = iter.second;
         if (mVal != nullptr) {
           auto val1 = std::dynamic_pointer_cast<PdxTests::PdxTypes1>(mVal);
           sprintf(buf, "value from map %d , expected value %d ",
diff --git a/cppcache/integration-test/ThinClientPutGetAll.hpp b/cppcache/integration-test/ThinClientPutGetAll.hpp
index 16f222cf..c1666b2e 100644
--- a/cppcache/integration-test/ThinClientPutGetAll.hpp
+++ b/cppcache/integration-test/ThinClientPutGetAll.hpp
@@ -312,7 +312,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, putallAndGetallPdxWithCallBackArg)
 
     RegionPtr regPtr0 = getHelper()->getRegion(_regionNames[0]);
     // TODO: Investigate whether callback is used
-    regPtr0->putAll(map0, 15, CacheableInt32::create(1001));
+    regPtr0->putAll(map0, std::chrono::seconds(15),
+                    CacheableInt32::create(1001));
     LOG("putallPdxWithCallBackArg on Pdx objects completed.");
 
     regPtr0->localDestroy(CacheableInt32::create(21));
diff --git a/cppcache/integration-test/ThinClientSecurity.hpp b/cppcache/integration-test/ThinClientSecurity.hpp
index 63a7cc5f..64cfc5b5 100644
--- a/cppcache/integration-test/ThinClientSecurity.hpp
+++ b/cppcache/integration-test/ThinClientSecurity.hpp
@@ -65,7 +65,7 @@ void createRegionForSecurity(const char* name, bool ackMode,
   printf("createRegionForSecurity poolname = %s \n", poolName);
   getHelper()->createPoolWithLocators(
       poolName, locatorsG, clientNotificationEnabled, subscriptionRedundancy,
-      -1, connections, isMultiuserMode);
+      std::chrono::milliseconds::zero(), connections, isMultiuserMode);
   createRegionAndAttachPool(name, ackMode, poolName, caching);
   setCacheListener(name, listener);
 }
diff --git a/cppcache/integration-test/ThinClientTransactions.hpp b/cppcache/integration-test/ThinClientTransactions.hpp
index 593a5589..82562dfb 100644
--- a/cppcache/integration-test/ThinClientTransactions.hpp
+++ b/cppcache/integration-test/ThinClientTransactions.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_INTEGRATION_TEST_THINCLIENTTRANSACTIONS_H_
-#define GEODE_INTEGRATION_TEST_THINCLIENTTRANSACTIONS_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,6 +15,11 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_INTEGRATION_TEST_THINCLIENTTRANSACTIONS_H_
+#define GEODE_INTEGRATION_TEST_THINCLIENTTRANSACTIONS_H_
+
 #include "fw_dunit.hpp"
 #include <geode/GeodeCppCache.hpp>
 #include <ace/Auto_Event.h>
@@ -66,7 +66,7 @@ void initClient(const bool isthinClient) {
     if (g_isGridClient) {
       config->insert("grid-client", "true");
     }
-    config->insert("suspended-tx-timeout", "1");
+    config->insert("suspended-tx-timeout", std::chrono::minutes(1));
     cacheHelper = new CacheHelper(isthinClient, config);
   }
   ASSERT(cacheHelper, "Failed to create a CacheHelper client instance.");
@@ -498,7 +498,7 @@ class ResumeTransactionThread : public ACE_Task_Base {
 
     if (m_tryResumeWithSleep) {
       m_txEvent->signal();
-      txManager->tryResume(m_suspendedTransaction, 30000);
+      txManager->tryResume(m_suspendedTransaction, std::chrono::seconds(30));
     } else {
       txManager->resume(m_suspendedTransaction);
     }
diff --git a/cppcache/integration-test/ThinClientTransactionsXA.hpp b/cppcache/integration-test/ThinClientTransactionsXA.hpp
index 77415560..05fe9904 100644
--- a/cppcache/integration-test/ThinClientTransactionsXA.hpp
+++ b/cppcache/integration-test/ThinClientTransactionsXA.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_INTEGRATION_TEST_THINCLIENTTRANSACTIONSXA_H_
-#define GEODE_INTEGRATION_TEST_THINCLIENTTRANSACTIONSXA_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,6 +15,11 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_INTEGRATION_TEST_THINCLIENTTRANSACTIONSXA_H_
+#define GEODE_INTEGRATION_TEST_THINCLIENTTRANSACTIONSXA_H_
+
 #include "fw_dunit.hpp"
 #include <geode/GeodeCppCache.hpp>
 #include <ace/Auto_Event.h>
@@ -65,7 +65,7 @@ void initClient(const bool isthinClient) {
     if (g_isGridClient) {
       config->insert("grid-client", "true");
     }
-    config->insert("suspended-tx-timeout", "1");
+    config->insert("suspended-tx-timeout", std::chrono::seconds(1));
     cacheHelper = new CacheHelper(isthinClient, config);
   }
   ASSERT(cacheHelper, "Failed to create a CacheHelper client instance.");
@@ -499,7 +499,7 @@ class ResumeTransactionThread : public ACE_Task_Base {
 
     if (m_tryResumeWithSleep) {
       m_txEvent->signal();
-      txManager->tryResume(m_suspendedTransaction, 30000);
+      txManager->tryResume(m_suspendedTransaction, std::chrono::seconds(30));
     } else {
       txManager->resume(m_suspendedTransaction);
     }
diff --git a/cppcache/integration-test/ThinClientVersionedOps.hpp b/cppcache/integration-test/ThinClientVersionedOps.hpp
index 8bd6899c..9319c7c8 100644
--- a/cppcache/integration-test/ThinClientVersionedOps.hpp
+++ b/cppcache/integration-test/ThinClientVersionedOps.hpp
@@ -143,7 +143,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, StartClient1)
 
     initClient(true);
     getHelper()->createPoolWithLocators("__TEST_POOL1__", locatorsG, true, -1,
-                                        -1, -1, false, group1);
+                                        std::chrono::milliseconds::zero(), -1,
+                                        false, group1);
     RegionPtr regPtr0 = getHelper()->createRegionAndAttachPool(
         regNames[0], USE_ACK, "__TEST_POOL1__", true);
     LOG("StepOne_Pooled_Locator1 complete.");
@@ -176,7 +177,8 @@ DUNIT_TASK_DEFINITION(CLIENT2, StartClient2)
     */
     initClient(true);
     getHelper()->createPoolWithLocators("__TEST_POOL1__", locatorsG, true, -1,
-                                        -1, -1, false, group2);
+                                        std::chrono::milliseconds::zero(), -1,
+                                        false, group2);
     RegionPtr regPtr0 = getHelper()->createRegionAndAttachPool(
         regNames[0], USE_ACK, "__TEST_POOL1__", true);
     LOG("StepOne_Pooled_Locator1 complete.");
diff --git a/cppcache/integration-test/system.properties b/cppcache/integration-test/system.properties
index b7b62dc4..50425b68 100644
--- a/cppcache/integration-test/system.properties
+++ b/cppcache/integration-test/system.properties
@@ -13,7 +13,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 # All the configurable parameters.
-statistic-sample-rate=700
+statistic-sample-rate=700s
 statistic-sampling-enabled=false
 statistic-archive-file=stats.gfs
 log-file=gfcpp.log
@@ -24,13 +24,13 @@ log-file-size-limit=1024000000
 archive-file-size-limit=1024000000
 heap-lru-limit=100
 heap-lru-delta=10
-notify-ack-interval=1234
-notify-dupcheck-life=4321
-ping-interval=123
-redundancy-monitor-interval=456
+notify-ack-interval=1234ms
+notify-dupcheck-life=4321ms
+ping-interval=123s
+redundancy-monitor-interval=456s
 durable-client-id=testDurableId
-durable-timeout=123
-connect-timeout=345
+durable-timeout=123s
+connect-timeout=345ms
 security-username=username
 security-password=password
 max-fe-threads=96
diff --git a/cppcache/integration-test/testAttributesMutator.cpp b/cppcache/integration-test/testAttributesMutator.cpp
index 208fd809..e93a791e 100644
--- a/cppcache/integration-test/testAttributesMutator.cpp
+++ b/cppcache/integration-test/testAttributesMutator.cpp
@@ -42,7 +42,8 @@ DUNIT_TASK(A, Init)
     Test.m_cache = cacheFactoryPtr->create();
 
     AttributesFactory af;
-    af.setEntryTimeToLive(ExpirationAction::LOCAL_INVALIDATE, 5);
+    af.setEntryTimeToLive(ExpirationAction::LOCAL_INVALIDATE,
+                          std::chrono::seconds(5));
     RegionAttributesPtr attrs = af.createRegionAttributes();
 
     CacheImpl* cacheImpl = CacheRegionHelper::getCacheImpl(Test.m_cache.get());
diff --git a/cppcache/integration-test/testCacheless.cpp b/cppcache/integration-test/testCacheless.cpp
index 9c448541..6eec6c7a 100644
--- a/cppcache/integration-test/testCacheless.cpp
+++ b/cppcache/integration-test/testCacheless.cpp
@@ -136,9 +136,10 @@ DUNIT_TASK_DEFINITION(s1p2, CreateNoCacheWListener)
     initClientWithPool(true, "__TEST_POOL1__", locHostPort, nullptr, nullptr, 0,
                        true);
     listener = std::make_shared<TallyListener>();
-    getHelper()->createPooledRegion(REGIONNAME, false, locHostPort,
-                                    "__TEST_POOL1__", true, true, 0, 0, 0, 0, 0,
-                                    listener);
+    getHelper()->createPooledRegion(
+        REGIONNAME, false, locHostPort, "__TEST_POOL1__", true, true,
+        std::chrono::seconds(0), std::chrono::seconds(0),
+        std::chrono::seconds(0), std::chrono::seconds(0), 0, listener);
   }
 END_TASK_DEFINITION
 
@@ -160,9 +161,10 @@ DUNIT_TASK_DEFINITION(s2p2, CreateRegionCache)
     initClientWithPool(true, "__TEST_POOL1__", locHostPort, nullptr, nullptr, 0,
                        true);
     listener = std::make_shared<TallyListener>();
-    getHelper()->createPooledRegion(REGIONNAME, false, locHostPort,
-                                    "__TEST_POOL1__", true, true, 0, 0, 0, 0, 0,
-                                    listener);
+    getHelper()->createPooledRegion(
+        REGIONNAME, false, locHostPort, "__TEST_POOL1__", true, true,
+        std::chrono::seconds(0), std::chrono::seconds(0),
+        std::chrono::seconds(0), std::chrono::seconds(0), 0, listener);
   }
 END_TASK_DEFINITION
 
diff --git a/cppcache/integration-test/testCreateAndDestroyPool.cpp b/cppcache/integration-test/testCreateAndDestroyPool.cpp
index d0e222d7..269ea3ae 100644
--- a/cppcache/integration-test/testCreateAndDestroyPool.cpp
+++ b/cppcache/integration-test/testCreateAndDestroyPool.cpp
@@ -41,7 +41,8 @@ const char* poolNames[] = {"Pool1"};
 
 void stepOne() {
   initClient(true);
-  createPoolAndDestroy(poolNames[0], locatorsG, nullptr, 0, false, -1, 1);
+  createPoolAndDestroy(poolNames[0], locatorsG, nullptr, 0, false,
+                       std::chrono::seconds::zero(), 1);
   LOG("StepOne complete.");
 }
 DUNIT_TASK_DEFINITION(CLIENT1, StepOne)
diff --git a/cppcache/integration-test/testExpiration.cpp b/cppcache/integration-test/testExpiration.cpp
index c6355461..b88a0539 100644
--- a/cppcache/integration-test/testExpiration.cpp
+++ b/cppcache/integration-test/testExpiration.cpp
@@ -76,8 +76,12 @@ CacheableKeyPtr do1Put(RegionPtr& rptr) {
   return key;
 }
 
-void setExpTimes(RegionAttributesPtr& attrs, int ettl = 0, int eit = 0,
-                 int rttl = 0, int rit = 0) {
+void setExpTimes(
+    RegionAttributesPtr& attrs,
+    const std::chrono::seconds& ettl = std::chrono::seconds::zero(),
+    const std::chrono::seconds& eit = std::chrono::seconds::zero(),
+    const std::chrono::seconds& rttl = std::chrono::seconds::zero(),
+    const std::chrono::seconds& rit = std::chrono::seconds::zero()) {
   AttributesFactory afact;
 
   afact.setEntryIdleTimeout(action, eit);
@@ -118,7 +122,8 @@ BEGIN_TEST(TEST_EXPIRATION)
 
     RegionAttributesPtr attrs_2;
 
-    setExpTimes(attrs_2, 20, 2, 0, 0);
+    setExpTimes(attrs_2, std::chrono::seconds(20), std::chrono::seconds(2),
+                std::chrono::seconds(0), std::chrono::seconds(0));
 
     RegionPtr R2;
     cacheImpl->createRegion("R2", attrs_2, R2);
@@ -135,7 +140,8 @@ BEGIN_TEST(TEST_EXPIRATION)
 
     RegionAttributesPtr attrs_3;
     // rttl = 20, reit = 2
-    setExpTimes(attrs_3, 0, 0, 20, 2);
+    setExpTimes(attrs_3, std::chrono::seconds(0), std::chrono::seconds(0),
+                std::chrono::seconds(20), std::chrono::seconds(2));
 
     RegionPtr R3;
     cacheImpl->createRegion("R3", attrs_3, R3);
@@ -147,7 +153,8 @@ BEGIN_TEST(TEST_EXPIRATION)
 
     RegionAttributesPtr attrs_4;
 
-    setExpTimes(attrs_4, 5, 0, 0, 0);
+    setExpTimes(attrs_4, std::chrono::seconds(5), std::chrono::seconds(0),
+                std::chrono::seconds(0), std::chrono::seconds(0));
 
     RegionPtr R4;
     cacheImpl->createRegion("R4", attrs_4, R4);
@@ -165,7 +172,8 @@ BEGIN_TEST(TEST_EXPIRATION)
 
     RegionAttributesPtr attrs_5;
     // ettl = 0, eit = 0, rttl = 0, reit = 0
-    setExpTimes(attrs_5, 0, 5, 0, 0);
+    setExpTimes(attrs_5, std::chrono::seconds(0), std::chrono::seconds(5),
+                std::chrono::seconds(0), std::chrono::seconds(0));
 
     RegionPtr R5;
     cacheImpl->createRegion("R5", attrs_5, R5);
@@ -192,7 +200,8 @@ BEGIN_TEST(TEST_EXPIRATION)
 
     RegionAttributesPtr attrs_6;
     // ettl = 0, eit = 0, rttl = 0, reit = 0
-    setExpTimes(attrs_6, 0, 0, 5, 0);
+    setExpTimes(attrs_6, std::chrono::seconds(0), std::chrono::seconds(0),
+                std::chrono::seconds(5), std::chrono::seconds(0));
 
     RegionPtr R6;
     cacheImpl->createRegion("R6", attrs_6, R6);
@@ -210,7 +219,8 @@ BEGIN_TEST(TEST_EXPIRATION)
 
     RegionAttributesPtr attrs_7;
     // ettl = 0, eit = 0, rttl = 0, reit = 0
-    setExpTimes(attrs_7, 0, 0, 0, 5);
+    setExpTimes(attrs_7, std::chrono::seconds(0), std::chrono::seconds(0),
+                std::chrono::seconds(0), std::chrono::seconds(5));
 
     RegionPtr R7;
     cacheImpl->createRegion("R7", attrs_7, R7);
@@ -228,7 +238,8 @@ BEGIN_TEST(TEST_EXPIRATION)
 
     RegionAttributesPtr attrs_8;
     // ettl = 0, eit = 0, rttl = 0, reit = 0
-    setExpTimes(attrs_8, 10, 0, 0, 0);
+    setExpTimes(attrs_8, std::chrono::seconds(10), std::chrono::seconds(0),
+                std::chrono::seconds(0), std::chrono::seconds(0));
 
     RegionPtr R8;
     cacheImpl->createRegion("R8", attrs_8, R8);
@@ -247,7 +258,8 @@ BEGIN_TEST(TEST_EXPIRATION)
 
     RegionAttributesPtr attrs_9;
     // ettl = 0, eit = 0, rttl = 0, reit = 0
-    setExpTimes(attrs_9, 0, 0, 0, 8);
+    setExpTimes(attrs_9, std::chrono::seconds(0), std::chrono::seconds(0),
+                std::chrono::seconds(0), std::chrono::seconds(8));
 
     RegionPtr R9;
     cacheImpl->createRegion("R9", attrs_9, R9);
@@ -268,7 +280,8 @@ BEGIN_TEST(TEST_EXPIRATION)
 
     RegionAttributesPtr attrs_10;
     // ettl = 0, eit = 0, rttl = 0, reit = 0
-    setExpTimes(attrs_10, 6, 0, 0, 12);
+    setExpTimes(attrs_10, std::chrono::seconds(6), std::chrono::seconds(0),
+                std::chrono::seconds(0), std::chrono::seconds(12));
 
     RegionPtr R10;
     cacheImpl->createRegion("R10", attrs_10, R10);
@@ -288,7 +301,8 @@ BEGIN_TEST(TEST_EXPIRATION)
     RegionAttributesPtr attrs_11;
 
     // ettl = 0, eit = 0, rttl = 0, reit = 0
-    setExpTimes(attrs_11, 0, 4, 0, 7);
+    setExpTimes(attrs_11, std::chrono::seconds(0), std::chrono::seconds(4),
+                std::chrono::seconds(0), std::chrono::seconds(7));
 
     RegionPtr R11;
     cacheImpl->createRegion("R11", attrs_11, R11);
@@ -314,7 +328,8 @@ BEGIN_TEST(TEST_EXPIRATION)
 
     RegionAttributesPtr attrs_12;
     // ettl = 0, eit = 0, rttl = 0, reit = 0
-    setExpTimes(attrs_12, 5, 0, 0, 0);
+    setExpTimes(attrs_12, std::chrono::seconds(5), std::chrono::seconds(0),
+                std::chrono::seconds(0), std::chrono::seconds(0));
 
     RegionPtr R12;
     cacheImpl->createRegion("R12", attrs_12, R12);
@@ -332,7 +347,8 @@ BEGIN_TEST(TEST_EXPIRATION)
 
     RegionAttributesPtr attrs_14;
     // ettl = 0, eit = 0, rttl = 0, reit = 0
-    setExpTimes(attrs_14, 0, 0, 10, 0);
+    setExpTimes(attrs_14, std::chrono::seconds(0), std::chrono::seconds(0),
+                std::chrono::seconds(10), std::chrono::seconds(0));
 
     RegionPtr R14;
     cacheImpl->createRegion("R14", attrs_14, R14);
@@ -346,7 +362,8 @@ BEGIN_TEST(TEST_EXPIRATION)
 
     RegionAttributesPtr attrs_15;
     // ettl = 0, eit = 0, rttl = 0, reit = 0
-    setExpTimes(attrs_15, 0, 5, 0, 0);
+    setExpTimes(attrs_15, std::chrono::seconds(0), std::chrono::seconds(5),
+                std::chrono::seconds(0), std::chrono::seconds(0));
 
     RegionPtr R15;
     cacheImpl->createRegion("R15", attrs_15, R15);
@@ -365,7 +382,8 @@ BEGIN_TEST(TEST_EXPIRATION)
     //////////////
     RegionAttributesPtr attrs_18;
     // ettl = 0, eit = 0, rttl = 0, reit = 0
-    setExpTimes(attrs_18, 6, 3, 0, 0);
+    setExpTimes(attrs_18, std::chrono::seconds(6), std::chrono::seconds(3),
+                std::chrono::seconds(0), std::chrono::seconds(0));
 
     RegionPtr R18;
     cacheImpl->createRegion("R18", attrs_18, R18);
@@ -384,7 +402,8 @@ BEGIN_TEST(TEST_EXPIRATION)
 
     RegionAttributesPtr attrs_19;
     // ettl = 0, eit = 0, rttl = 0, reit = 0
-    setExpTimes(attrs_19, 0, 0, 6, 3);
+    setExpTimes(attrs_19, std::chrono::seconds(0), std::chrono::seconds(0),
+                std::chrono::seconds(6), std::chrono::seconds(3));
 
     RegionPtr R19;
     cacheImpl->createRegion("R19x", attrs_19, R19);
diff --git a/cppcache/integration-test/testSystemProperties.cpp b/cppcache/integration-test/testSystemProperties.cpp
index 10c01abb..112ac319 100644
--- a/cppcache/integration-test/testSystemProperties.cpp
+++ b/cppcache/integration-test/testSystemProperties.cpp
@@ -45,7 +45,8 @@ const bool checkSecurityProperties(PropertiesPtr securityProperties,
 BEGIN_TEST(DEFAULT)
   {
     SystemProperties* sp = new SystemProperties(nullptr, "./non-existent");
-    ASSERT(sp->statisticsSampleInterval() == 1, "expected 1");
+    ASSERT(sp->statisticsSampleInterval() == std::chrono::seconds(1),
+           "expected 1");
     ASSERT(sp->statisticsEnabled() == true, "expected true");
     LOG(sp->statisticsArchiveFile());
     const char* safname = sp->statisticsArchiveFile();
@@ -78,7 +79,8 @@ BEGIN_TEST(CONFIG)
     Log::init(Log::Config, nullptr, 0);
 
     SystemProperties* sp = new SystemProperties(nullptr, "test.properties");
-    ASSERT(sp->statisticsSampleInterval() == 1, "expected 1");
+    ASSERT(sp->statisticsSampleInterval() == std::chrono::seconds(1),
+           "expected 1");
     ASSERT(sp->statisticsEnabled() == true, "expected true");
     const char* safname = sp->statisticsArchiveFile();
     int ret = strcmp(safname, "statArchive.gfs");
@@ -101,7 +103,8 @@ BEGIN_TEST(NEW_CONFIG)
 
     SystemProperties* sp = new SystemProperties(nullptr, filePath.c_str());
 
-    ASSERT(sp->statisticsSampleInterval() == 700, "expected 700");
+    ASSERT(sp->statisticsSampleInterval() == std::chrono::seconds(700),
+           "expected 700");
 
     ASSERT(sp->statisticsEnabled() == false, "expected false");
 
@@ -126,15 +129,17 @@ BEGIN_TEST(NEW_CONFIG)
     ret = strcmp(cxml, "cache.xml");
     ASSERT(ret == 0, "expected 0");
 
-    ASSERT(sp->pingInterval() == 123, "expected 123 pingInterval");
-    ASSERT(sp->redundancyMonitorInterval() == 456,
-           "expected 456 redundancyMonitorInterval");
+    ASSERT(sp->pingInterval() == std::chrono::seconds(123),
+           "expected 123 pingInterval");
+    ASSERT(sp->redundancyMonitorInterval() == std::chrono::seconds(456),
+           "expected 456s redundancyMonitorInterval");
 
     ASSERT(sp->heapLRULimit() == 100, "expected 100");
     ASSERT(sp->heapLRUDelta() == 10, "expected 10");
 
-    ASSERT(sp->notifyAckInterval() == 1234, "expected 1234 notifyAckInterval");
-    ASSERT(sp->notifyDupCheckLife() == 4321,
+    ASSERT(sp->notifyAckInterval() == std::chrono::milliseconds(1234),
+           "expected 1234 notifyAckInterval");
+    ASSERT(sp->notifyDupCheckLife() == std::chrono::milliseconds(4321),
            "expected 4321 notifyDupCheckLife");
 
     ASSERT(sp->logFileSizeLimit() == 1024000000, "expected 1024000000");
@@ -145,9 +150,11 @@ BEGIN_TEST(NEW_CONFIG)
     ret = strcmp(durableId, "testDurableId");
     ASSERT(ret == 0, "expected 0");
 
-    ASSERT(sp->durableTimeout() == 123, "expected 123 durableTimeOut");
+    ASSERT(sp->durableTimeout() == std::chrono::seconds(123),
+           "expected 123 durableTimeOut");
 
-    ASSERT(sp->connectTimeout() == 345, "expected 345 for connect timeout");
+    ASSERT(sp->connectTimeout() == std::chrono::milliseconds(345),
+           "expected 345 for connect timeout");
 
     PropertiesPtr securityProperties = sp->getSecurityProperties();
     ASSERT(checkSecurityProperties(securityProperties, "security-username",
diff --git a/cppcache/integration-test/testThinClientAfterRegionLive.cpp b/cppcache/integration-test/testThinClientAfterRegionLive.cpp
index 3bcdfe05..ffaa6311 100644
--- a/cppcache/integration-test/testThinClientAfterRegionLive.cpp
+++ b/cppcache/integration-test/testThinClientAfterRegionLive.cpp
@@ -70,10 +70,10 @@ void createPooledRegionMine(bool callReadyForEventsAPI = false) {
   AttributesFactory af;
   af.setCachingEnabled(true);
   af.setLruEntriesLimit(0);
-  af.setEntryIdleTimeout(ExpirationAction::DESTROY, 0);
-  af.setEntryTimeToLive(ExpirationAction::DESTROY, 0);
-  af.setRegionIdleTimeout(ExpirationAction::DESTROY, 0);
-  af.setRegionTimeToLive(ExpirationAction::DESTROY, 0);
+  af.setEntryIdleTimeout(ExpirationAction::DESTROY, std::chrono::seconds(0));
+  af.setEntryTimeToLive(ExpirationAction::DESTROY, std::chrono::seconds(0));
+  af.setRegionIdleTimeout(ExpirationAction::DESTROY, std::chrono::seconds(0));
+  af.setRegionTimeToLive(ExpirationAction::DESTROY, std::chrono::seconds(0));
   af.setPoolName("__TEST_POOL1__");
   LOG("poolName = ");
   LOG("__TEST_POOL1__");
diff --git a/cppcache/integration-test/testThinClientConflation.cpp b/cppcache/integration-test/testThinClientConflation.cpp
index 15932f5f..c13ae952 100644
--- a/cppcache/integration-test/testThinClientConflation.cpp
+++ b/cppcache/integration-test/testThinClientConflation.cpp
@@ -101,7 +101,8 @@ const char* regions[] = {"ConflatedRegion", "NonConflatedRegion"};
 
 void initClientCache(OperMonitorPtr& mon1, OperMonitorPtr& mon2, int durableIdx,
                      const char* conflation) {
-  initClientAndTwoRegions(durableIdx, 0, 300, conflation, regions);
+  initClientAndTwoRegions(durableIdx, 0, std::chrono::seconds(300), conflation,
+                          regions);
 
   // Recreate listener
   mon1 = std::make_shared<OperMonitor>();
diff --git a/cppcache/integration-test/testThinClientCq.cpp b/cppcache/integration-test/testThinClientCq.cpp
index 05daa406..81225db0 100644
--- a/cppcache/integration-test/testThinClientCq.cpp
+++ b/cppcache/integration-test/testThinClientCq.cpp
@@ -328,12 +328,14 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepOne_Pooled_Locator)
     initClient(true);
 
     getHelper()->createPoolWithLocators("__TEST_POOL1__", locHostPort, true, -1,
-                                        -1, -1, false, "group1");
+                                        std::chrono::seconds::zero(), -1, false,
+                                        "group1");
     getHelper()->createRegionAndAttachPool(regionName, USE_ACK,
                                            "__TEST_POOL1__", true);
 
     getHelper()->createPoolWithLocators("__TEST_POOL2__", locHostPort, true, -1,
-                                        -1, -1, false, "group2");
+                                        std::chrono::seconds::zero(), -1, false,
+                                        "group2");
     getHelper()->createRegionAndAttachPool(regionName1, USE_ACK,
                                            "__TEST_POOL2__", true);
 
diff --git a/cppcache/integration-test/testThinClientCqDelta.cpp b/cppcache/integration-test/testThinClientCqDelta.cpp
index 8372c06f..40a2f8c3 100644
--- a/cppcache/integration-test/testThinClientCqDelta.cpp
+++ b/cppcache/integration-test/testThinClientCqDelta.cpp
@@ -14,12 +14,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-/*
- * testThinClientCqDelta.cpp
- *
- *  Created on: Sept 17, 2009
- *      Author: abhaware
- */
 
 #include "testobject/DeltaTestImpl.hpp"
 #include "fw_dunit.hpp"
@@ -124,7 +118,9 @@ void createPooledLRURegion(const char* name, bool ackMode, const char* locators,
   LOG(" createPooledLRURegion entered");
   RegionPtr regPtr = getHelper()->createPooledRegionDiscOverFlow(
       name, ackMode, locators, poolname, cachingEnable,
-      clientNotificationEnabled, 0, 0, 0, 0, 3 /*LruLimit = 3*/);
+      clientNotificationEnabled, std::chrono::seconds(0),
+      std::chrono::seconds(0), std::chrono::seconds(0), std::chrono::seconds(0),
+      3 /*LruLimit = 3*/);
   LOG(" createPooledLRURegion exited");
 }
 
diff --git a/cppcache/integration-test/testThinClientCqDurable.cpp b/cppcache/integration-test/testThinClientCqDurable.cpp
index 48cd2ab2..1b2831d7 100644
--- a/cppcache/integration-test/testThinClientCqDurable.cpp
+++ b/cppcache/integration-test/testThinClientCqDurable.cpp
@@ -63,8 +63,8 @@ static bool m_isPdx = false;
 void initClientWithId(int ClientIdx, bool typeRegistered = false) {
   PropertiesPtr pp = Properties::create();
   pp->insert("durable-client-id", durableIds[ClientIdx]);
-  pp->insert("durable-timeout", 60);
-  pp->insert("notify-ack-interval", 1);
+  pp->insert("durable-timeout", std::chrono::seconds(60));
+  pp->insert("notify-ack-interval", std::chrono::seconds(1));
 
   initClient(true, pp);
 
@@ -188,15 +188,15 @@ void RunDurableCqClient() {
   // Create durable client's properties using api.
   auto pp = Properties::create();
   pp->insert("durable-client-id", "DurableClientId");
-  pp->insert("durable-timeout", 3600);
+  pp->insert("durable-timeout", std::chrono::seconds(3600));
 
   // Create a Geode Cache Programmatically.
   auto cacheFactory = CacheFactory::createCacheFactory(pp);
   auto cachePtr = cacheFactory->create();
   auto poolFactory = cachePtr->getPoolManager().createFactory();
   poolFactory->setSubscriptionEnabled(true);
-  poolFactory->setSubscriptionAckInterval(5000);
-  poolFactory->setSubscriptionMessageTrackingTimeout(50000);
+  poolFactory->setSubscriptionAckInterval(std::chrono::milliseconds(5000));
+  poolFactory->setSubscriptionMessageTrackingTimeout(std::chrono::milliseconds(50000));
   poolFactory->create("");
 
   LOGINFO("Created the Geode Cache Programmatically");
diff --git a/cppcache/integration-test/testThinClientDeltaWithNotification.cpp b/cppcache/integration-test/testThinClientDeltaWithNotification.cpp
index 4d79837d..9bb59c97 100644
--- a/cppcache/integration-test/testThinClientDeltaWithNotification.cpp
+++ b/cppcache/integration-test/testThinClientDeltaWithNotification.cpp
@@ -14,12 +14,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-/*
- * testThinClientDeltaWithNotification.cpp
- *
- *  Created on: May 8, 2009
- *      Author: abhaware
- */
 
 #define ROOT_NAME "testThinClientDeltaWithNotification"
 
@@ -98,8 +92,9 @@ void createPooledExpirationRegion(const char* name, const char* poolname) {
   LOG("createPooledExpirationRegion() entered.");
   // Entry time-to-live = 1 second.
   RegionPtr regPtr = getHelper()->createPooledRegionDiscOverFlow(
-      name, true, locatorsG, poolname, true, true, 1, 0, 0, 0, 0, nullptr,
-      ExpirationAction::LOCAL_INVALIDATE);
+      name, true, locatorsG, poolname, true, true, std::chrono::seconds(1),
+      std::chrono::seconds(0), std::chrono::seconds(0), std::chrono::seconds(0),
+      0, nullptr, ExpirationAction::LOCAL_INVALIDATE);
 }
 
 void createPooledLRURegion(const char* name, bool ackMode, const char* locators,
@@ -109,7 +104,9 @@ void createPooledLRURegion(const char* name, bool ackMode, const char* locators,
   LOG(" createPooledLRURegion entered");
   RegionPtr regPtr = getHelper()->createPooledRegionDiscOverFlow(
       name, ackMode, locators, poolname, cachingEnable,
-      clientNotificationEnabled, 0, 0, 0, 0, 3 /*LruLimit = 3*/);
+      clientNotificationEnabled, std::chrono::seconds(0),
+      std::chrono::seconds(0), std::chrono::seconds(0), std::chrono::seconds(0),
+      3 /*LruLimit = 3*/);
   LOG(" createPooledLRURegion exited");
 }
 
@@ -129,7 +126,8 @@ void createLRURegion(const char* name, bool clientNotificationEnabled = false,
                      bool cachingEnable = true) {
   LOG(" createPooledLRURegion entered");
   RegionPtr regPtr = getHelper()->createRegionDiscOverFlow(
-      name, cachingEnable, clientNotificationEnabled, 0, 0, 0, 0,
+      name, cachingEnable, clientNotificationEnabled, std::chrono::seconds(0),
+      std::chrono::seconds(0), std::chrono::seconds(0), std::chrono::seconds(0),
       3 /*LruLimit = 3*/);
   LOG(" createPooledLRURegion exited");
 }
@@ -139,8 +137,9 @@ void createExpirationRegion(const char* name,
                             bool cachingEnable = true) {
   LOG(" createPooledLRURegion entered");
   RegionPtr regPtr = getHelper()->createRegionDiscOverFlow(
-      name, cachingEnable, clientNotificationEnabled, 1, 0, 0, 0, 0,
-      ExpirationAction::LOCAL_INVALIDATE);
+      name, cachingEnable, clientNotificationEnabled, std::chrono::seconds(1),
+      std::chrono::seconds(0), std::chrono::seconds(0), std::chrono::seconds(0),
+      0, ExpirationAction::LOCAL_INVALIDATE);
   LOG(" createPooledLRURegion exited");
 }
 
diff --git a/cppcache/integration-test/testThinClientExecuteFunctionPrSHOP.cpp b/cppcache/integration-test/testThinClientExecuteFunctionPrSHOP.cpp
index b2496623..221d0e32 100644
--- a/cppcache/integration-test/testThinClientExecuteFunctionPrSHOP.cpp
+++ b/cppcache/integration-test/testThinClientExecuteFunctionPrSHOP.cpp
@@ -20,6 +20,7 @@
 #include "fw_dunit.hpp"
 #include "ThinClientHelper.hpp"
 #include "testobject/VariousPdxTypes.hpp"
+#include <geode/DefaultResultCollector.hpp>
 
 using namespace PdxTests;
 /* This is to test
@@ -47,105 +48,74 @@ char* putFuncName = (char*)"MultiPutFunction";
 char* putFuncIName = (char*)"MultiPutFunctionI";
 char* FETimeOut = (char*)"FunctionExecutionTimeOut";
 
-class MyResultCollector : public ResultCollector {
+class MyResultCollector : public DefaultResultCollector {
  public:
   MyResultCollector()
-      : m_resultList(CacheableVector::create()),
-        m_isResultReady(false),
-        m_endResultCount(0),
-        m_addResultCount(0),
-        m_getResultCount(0) {}
-  ~MyResultCollector() {}
-  CacheableVectorPtr getResult(uint32_t timeout) {
+      : m_endResultCount(0), m_addResultCount(0), m_getResultCount(0) {}
+  ~MyResultCollector() noexcept {}
+
+  CacheableVectorPtr getResult(std::chrono::milliseconds timeout) override {
     m_getResultCount++;
-    if (m_isResultReady == true) {
-      return m_resultList;
-    } else {
-      for (uint32_t i = 0; i < timeout; i++) {
-        SLEEP(1);
-        if (m_isResultReady == true) return m_resultList;
-      }
-      throw FunctionExecutionException(
-          "Result is not ready, endResults callback is called before invoking "
-          "getResult() method");
-    }
+    return DefaultResultCollector::getResult(timeout);
   }
 
-  void addResult(const CacheablePtr& resultItem) {
+  void addResult(const CacheablePtr& resultItem) override {
     m_addResultCount++;
     if (resultItem == nullptr) {
       return;
     }
-    try {
-      auto result = std::dynamic_pointer_cast<CacheableArrayList>(resultItem);
-      for (int32_t i = 0; i < result->size(); i++) {
-        m_resultList->push_back(result->operator[](i));
+    if (auto results =
+            std::dynamic_pointer_cast<CacheableArrayList>(resultItem)) {
+      for (auto& result : *results) {
+        DefaultResultCollector::addResult(result);
       }
-    } catch (ClassCastException) {
-      auto result =
-          std::dynamic_pointer_cast<UserFunctionExecutionException>(resultItem);
-      m_resultList->push_back(result);
+    } else {
+      DefaultResultCollector::addResult(resultItem);
     }
   }
-  void endResults() {
-    m_isResultReady = true;
+
+  void endResults() override {
     m_endResultCount++;
+    DefaultResultCollector::endResults();
   }
+
   uint32_t getEndResultCount() { return m_endResultCount; }
   uint32_t getAddResultCount() { return m_addResultCount; }
   uint32_t getGetResultCount() { return m_getResultCount; }
 
  private:
-  CacheableVectorPtr m_resultList;
-  volatile bool m_isResultReady;
   uint32_t m_endResultCount;
   uint32_t m_addResultCount;
   uint32_t m_getResultCount;
 };
 typedef std::shared_ptr<MyResultCollector> MyResultCollectorPtr;
-class MyResultCollector2 : public ResultCollector {
+
+class MyResultCollector2 : public DefaultResultCollector {
  public:
   MyResultCollector2()
-      : m_resultList(CacheableVector::create()),
-        m_isResultReady(false),
-        m_endResultCount(0),
-        m_addResultCount(0),
-        m_getResultCount(0) {}
-  ~MyResultCollector2() {}
-  CacheableVectorPtr getResult(uint32_t timeout) {
+      : m_endResultCount(0), m_addResultCount(0), m_getResultCount(0) {}
+  ~MyResultCollector2() noexcept {}
+
+  CacheableVectorPtr getResult(std::chrono::milliseconds timeout) override {
     m_getResultCount++;
-    if (m_isResultReady == true) {
-      return m_resultList;
-    } else {
-      for (uint32_t i = 0; i < timeout; i++) {
-        SLEEP(1);
-        if (m_isResultReady == true) return m_resultList;
-      }
-      throw FunctionExecutionException(
-          "Result is not ready, endResults callback is called before invoking "
-          "getResult() method");
-    }
+    return DefaultResultCollector::getResult(timeout);
   }
 
-  void addResult(const CacheablePtr& resultItem) {
+  void addResult(const CacheablePtr& resultItem) override {
     m_addResultCount++;
-    if (resultItem == nullptr) {
-      return;
-    }
-    auto result = std::dynamic_pointer_cast<CacheableBoolean>(resultItem);
-    m_resultList->push_back(result);
+    DefaultResultCollector::addResult(resultItem);
   }
-  void endResults() {
-    m_isResultReady = true;
+
+  void endResults() override {
     m_endResultCount++;
+    DefaultResultCollector::endResults();
   }
+
   uint32_t getEndResultCount() { return m_endResultCount; }
   uint32_t getAddResultCount() { return m_addResultCount; }
   uint32_t getGetResultCount() { return m_getResultCount; }
 
  private:
-  CacheableVectorPtr m_resultList;
-  volatile bool m_isResultReady;
   uint32_t m_endResultCount;
   uint32_t m_addResultCount;
   uint32_t m_getResultCount;
@@ -203,7 +173,6 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest2)
     }
     LOG("Put done.");
     try {
-      bool getResult = true;
       for (int k = 0; k < 210; k++) {
         CacheableVectorPtr routingObj = CacheableVector::create();
         for (int i = k; i < k + 20; i++) {
@@ -216,7 +185,9 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest2)
         CacheableVectorPtr resultList = CacheableVector::create();
         LOG("Executing getFuncName function");
         CacheableVectorPtr executeFunctionResult =
-            exe->withFilter(routingObj)->execute(getFuncName, 15)->getResult();
+            exe->withFilter(routingObj)
+                ->execute(getFuncName, std::chrono::seconds(15))
+                ->getResult();
         if (executeFunctionResult == nullptr) {
           ASSERT(false, "executeFunctionResult is nullptr");
         } else {
@@ -248,11 +219,10 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest2)
         }
         LOGINFO("getFuncName done");
         auto myRC = std::make_shared<MyResultCollector>();
-        CacheableVectorPtr executeFunctionResult1 =
-            exe->withFilter(routingObj)
-                ->withCollector(myRC)
-                ->execute(getFuncName, getResult)
-                ->getResult();
+        auto executeFunctionResult1 = exe->withFilter(routingObj)
+                                          ->withCollector(myRC)
+                                          ->execute(getFuncName)
+                                          ->getResult();
         LOGINFO("add result count = %d", myRC->getAddResultCount());
         LOGINFO("end result count = %d", myRC->getEndResultCount());
         LOGINFO("get result count = %d", myRC->getGetResultCount());
@@ -565,11 +535,11 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest2)
 
       ///////////////////TimeOut test //////////////////////
       LOGINFO("FETimeOut begin onRegion");
-      ExecutionPtr RexecutionPtr = FunctionService::onRegion(regPtr0);
-      CacheableVectorPtr fe =
-          RexecutionPtr->withArgs(CacheableInt32::create(5000 * 1000))
-              ->execute(FETimeOut, 5000 * 1000)
-              ->getResult();
+      auto timeout = std::chrono::milliseconds(15000);
+      auto RexecutionPtr = FunctionService::onRegion(regPtr0);
+      auto fe = RexecutionPtr->withArgs(CacheableInt32::create(timeout.count()))
+                    ->execute(FETimeOut, timeout)
+                    ->getResult();
       if (fe == nullptr) {
         ASSERT(false, "functionResult is nullptr");
       } else {
diff --git a/cppcache/integration-test/testThinClientGetInterests.cpp b/cppcache/integration-test/testThinClientGetInterests.cpp
index 9e1e6c16..aaa3102a 100644
--- a/cppcache/integration-test/testThinClientGetInterests.cpp
+++ b/cppcache/integration-test/testThinClientGetInterests.cpp
@@ -44,8 +44,8 @@ DUNIT_TASK(CLIENT1, SetupClient1)
   {
     PropertiesPtr pp = Properties::create();
     pp->insert("durable-client-id", durableIds[0]);
-    pp->insert("durable-timeout", 300);
-    pp->insert("notify-ack-interval", 1);
+    pp->insert("durable-timeout", std::chrono::seconds(300));
+    pp->insert("notify-ack-interval", std::chrono::seconds(1));
 
     initClientWithPool(true, "__TEST_POOL1__", locatorsG, nullptr, pp, 0, true);
     getHelper()->createPooledRegion(regionNames[0], false, locatorsG,
diff --git a/cppcache/integration-test/testThinClientHAEventIDMap.cpp b/cppcache/integration-test/testThinClientHAEventIDMap.cpp
index 61125419..b0e264d6 100644
--- a/cppcache/integration-test/testThinClientHAEventIDMap.cpp
+++ b/cppcache/integration-test/testThinClientHAEventIDMap.cpp
@@ -96,8 +96,8 @@ int g_redundancyLevel = 0;
 
 void initClient() {
   PropertiesPtr props = Properties::create();
-  props->insert("notify-ack-interval", 3600);  // set to 1 hr.
-  props->insert("notify-dupcheck-life", 3600);
+  props->insert("notify-ack-interval", std::chrono::hours(1));  // set to 1 hr.
+  props->insert("notify-dupcheck-life", std::chrono::hours(1));
 
   if (cacheHelper == nullptr) {
     cacheHelper = new CacheHelper(true, props);
diff --git a/cppcache/integration-test/testThinClientHAPeriodicAck.cpp b/cppcache/integration-test/testThinClientHAPeriodicAck.cpp
index ddd47b34..dae1da78 100644
--- a/cppcache/integration-test/testThinClientHAPeriodicAck.cpp
+++ b/cppcache/integration-test/testThinClientHAPeriodicAck.cpp
@@ -97,8 +97,8 @@ bool g_poolLocators = false;
 
 void initClient(int redundancyLevel) {
   PropertiesPtr props = Properties::create();
-  props->insert("notify-ack-interval", 1);
-  props->insert("notify-dupcheck-life", 30);
+  props->insert("notify-ack-interval", std::chrono::seconds(1));
+  props->insert("notify-dupcheck-life", std::chrono::seconds(30));
 
   if (cacheHelper == nullptr) {
     cacheHelper = new CacheHelper(redundancyLevel, props);
@@ -109,8 +109,8 @@ void initClient(int redundancyLevel) {
 
 void initClient() {
   PropertiesPtr props = Properties::create();
-  props->insert("notify-ack-interval", 1);
-  props->insert("notify-dupcheck-life", 30);
+  props->insert("notify-ack-interval", std::chrono::seconds(1));
+  props->insert("notify-dupcheck-life", std::chrono::seconds(30));
 
   if (cacheHelper == nullptr) {
     cacheHelper = new CacheHelper(true, props);
diff --git a/cppcache/integration-test/testThinClientInterestNotify.cpp b/cppcache/integration-test/testThinClientInterestNotify.cpp
index a35a5290..dc660fde 100644
--- a/cppcache/integration-test/testThinClientInterestNotify.cpp
+++ b/cppcache/integration-test/testThinClientInterestNotify.cpp
@@ -165,7 +165,8 @@ void initClientForInterestNotify(EventListenerPtr& mon1, EventListenerPtr& mon2,
   initClient(true, props);
 
   LOG("CLIENT: Setting pool with locator.");
-  getHelper()->createPoolWithLocators("__TESTPOOL1_", locatorsG, true, 0, 1);
+  getHelper()->createPoolWithLocators("__TESTPOOL1_", locatorsG, true, 0,
+                                      std::chrono::seconds(1));
   createRegionAndAttachPool(regions[0], USE_ACK, "__TESTPOOL1_", true);
   createRegionAndAttachPool(regions[1], USE_ACK, "__TESTPOOL1_", true);
   createRegionAndAttachPool(regions[2], USE_ACK, "__TESTPOOL1_", true);
diff --git a/cppcache/integration-test/testThinClientLRUExpiration.cpp b/cppcache/integration-test/testThinClientLRUExpiration.cpp
index 31f159b1..4c33f244 100644
--- a/cppcache/integration-test/testThinClientLRUExpiration.cpp
+++ b/cppcache/integration-test/testThinClientLRUExpiration.cpp
@@ -14,12 +14,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 #include "fw_dunit.hpp"
-#include <geode/GeodeCppCache.hpp>
+
+#include <string>
+
 #include <ace/OS.h>
 #include <ace/High_Res_Timer.h>
 
-#include <string>
+#include <geode/GeodeCppCache.hpp>
+#include <geode/util/chrono/duration.hpp>
 
 #define ROOT_NAME "testThinClientLRUExpiration"
 #define ROOT_SCOPE DISTRIBUTED_ACK
@@ -30,6 +34,7 @@
 
 using namespace apache::geode::client;
 using namespace test;
+using namespace apache::geode::util::chrono::duration;
 
 #define CLIENT1 s1p1
 #define CLIENT2 s1p2
@@ -74,10 +79,14 @@ void printAttribute(RegionAttributesPtr& attr) {
   printf("InitialCapacity: %d\n", attr->getInitialCapacity());
   printf("LoadFactor: %f\n", attr->getLoadFactor());
   printf("ConcurencyLevel: %d\n", attr->getConcurrencyLevel());
-  printf("RegionTimeToLive: %d\n", attr->getRegionTimeToLive());
-  printf("RegionIdleTimeout: %d\n", attr->getRegionIdleTimeout());
-  printf("EntryTimeToLive: %d\n", attr->getEntryTimeToLive());
-  printf("EntryIdleTimeout: %d\n", attr->getEntryIdleTimeout());
+  printf("RegionTimeToLive: %s\n",
+         to_string(attr->getRegionTimeToLive()).c_str());
+  printf("RegionIdleTimeout: %s\n",
+         to_string(attr->getRegionIdleTimeout()).c_str());
+  printf("EntryTimeToLive: %s\n",
+         to_string(attr->getEntryTimeToLive()).c_str());
+  printf("EntryIdleTimeout: %s\n",
+         to_string(attr->getEntryIdleTimeout()).c_str());
   printf("getLruEntriesLimit: %d\n", attr->getLruEntriesLimit());
   printf("RegionTimeToLiveAction: %d\n", attr->getRegionTimeToLiveAction());
   printf("RegionIdleTimeoutAction: %d\n", attr->getRegionIdleTimeoutAction());
@@ -128,15 +137,18 @@ void ValidateDestroyRegion(const char* name) {
   }
 }
 
-void createRegion(const char* name, bool ackMode, int ettl, int eit, int rttl,
-                  int rit, int lel, bool clientNotificationEnabled = false,
+void createRegion(const char* name, bool ackMode,
+                  const std::chrono::seconds& ettl,
+                  const std::chrono::seconds& eit,
+                  const std::chrono::seconds& rttl,
+                  const std::chrono::seconds& rit, int lel,
+                  bool clientNotificationEnabled = false,
                   ExpirationAction::Action action = ExpirationAction::DESTROY) {
   fprintf(stdout, "Creating region --  %s  ackMode is %d\n", name, ackMode);
   fflush(stdout);
-  RegionPtr
-      regPtr =  // getHelper()->createRegion( name, ackMode, true,
-                // ettl,eit,rttl,rit,lel,action,endpoints,clientNotificationEnabled
-                // );
+  RegionPtr regPtr =  // getHelper()->createRegion( name, ackMode, true,
+      // ettl,eit,rttl,rit,lel,action,endpoints,clientNotificationEnabled
+      // );
       getHelper()->createRegionAndAttachPool(name, ackMode, "LRUPool", true,
                                              ettl, eit, rttl, rit, lel, action);
   ASSERT(regPtr != nullptr, "Failed to create region.");
@@ -220,9 +232,10 @@ void localDestroyRegion(const char* name) {
 }
 
 void createThinClientRegion(
-    const char* regionName, int ettl, int eit, int rttl, int rit, int lel,
-    int noOfEntry = 0, int rgnOpt = 0, bool destroyRgn = true,
-    bool clientNotificationEnabled = true,
+    const char* regionName, const std::chrono::seconds& ettl,
+    const std::chrono::seconds& eit, const std::chrono::seconds& rttl,
+    const std::chrono::seconds& rit, int lel, int noOfEntry = 0, int rgnOpt = 0,
+    bool destroyRgn = true, bool clientNotificationEnabled = true,
     ExpirationAction::Action action = ExpirationAction::DESTROY) {
   if (destroyRgn) {
     try {
@@ -254,7 +267,9 @@ DUNIT_TASK(CLIENT1, StepOneCase1)
     // - [put-0/get-5/destroy-3] ,destroyRgn - [true/false]
     // ,clientNotificationEnabled - [true/false] ,ExpirationAction::Action
     getHelper()->createPoolWithLocators("LRUPool", locatorsG, true);
-    createThinClientRegion(regionNames[0], 4, 2, 0, 0, 0, 0, 6, false);
+    createThinClientRegion(regionNames[0], std::chrono::seconds(4),
+                           std::chrono::seconds(2), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 0, 0, 6, false);
   }
 END_TASK(StepOneCase1)
 
@@ -266,7 +281,9 @@ DUNIT_TASK(CLIENT2, StepTwoCase1)
     // ,destroyRgn - [true/false] ,clientNotificationEnabled - [true/false]
     // ,ExpirationAction::Action
     getHelper()->createPoolWithLocators("LRUPool", locatorsG, true);
-    createThinClientRegion(regionNames[0], 0, 0, 0, 0, 0, 0, 6, false);
+    createThinClientRegion(regionNames[0], std::chrono::seconds(0),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 0, 0, 6, false);
   }
 END_TASK(StepTwoCase1)
 
@@ -313,7 +330,9 @@ DUNIT_TASK(CLIENT1, StepOneCase2)
     // [put-0/get-5/destroy-3] ,destroyRgn - [true/false]
     // ,clientNotificationEnabled - [true/false]
     // ,ExpirationAction::Action
-    createThinClientRegion(regionNames[0], 4, 2, 0, 0, 0, 100, 3, true, true,
+    createThinClientRegion(regionNames[0], std::chrono::seconds(4),
+                           std::chrono::seconds(2), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 0, 100, 3, true, true,
                            ExpirationAction::LOCAL_INVALIDATE);
     LOG("StepOneCase2 complete.");
   }
@@ -326,7 +345,9 @@ DUNIT_TASK(CLIENT2, StepTwoCase2)
     // [put-0/get-5/destroy-3] ,destroyRgn - [true/false]
     // ,clientNotificationEnabled - [true/false]
     // ,ExpirationAction::Action
-    createThinClientRegion(regionNames[0], 0, 0, 0, 0, 0, 100, 3);
+    createThinClientRegion(regionNames[0], std::chrono::seconds(0),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 0, 100, 3);
     LOG("StepTwoCase2 complete.");
   }
 END_TASK(StepTwoCase2)
@@ -376,7 +397,9 @@ DUNIT_TASK(CLIENT1, StepOneCase3)
     // [put-0/get-5/destroy-3] ,destroyRgn -
     // [true/false] ,clientNotificationEnabled -
     // [true/false] ,ExpirationAction::Action
-    createThinClientRegion(regionNames[0], 0, 0, 0, 0, 5, 10, 3);
+    createThinClientRegion(regionNames[0], std::chrono::seconds(0),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 5, 10, 3);
   }
 END_TASK(StepOneCase3)
 
@@ -387,7 +410,9 @@ DUNIT_TASK(CLIENT2, StepTwoCase3)
     // [put-0/get-5/destroy-3] ,destroyRgn -
     // [true/false] ,clientNotificationEnabled -
     // [true/false] ,ExpirationAction::Action
-    createThinClientRegion(regionNames[0], 0, 0, 0, 0, 0, 10, 3);
+    createThinClientRegion(regionNames[0], std::chrono::seconds(0),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 0, 10, 3);
   }
 END_TASK(StepTwoCase3)
 DUNIT_TASK(CLIENT1, StepThreeCase3)
@@ -435,7 +460,9 @@ DUNIT_TASK(CLIENT1, StepOneCase4)
     // ,clientNotificationEnabled -
     // [true/false]
     // ,ExpirationAction::Action
-    createThinClientRegion(regionNames[0], 5, 0, 0, 0, 5, 10, 3, true, true,
+    createThinClientRegion(regionNames[0], std::chrono::seconds(5),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 5, 10, 3, true, true,
                            ExpirationAction::LOCAL_INVALIDATE);
   }
 END_TASK(StepOneCase4)
@@ -449,7 +476,9 @@ DUNIT_TASK(CLIENT2, StepTwoCase4)
     // ,clientNotificationEnabled -
     // [true/false]
     // ,ExpirationAction::Action
-    createThinClientRegion(regionNames[0], 0, 0, 0, 0, 0, 10, 3);
+    createThinClientRegion(regionNames[0], std::chrono::seconds(0),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 0, 10, 3);
   }
 END_TASK(StepTwoCase4)
 DUNIT_TASK(CLIENT1, StepThreeCase4)
@@ -506,7 +535,9 @@ DUNIT_TASK(CLIENT1, StepOneCase5)
     // ,clientNotificationEnabled
     // - [true/false]
     // ,ExpirationAction::Action
-    createThinClientRegion(regionNames[0], 5, 0, 0, 0, 5, 10, 3);
+    createThinClientRegion(regionNames[0], std::chrono::seconds(5),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 5, 10, 3);
   }
 END_TASK(StepOneCase5)
 
@@ -522,7 +553,9 @@ DUNIT_TASK(CLIENT2, StepTwoCase5)
     // ,clientNotificationEnabled
     // - [true/false]
     // ,ExpirationAction::Action
-    createThinClientRegion(regionNames[0], 0, 0, 0, 0, 0, 10, 3);
+    createThinClientRegion(regionNames[0], std::chrono::seconds(0),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 0, 10, 3);
   }
 END_TASK(StepTwoCase5)
 DUNIT_TASK(CLIENT1, StepThreeCase5)
@@ -608,7 +641,9 @@ DUNIT_TASK(CLIENT1, StepOneCase6)
     // -
     // [true/false]
     // ,ExpirationAction::Action
-    createThinClientRegion(regionNames[0], 0, 5, 0, 0, 5, 10, 3, true, true,
+    createThinClientRegion(regionNames[0], std::chrono::seconds(0),
+                           std::chrono::seconds(5), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 5, 10, 3, true, true,
                            ExpirationAction::LOCAL_INVALIDATE);
   }
 END_TASK(StepOneCase6)
@@ -628,7 +663,9 @@ DUNIT_TASK(CLIENT2, StepTwoCase6)
     // -
     // [true/false]
     // ,ExpirationAction::Action
-    createThinClientRegion(regionNames[0], 0, 0, 0, 0, 0, 10, 3);
+    createThinClientRegion(regionNames[0], std::chrono::seconds(0),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 0, 10, 3);
   }
 END_TASK(StepTwoCase6)
 DUNIT_TASK(CLIENT1, StepThreeCase6)
@@ -655,29 +692,8 @@ DUNIT_TASK(CLIENT2, StepFourCase6)
   {
     doRgnOperations(regionNames[0], 10, 5);
     auto n = getNumOfEntries(regionNames[0]);
-    ASSERT(n == 10,
-           "Ex"
-           "pe"
-           "ct"
-           "ed"
-           " 1"
-           "0 "
-           "en"
-           "tr"
-           "ie"
-           "s");
-    LOG("St"
-        "ep"
-        "Fo"
-        "ur"
-        "Ca"
-        "se"
-        "6 "
-        "co"
-        "mp"
-        "le"
-        "te"
-        ".");
+    ASSERT(n == 10, "Expected 10 entries");
+    LOG("StepFourCase6 complete.");
   }
 END_TASK(StepFourCase6)
 DUNIT_TASK(CLIENT1, StepFiveCase6)
@@ -708,7 +724,9 @@ DUNIT_TASK(CLIENT1, StepOneCase7)
     // regionName, ettl, eit , rttl, rit,lel,endpoints,noOfEntry,rgnOpetation -
     // [put-0/get-5/destroy-3] ,destroyRgn - [true/false]
     // ,clientNotificationEnabled - [true/false] ,ExpirationAction::Action
-    createThinClientRegion(regionNames[0], 0, 0, 10, 0, 0, 10, 3);
+    createThinClientRegion(regionNames[0], std::chrono::seconds(0),
+                           std::chrono::seconds(0), std::chrono::seconds(10),
+                           std::chrono::seconds(0), 0, 10, 3);
   }
 END_TASK(StepOneCase7)
 
@@ -717,7 +735,9 @@ DUNIT_TASK(CLIENT2, StepTwoCase7)
     // regionName, ettl, eit , rttl, rit,lel,endpoints,noOfEntry,rgnOpetation -
     // [put-0/get-5/destroy-3] ,destroyRgn - [true/false]
     // ,clientNotificationEnabled - [true/false] ,ExpirationAction::Action
-    createThinClientRegion(regionNames[0], 0, 0, 0, 0, 0, 10, 3);
+    createThinClientRegion(regionNames[0], std::chrono::seconds(0),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 0, 10, 3);
   }
 END_TASK(StepTwoCase7)
 DUNIT_TASK(CLIENT1, StepThreeCase7)
@@ -756,7 +776,9 @@ DUNIT_TASK(CLIENT1, StepOneCase8)
     // regionName, ettl, eit , rttl, rit,lel,endpoints,noOfEntry,rgnOpetation -
     // [put-0/get-5/destroy-3] ,destroyRgn - [true/false]
     // ,clientNotificationEnabled - [true/false] ,ExpirationAction::Action
-    createThinClientRegion(regionNames[1], 0, 0, 8, 0, 0, 0, 6, false);
+    createThinClientRegion(regionNames[1], std::chrono::seconds(0),
+                           std::chrono::seconds(0), std::chrono::seconds(8),
+                           std::chrono::seconds(0), 0, 0, 6, false);
   }
 END_TASK(StepOneCase8)
 
@@ -765,7 +787,9 @@ DUNIT_TASK(CLIENT2, StepTwoCase8)
     // regionName, ettl, eit , rttl, rit,lel,endpoints,noOfEntry,rgnOpetation -
     // [put-0/get-5/destroy-3] ,destroyRgn - [true/false]
     // ,clientNotificationEnabled - [true/false] ,ExpirationAction::Action
-    createThinClientRegion(regionNames[1], 0, 0, 0, 0, 0, 0, 6, false);
+    createThinClientRegion(regionNames[1], std::chrono::seconds(0),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 0, 0, 6, false);
   }
 END_TASK(StepTwoCase8)
 DUNIT_TASK(CLIENT1, StepThreeCase8)
@@ -806,7 +830,9 @@ DUNIT_TASK(CLIENT1, StepOneCase9)
     // regionName, ettl, eit , rttl, rit,lel,endpoints,noOfEntry,rgnOpetation -
     // [put-0/get-5/destroy-3] ,destroyRgn - [true/false]
     // ,clientNotificationEnabled - [true/false] ,ExpirationAction::Action
-    createThinClientRegion(regionNames[2], 4, 0, 8, 0, 5, 0, 6, false);
+    createThinClientRegion(regionNames[2], std::chrono::seconds(4),
+                           std::chrono::seconds(0), std::chrono::seconds(8),
+                           std::chrono::seconds(0), 5, 0, 6, false);
   }
 END_TASK(StepOneCase9)
 
@@ -815,7 +841,9 @@ DUNIT_TASK(CLIENT2, StepTwoCase9)
     // regionName, ettl, eit , rttl, rit,lel,endpoints,noOfEntry,rgnOpetation -
     // [put-0/get-5/destroy-3] ,destroyRgn - [true/false]
     // ,clientNotificationEnabled - [true/false] ,ExpirationAction::Action
-    createThinClientRegion(regionNames[2], 0, 0, 0, 0, 0, 0, 6, false);
+    createThinClientRegion(regionNames[2], std::chrono::seconds(0),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 0, 0, 6, false);
   }
 END_TASK(StepTwoCase9)
 DUNIT_TASK(CLIENT1, StepThreeCase9)
@@ -857,7 +885,9 @@ DUNIT_TASK(CLIENT1, StepOneCase10)
     // regionName, ettl, eit , rttl, rit,lel,endpoints,noOfEntry,rgnOpetation -
     // [put-0/get-5/destroy-3] ,destroyRgn - [true/false]
     // ,clientNotificationEnabled - [true/false] ,ExpirationAction::Action
-    createThinClientRegion(regionNames[3], 4, 0, 0, 8, 5, 0, 6, false);
+    createThinClientRegion(regionNames[3], std::chrono::seconds(4),
+                           std::chrono::seconds(0), std::chrono::seconds(8),
+                           std::chrono::seconds(0), 5, 0, 6, false);
   }
 END_TASK(StepOneCase10)
 
@@ -866,7 +896,9 @@ DUNIT_TASK(CLIENT2, StepTwoCase10)
     // regionName, ettl, eit , rttl, rit,lel,endpoints,noOfEntry,rgnOpetation -
     // [put-0/get-5/destroy-3] ,destroyRgn - [true/false]
     // ,clientNotificationEnabled - [true/false] ,ExpirationAction::Action
-    createThinClientRegion(regionNames[3], 0, 0, 0, 0, 0, 0, 6, false);
+    createThinClientRegion(regionNames[3], std::chrono::seconds(0),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 0, 0, 6, false);
   }
 END_TASK(StepTwoCase10)
 DUNIT_TASK(CLIENT1, StepThreeCase10)
@@ -909,7 +941,9 @@ DUNIT_TASK(CLIENT1, StepOneCase11)
     // regionName, ettl, eit , rttl, rit,lel,endpoints,noOfEntry,rgnOpetation -
     // [put-0/get-5/destroy-3] ,destroyRgn - [true/false]
     // ,clientNotificationEnabled - [true/false] ,ExpirationAction::Action
-    createThinClientRegion(regionNames[4], 4, 0, 0, 0, 5, 0, 6, false);
+    createThinClientRegion(regionNames[4], std::chrono::seconds(4),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 5, 0, 6, false);
     regListener = std::make_shared<TallyListener>();
     regWriter = std::make_shared<TallyWriter>();
     setCacheListener(regionNames[4], regListener);
@@ -922,7 +956,9 @@ DUNIT_TASK(CLIENT2, StepTwoCase11)
     // regionName, ettl, eit , rttl, rit,lel,endpoints,noOfEntry,rgnOpetation -
     // [put-0/get-5/destroy-3] ,destroyRgn - [true/false]
     // ,clientNotificationEnabled - [true/false] ,ExpirationAction::Action
-    createThinClientRegion(regionNames[4], 0, 0, 0, 0, 0, 0, 6, false);
+    createThinClientRegion(regionNames[4], std::chrono::seconds(0),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 0, 0, 6, false);
     regListener = std::make_shared<TallyListener>();
     regWriter = std::make_shared<TallyWriter>();
     setCacheListener(regionNames[4], regListener);
@@ -1044,7 +1080,9 @@ DUNIT_TASK(CLIENT1, StepOneCase12)
     // regionName, ettl, eit , rttl, rit,lel,endpoints,noOfEntry,rgnOpetation -
     // [put-0/get-5/destroy-3] ,destroyRgn - [true/false]
     // ,clientNotificationEnabled - [true/false] ,ExpirationAction::Action
-    createThinClientRegion(regionNames[5], 4, 0, 0, 0, 5, 0, 6, false);
+    createThinClientRegion(regionNames[5], std::chrono::seconds(4),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 5, 0, 6, false);
     regListener = std::make_shared<TallyListener>();
     regWriter = std::make_shared<TallyWriter>();
     setCacheListener(regionNames[5], regListener);
@@ -1057,7 +1095,9 @@ DUNIT_TASK(CLIENT2, StepTwoCase12)
     // regionName, ettl, eit , rttl, rit,lel,endpoints,noOfEntry,rgnOpetation -
     // [put-0/get-5/destroy-3] ,destroyRgn - [true/false]
     // ,clientNotificationEnabled - [true/false] ,ExpirationAction::Action
-    createThinClientRegion(regionNames[5], 0, 0, 0, 0, 0, 0, 6, false);
+    createThinClientRegion(regionNames[5], std::chrono::seconds(0),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 0, 0, 6, false);
     regListener = std::make_shared<TallyListener>();
     regWriter = std::make_shared<TallyWriter>();
     setCacheListener(regionNames[5], regListener);
@@ -1140,7 +1180,9 @@ DUNIT_TASK(CLIENT1, StepOneCase13)
     // ,clientNotificationEnabled - [true/false] ,ExpirationAction::Action
     initClient(true);
     getHelper()->createPoolWithLocators("LRUPool", locatorsG, true);
-    createThinClientRegion(regionNames[5], 4, 0, 0, 0, 5, 0, 6, false);
+    createThinClientRegion(regionNames[5], std::chrono::seconds(4),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 5, 0, 6, false);
     regListener = std::make_shared<TallyListener>();
     regWriter = std::make_shared<TallyWriter>();
     setCacheListener(regionNames[5], regListener);
@@ -1155,7 +1197,9 @@ DUNIT_TASK(CLIENT2, StepTwoCase13)
     // ,clientNotificationEnabled - [true/false] ,ExpirationAction::Action
     initClient(true);
     getHelper()->createPoolWithLocators("LRUPool", locatorsG, true);
-    createThinClientRegion(regionNames[5], 0, 0, 0, 0, 0, 0, 6, false);
+    createThinClientRegion(regionNames[5], std::chrono::seconds(0),
+                           std::chrono::seconds(0), std::chrono::seconds(0),
+                           std::chrono::seconds(0), 0, 0, 6, false);
     regListener = std::make_shared<TallyListener>();
     regWriter = std::make_shared<TallyWriter>();
     setCacheListener(regionNames[5], regListener);
diff --git a/cppcache/integration-test/testThinClientPRSingleHop.cpp b/cppcache/integration-test/testThinClientPRSingleHop.cpp
index e2095e32..66d01b72 100644
--- a/cppcache/integration-test/testThinClientPRSingleHop.cpp
+++ b/cppcache/integration-test/testThinClientPRSingleHop.cpp
@@ -14,6 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 #include <string>
 
 #include <ace/OS.h>
@@ -272,12 +273,10 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepOne_Pooled_LocatorTL)
     initClient(true);
 
     RegionPtr regPtr = getHelper()->createPooledRegionStickySingleHop(
-        regionNames[0], USE_ACK, nullptr, locatorsG, "__TEST_POOL1__", false,
-        false);
+        regionNames[0], USE_ACK, locatorsG, "__TEST_POOL1__", false, false);
     ASSERT(regPtr != nullptr, "Failed to create region.");
     regPtr = getHelper()->createPooledRegionStickySingleHop(
-        regionNames[1], NO_ACK, nullptr, locatorsG, "__TEST_POOL1__", false,
-        false);
+        regionNames[1], NO_ACK, locatorsG, "__TEST_POOL1__", false, false);
     ASSERT(regPtr != nullptr, "Failed to create region.");
 
     LOG("StepOne_Pooled_LocatorTL complete.");
diff --git a/cppcache/integration-test/testThinClientPRSingleHopServerGroup.cpp b/cppcache/integration-test/testThinClientPRSingleHopServerGroup.cpp
index 0c5bd5ad..1614babc 100644
--- a/cppcache/integration-test/testThinClientPRSingleHopServerGroup.cpp
+++ b/cppcache/integration-test/testThinClientPRSingleHopServerGroup.cpp
@@ -60,7 +60,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepOne_Pooled_Locator1)
   {
     initClient(true);
     getHelper()->createPoolWithLocators("__TEST_POOL1__", locatorsG, false, -1,
-                                        -1, -1, false, group1);
+                                        std::chrono::seconds::zero(), -1, false,
+                                        group1);
     getHelper()->createRegionAndAttachPool(regionNames[0], USE_ACK,
                                            "__TEST_POOL1__", false);
     LOG("StepOne_Pooled_Locator1 complete.");
@@ -71,7 +72,8 @@ DUNIT_TASK_DEFINITION(CLIENT2, StepOne_Pooled_Locator2)
   {
     initClient(true);
     getHelper()->createPoolWithLocators("__TEST_POOL2__", locatorsG, false, -1,
-                                        -1, -1, false, group2);
+                                        std::chrono::seconds::zero(), -1, false,
+                                        group2);
     getHelper()->createRegionAndAttachPool(regionNames[0], USE_ACK,
                                            "__TEST_POOL2__", false);
     LOG("StepOne_Pooled_Locator2 complete.");
@@ -82,7 +84,8 @@ DUNIT_TASK_DEFINITION(CLIENT3, StepOne_Pooled_Locator3)
   {
     initClient(true);
     getHelper()->createPoolWithLocators("__TEST_POOL3__", locatorsG, false, -1,
-                                        -1, -1, false, group3);
+                                        std::chrono::seconds::zero(), -1, false,
+                                        group3);
     getHelper()->createRegionAndAttachPool(regionNames[0], USE_ACK,
                                            "__TEST_POOL3__", false);
     LOG("StepOne_Pooled_Locator3 complete.");
diff --git a/cppcache/integration-test/testThinClientPdxDeltaWithNotification.cpp b/cppcache/integration-test/testThinClientPdxDeltaWithNotification.cpp
index 2dc2dd57..a33f2298 100644
--- a/cppcache/integration-test/testThinClientPdxDeltaWithNotification.cpp
+++ b/cppcache/integration-test/testThinClientPdxDeltaWithNotification.cpp
@@ -14,12 +14,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-/*
- * testThinClientPdxDeltaWithNotification.cpp
- *
- *  Created on: May 8, 2009
- *      Author: abhaware
- */
 
 #define ROOT_NAME "testThinClientPdxDeltaWithNotification"
 
@@ -96,8 +90,9 @@ void createPooledExpirationRegion(const char* name, const char* poolname) {
   LOG("createPooledExpirationRegion() entered.");
   // Entry time-to-live = 1 second.
   RegionPtr regPtr = getHelper()->createPooledRegionDiscOverFlow(
-      name, true, locatorsG, poolname, true, true, 1, 0, 0, 0, 0, nullptr,
-      ExpirationAction::LOCAL_INVALIDATE);
+      name, true, locatorsG, poolname, true, true, std::chrono::seconds(1),
+      std::chrono::seconds(0), std::chrono::seconds(0), std::chrono::seconds(0),
+      0, nullptr, ExpirationAction::LOCAL_INVALIDATE);
 }
 
 void createPooledLRURegion(const char* name, bool ackMode, const char* locators,
@@ -107,7 +102,9 @@ void createPooledLRURegion(const char* name, bool ackMode, const char* locators,
   LOG(" createPooledLRURegion entered");
   RegionPtr regPtr = getHelper()->createPooledRegionDiscOverFlow(
       name, ackMode, locators, poolname, cachingEnable,
-      clientNotificationEnabled, 0, 0, 0, 0, 3 /*LruLimit = 3*/);
+      clientNotificationEnabled, std::chrono::seconds(0),
+      std::chrono::seconds(0), std::chrono::seconds(0), std::chrono::seconds(0),
+      3 /*LruLimit = 3*/);
   LOG(" createPooledLRURegion exited");
 }
 
@@ -127,8 +124,9 @@ void createLRURegion(const char* name, bool clientNotificationEnabled = false,
                      bool cachingEnable = true) {
   LOG(" createPooledLRURegion entered");
   RegionPtr regPtr = getHelper()->createRegionDiscOverFlow(
-      name, cachingEnable, clientNotificationEnabled, 0, 0, 0, 0,
-      3 /*LruLimit = 3*/);
+      name, cachingEnable, clientNotificationEnabled,
+      std::chrono::seconds::zero(), std::chrono::seconds(0),
+      std::chrono::seconds(0), std::chrono::seconds(0), 3 /*LruLimit = 3*/);
   LOG(" createPooledLRURegion exited");
 }
 
@@ -137,8 +135,9 @@ void createExpirationRegion(const char* name,
                             bool cachingEnable = true) {
   LOG(" createPooledLRURegion entered");
   RegionPtr regPtr = getHelper()->createRegionDiscOverFlow(
-      name, cachingEnable, clientNotificationEnabled, 1, 0, 0, 0, 0,
-      ExpirationAction::LOCAL_INVALIDATE);
+      name, cachingEnable, clientNotificationEnabled, std::chrono::seconds(1),
+      std::chrono::seconds(0), std::chrono::seconds(0), std::chrono::seconds(0),
+      0, ExpirationAction::LOCAL_INVALIDATE);
   LOG(" createPooledLRURegion exited");
 }
 
diff --git a/cppcache/integration-test/testThinClientPdxTests.cpp b/cppcache/integration-test/testThinClientPdxTests.cpp
index 06560e3f..ca7621f6 100644
--- a/cppcache/integration-test/testThinClientPdxTests.cpp
+++ b/cppcache/integration-test/testThinClientPdxTests.cpp
@@ -2346,7 +2346,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, generateJavaPdxType)
 
     ResultCollectorPtr collector = funcExec->withArgs(args)
                                        ->withFilter(routingObj)
-                                       ->execute("ComparePdxTypes", true);
+                                       ->execute("ComparePdxTypes");
     ASSERT(collector != nullptr, "onRegion collector nullptr");
 
     CacheableVectorPtr result = collector->getResult();
@@ -2513,7 +2513,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, verifyDotNetPdxTypes)
 
     ResultCollectorPtr collector = funcExec->withArgs(args)
                                        ->withFilter(routingObj)
-                                       ->execute("ComparePdxTypes", true);
+                                       ->execute("ComparePdxTypes");
     ASSERT(collector != nullptr, "onRegion collector nullptr");
 
     CacheableVectorPtr result = collector->getResult();
@@ -2620,7 +2620,7 @@ DUNIT_TASK_DEFINITION(CLIENT3, client3GetsV2Object)
 
     ExecutionPtr funcExec = FunctionService::onRegion(regPtr0);
 
-    ResultCollectorPtr collector = funcExec->execute("IterateRegion", true);
+    ResultCollectorPtr collector = funcExec->execute("IterateRegion");
     ASSERT(collector != nullptr, "onRegion collector nullptr");
 
     CacheableVectorPtr result = collector->getResult();
diff --git a/cppcache/integration-test/testThinClientPoolAttrTest.cpp b/cppcache/integration-test/testThinClientPoolAttrTest.cpp
index c6009695..5d72831f 100644
--- a/cppcache/integration-test/testThinClientPoolAttrTest.cpp
+++ b/cppcache/integration-test/testThinClientPoolAttrTest.cpp
@@ -73,22 +73,23 @@ class putThread : public ACE_Task_Base {
 void doAttrTestingAndCreatePool(const char* poolName) {
   PoolFactoryPtr poolFacPtr =
       getHelper()->getCache()->getPoolManager().createFactory();
-  poolFacPtr->setFreeConnectionTimeout(10000);
-  poolFacPtr->setLoadConditioningInterval(60000);
+  poolFacPtr->setFreeConnectionTimeout(std::chrono::milliseconds(10000));
+  poolFacPtr->setLoadConditioningInterval(std::chrono::milliseconds(60000));
   poolFacPtr->setSocketBufferSize(1024);
-  poolFacPtr->setReadTimeout(10000);
+  poolFacPtr->setReadTimeout(std::chrono::milliseconds(10000));
   poolFacPtr->setMinConnections(4);
   poolFacPtr->setMaxConnections(8);
-  poolFacPtr->setIdleTimeout(5000);
+  poolFacPtr->setIdleTimeout(std::chrono::seconds(5));
   poolFacPtr->setRetryAttempts(5);
-  poolFacPtr->setPingInterval(120000);
-  poolFacPtr->setUpdateLocatorListInterval(122000);
-  poolFacPtr->setStatisticInterval(120000);
+  poolFacPtr->setPingInterval(std::chrono::milliseconds(120000));
+  poolFacPtr->setUpdateLocatorListInterval(std::chrono::milliseconds(122000));
+  poolFacPtr->setStatisticInterval(std::chrono::milliseconds(120000));
   poolFacPtr->setServerGroup(serverGroup);
   poolFacPtr->setSubscriptionEnabled(true);
   poolFacPtr->setSubscriptionRedundancy(1);
-  poolFacPtr->setSubscriptionMessageTrackingTimeout(500000);
-  poolFacPtr->setSubscriptionAckInterval(120000);
+  poolFacPtr->setSubscriptionMessageTrackingTimeout(
+      std::chrono::milliseconds(500000));
+  poolFacPtr->setSubscriptionAckInterval(std::chrono::milliseconds(120000));
   poolFacPtr->addLocator("localhost", CacheHelper::staticLocatorHostPort1);
   // poolFacPtr->setMultiuserSecurityMode(true);
   poolFacPtr->setPRSingleHopEnabled(false);
@@ -96,22 +97,26 @@ void doAttrTestingAndCreatePool(const char* poolName) {
   PoolPtr pptr = poolFacPtr->create(poolName);
 
   // Validate the attributes
-  ASSERT(pptr->getFreeConnectionTimeout() == 10000,
+  ASSERT(pptr->getFreeConnectionTimeout() == std::chrono::milliseconds(10000),
          "FreeConnectionTimeout Should have been 10000");
-  ASSERT(pptr->getLoadConditioningInterval() == 60000,
-         "LoadConditioningInterval Should have been 60000");
+  ASSERT(
+      pptr->getLoadConditioningInterval() == std::chrono::milliseconds(60000),
+      "LoadConditioningInterval Should have been 60000");
   ASSERT(pptr->getSocketBufferSize() == 1024,
          "SocketBufferSize Should have been 1024");
-  ASSERT(pptr->getReadTimeout() == 10000, "ReadTimeout Should have been 10000");
+  ASSERT(pptr->getReadTimeout() == std::chrono::milliseconds(10000),
+         "ReadTimeout Should have been 10000");
   ASSERT(pptr->getMinConnections() == 4, "MinConnections Should have been 4");
   ASSERT(pptr->getMaxConnections() == 8, "MaxConnections Should have been 8");
-  ASSERT(pptr->getIdleTimeout() == 5000, "IdleTimeout Should have been 5000");
+  ASSERT(pptr->getIdleTimeout() == std::chrono::seconds(5),
+         "IdleTimeout Should have been 5s");
   ASSERT(pptr->getRetryAttempts() == 5, "RetryAttempts Should have been 5");
-  ASSERT(pptr->getPingInterval() == 120000,
+  ASSERT(pptr->getPingInterval() == std::chrono::milliseconds(120000),
          "PingInterval Should have been 120000");
-  ASSERT(pptr->getUpdateLocatorListInterval() == 122000,
-         "UpdateLocatorListInterval Should have been 122000");
-  ASSERT(pptr->getStatisticInterval() == 120000,
+  ASSERT(
+      pptr->getUpdateLocatorListInterval() == std::chrono::milliseconds(122000),
+      "UpdateLocatorListInterval Should have been 122000");
+  ASSERT(pptr->getStatisticInterval() == std::chrono::milliseconds(120000),
          "StatisticInterval Should have been 120000");
   ASSERT(strcmp(pptr->getServerGroup(), "ServerGroup1") == 0,
          "ServerGroup Should have been ServerGroup1");
@@ -119,10 +124,12 @@ void doAttrTestingAndCreatePool(const char* poolName) {
          "SubscriptionEnabled Should have been true");
   ASSERT(pptr->getSubscriptionRedundancy() == 1,
          "SubscriptionRedundancy Should have been 1");
-  ASSERT(pptr->getSubscriptionMessageTrackingTimeout() == 500000,
+  ASSERT(pptr->getSubscriptionMessageTrackingTimeout() ==
+             std::chrono::milliseconds(500000),
          "SubscriptionMessageTrackingTimeout Should have been 500000");
-  ASSERT(pptr->getSubscriptionAckInterval() == 120000,
-         "SubscriptionAckInterval Should have been 120000");
+  ASSERT(
+      pptr->getSubscriptionAckInterval() == std::chrono::milliseconds(120000),
+      "SubscriptionAckInterval Should have been 120000");
   // ASSERT(pptr->getMultiuserSecurityMode()==true,"SetMultiuserSecurityMode
   // Should have been true");
   ASSERT(pptr->getPRSingleHopEnabled() == false,
@@ -136,21 +143,25 @@ void doAttrTesting(const char* poolName1) {
 
   ASSERT(strcmp(pptr->getName(), "clientPool") == 0,
          "Pool name should have been clientPool");
-  ASSERT(pptr->getFreeConnectionTimeout() == 10000,
+  ASSERT(pptr->getFreeConnectionTimeout() == std::chrono::milliseconds(10000),
          "FreeConnectionTimeout Should have been 10000");
-  ASSERT(pptr->getLoadConditioningInterval() == 1,
+  ASSERT(pptr->getLoadConditioningInterval() == std::chrono::seconds(1),
          "LoadConditioningInterval Should have been 1");
   ASSERT(pptr->getSocketBufferSize() == 1024,
          "SocketBufferSize Should have been 1024");
-  ASSERT(pptr->getReadTimeout() == 10, "ReadTimeout Should have been 10");
+  ASSERT(pptr->getReadTimeout() == std::chrono::seconds(10),
+         "ReadTimeout Should have been 10");
   ASSERT(pptr->getMinConnections() == 2, "MinConnections Should have been 2");
   ASSERT(pptr->getMaxConnections() == 5, "MaxConnections Should have been 5");
-  ASSERT(pptr->getIdleTimeout() == 5, "IdleTimeout Should have been 5");
+  ASSERT(pptr->getIdleTimeout() == std::chrono::milliseconds(5),
+         "IdleTimeout Should have been 5ms");
   ASSERT(pptr->getRetryAttempts() == 5, "RetryAttempts Should have been 5");
-  ASSERT(pptr->getPingInterval() == 1, "PingInterval Should have been 1");
-  ASSERT(pptr->getUpdateLocatorListInterval() == 25000,
-         "UpdateLocatorListInterval Should have been 25000");
-  ASSERT(pptr->getStatisticInterval() == 1,
+  ASSERT(pptr->getPingInterval() == std::chrono::seconds(1),
+         "PingInterval Should have been 1");
+  ASSERT(
+      pptr->getUpdateLocatorListInterval() == std::chrono::milliseconds(25000),
+      "UpdateLocatorListInterval Should have been 25000");
+  ASSERT(pptr->getStatisticInterval() == std::chrono::seconds(1),
          "StatisticInterval Should have been 1");
   ASSERT(strcmp(pptr->getServerGroup(), "ServerGroup1") == 0,
          "ServerGroup Should have been ServerGroup1");
@@ -158,9 +169,10 @@ void doAttrTesting(const char* poolName1) {
          "SubscriptionEnabled Should have been true");
   ASSERT(pptr->getSubscriptionRedundancy() == 1,
          "SubscriptionRedundancy Should have been 1");
-  ASSERT(pptr->getSubscriptionMessageTrackingTimeout() == 5,
-         "SubscriptionMessageTrackingTimeout Should have been 5");
-  ASSERT(pptr->getSubscriptionAckInterval() == 1,
+  ASSERT(
+      pptr->getSubscriptionMessageTrackingTimeout() == std::chrono::seconds(5),
+      "SubscriptionMessageTrackingTimeout Should have been 5");
+  ASSERT(pptr->getSubscriptionAckInterval() == std::chrono::seconds(1),
          "SubscriptionAckInterval Should have been 1");
   ASSERT(pptr->getPRSingleHopEnabled() == false,
          "PRSingleHopEnabled should have been false");
@@ -188,9 +200,9 @@ END_TASK(StartS12)
 DUNIT_TASK(CLIENT1, StartC1)
   {
     PropertiesPtr props = Properties::create();
-    props->insert("redundancy-monitor-interval", "120");
+    props->insert("redundancy-monitor-interval", "120s");
     props->insert("statistic-sampling-enabled", "false");
-    props->insert("statistic-sample-rate", "120");
+    props->insert("statistic-sample-rate", "120s");
 
     initClient(true, props);
 
diff --git a/cppcache/integration-test/testThinClientPoolExecuteFunction.cpp b/cppcache/integration-test/testThinClientPoolExecuteFunction.cpp
index 9d3422b0..fc582fe4 100644
--- a/cppcache/integration-test/testThinClientPoolExecuteFunction.cpp
+++ b/cppcache/integration-test/testThinClientPoolExecuteFunction.cpp
@@ -22,6 +22,8 @@
 
 #include <ace/ACE.h>
 
+#include <geode/DefaultResultCollector.hpp>
+
 using namespace PdxTests;
 /* This is to test
 1- funtion execution on pool
@@ -110,57 +112,46 @@ char* FETimeOut = (char*)"FunctionExecutionTimeOut";
     }                                        \
   }                                          \
   ASSERT(found, "this returned value is invalid");
-class MyResultCollector : public ResultCollector {
+
+class MyResultCollector : public DefaultResultCollector {
  public:
   MyResultCollector()
-      : m_resultList(CacheableVector::create()),
-        m_isResultReady(false),
+      : DefaultResultCollector(),
         m_endResultCount(0),
         m_addResultCount(0),
         m_getResultCount(0) {}
   ~MyResultCollector() {}
-  CacheableVectorPtr getResult(uint32_t timeout) {
+
+  CacheableVectorPtr getResult(std::chrono::milliseconds timeout) override {
     m_getResultCount++;
-    if (m_isResultReady == true) {
-      return m_resultList;
-    } else {
-      for (uint32_t i = 0; i < timeout; i++) {
-        SLEEP(1);
-        if (m_isResultReady == true) return m_resultList;
-      }
-      throw FunctionExecutionException(
-          "Result is not ready, endResults callback is called before invoking "
-          "getResult() method");
-    }
+    return DefaultResultCollector::getResult(timeout);
   }
 
-  void addResult(const CacheablePtr& resultItem) {
+  void addResult(const CacheablePtr& resultItem) override {
     m_addResultCount++;
     if (resultItem == nullptr) {
       return;
     }
-    if (auto result =
+    if (auto results =
             std::dynamic_pointer_cast<CacheableArrayList>(resultItem)) {
-      for (int32_t i = 0; i < result->size(); i++) {
-        m_resultList->push_back(result->operator[](i));
+      for (auto& result : *results) {
+        DefaultResultCollector::addResult(result);
       }
     } else {
-      auto ex =
-          std::dynamic_pointer_cast<UserFunctionExecutionException>(resultItem);
-      m_resultList->push_back(ex);
+      DefaultResultCollector::addResult(resultItem);
     }
   }
-  void endResults() {
-    m_isResultReady = true;
+
+  void endResults() override {
     m_endResultCount++;
+    DefaultResultCollector::endResults();
   }
+
   uint32_t getEndResultCount() { return m_endResultCount; }
   uint32_t getAddResultCount() { return m_addResultCount; }
   uint32_t getGetResultCount() { return m_getResultCount; }
 
  private:
-  CacheableVectorPtr m_resultList;
-  volatile bool m_isResultReady;
   uint32_t m_endResultCount;
   uint32_t m_addResultCount;
   uint32_t m_getResultCount;
@@ -271,7 +262,6 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
     SLEEP(10000);  // let the put finish
     try {
       CacheablePtr args = CacheableBoolean::create(1);
-      bool getResult = true;
       auto routingObj = CacheableVector::create();
       for (int i = 0; i < 34; i++) {
         if (i % 2 == 0) continue;
@@ -290,7 +280,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       auto exe2 = exe1->withArgs(args1);
 
       auto resultList = CacheableVector::create();
-      auto executeFunctionResult = exe1->execute(rjFuncName, 15)->getResult();
+      auto executeFunctionResult =
+          exe1->execute(rjFuncName, std::chrono::seconds(15))->getResult();
       if (executeFunctionResult == nullptr) {
         ASSERT(false, "echo String : executeFunctionResult is nullptr");
       } else {
@@ -306,15 +297,17 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
           FAIL("echo String : wrong argument type");
         }
       }
-      executeFunctionResult = exc->withFilter(routingObj)
-                                  ->withArgs(args)
-                                  ->execute(exFuncName, 15)
-                                  ->getResult();
+      executeFunctionResult =
+          exc->withFilter(routingObj)
+              ->withArgs(args)
+              ->execute(exFuncName, std::chrono::seconds(15))
+              ->getResult();
 
-      executeFunctionResult = exc->withFilter(routingObj)
-                                  ->withArgs(args)
-                                  ->execute(rjFuncName, 15)
-                                  ->getResult();
+      executeFunctionResult =
+          exc->withFilter(routingObj)
+              ->withArgs(args)
+              ->execute(rjFuncName, std::chrono::seconds(15))
+              ->getResult();
       if (executeFunctionResult == nullptr) {
         ASSERT(false, "echo String : executeFunctionResult is nullptr");
       } else {
@@ -328,10 +321,11 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
         ASSERT(strcmp("echoString", str) == 0, "echoString is not eched back");
       }
       args = CacheableKey::create("echoBoolean");
-      executeFunctionResult = exc->withFilter(routingObj)
-                                  ->withArgs(args)
-                                  ->execute(rjFuncName, 15)
-                                  ->getResult();
+      executeFunctionResult =
+          exc->withFilter(routingObj)
+              ->withArgs(args)
+              ->execute(rjFuncName, std::chrono::seconds(15))
+              ->getResult();
       if (executeFunctionResult == nullptr) {
         ASSERT(false, "echo Boolean: executeFunctionResult is nullptr");
       } else {
@@ -347,7 +341,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
 
       executeFunctionResult = exc->withFilter(routingObj)
                                   ->withArgs(args)
-                                  ->execute(getFuncName, getResult)
+                                  ->execute(getFuncName)
                                   ->getResult();
       /****
        **decomposed from above long expression:
@@ -403,7 +397,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       executeFunctionResult = exc->withFilter(routingObj)
                                   ->withArgs(args)
                                   ->withCollector(myRC)
-                                  ->execute(getFuncName, getResult)
+                                  ->execute(getFuncName)
                                   ->getResult();
       sprintf(buf, "add result count = %d", myRC->getAddResultCount());
       LOG(buf);
@@ -440,8 +434,9 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
         }
       }
       //     test put function without result
-      getResult = false;
-      exc->withFilter(routingObj)->withArgs(args)->execute(putFuncName, 15);
+      exc->withFilter(routingObj)
+          ->withArgs(args)
+          ->execute(putFuncName, std::chrono::seconds(15));
       SLEEP(10000);  // let the put finish
       for (int i = 0; i < 34; i++) {
         if (i % 2 == 0) continue;
@@ -455,11 +450,11 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       }
 
       args = routingObj;
-      getResult = true;
-      executeFunctionResult = exc->withArgs(args)
-                                  ->withFilter(routingObj)
-                                  ->execute(getFuncName, 15)
-                                  ->getResult();
+      executeFunctionResult =
+          exc->withArgs(args)
+              ->withFilter(routingObj)
+              ->execute(getFuncName, std::chrono::seconds(15))
+              ->getResult();
 
       if (executeFunctionResult == nullptr) {
         ASSERT(false, "get executeFunctionResult is nullptr");
@@ -523,13 +518,12 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       LOG("Adding filter done.");
 
       args = CacheableBoolean::create(1);
-      getResult = true;
 
       auto funcExec = FunctionService::onRegion(regPtr0);
       ASSERT(funcExec != nullptr, "onRegion Returned nullptr");
 
       auto collector = funcExec->withArgs(args)->withFilter(filter)->execute(
-          exFuncNameSendException, 15);
+          exFuncNameSendException, std::chrono::seconds(15));
       ASSERT(collector != nullptr, "onRegion collector nullptr");
 
       auto result = collector->getResult();
@@ -547,7 +541,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       LOG("exFuncNameSendException done for bool arguement.");
 
       collector = funcExec->withArgs(arrList)->withFilter(filter)->execute(
-          exFuncNameSendException, 15);
+          exFuncNameSendException, std::chrono::seconds(15));
       ASSERT(collector != nullptr, "onRegion collector for arrList nullptr");
 
       result = collector->getResult();
@@ -569,7 +563,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
 
       args = CacheableString::create("Multiple");
       collector = funcExec->withArgs(args)->withFilter(filter)->execute(
-          exFuncNameSendException, 15);
+          exFuncNameSendException, std::chrono::seconds(15));
       ASSERT(collector != nullptr, "onRegion collector for string nullptr");
       result = collector->getResult();
       LOGINFO("result->size() for Multiple String = %d ", result->size());
@@ -596,7 +590,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       result = funcExec->withArgs(args)
                    ->withFilter(filter)
                    ->withCollector(myRC1)
-                   ->execute(exFuncNameSendException, getResult)
+                   ->execute(exFuncNameSendException)
                    ->getResult();
       LOGINFO("add result count = %d", myRC1->getAddResultCount());
       LOGINFO("end result count = %d", myRC1->getEndResultCount());
@@ -631,7 +625,6 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
 
       // test data independant function
       //     test get function with result
-      getResult = true;
       args = routingObj;
       // ExecutionPtr exc=nullptr;
       // CacheableVectorPtr executeFunctionResult = nullptr;
@@ -639,7 +632,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       LOG("test data independant get function on one server");
       exc = FunctionService::onServer(getHelper()->cachePtr);
       executeFunctionResult =
-          exc->withArgs(args)->execute(getFuncIName, getResult)->getResult();
+          exc->withArgs(args)->execute(getFuncIName)->getResult();
       if (executeFunctionResult == nullptr) {
         ASSERT(false, "get executeFunctionResult is nullptr");
       } else {
@@ -671,8 +664,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       }
       LOG("test data independant put function on one server");
       //     test put function without result
-      getResult = false;
-      exc->withArgs(args)->execute(putFuncIName, 15);
+      exc->withArgs(args)->execute(putFuncIName, std::chrono::seconds(15));
       SLEEP(500);  // let the put finish
       for (int i = 0; i < 34; i++) {
         if (i % 2 == 0) continue;
@@ -691,7 +683,6 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       //-----------------------Test with PdxObject
       // onServers-------------------------------//
 
-      getResult = true;
       try {
         SerializationRegistryPtr serializationRegistry =
             CacheRegionHelper::getCacheImpl(cacheHelper->getCache().get())
@@ -719,10 +710,9 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       }
 
       auto pdxExc = FunctionService::onServers(getHelper()->cachePtr);
-      auto executeFunctionResultPdx =
-          pdxExc->withArgs(pdxRoutingObj)
-              ->execute(exFuncNamePdxType, getResult)
-              ->getResult();
+      auto executeFunctionResultPdx = pdxExc->withArgs(pdxRoutingObj)
+                                          ->execute(exFuncNamePdxType)
+                                          ->getResult();
       LOGINFO("FE on pdxObject done");
       if (executeFunctionResultPdx == nullptr) {
         ASSERT(false, "get executeFunctionResultPdx is nullptr");
@@ -792,7 +782,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       auto pdxInstanceExc = FunctionService::onServers(getHelper()->cachePtr);
       auto executeFunctionResultPdxInstance =
           pdxInstanceExc->withArgs(pdxInstanceRoutingObj)
-              ->execute(exFuncNamePdxType, getResult)
+              ->execute(exFuncNamePdxType)
               ->getResult();
       LOGINFO("FE on pdxObject done");
       if (executeFunctionResultPdxInstance == nullptr) {
@@ -861,10 +851,9 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       SLEEP(60000);  // let this servers gets all the data
 
       //---------------------------------------------------------------------
-      getResult = true;
       exc = FunctionService::onServers(getHelper()->cachePtr);
       executeFunctionResult =
-          exc->withArgs(args)->execute(getFuncIName, getResult)->getResult();
+          exc->withArgs(args)->execute(getFuncIName)->getResult();
       if (executeFunctionResult == nullptr) {
         ASSERT(false, "get executeFunctionResult is nullptr");
       } else {
@@ -898,8 +887,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       LOG("test data independant put function on all servers");
       // test data independant function on all servers
       // test put
-      getResult = false;
-      exc->withArgs(args)->execute(putFuncIName, 15);
+      exc->withArgs(args)->execute(putFuncIName, std::chrono::seconds(15));
       SLEEP(10000);  // let the put finish
       for (int i = 0; i < 34; i++) {
         if (i % 2 == 0) continue;
@@ -915,11 +903,10 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       // onServers-------------------------------//
       LOG("OnServers with sendException");
       args = CacheableBoolean::create(1);
-      getResult = true;
       funcExec = FunctionService::onServers(getHelper()->cachePtr);
 
-      collector =
-          funcExec->withArgs(args)->execute(exFuncNameSendException, 15);
+      collector = funcExec->withArgs(args)->execute(exFuncNameSendException,
+                                                    std::chrono::seconds(15));
       ASSERT(collector != nullptr, "onServers collector for bool nullptr");
 
       result = collector->getResult();
@@ -936,8 +923,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
         }
       }
 
-      collector =
-          funcExec->withArgs(arrList)->execute(exFuncNameSendException, 15);
+      collector = funcExec->withArgs(arrList)->execute(
+          exFuncNameSendException, std::chrono::seconds(15));
       ASSERT(collector != nullptr, "onServers collector for arrList nullptr");
 
       result = collector->getResult();
@@ -963,8 +950,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       LOG("exFuncNameSendException for string arguement.");
 
       args = CacheableString::create("Multiple");
-      collector =
-          funcExec->withArgs(args)->execute(exFuncNameSendException, 15);
+      collector = funcExec->withArgs(args)->execute(exFuncNameSendException,
+                                                    std::chrono::seconds(15));
       ASSERT(collector != nullptr, "onServers collector for string nullptr");
 
       result = collector->getResult();
@@ -987,7 +974,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       auto myRC2 = std::make_shared<MyResultCollector>();
       result = funcExec->withArgs(args)
                    ->withCollector(myRC2)
-                   ->execute(exFuncNameSendException, getResult)
+                   ->execute(exFuncNameSendException)
                    ->getResult();
       ASSERT(3 == myRC2->getAddResultCount(), "add result count is not 3");
       ASSERT(1 == myRC2->getEndResultCount(), "end result count is not 1");
@@ -1033,14 +1020,15 @@ END_TASK_DEFINITION
 
 DUNIT_TASK_DEFINITION(CLIENT1, Client2OpTest)
   {
+    std::chrono::milliseconds timeout = std::chrono::seconds{15};
     auto regPtr0 = getHelper()->getRegion(poolRegNames[0]);
     char buf[128];
     SLEEP(10000);
     try {
       LOGINFO("FETimeOut begin onRegion");
       auto RexecutionPtr = FunctionService::onRegion(regPtr0);
-      auto fe = RexecutionPtr->withArgs(CacheableInt32::create(5000 * 1000))
-                    ->execute(FETimeOut, 5000 * 1000)
+      auto fe = RexecutionPtr->withArgs(CacheableInt32::create(timeout.count()))
+                    ->execute(FETimeOut, timeout)
                     ->getResult();
       if (fe == nullptr) {
         ASSERT(false, "functionResult is nullptr");
@@ -1059,8 +1047,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client2OpTest)
 
       LOGINFO("FETimeOut begin onServer");
       auto serverExc = FunctionService::onServer(getHelper()->cachePtr);
-      auto vec = serverExc->withArgs(CacheableInt32::create(5000 * 1000))
-                     ->execute(FETimeOut, 5000 * 1000)
+      auto vec = serverExc->withArgs(CacheableInt32::create(timeout.count()))
+                     ->execute(FETimeOut, timeout)
                      ->getResult();
       if (vec == nullptr) {
         ASSERT(false, "functionResult is nullptr");
@@ -1079,8 +1067,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client2OpTest)
 
       LOGINFO("FETimeOut begin onServers");
       auto serversExc = FunctionService::onServers(getHelper()->cachePtr);
-      auto vecs = serversExc->withArgs(CacheableInt32::create(5000 * 1000))
-                      ->execute(FETimeOut, 5000 * 1000)
+      auto vecs = serversExc->withArgs(CacheableInt32::create(timeout.count()))
+                      ->execute(FETimeOut, timeout)
                       ->getResult();
       if (vecs == nullptr) {
         ASSERT(false, "functionResult is nullptr");
@@ -1174,7 +1162,8 @@ class putThread : public ACE_Task_Base {
           auto routingObj = CacheableVector::create();
           routingObj->push_back(key);
           auto exc = FunctionService::onRegion(regPtr0);
-          exc->execute(routingObj, args, rPtr, getFuncName2, 300 /*in millis*/)
+          exc->execute(routingObj, args, rPtr, getFuncName2,
+                       std::chrono::seconds(300))
               ->getResult();
         } catch (const TimeoutException& te) {
           LOGINFO("Timeout exception occurred %s", te.getMessage());
@@ -1216,7 +1205,8 @@ void executeFunction() {
     auto routingObj = CacheableVector::create();
     routingObj->push_back(key);
     auto exc = FunctionService::onRegion(regPtr0);
-    exc->execute(routingObj, args, rPtr, getFuncName2, 300 /*in millis*/)
+    exc->execute(routingObj, args, rPtr, getFuncName2,
+                 std::chrono::seconds(300))
         ->getResult();
   }
   LOGINFO("executeFunction failureCount %d", failureCount);
diff --git a/cppcache/integration-test/testThinClientPoolExecuteFunctionDisableChunkHandlerThread.cpp b/cppcache/integration-test/testThinClientPoolExecuteFunctionDisableChunkHandlerThread.cpp
index 3fa44296..7479da00 100644
--- a/cppcache/integration-test/testThinClientPoolExecuteFunctionDisableChunkHandlerThread.cpp
+++ b/cppcache/integration-test/testThinClientPoolExecuteFunctionDisableChunkHandlerThread.cpp
@@ -137,8 +137,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, StartTestClient)
     config->insert("disable-chunk-handler-thread", "true");
     config->insert("read-timeout-unit-in-millis", "true");
     config->insert("ping-interval", "-1");
-    config->insert("bucket-wait-timeout", "2000");
-    config->insert("connect-wait-timeout", "10");
+    config->insert("bucket-wait-timeout", "2000s");
+    config->insert("connect-wait-timeout", "10s");
 
     initClientWithPool(true, nullptr, locHostPort, serverGroup, config, 0, true,
                        -1, -1, -1, true, false);
@@ -159,8 +159,8 @@ DUNIT_TASK_DEFINITION(CLIENT2, StartTestClient2)
     config->insert("disable-chunk-handler-thread", "true");
     config->insert("read-timeout-unit-in-millis", "true");
     config->insert("ping-interval", "-1");
-    config->insert("bucket-wait-timeout", "2000");
-    config->insert("connect-wait-timeout", "10");
+    config->insert("bucket-wait-timeout", "2000s");
+    config->insert("connect-wait-timeout", "10s");
 
     initClientWithPool(true, nullptr, locHostPort, serverGroup, config, 0, true,
                        -1, -1, -1, true, false);
@@ -226,7 +226,8 @@ class putThread : public ACE_Task_Base {
           CacheableVectorPtr routingObj = CacheableVector::create();
           routingObj->push_back(key);
           ExecutionPtr exc = FunctionService::onRegion(regPtr0);
-          exc->execute(routingObj, args, rPtr, getFuncName2, 300 /*in millis*/)
+          exc->execute(routingObj, args, rPtr, getFuncName2,
+                       std::chrono::seconds(300))
               ->getResult();
         } catch (const TimeoutException& te) {
           LOGINFO("Timeout exception occurred %s", te.getMessage());
@@ -268,7 +269,8 @@ void executeFunction() {
     CacheableVectorPtr routingObj = CacheableVector::create();
     routingObj->push_back(key);
     ExecutionPtr exc = FunctionService::onRegion(regPtr0);
-    exc->execute(routingObj, args, rPtr, getFuncName2, 300 /*in millis*/)
+    exc->execute(routingObj, args, rPtr, getFuncName2,
+                 std::chrono::seconds(300))
         ->getResult();
   }
   LOGINFO("executeFunction failureCount %d", failureCount);
diff --git a/cppcache/integration-test/testThinClientPoolExecuteFunctionPrSHOP.cpp b/cppcache/integration-test/testThinClientPoolExecuteFunctionPrSHOP.cpp
index db67f131..855efa5d 100644
--- a/cppcache/integration-test/testThinClientPoolExecuteFunctionPrSHOP.cpp
+++ b/cppcache/integration-test/testThinClientPoolExecuteFunctionPrSHOP.cpp
@@ -24,8 +24,10 @@
 #include "SerializationRegistry.hpp"
 #include "CacheRegionHelper.hpp"
 #include "CacheImpl.hpp"
+#include <geode/DefaultResultCollector.hpp>
 
 using namespace PdxTests;
+
 /* This is to test
 1- funtion execution on pool
 */
@@ -114,57 +116,43 @@ char* FETimeOut = (char*)"FunctionExecutionTimeOut";
     }                                        \
   }                                          \
   ASSERT(found, "this returned value is invalid");
-class MyResultCollector : public ResultCollector {
+
+class MyResultCollector : public DefaultResultCollector {
  public:
   MyResultCollector()
-      : m_resultList(CacheableVector::create()),
-        m_isResultReady(false),
-        m_endResultCount(0),
-        m_addResultCount(0),
-        m_getResultCount(0) {}
-  ~MyResultCollector() {}
-  CacheableVectorPtr getResult(uint32_t timeout) {
+      : m_endResultCount(0), m_addResultCount(0), m_getResultCount(0) {}
+  ~MyResultCollector() noexcept {}
+
+  CacheableVectorPtr getResult(std::chrono::milliseconds timeout) override {
     m_getResultCount++;
-    if (m_isResultReady == true) {
-      return m_resultList;
-    } else {
-      for (uint32_t i = 0; i < timeout; i++) {
-        SLEEP(1);
-        if (m_isResultReady == true) return m_resultList;
-      }
-      throw FunctionExecutionException(
-          "Result is not ready, endResults callback is called before invoking "
-          "getResult() method");
-    }
+    return DefaultResultCollector::getResult(timeout);
   }
 
-  void addResult(const CacheablePtr& resultItem) {
+  void addResult(const CacheablePtr& resultItem) override {
     m_addResultCount++;
     if (resultItem == nullptr) {
       return;
     }
-    if (auto result =
+    if (auto results =
             std::dynamic_pointer_cast<CacheableArrayList>(resultItem)) {
-      for (int32_t i = 0; i < result->size(); i++) {
-        m_resultList->push_back(result->operator[](i));
+      for (auto& result : *results) {
+        DefaultResultCollector::addResult(result);
       }
     } else {
-      auto ex =
-          std::dynamic_pointer_cast<UserFunctionExecutionException>(resultItem);
-      m_resultList->push_back(ex);
+      DefaultResultCollector::addResult(resultItem);
     }
   }
-  void endResults() {
-    m_isResultReady = true;
+
+  void endResults() override {
     m_endResultCount++;
+    DefaultResultCollector::endResults();
   }
+
   uint32_t getEndResultCount() { return m_endResultCount; }
   uint32_t getAddResultCount() { return m_addResultCount; }
   uint32_t getGetResultCount() { return m_getResultCount; }
 
  private:
-  CacheableVectorPtr m_resultList;
-  volatile bool m_isResultReady;
   uint32_t m_endResultCount;
   uint32_t m_addResultCount;
   uint32_t m_getResultCount;
@@ -266,7 +254,6 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
     SLEEP(10000);  // let the put finish
     try {
       CacheablePtr args = CacheableBoolean::create(1);
-      bool getResult = true;
       auto routingObj = CacheableVector::create();
       for (int i = 0; i < 34; i++) {
         if (i % 2 == 0) continue;
@@ -285,7 +272,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       auto exe2 = exe1->withArgs(args1);
 
       auto resultList = CacheableVector::create();
-      auto executeFunctionResult = exe1->execute(rjFuncName, 15)->getResult();
+      auto executeFunctionResult =
+          exe1->execute(rjFuncName, std::chrono::seconds(15))->getResult();
       if (executeFunctionResult == nullptr) {
         ASSERT(false, "echo String : executeFunctionResult is nullptr");
       } else {
@@ -301,15 +289,17 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
           FAIL("echo String : wrong argument type");
         }
       }
-      executeFunctionResult = exc->withFilter(routingObj)
-                                  ->withArgs(args)
-                                  ->execute(exFuncName, 15)
-                                  ->getResult();
+      executeFunctionResult =
+          exc->withFilter(routingObj)
+              ->withArgs(args)
+              ->execute(exFuncName, std::chrono::seconds(15))
+              ->getResult();
 
-      executeFunctionResult = exc->withFilter(routingObj)
-                                  ->withArgs(args)
-                                  ->execute(rjFuncName, 15)
-                                  ->getResult();
+      executeFunctionResult =
+          exc->withFilter(routingObj)
+              ->withArgs(args)
+              ->execute(rjFuncName, std::chrono::seconds(15))
+              ->getResult();
       if (executeFunctionResult == nullptr) {
         ASSERT(false, "echo String : executeFunctionResult is nullptr");
       } else {
@@ -323,10 +313,11 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
         ASSERT(strcmp("echoString", str) == 0, "echoString is not eched back");
       }
       args = CacheableKey::create("echoBoolean");
-      executeFunctionResult = exc->withFilter(routingObj)
-                                  ->withArgs(args)
-                                  ->execute(rjFuncName, 15)
-                                  ->getResult();
+      executeFunctionResult =
+          exc->withFilter(routingObj)
+              ->withArgs(args)
+              ->execute(rjFuncName, std::chrono::seconds(15))
+              ->getResult();
       if (executeFunctionResult == nullptr) {
         ASSERT(false, "echo Boolean: executeFunctionResult is nullptr");
       } else {
@@ -342,7 +333,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
 
       executeFunctionResult = exc->withFilter(routingObj)
                                   ->withArgs(args)
-                                  ->execute(getFuncName, getResult)
+                                  ->execute(getFuncName)
                                   ->getResult();
       /****
        **decomposed from above long expression:
@@ -350,7 +341,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       ASSERT(exc!=nullptr, "withFilter Returned nullptr");
       exc = exc->withArgs(args);
       ASSERT(exc!=nullptr, "withArgs Returned nullptr");
-      ResultCollectorPtr rc = exc->execute(getFuncName, getResult);
+      ResultCollectorPtr rc = exc->execute(getFuncName);
       ASSERT(rc!=nullptr, "execute Returned nullptr");
       CacheableVectorPtr executeFunctionResult = rc->getResult();
       */
@@ -398,7 +389,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       executeFunctionResult = exc->withFilter(routingObj)
                                   ->withArgs(args)
                                   ->withCollector(myRC)
-                                  ->execute(getFuncName, getResult)
+                                  ->execute(getFuncName)
                                   ->getResult();
       sprintf(buf, "add result count = %d", myRC->getAddResultCount());
       LOG(buf);
@@ -435,8 +426,9 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
         }
       }
       //     test put function without result
-      getResult = false;
-      exc->withFilter(routingObj)->withArgs(args)->execute(putFuncName, 15);
+      exc->withFilter(routingObj)
+          ->withArgs(args)
+          ->execute(putFuncName, std::chrono::seconds(15));
       SLEEP(10000);  // let the put finish
       for (int i = 0; i < 34; i++) {
         if (i % 2 == 0) continue;
@@ -450,11 +442,11 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       }
 
       args = routingObj;
-      getResult = true;
-      executeFunctionResult = exc->withArgs(args)
-                                  ->withFilter(routingObj)
-                                  ->execute(getFuncName, 15)
-                                  ->getResult();
+      executeFunctionResult =
+          exc->withArgs(args)
+              ->withFilter(routingObj)
+              ->execute(getFuncName, std::chrono::seconds(15))
+              ->getResult();
 
       if (executeFunctionResult == nullptr) {
         ASSERT(false, "get executeFunctionResult is nullptr");
@@ -518,13 +510,12 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       LOG("Adding filter done.");
 
       args = CacheableBoolean::create(1);
-      getResult = true;
 
       auto funcExec = FunctionService::onRegion(regPtr0);
       ASSERT(funcExec != nullptr, "onRegion Returned nullptr");
 
       auto collector = funcExec->withArgs(args)->withFilter(filter)->execute(
-          exFuncNameSendException, 15);
+          exFuncNameSendException, std::chrono::seconds(15));
       ASSERT(collector != nullptr, "onRegion collector nullptr");
 
       auto result = collector->getResult();
@@ -542,7 +533,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       LOG("exFuncNameSendException done for bool arguement.");
 
       collector = funcExec->withArgs(arrList)->withFilter(filter)->execute(
-          exFuncNameSendException, 15);
+          exFuncNameSendException, std::chrono::seconds(15));
       ASSERT(collector != nullptr, "onRegion collector for arrList nullptr");
 
       result = collector->getResult();
@@ -564,7 +555,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
 
       args = CacheableString::create("Multiple");
       collector = funcExec->withArgs(args)->withFilter(filter)->execute(
-          exFuncNameSendException, 15);
+          exFuncNameSendException, std::chrono::seconds(15));
       ASSERT(collector != nullptr, "onRegion collector for string nullptr");
       result = collector->getResult();
       LOGINFO("result->size() for Multiple String = %d ", result->size());
@@ -591,7 +582,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       result = funcExec->withArgs(args)
                    ->withFilter(filter)
                    ->withCollector(myRC1)
-                   ->execute(exFuncNameSendException, getResult)
+                   ->execute(exFuncNameSendException)
                    ->getResult();
       LOGINFO("add result count = %d", myRC1->getAddResultCount());
       LOGINFO("end result count = %d", myRC1->getEndResultCount());
@@ -626,7 +617,6 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
 
       // test data independant function
       //     test get function with result
-      getResult = true;
       args = routingObj;
       // ExecutionPtr exc=nullptr;
       // CacheableVectorPtr executeFunctionResult = nullptr;
@@ -634,7 +624,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       LOG("test data independant get function on one server");
       exc = FunctionService::onServer(getHelper()->cachePtr);
       executeFunctionResult =
-          exc->withArgs(args)->execute(getFuncIName, getResult)->getResult();
+          exc->withArgs(args)->execute(getFuncIName)->getResult();
       if (executeFunctionResult == nullptr) {
         ASSERT(false, "get executeFunctionResult is nullptr");
       } else {
@@ -666,8 +656,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       }
       LOG("test data independant put function on one server");
       //     test put function without result
-      getResult = false;
-      exc->withArgs(args)->execute(putFuncIName, 15);
+      exc->withArgs(args)->execute(putFuncIName, std::chrono::seconds(15));
       SLEEP(500);  // let the put finish
       for (int i = 0; i < 34; i++) {
         if (i % 2 == 0) continue;
@@ -686,7 +675,6 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       //-----------------------Test with PdxObject
       // onServers-------------------------------//
 
-      getResult = true;
       try {
         SerializationRegistryPtr serializationRegistry =
             CacheRegionHelper::getCacheImpl(getHelper()->getCache().get())
@@ -715,10 +703,9 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       }
 
       auto pdxExc = FunctionService::onServers(getHelper()->cachePtr);
-      auto executeFunctionResultPdx =
-          pdxExc->withArgs(pdxRoutingObj)
-              ->execute(exFuncNamePdxType, getResult)
-              ->getResult();
+      auto executeFunctionResultPdx = pdxExc->withArgs(pdxRoutingObj)
+                                          ->execute(exFuncNamePdxType)
+                                          ->getResult();
       LOGINFO("FE on pdxObject done");
       if (executeFunctionResultPdx == nullptr) {
         ASSERT(false, "get executeFunctionResultPdx is nullptr");
@@ -788,7 +775,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       auto pdxInstanceExc = FunctionService::onServers(getHelper()->cachePtr);
       auto executeFunctionResultPdxInstance =
           pdxInstanceExc->withArgs(pdxInstanceRoutingObj)
-              ->execute(exFuncNamePdxType, getResult)
+              ->execute(exFuncNamePdxType)
               ->getResult();
       LOGINFO("FE on pdxObject done");
       if (executeFunctionResultPdxInstance == nullptr) {
@@ -857,10 +844,9 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       SLEEP(60000);  // let this servers gets all the data
 
       //---------------------------------------------------------------------
-      getResult = true;
       exc = FunctionService::onServers(getHelper()->cachePtr);
       executeFunctionResult =
-          exc->withArgs(args)->execute(getFuncIName, getResult)->getResult();
+          exc->withArgs(args)->execute(getFuncIName)->getResult();
       if (executeFunctionResult == nullptr) {
         ASSERT(false, "get executeFunctionResult is nullptr");
       } else {
@@ -894,8 +880,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       LOG("test data independant put function on all servers");
       // test data independant function on all servers
       // test put
-      getResult = false;
-      exc->withArgs(args)->execute(putFuncIName, 15);
+      exc->withArgs(args)->execute(putFuncIName, std::chrono::seconds(15));
       SLEEP(10000);  // let the put finish
       for (int i = 0; i < 34; i++) {
         if (i % 2 == 0) continue;
@@ -911,11 +896,10 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       // onServers-------------------------------//
       LOG("OnServers with sendException");
       args = CacheableBoolean::create(1);
-      getResult = true;
       funcExec = FunctionService::onServers(getHelper()->cachePtr);
 
-      collector =
-          funcExec->withArgs(args)->execute(exFuncNameSendException, 15);
+      collector = funcExec->withArgs(args)->execute(exFuncNameSendException,
+                                                    std::chrono::seconds(15));
       ASSERT(collector != nullptr, "onServers collector for bool nullptr");
 
       result = collector->getResult();
@@ -932,8 +916,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
         }
       }
 
-      collector =
-          funcExec->withArgs(arrList)->execute(exFuncNameSendException, 15);
+      collector = funcExec->withArgs(arrList)->execute(
+          exFuncNameSendException, std::chrono::seconds(15));
       ASSERT(collector != nullptr, "onServers collector for arrList nullptr");
 
       result = collector->getResult();
@@ -959,8 +943,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       LOG("exFuncNameSendException for string arguement.");
 
       args = CacheableString::create("Multiple");
-      collector =
-          funcExec->withArgs(args)->execute(exFuncNameSendException, 15);
+      collector = funcExec->withArgs(args)->execute(exFuncNameSendException,
+                                                    std::chrono::seconds(15));
       ASSERT(collector != nullptr, "onServers collector for string nullptr");
 
       result = collector->getResult();
@@ -983,7 +967,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       auto myRC2 = std::make_shared<MyResultCollector>();
       result = funcExec->withArgs(args)
                    ->withCollector(myRC2)
-                   ->execute(exFuncNameSendException, getResult)
+                   ->execute(exFuncNameSendException)
                    ->getResult();
       ASSERT(3 == myRC2->getAddResultCount(), "add result count is not 3");
       ASSERT(1 == myRC2->getEndResultCount(), "end result count is not 1");
@@ -1017,13 +1001,14 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       }
       LOGINFO("Put done.");
 
-      getResult = true;
       for (int i = 0; i < 230; i++) {
         auto fil = CacheableVector::create();
         fil->push_back(CacheableInt32::create(i));
         auto exe = FunctionService::onRegion(regPtr0);
         auto executeFunctionResult2 =
-            exe->withFilter(fil)->execute(FEOnRegionPrSHOP, 15)->getResult();
+            exe->withFilter(fil)
+                ->execute(FEOnRegionPrSHOP, std::chrono::seconds(15))
+                ->getResult();
         if (executeFunctionResult2 == nullptr) {
           ASSERT(false, "executeFunctionResult2 is nullptr");
         } else {
@@ -1043,10 +1028,10 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
         executeFunctionResult2->clear();
         LOGINFO("FEOnRegionPrSHOP without Filter done");
 
-        auto functionResult =
-            exe->withFilter(fil)
-                ->execute(FEOnRegionPrSHOP_OptimizeForWrite, 15)
-                ->getResult();
+        auto functionResult = exe->withFilter(fil)
+                                  ->execute(FEOnRegionPrSHOP_OptimizeForWrite,
+                                            std::chrono::seconds(15))
+                                  ->getResult();
         if (functionResult == nullptr) {
           ASSERT(false, "functionResult is nullptr");
         } else {
@@ -1069,9 +1054,10 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
 
       //////////////////////OnRegion TimeOut ///////////////////////////
       LOGINFO("FETimeOut begin onRegion");
+      auto timeout = std::chrono::milliseconds{5000};
       auto RexecutionPtr = FunctionService::onRegion(regPtr0);
-      auto fe = RexecutionPtr->withArgs(CacheableInt32::create(5000 * 1000))
-                    ->execute(FETimeOut, 5000 * 1000)
+      auto fe = RexecutionPtr->withArgs(CacheableInt32::create(timeout.count()))
+                    ->execute(FETimeOut, timeout)
                     ->getResult();
       if (fe == nullptr) {
         ASSERT(false, "functionResult is nullptr");
@@ -1092,8 +1078,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
 
       LOGINFO("FETimeOut begin onServer");
       auto serverExc = FunctionService::onServer(getHelper()->cachePtr);
-      auto vec = serverExc->withArgs(CacheableInt32::create(5000 * 1000))
-                     ->execute(FETimeOut, 5000 * 1000)
+      auto vec = serverExc->withArgs(CacheableInt32::create(timeout.count()))
+                     ->execute(FETimeOut, timeout)
                      ->getResult();
       if (vec == nullptr) {
         ASSERT(false, "functionResult is nullptr");
@@ -1113,8 +1099,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
 
       LOGINFO("FETimeOut begin onServers");
       auto serversExc = FunctionService::onServers(getHelper()->cachePtr);
-      auto vecs = serversExc->withArgs(CacheableInt32::create(5000 * 1000))
-                      ->execute(FETimeOut, 5000 * 1000)
+      auto vecs = serversExc->withArgs(CacheableInt32::create(timeout.count()))
+                      ->execute(FETimeOut, timeout)
                       ->getResult();
       if (vecs == nullptr) {
         ASSERT(false, "functionResult is nullptr");
diff --git a/cppcache/integration-test/testThinClientPoolExecuteFunctionThrowsException.cpp b/cppcache/integration-test/testThinClientPoolExecuteFunctionThrowsException.cpp
index 640b7c3d..9b3bbd6a 100644
--- a/cppcache/integration-test/testThinClientPoolExecuteFunctionThrowsException.cpp
+++ b/cppcache/integration-test/testThinClientPoolExecuteFunctionThrowsException.cpp
@@ -24,6 +24,8 @@
 #include <thread>
 #include <chrono>
 
+#include <geode/DefaultResultCollector.hpp>
+
 using namespace PdxTests;
 /* This is to test
 1- funtion execution on pool
@@ -105,57 +107,43 @@ char* FETimeOut = (char*)"FunctionExecutionTimeOut";
     }                                        \
   }                                          \
   ASSERT(found, "this returned value is invalid");
-class MyResultCollector : public ResultCollector {
+
+class MyResultCollector : public DefaultResultCollector {
  public:
   MyResultCollector()
-      : m_resultList(CacheableVector::create()),
-        m_isResultReady(false),
-        m_endResultCount(0),
-        m_addResultCount(0),
-        m_getResultCount(0) {}
+      : m_endResultCount(0), m_addResultCount(0), m_getResultCount(0) {}
   ~MyResultCollector() {}
-  CacheableVectorPtr getResult(uint32_t timeout) {
+
+  CacheableVectorPtr getResult(std::chrono::milliseconds timeout) override {
     m_getResultCount++;
-    if (m_isResultReady == true) {
-      return m_resultList;
-    } else {
-      for (uint32_t i = 0; i < timeout; i++) {
-        SLEEP(1);
-        if (m_isResultReady == true) return m_resultList;
-      }
-      throw FunctionExecutionException(
-          "Result is not ready, endResults callback is called before invoking "
-          "getResult() method");
-    }
+    return DefaultResultCollector::getResult(timeout);
   }
 
-  void addResult(const CacheablePtr& resultItem) {
+  void addResult(const CacheablePtr& resultItem) override {
     m_addResultCount++;
     if (resultItem == nullptr) {
       return;
     }
-    if (auto result =
+    if (auto results =
             std::dynamic_pointer_cast<CacheableArrayList>(resultItem)) {
-      for (int32_t i = 0; i < result->size(); i++) {
-        m_resultList->push_back(result->operator[](i));
+      for (auto& result : *results) {
+        DefaultResultCollector::addResult(result);
       }
     } else {
-      auto ex =
-          std::dynamic_pointer_cast<UserFunctionExecutionException>(resultItem);
-      m_resultList->push_back(ex);
+      DefaultResultCollector::addResult(resultItem);
     }
   }
-  void endResults() {
-    m_isResultReady = true;
+
+  void endResults() override {
     m_endResultCount++;
+    DefaultResultCollector::endResults();
   }
+
   uint32_t getEndResultCount() { return m_endResultCount; }
   uint32_t getAddResultCount() { return m_addResultCount; }
   uint32_t getGetResultCount() { return m_getResultCount; }
 
  private:
-  CacheableVectorPtr m_resultList;
-  volatile bool m_isResultReady;
   uint32_t m_endResultCount;
   uint32_t m_addResultCount;
   uint32_t m_getResultCount;
@@ -254,7 +242,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
 
     ResultCollectorPtr collector =
         funcExec->withArgs(args)->withFilter(filter)->execute(
-            exFuncNameSendException, 15);
+            exFuncNameSendException, std::chrono::seconds(15));
     ASSERT(collector != nullptr, "onRegion collector nullptr");
 
     CacheableVectorPtr result = collector->getResult();
@@ -280,7 +268,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
     LOG("exFuncNameSendException done for bool argument.");
 
     collector = funcExec->withArgs(arrList)->withFilter(filter)->execute(
-        exFuncNameSendException, 15);
+        exFuncNameSendException, std::chrono::seconds(15));
     ASSERT(collector != nullptr, "onRegion collector for arrList nullptr");
     std::this_thread::sleep_for(std::chrono::seconds(2));
 
@@ -293,7 +281,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       CacheableVectorPtr executeFunctionResult3 =
           funcExec->withArgs(arrList)
               ->withFilter(filter)
-              ->execute("ThinClientRegionExceptionTest", 15)
+              ->execute("ThinClientRegionExceptionTest",
+                        std::chrono::seconds(15))
               ->getResult();
       FAIL("Failed to throw expected exception.");
     } catch (...) {
diff --git a/cppcache/integration-test/testThinClientPoolExecuteHAFunction.cpp b/cppcache/integration-test/testThinClientPoolExecuteHAFunction.cpp
index 954c21ac..c779a1c0 100644
--- a/cppcache/integration-test/testThinClientPoolExecuteHAFunction.cpp
+++ b/cppcache/integration-test/testThinClientPoolExecuteHAFunction.cpp
@@ -18,7 +18,7 @@
 #include "ThinClientHelper.hpp"
 #include <geode/FunctionService.hpp>
 #include <geode/Execution.hpp>
-#include <geode/ResultCollector.hpp>
+#include <geode/DefaultResultCollector.hpp>
 
 #define CLIENT1 s1p1
 #define LOCATOR1 s2p1
@@ -65,53 +65,48 @@ char* RegionOperationsHAFunction = (char*)"RegionOperationsHAFunction";
     }                                        \
   }                                          \
   ASSERT(found, "this returned value is invalid");
-class MyResultCollector : public ResultCollector {
+
+class MyResultCollector : public DefaultResultCollector {
  public:
   MyResultCollector()
-      : m_resultList(CacheableVector::create()),
-        m_isResultReady(false),
-        m_endResultCount(0),
-        m_addResultCount(0),
-        m_getResultCount(0) {}
+      : m_endResultCount(0), m_addResultCount(0), m_getResultCount(0) {}
   ~MyResultCollector() {}
-  CacheableVectorPtr getResult(uint32_t timeout) {
+
+  CacheableVectorPtr getResult(std::chrono::milliseconds timeout) override {
     m_getResultCount++;
-    if (m_isResultReady == true) {
-      return m_resultList;
-    } else {
-      for (uint32_t i = 0; i < timeout; i++) {
-        SLEEP(1);
-        if (m_isResultReady == true) return m_resultList;
-      }
-      throw FunctionExecutionException(
-          "Result is not ready, endResults callback is called before invoking "
-          "getResult() method");
-    }
+    return DefaultResultCollector::getResult(timeout);
   }
 
-  void addResult(const CacheablePtr& resultItem) {
+  void addResult(const CacheablePtr& resultItem) override {
     m_addResultCount++;
-    if (resultItem == nullptr) return;
-    auto result = std::dynamic_pointer_cast<CacheableArrayList>(resultItem);
-    for (int32_t i = 0; i < result->size(); i++) {
-      m_resultList->push_back(result->operator[](i));
+    if (resultItem == nullptr) {
+      return;
+    }
+    if (auto results =
+            std::dynamic_pointer_cast<CacheableArrayList>(resultItem)) {
+      for (auto& result : *results) {
+        DefaultResultCollector::addResult(result);
+      }
+    } else {
+      DefaultResultCollector::addResult(resultItem);
     }
   }
-  void endResults() {
-    m_isResultReady = true;
+
+  void endResults() override {
     m_endResultCount++;
+    DefaultResultCollector::endResults();
   }
+
   uint32_t getEndResultCount() { return m_endResultCount; }
   uint32_t getAddResultCount() { return m_addResultCount; }
   uint32_t getGetResultCount() { return m_getResultCount; }
 
  private:
-  CacheableVectorPtr m_resultList;
-  volatile bool m_isResultReady;
   uint32_t m_endResultCount;
   uint32_t m_addResultCount;
   uint32_t m_getResultCount;
 };
+
 DUNIT_TASK_DEFINITION(LOCATOR1, StartLocator1)
   {
     // starting locator
@@ -207,9 +202,10 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       ASSERT(exc != nullptr, "onRegion Returned nullptr");
       auto resultList = CacheableVector::create();
 
-      auto executeFunctionResult = exc->withArgs(routingObj)
-                                       ->execute(RegionOperationsHAFunction, 15)
-                                       ->getResult();
+      auto executeFunctionResult =
+          exc->withArgs(routingObj)
+              ->execute(RegionOperationsHAFunction, std::chrono::seconds(15))
+              ->getResult();
 
       if (executeFunctionResult == nullptr) {
         ASSERT(false, "get executeFunctionResult is nullptr");
@@ -250,10 +246,11 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
       auto filter = CacheableVector::create();
       const char* key = "KEY--10";
       filter->push_back(CacheableString::create(key));
-      executeFunctionResult = exc->withArgs(routingObj)
-                                  ->withFilter(filter)
-                                  ->execute(RegionOperationsHAFunction, 15)
-                                  ->getResult();
+      executeFunctionResult =
+          exc->withArgs(routingObj)
+              ->withFilter(filter)
+              ->execute(RegionOperationsHAFunction, std::chrono::seconds(15))
+              ->getResult();
 
       if (executeFunctionResult == nullptr) {
         ASSERT(false, "get executeFunctionResult is nullptr");
@@ -337,7 +334,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OnServerHATest)
       // Test with HA exception
       auto executeFunctionResult =
           exc->withArgs(routingObj)
-              ->execute(OnServerHAExceptionFunction, 15)
+              ->execute(OnServerHAExceptionFunction, std::chrono::seconds(15))
               ->getResult();
 
       if (executeFunctionResult == nullptr) {
@@ -376,7 +373,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OnServerHATest)
       // Test with HA server shutdown
       auto executeFunctionResult1 =
           exc->withArgs(routingObj)
-              ->execute(OnServerHAShutdownFunction, 15)
+              ->execute(OnServerHAShutdownFunction, std::chrono::seconds(15))
               ->getResult();
 
       if (executeFunctionResult1 == nullptr) {
diff --git a/cppcache/integration-test/testThinClientPoolExecuteHAFunctionPrSHOP.cpp b/cppcache/integration-test/testThinClientPoolExecuteHAFunctionPrSHOP.cpp
index 003fd9e5..77e3a310 100644
--- a/cppcache/integration-test/testThinClientPoolExecuteHAFunctionPrSHOP.cpp
+++ b/cppcache/integration-test/testThinClientPoolExecuteHAFunctionPrSHOP.cpp
@@ -18,7 +18,7 @@
 #include "ThinClientHelper.hpp"
 #include <geode/FunctionService.hpp>
 #include <geode/Execution.hpp>
-#include <geode/ResultCollector.hpp>
+#include <geode/DefaultResultCollector.hpp>
 
 #define CLIENT1 s1p1
 #define LOCATOR1 s2p1
@@ -65,53 +65,48 @@ char* RegionOperationsHAFunctionPrSHOP =
     }                                        \
   }                                          \
   ASSERT(found, "this returned value is invalid");
-class MyResultCollector : public ResultCollector {
+
+class MyResultCollector : public DefaultResultCollector {
  public:
   MyResultCollector()
-      : m_resultList(CacheableVector::create()),
-        m_isResultReady(false),
-        m_endResultCount(0),
-        m_addResultCount(0),
-        m_getResultCount(0) {}
-  ~MyResultCollector() {}
-  CacheableVectorPtr getResult(uint32_t timeout) {
+      : m_endResultCount(0), m_addResultCount(0), m_getResultCount(0) {}
+  ~MyResultCollector() noexcept {}
+
+  CacheableVectorPtr getResult(std::chrono::milliseconds timeout) override {
     m_getResultCount++;
-    if (m_isResultReady == true) {
-      return m_resultList;
-    } else {
-      for (uint32_t i = 0; i < timeout; i++) {
-        SLEEP(1);
-        if (m_isResultReady == true) return m_resultList;
-      }
-      throw FunctionExecutionException(
-          "Result is not ready, endResults callback is called before invoking "
-          "getResult() method");
-    }
+    return DefaultResultCollector::getResult(timeout);
   }
 
-  void addResult(const CacheablePtr& resultItem) {
+  void addResult(const CacheablePtr& resultItem) override {
     m_addResultCount++;
-    if (resultItem == nullptr) return;
-    auto result = std::dynamic_pointer_cast<CacheableArrayList>(resultItem);
-    for (int32_t i = 0; i < result->size(); i++) {
-      m_resultList->push_back(result->operator[](i));
+    if (resultItem == nullptr) {
+      return;
+    }
+    if (auto results =
+            std::dynamic_pointer_cast<CacheableArrayList>(resultItem)) {
+      for (auto& result : *results) {
+        DefaultResultCollector::addResult(result);
+      }
+    } else {
+      DefaultResultCollector::addResult(resultItem);
     }
   }
-  void endResults() {
-    m_isResultReady = true;
+
+  void endResults() override {
     m_endResultCount++;
+    DefaultResultCollector::endResults();
   }
+
   uint32_t getEndResultCount() { return m_endResultCount; }
   uint32_t getAddResultCount() { return m_addResultCount; }
   uint32_t getGetResultCount() { return m_getResultCount; }
 
  private:
-  CacheableVectorPtr m_resultList;
-  volatile bool m_isResultReady;
   uint32_t m_endResultCount;
   uint32_t m_addResultCount;
   uint32_t m_getResultCount;
 };
+
 DUNIT_TASK_DEFINITION(LOCATOR1, StartLocator1)
   {
     // starting locator
@@ -207,7 +202,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OpTest)
 
       auto executeFunctionResult =
           exc->withArgs(routingObj)
-              ->execute(RegionOperationsHAFunctionPrSHOP, 15)
+              ->execute(RegionOperationsHAFunctionPrSHOP,
+                        std::chrono::seconds(15))
               ->getResult();
 
       if (executeFunctionResult == nullptr) {
@@ -289,7 +285,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OnServerHATest)
       // Test with HA exception
       auto executeFunctionResult =
           exc->withArgs(routingObj)
-              ->execute(OnServerHAExceptionFunction, 15)
+              ->execute(OnServerHAExceptionFunction, std::chrono::seconds(15))
               ->getResult();
 
       if (executeFunctionResult == nullptr) {
@@ -328,7 +324,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, Client1OnServerHATest)
       // Test with HA server shutdown
       auto executeFunctionResult1 =
           exc->withArgs(routingObj)
-              ->execute(OnServerHAShutdownFunction, 15)
+              ->execute(OnServerHAShutdownFunction, std::chrono::seconds(15))
               ->getResult();
 
       if (executeFunctionResult1 == nullptr) {
diff --git a/cppcache/integration-test/testThinClientRemoteQueryTimeout.cpp b/cppcache/integration-test/testThinClientRemoteQueryTimeout.cpp
index 82d6e97f..07bd6f98 100644
--- a/cppcache/integration-test/testThinClientRemoteQueryTimeout.cpp
+++ b/cppcache/integration-test/testThinClientRemoteQueryTimeout.cpp
@@ -155,7 +155,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepThree)
     try {
       LOG("EXECUTE 1 START");
 
-      results = qry->execute(3);
+      results = qry->execute(std::chrono::seconds(3));
 
       LOG("EXECUTE 1 STOP");
 
@@ -199,7 +199,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepFour)
     try {
       LOG("EXECUTE 2 START");
 
-      results = qry->execute(850);
+      results = qry->execute(std::chrono::seconds(850));
 
       LOG("EXECUTE 2 STOP");
 
@@ -239,7 +239,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepFive)
     try {
       LOG("EXECUTE 3 START");
 
-      results = qry->execute(2);
+      results = qry->execute(std::chrono::seconds(2));
 
       LOG("EXECUTE 3 STOP");
 
@@ -283,7 +283,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepSix)
     try {
       LOG("EXECUTE 4 START");
 
-      results = qry->execute(850);
+      results = qry->execute(std::chrono::seconds(850));
 
       LOG("EXECUTE 4 STOP");
 
@@ -332,7 +332,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepSeven)
           paramList->push_back(Cacheable::create(queryparamSetSS[5][j]));
         }
       }
-      results = qry->execute(paramList, 1);
+      results = qry->execute(paramList, std::chrono::seconds(1));
 
       LOG("EXECUTE Five STOP");
 
@@ -386,7 +386,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepEight)
         }
       }
 
-      results = qry->execute(paramList, 850);
+      results = qry->execute(paramList, std::chrono::seconds(850));
 
       LOG("EXECUTE 6 STOP");
 
@@ -426,7 +426,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, verifyNegativeValueTimeout)
     try {
       LOG("Task::verifyNegativeValueTimeout - EXECUTE 1 START");
 
-      results = qry->execute(-3);
+      results = qry->execute(std::chrono::seconds(-3));
 
       LOG("Task::verifyNegativeValueTimeout - EXECUTE 1 STOP");
 
@@ -472,7 +472,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, verifyLargeValueTimeout)
     try {
       LOG("Task:: verifyLargeValueTimeout - EXECUTE 1 START");
 
-      results = qry->execute(2147500);
+      results = qry->execute(std::chrono::seconds(2147500));
 
       LOG("Task:: verifyLargeValueTimeout - EXECUTE 1 STOP");
 
diff --git a/cppcache/integration-test/testThinClientRemoteRegionQuery.cpp b/cppcache/integration-test/testThinClientRemoteRegionQuery.cpp
index ab41a4c2..d7414abb 100644
--- a/cppcache/integration-test/testThinClientRemoteRegionQuery.cpp
+++ b/cppcache/integration-test/testThinClientRemoteRegionQuery.cpp
@@ -204,7 +204,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepThree)
 
     try {
       SelectResultsPtr results =
-          region->query(const_cast<char*>(regionQueries[0].query()), 2200000);
+          region->query(const_cast<char*>(regionQueries[0].query()),
+                        std::chrono::seconds(2200000));
       FAIL("Expected IllegalArgumentException exception for invalid timeout");
     } catch (apache::geode::client::IllegalArgumentException ex) {
       LOG("got expected IllegalArgumentException exception for invalid "
@@ -214,7 +215,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepThree)
 
     try {
       SelectResultsPtr results =
-          region->query(const_cast<char*>(regionQueries[0].query()), -1);
+          region->query(const_cast<char*>(regionQueries[0].query()), std::chrono::seconds(-1));
       FAIL("Expected IllegalArgumentException exception for invalid timeout");
     } catch (apache::geode::client::IllegalArgumentException ex) {
       LOG("got expected IllegalArgumentException exception for invalid "
@@ -278,8 +279,9 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepFour)
     }
 
     try {
-      bool existsValue ATTR_UNUSED = region->existsValue(
-          const_cast<char*>(regionQueries[0].query()), 2200000);
+      bool existsValue ATTR_UNUSED =
+          region->existsValue(const_cast<char*>(regionQueries[0].query()),
+                              std::chrono::seconds(2200000));
       FAIL("Expected IllegalArgumentException exception for invalid timeout");
     } catch (apache::geode::client::IllegalArgumentException ex) {
       LOG("got expected IllegalArgumentException exception for invalid "
@@ -289,7 +291,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepFour)
 
     try {
       bool existsValue ATTR_UNUSED =
-          region->existsValue(const_cast<char*>(regionQueries[0].query()), -1);
+          region->existsValue(const_cast<char*>(regionQueries[0].query()),
+                              std::chrono::seconds(-1));
       FAIL("Expected IllegalArgumentException exception for invalid timeout");
     } catch (apache::geode::client::IllegalArgumentException ex) {
       LOG("got expected IllegalArgumentException exception for invalid "
@@ -383,9 +386,9 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepFive)
     }
 
     try {
-      auto results =
-          std::dynamic_pointer_cast<SelectResults>(region->selectValue(
-              const_cast<char*>(regionQueries[0].query()), 2200000));
+      auto results = std::dynamic_pointer_cast<SelectResults>(
+          region->selectValue(const_cast<char*>(regionQueries[0].query()),
+                              std::chrono::seconds(2200000)));
       FAIL("Expected IllegalArgumentException exception for invalid timeout");
     } catch (apache::geode::client::IllegalArgumentException ex) {
       LOG("got expected IllegalArgumentException exception for invalid "
@@ -395,7 +398,8 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepFive)
 
     try {
       auto results = std::dynamic_pointer_cast<SelectResults>(
-          region->selectValue(const_cast<char*>(regionQueries[0].query()), -1));
+          region->selectValue(const_cast<char*>(regionQueries[0].query()),
+                              std::chrono::seconds(-1)));
       FAIL("Expected IllegalArgumentException exception for invalid timeout");
     } catch (apache::geode::client::IllegalArgumentException ex) {
       LOG("got expected IllegalArgumentException exception for invalid "
diff --git a/cppcache/integration-test/testThinClientSSLWithSecurityAuthz.cpp b/cppcache/integration-test/testThinClientSSLWithSecurityAuthz.cpp
index 6dc32263..069b4954 100644
--- a/cppcache/integration-test/testThinClientSSLWithSecurityAuthz.cpp
+++ b/cppcache/integration-test/testThinClientSSLWithSecurityAuthz.cpp
@@ -267,9 +267,7 @@ DUNIT_TASK_DEFINITION(ADMIN_CLIENT, StepOne)
       qs->executeCqs();
       LOG("CQ completed successfully");
       if (pool != nullptr) {
-        FunctionService::onServer(pool)
-            ->execute("securityTest", true)
-            ->getResult();
+        FunctionService::onServer(pool)->execute("securityTest")->getResult();
         LOG("Function execution completed successfully");
       } else {
         LOG("Skipping function execution for non pool case");
@@ -406,9 +404,7 @@ DUNIT_TASK_DEFINITION(WRITER_CLIENT, StepTwo)
 
     try {
       if (pool != nullptr) {
-        FunctionService::onServer(pool)
-            ->execute("securityTest", true)
-            ->getResult();
+        FunctionService::onServer(pool)->execute("securityTest")->getResult();
         //   FAIL("Function execution should not have completed successfully");
       } else {
         LOG("Skipping function execution for non pool case");
@@ -548,9 +544,7 @@ DUNIT_TASK_DEFINITION(READER_CLIENT, StepThree)
 
     try {
       if (pool != nullptr) {
-        FunctionService::onServer(pool)
-            ->execute("securityTest", true)
-            ->getResult();
+        FunctionService::onServer(pool)->execute("securityTest")->getResult();
         FAIL("Function execution should not have completed successfully");
       } else {
         LOG("Skipping function execution for non pool case");
diff --git a/cppcache/integration-test/testThinClientSecurityAuthorization.cpp b/cppcache/integration-test/testThinClientSecurityAuthorization.cpp
index 1b58f5b6..00559226 100644
--- a/cppcache/integration-test/testThinClientSecurityAuthorization.cpp
+++ b/cppcache/integration-test/testThinClientSecurityAuthorization.cpp
@@ -280,19 +280,13 @@ DUNIT_TASK_DEFINITION(ADMIN_CLIENT, StepOne)
       LOG("CQ completed successfully");
       if (pool != nullptr) {
         // TODO:
-        FunctionService::onServer(pool)
-            ->execute("securityTest", true)
-            ->getResult();
+        FunctionService::onServer(pool)->execute("securityTest")->getResult();
         LOG("Function execution completed successfully");
-        FunctionService::onServers(pool)
-            ->execute("securityTest", true)
-            ->getResult();
+        FunctionService::onServers(pool)->execute("securityTest")->getResult();
         LOG("Function execution completed successfully");
-        FunctionService::onRegion(regPtr)
-            ->execute("securityTest", true)
-            ->getResult();
+        FunctionService::onRegion(regPtr)->execute("securityTest")->getResult();
         LOG("Function execution completed successfully");
-        FunctionService::onRegion(regPtr)->execute("FireNForget", false);
+        FunctionService::onRegion(regPtr)->execute("FireNForget");
         LOG("Function execution with no result completed successfully");
       } else {
         LOG("Skipping function execution for non pool case");
@@ -597,9 +591,7 @@ DUNIT_TASK_DEFINITION(READER_CLIENT, StepThree)
 
     try {
       if (pool != nullptr) {
-        FunctionService::onServer(pool)
-            ->execute("securityTest", true)
-            ->getResult();
+        FunctionService::onServer(pool)->execute("securityTest")->getResult();
         FAIL("Function execution should not have completed successfully");
       } else {
         LOG("Skipping function execution for non pool case");
@@ -609,9 +601,7 @@ DUNIT_TASK_DEFINITION(READER_CLIENT, StepThree)
 
     try {
       if (pool != nullptr) {
-        FunctionService::onServer(pool)
-            ->execute("securityTest", true)
-            ->getResult();
+        FunctionService::onServer(pool)->execute("securityTest")->getResult();
         FAIL("Function execution should not have completed successfully");
       } else {
         LOG("Skipping function execution for non pool case");
@@ -621,9 +611,7 @@ DUNIT_TASK_DEFINITION(READER_CLIENT, StepThree)
 
     try {
       if (pool != nullptr) {
-        FunctionService::onServers(pool)
-            ->execute("securityTest", true)
-            ->getResult();
+        FunctionService::onServers(pool)->execute("securityTest")->getResult();
         FAIL("Function execution should not have completed successfully");
       } else {
         LOG("Skipping function execution for non pool case");
@@ -635,7 +623,7 @@ DUNIT_TASK_DEFINITION(READER_CLIENT, StepThree)
       if (pool != nullptr) {
         RegionPtr regPtr0 = getHelper()->getRegion(regionNamesAuth[0]);
         FunctionService::onRegion(regPtr0)
-            ->execute("securityTest", true)
+            ->execute("securityTest")
             ->getResult();
         FAIL("Function execution should not have completed successfully");
       } else {
diff --git a/cppcache/integration-test/testThinClientSecurityAuthorizationMU.cpp b/cppcache/integration-test/testThinClientSecurityAuthorizationMU.cpp
index dad03763..f29f1662 100644
--- a/cppcache/integration-test/testThinClientSecurityAuthorizationMU.cpp
+++ b/cppcache/integration-test/testThinClientSecurityAuthorizationMU.cpp
@@ -305,7 +305,7 @@ DUNIT_TASK_DEFINITION(ADMIN_CLIENT, StepOne)
 
       SelectResultsPtr results;
       printf(" before query executing\n");
-      results = qry->execute(850);
+      results = qry->execute(std::chrono::seconds(850));
       LOG("Query completed successfully");
 
       sprintf(queryString, "select * from /%s", regionNamesAuth[0]);
@@ -323,19 +323,19 @@ DUNIT_TASK_DEFINITION(ADMIN_CLIENT, StepOne)
         // FunctionServicePtr funcServ = virtualCache->getFunctionService();
         // funcServ->onServer()->execute("securityTest", true)->getResult();
         FunctionService::onServer(virtualCache)
-            ->execute("securityTest", true)
+            ->execute("securityTest")
             ->getResult();
         LOG("onServer executed successfully.");
         // funcServ->onServers()->execute("securityTest", true)->getResult();
         FunctionService::onServers(virtualCache)
-            ->execute("securityTest", true)
+            ->execute("securityTest")
             ->getResult();
         LOG("onServerS executed successfully.");
         FunctionService::onRegion(regionPtr)
-            ->execute("securityTest", true)
+            ->execute("securityTest")
             ->getResult();
         LOG("FunctionService::onRegion executed successfully.");
-        FunctionService::onRegion(regionPtr)->execute("FireNForget", false);
+        FunctionService::onRegion(regionPtr)->execute("FireNForget");
         LOG("Function execution with no result completed successfully");
 
         //-----------------------Test with
@@ -375,7 +375,7 @@ DUNIT_TASK_DEFINITION(ADMIN_CLIENT, StepOne)
 
         ResultCollectorPtr collector =
             funcExec->withArgs(args)->withFilter(filter)->execute(
-                exFuncNameSendException, 15);
+                exFuncNameSendException, std::chrono::seconds(15));
         ASSERT(collector != nullptr, "onRegion collector nullptr");
 
         CacheableVectorPtr result = collector->getResult();
@@ -413,7 +413,7 @@ DUNIT_TASK_DEFINITION(ADMIN_CLIENT, StepOne)
         LOG("exFuncNameSendException done for bool arguement.");
 
         collector = funcExec->withArgs(arrList)->withFilter(filter)->execute(
-            exFuncNameSendException, 15);
+            exFuncNameSendException, std::chrono::seconds(15));
         ASSERT(collector != nullptr, "onRegion collector for arrList nullptr");
 
         result = collector->getResult();
@@ -702,7 +702,7 @@ DUNIT_TASK_DEFINITION(WRITER_CLIENT, StepTwo)
       //  FunctionServicePtr funcServ = virtualCache->getFunctionService();
       // funcServ->onServer()->execute("securityTest", true)->getResult();
       FunctionService::onServer(virtualCache)
-          ->execute("securityTest", true)
+          ->execute("securityTest")
           ->getResult();
     }
     HANDLE_NOT_AUTHORIZED_EXCEPTION
@@ -717,7 +717,7 @@ DUNIT_TASK_DEFINITION(WRITER_CLIENT, StepTwo)
       // FunctionServicePtr funcServ = virtualCache->getFunctionService();
       // funcServ->onServers()->execute("securityTest", true)->getResult();
       FunctionService::onServers(virtualCache)
-          ->execute("securityTest", true)
+          ->execute("securityTest")
           ->getResult();
     }
     HANDLE_NOT_AUTHORIZED_EXCEPTION
@@ -766,8 +766,8 @@ DUNIT_TASK_DEFINITION(WRITER_CLIENT, StepTwo)
 
       ExecutionPtr funcExec = FunctionService::onServers(virtualCache);
 
-      ResultCollectorPtr collector =
-          funcExec->withArgs(args)->execute(exFuncNameSendException, 15);
+      ResultCollectorPtr collector = funcExec->withArgs(args)->execute(
+          exFuncNameSendException, std::chrono::seconds(15));
 
       //----------------------------------------------------------------------------------------------//
     }
@@ -784,7 +784,7 @@ DUNIT_TASK_DEFINITION(WRITER_CLIENT, StepTwo)
       // true)->getResult();
       // FAIL("Function execution should not have completed successfully");
       FunctionService::onRegion(regionPtr)
-          ->execute("securityTest", true)
+          ->execute("securityTest")
           ->getResult();
     }
     HANDLE_NOT_AUTHORIZED_EXCEPTION
@@ -835,7 +835,7 @@ DUNIT_TASK_DEFINITION(WRITER_CLIENT, StepTwo)
 
       ResultCollectorPtr collector =
           funcExec->withArgs(args)->withFilter(filter)->execute(
-              exFuncNameSendException, 15);
+              exFuncNameSendException, std::chrono::seconds(15));
 
       //----------------------------------------------------------------------------------------------//
 
@@ -1008,7 +1008,7 @@ DUNIT_TASK_DEFINITION(READER_CLIENT, StepThree)
       // FunctionServicePtr funcServ = virtualCache->getFunctionService();
       // funcServ->onServer()->execute("securityTest", true)->getResult();
       FunctionService::onServer(virtualCache)
-          ->execute("securityTest", true)
+          ->execute("securityTest")
           ->getResult();
     }
     HANDLE_NOT_AUTHORIZED_EXCEPTION
diff --git a/cppcache/integration-test/testThinClientSecurityDurableCQAuthorizationMU.cpp b/cppcache/integration-test/testThinClientSecurityDurableCQAuthorizationMU.cpp
index 09b182e7..0e3fe5a6 100644
--- a/cppcache/integration-test/testThinClientSecurityDurableCQAuthorizationMU.cpp
+++ b/cppcache/integration-test/testThinClientSecurityDurableCQAuthorizationMU.cpp
@@ -158,8 +158,8 @@ void initClientCq(const bool isthinClient, int clientIdx) {
   credentialGeneratorHandler->getValidCredentials(userCreds);
 
   config->insert("durable-client-id", durableIds[clientIdx]);
-  config->insert("durable-timeout", 60);
-  config->insert("notify-ack-interval", 1);
+  config->insert("durable-timeout", std::chrono::seconds(60));
+  config->insert("notify-ack-interval", std::chrono::seconds(1));
 
   if (cacheHelper == nullptr) {
     cacheHelper = new CacheHelper(isthinClient, config);
diff --git a/cppcache/integration-test/testThinClientStatistics.cpp b/cppcache/integration-test/testThinClientStatistics.cpp
index 00b74dbf..e5b84493 100644
--- a/cppcache/integration-test/testThinClientStatistics.cpp
+++ b/cppcache/integration-test/testThinClientStatistics.cpp
@@ -122,9 +122,9 @@ static int selector(const dirent* d) {
 void initClientWithStats() {
   PropertiesPtr pp = Properties::create();
   pp->insert("statistic-sampling-enabled", "true");
-  pp->insert("statistic-sample-rate", 1);
+  pp->insert("statistic-sample-rate", std::chrono::seconds(1));
   pp->insert("statistic-archive-file", "./statArchive.gfs");
-  pp->insert("notify-ack-interval", 1);
+  pp->insert("notify-ack-interval", std::chrono::seconds(1));
 
   initClientWithPool(true, "__TEST_POOL1__", locatorsG, nullptr, pp, 0, true);
   getHelper()->createPooledRegion(regionNames[0], USE_ACK, locatorsG,
diff --git a/cppcache/integration-test/testXmlCacheCreationWithOverFlow.cpp b/cppcache/integration-test/testXmlCacheCreationWithOverFlow.cpp
index af49ff03..483b68c6 100644
--- a/cppcache/integration-test/testXmlCacheCreationWithOverFlow.cpp
+++ b/cppcache/integration-test/testXmlCacheCreationWithOverFlow.cpp
@@ -167,7 +167,7 @@ int testXmlCacheCreationWithOverflow() {
   if (initialCapacity != 25) {
     return -1;
   }
-  int regionIdleTO = regAttr->getRegionIdleTimeout();
+  int regionIdleTO = regAttr->getRegionIdleTimeout().count();
   std::cout << "RegionIdleTimeout:20 " << std::endl;
   if (regionIdleTO != 20) {
     return -1;
diff --git a/cppcache/integration-test/testXmlCacheCreationWithPools.cpp b/cppcache/integration-test/testXmlCacheCreationWithPools.cpp
index b9e9ddca..5b7d2083 100644
--- a/cppcache/integration-test/testXmlCacheCreationWithPools.cpp
+++ b/cppcache/integration-test/testXmlCacheCreationWithPools.cpp
@@ -22,6 +22,7 @@
 #include "fw_dunit.hpp"
 
 #include <geode/GeodeCppCache.hpp>
+#include <geode/util/chrono/duration.hpp>
 
 #define CLIENT1 s1p1
 #define CLIENT2 s1p2
@@ -74,13 +75,16 @@ bool checkStringArray(SLIST& first, CacheableStringArrayPtr second) {
 bool checkPoolAttribs(PoolPtr pool, SLIST& locators, SLIST& servers,
                       int freeConnectionTimeout, int loadConditioningInterval,
                       int minConnections, int maxConnections, int retryAttempts,
-                      int idleTimeout, int pingInterval, const char* name,
-                      int readTimeout, const char* serverGroup,
-                      int socketBufferSize, bool subscriptionEnabled,
+                      std::chrono::milliseconds idleTimeout, int pingInterval,
+                      const char* name, int readTimeout,
+                      const char* serverGroup, int socketBufferSize,
+                      bool subscriptionEnabled,
                       int subscriptionMessageTrackingTimeout,
                       int subscriptionAckInterval, int subscriptionRedundancy,
                       int statisticInterval, int threadLocalConnections,
                       bool prSingleHopEnabled, int updateLocatorListInterval) {
+  using namespace apache::geode::util::chrono::duration;
+
   char logmsg[500] = {0};
 
   if (pool == nullptr) {
@@ -104,19 +108,22 @@ bool checkPoolAttribs(PoolPtr pool, SLIST& locators, SLIST& servers,
     LOG("checkPoolAttribs: servers mismatch");
     return false;
   }
-  if (freeConnectionTimeout != pool->getFreeConnectionTimeout()) {
+  if (std::chrono::milliseconds(freeConnectionTimeout) !=
+      pool->getFreeConnectionTimeout()) {
     sprintf(logmsg,
             "checkPoolAttribs: Pool freeConnectionTimeout expected [%d], "
-            "actual [%d]",
-            freeConnectionTimeout, pool->getFreeConnectionTimeout());
+            "actual [%lld]",
+            freeConnectionTimeout, pool->getFreeConnectionTimeout().count());
     LOG(logmsg);
     return false;
   }
-  if (loadConditioningInterval != pool->getLoadConditioningInterval()) {
+  if (std::chrono::milliseconds(loadConditioningInterval) !=
+      pool->getLoadConditioningInterval()) {
     sprintf(logmsg,
             "checkPoolAttribs: Pool loadConditioningInterval expected [%d], "
-            "actual [%d]",
-            loadConditioningInterval, pool->getLoadConditioningInterval());
+            "actual [%lld]",
+            loadConditioningInterval,
+            pool->getLoadConditioningInterval().count());
     LOG(logmsg);
     return false;
   }
@@ -143,22 +150,23 @@ bool checkPoolAttribs(PoolPtr pool, SLIST& locators, SLIST& servers,
   }
   if (idleTimeout != pool->getIdleTimeout()) {
     sprintf(logmsg,
-            "checkPoolAttribs: Pool idleTimeout expected [%d], actual [%ld]",
-            idleTimeout, pool->getIdleTimeout());
+            "checkPoolAttribs: Pool idleTimeout expected [%s], actual [%s]",
+            to_string(idleTimeout).c_str(),
+            to_string(pool->getIdleTimeout()).c_str());
     LOG(logmsg);
     return false;
   }
-  if (pingInterval != pool->getPingInterval()) {
+  if (std::chrono::milliseconds(pingInterval) != pool->getPingInterval()) {
     sprintf(logmsg,
-            "checkPoolAttribs: Pool pingInterval expected [%d], actual [%ld]",
-            pingInterval, pool->getPingInterval());
+            "checkPoolAttribs: Pool pingInterval expected [%d], actual [%lld]",
+            pingInterval, pool->getPingInterval().count());
     LOG(logmsg);
     return false;
   }
-  if (readTimeout != pool->getReadTimeout()) {
+  if (std::chrono::milliseconds(readTimeout) != pool->getReadTimeout()) {
     sprintf(logmsg,
-            "checkPoolAttribs: Pool readTimeout expected [%d], actual [%d]",
-            readTimeout, pool->getReadTimeout());
+            "checkPoolAttribs: Pool readTimeout expected [%d], actual [%lld]",
+            readTimeout, pool->getReadTimeout().count());
     LOG(logmsg);
     return false;
   }
@@ -187,21 +195,23 @@ bool checkPoolAttribs(PoolPtr pool, SLIST& locators, SLIST& servers,
     LOG(logmsg);
     return false;
   }
-  if (subscriptionMessageTrackingTimeout !=
+  if (std::chrono::milliseconds(subscriptionMessageTrackingTimeout) !=
       pool->getSubscriptionMessageTrackingTimeout()) {
     sprintf(logmsg,
             "checkPoolAttribs: Pool subscriptionMessageTrackingTimeout "
-            "expected [%d], actual [%d]",
+            "expected [%d], actual [%lld]",
             subscriptionMessageTrackingTimeout,
-            pool->getSubscriptionMessageTrackingTimeout());
+            pool->getSubscriptionMessageTrackingTimeout().count());
     LOG(logmsg);
     return false;
   }
-  if (subscriptionAckInterval != pool->getSubscriptionAckInterval()) {
+  if (std::chrono::milliseconds(subscriptionAckInterval) !=
+      pool->getSubscriptionAckInterval()) {
     sprintf(logmsg,
             "checkPoolAttribs: Pool subscriptionAckInterval expected [%d], "
-            "actual [%d]",
-            subscriptionAckInterval, pool->getSubscriptionAckInterval());
+            "actual [%lld]",
+            subscriptionAckInterval,
+            pool->getSubscriptionAckInterval().count());
     LOG(logmsg);
     return false;
   }
@@ -213,11 +223,12 @@ bool checkPoolAttribs(PoolPtr pool, SLIST& locators, SLIST& servers,
     LOG(logmsg);
     return false;
   }
-  if (statisticInterval != pool->getStatisticInterval()) {
+  if (std::chrono::milliseconds(statisticInterval) !=
+      pool->getStatisticInterval()) {
     sprintf(
         logmsg,
-        "checkPoolAttribs: Pool statisticInterval expected [%d], actual [%d]",
-        statisticInterval, pool->getStatisticInterval());
+        "checkPoolAttribs: Pool statisticInterval expected [%d], actual [%lld]",
+        statisticInterval, pool->getStatisticInterval().count());
     LOG(logmsg);
     return false;
   }
@@ -229,11 +240,13 @@ bool checkPoolAttribs(PoolPtr pool, SLIST& locators, SLIST& servers,
     LOG(logmsg);
     return false;
   }
-  if (updateLocatorListInterval != pool->getUpdateLocatorListInterval()) {
+  if (std::chrono::milliseconds(updateLocatorListInterval) !=
+      pool->getUpdateLocatorListInterval()) {
     sprintf(logmsg,
             "checkPoolAttribs: Pool updateLocatorListInterval expected [%d], "
-            "actual [%ld]",
-            updateLocatorListInterval, pool->getUpdateLocatorListInterval());
+            "actual [%lld]",
+            updateLocatorListInterval,
+            pool->getUpdateLocatorListInterval().count());
     LOG(logmsg);
     return false;
   }
@@ -371,19 +384,19 @@ int testXmlCacheCreationWithPools() {
 
   // THIS MUST MATCH WITH THE CLIENT CACHE XML LOADED
 
-  bool check1 =
-      checkPoolAttribs(poolOfReg1, locators, emptylist, 12345, 23456, 3, 7, 3,
-                       5555, 12345, "test_pool_1", 23456, "ServerGroup1", 32768,
-                       true, 900123, 567, 0, 10123, 5, true, 250001);
-
-  bool check2 =
-      checkPoolAttribs(poolOfReg2, emptylist, servers, 23456, 34567, 2, 8, 5,
-                       6666, 23456, "test_pool_2", 34567, "ServerGroup2", 65536,
-                       false, 800222, 678, 1, 20345, 3, false, 5000);
-  bool check3 =
-      checkPoolAttribs(poolOfSubReg, emptylist, servers, 23456, 34567, 2, 8, 5,
-                       6666, 23456, "test_pool_2", 34567, "ServerGroup2", 65536,
-                       false, 800222, 678, 1, 20345, 3, false, 5000);
+  bool check1 = checkPoolAttribs(
+      poolOfReg1, locators, emptylist, 12345, 23456, 3, 7, 3,
+      std::chrono::milliseconds(5555), 12345, "test_pool_1", 23456,
+      "ServerGroup1", 32768, true, 900123, 567, 0, 10123, 5, true, 250001);
+
+  bool check2 = checkPoolAttribs(
+      poolOfReg2, emptylist, servers, 23456, 34567, 2, 8, 5,
+      std::chrono::milliseconds(6666), 23456, "test_pool_2", 34567,
+      "ServerGroup2", 65536, false, 800222, 678, 1, 20345, 3, false, 5000);
+  bool check3 = checkPoolAttribs(
+      poolOfSubReg, emptylist, servers, 23456, 34567, 2, 8, 5,
+      std::chrono::milliseconds(6666), 23456, "test_pool_2", 34567,
+      "ServerGroup2", 65536, false, 800222, 678, 1, 20345, 3, false, 5000);
 
   if (!cptr->isClosed()) {
     cptr->close();
diff --git a/cppcache/integration-test/testXmlCacheCreationWithRefid.cpp b/cppcache/integration-test/testXmlCacheCreationWithRefid.cpp
index da2fd882..b3c12c00 100644
--- a/cppcache/integration-test/testXmlCacheCreationWithRefid.cpp
+++ b/cppcache/integration-test/testXmlCacheCreationWithRefid.cpp
@@ -158,7 +158,7 @@ int testXmlCacheCreationWithRefid(const char* fileName) {
     return -1;
   }
 
-  if (atts->getEntryIdleTimeout() != 10) {
+  if (atts->getEntryIdleTimeout().count() != 10) {
     LOGINFO("Entryidletimeout of SubRegion21 is not 10");
     return -1;
   }
@@ -168,7 +168,7 @@ int testXmlCacheCreationWithRefid(const char* fileName) {
     return -1;
   }
 
-  if (atts->getRegionIdleTimeout() != 20) {
+  if (atts->getRegionIdleTimeout().count() != 20) {
     LOGINFO("Regionidletimeout of SubRegion21 is not 20");
     return -1;
   }
@@ -202,7 +202,7 @@ int testXmlCacheCreationWithRefid(const char* fileName) {
     return -1;
   }
 
-  if (atts->getEntryIdleTimeout() != 10) {
+  if (atts->getEntryIdleTimeout().count() != 10) {
     LOGINFO("Entryidletimeout of Root2 is not 10");
     return -1;
   }
@@ -212,7 +212,7 @@ int testXmlCacheCreationWithRefid(const char* fileName) {
     return -1;
   }
 
-  if (atts->getEntryTimeToLive() != 0) {
+  if (atts->getEntryTimeToLive().count() != 0) {
     LOGINFO("Entrytimetolive of Root2 is not 0");
     return -1;
   }
@@ -222,7 +222,7 @@ int testXmlCacheCreationWithRefid(const char* fileName) {
     return -1;
   }
 
-  if (atts->getRegionIdleTimeout() != 0) {
+  if (atts->getRegionIdleTimeout().count() != 0) {
     LOGINFO("Regionidletimeout of Root2 is not 0");
     return -1;
   }
@@ -232,7 +232,7 @@ int testXmlCacheCreationWithRefid(const char* fileName) {
     return -1;
   }
 
-  if (atts->getRegionTimeToLive() != 0) {
+  if (atts->getRegionTimeToLive().count() != 0) {
     LOGINFO("Regiontimetolive of Root2 is not 0");
     return -1;
   }
diff --git a/cppcache/integration-test/valid_cache_pool.xml b/cppcache/integration-test/valid_cache_pool.xml
index ae847540..a2da0d01 100644
--- a/cppcache/integration-test/valid_cache_pool.xml
+++ b/cppcache/integration-test/valid_cache_pool.xml
@@ -20,11 +20,12 @@
 
 <!-- Well-formed and valid xml file -->
 <client-cache
-    xmlns="http://schema.pivotal.io/gemfire/gfcpp-cache"
+    xmlns="http://geode.apache.org/schema/cpp-cache"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://schema.pivotal.io/gemfire/gfcpp-cache
-                        http://schema.pivotal.io/gemfire/gfcpp-cache/gfcpp-cache-9.0.xsd"
-    version="9.0">
+    xsi:schemaLocation="http://geode.apache.org/schema/cpp-cache
+                        http://geode.apache.org/schema/cpp-cache/cpp-cache-1.0.xsd"
+    version="1.0">
+
   <pdx ignore-unread-fields="true" />
   <root-region name = "Root1" >
     <region-attributes caching-enabled="true" pool-name="test_pool_1" />
@@ -40,22 +41,22 @@
   </root-region>
 
   <pool
-    free-connection-timeout = "12345"    
-    idle-timeout = "5555"
-    load-conditioning-interval = "23456"
+    free-connection-timeout = "12345ms"
+    idle-timeout = "5555ms"
+    load-conditioning-interval = "23456ms"
     max-connections = "7"
     min-connections = "3"
     name = "test_pool_1"
-    ping-interval = "12345"
-	  update-locator-list-interval="250001"
-    read-timeout = "23456"
+    ping-interval = "12345ms"
+	  update-locator-list-interval="250001ms"
+    read-timeout = "23456ms"
     retry-attempts = "3"
     server-group = "ServerGroup1"
     socket-buffer-size = "32768"
-    statistic-interval = "10123"
-    subscription-ack-interval = "567"
+    statistic-interval = "10123ms"
+    subscription-ack-interval = "567ms"
     subscription-enabled = "true"
-    subscription-message-tracking-timeout = "900123"    
+    subscription-message-tracking-timeout = "900123ms"    
     subscription-redundancy = "0"    
     thread-local-connections = "5"
     pr-single-hop-enabled="true"
@@ -65,21 +66,21 @@
   </pool>
   
   <pool
-    free-connection-timeout = "23456"    
-    idle-timeout = "6666"
-    load-conditioning-interval = "34567"
+    free-connection-timeout = "23456ms"
+    idle-timeout = "6666ms"
+    load-conditioning-interval = "34567ms"
     max-connections = "8"
     min-connections = "2"
     name = "test_pool_2"
-    ping-interval = "23456"
-    read-timeout = "34567"
+    ping-interval = "23456ms"
+    read-timeout = "34567ms"
     retry-attempts = "5"
     server-group = "ServerGroup2"
     socket-buffer-size = "65536"
-    statistic-interval = "20345"
-    subscription-ack-interval = "678"
+    statistic-interval = "20345ms"
+    subscription-ack-interval = "678ms"
     subscription-enabled = "false"
-    subscription-message-tracking-timeout = "800222"    
+    subscription-message-tracking-timeout = "800222ms"    
     subscription-redundancy = "1"
     thread-local-connections = "3"
     pr-single-hop-enabled="false"
diff --git a/cppcache/integration-test/valid_cache_refid.xml b/cppcache/integration-test/valid_cache_refid.xml
index afb76912..c45f76cd 100644
--- a/cppcache/integration-test/valid_cache_refid.xml
+++ b/cppcache/integration-test/valid_cache_refid.xml
@@ -19,24 +19,24 @@
 
 
 <!-- Well-formed and valid xml file -->
-<client-cache xmlns="http://geode.apache.org/schema/cache"
+<client-cache xmlns="http://geode.apache.org/schema/cpp-cache"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-              xsi:schemaLocation="http://geode.apache.org/schema/cache http://geode.apache.org/schema/cache/cache-1.0.xsd"
+              xsi:schemaLocation="http://geode.apache.org/schema/cpp-cache http://geode.apache.org/schema/cpp-cache/cpp-cache-1.0.xsd"
               version="1.0">
 
- <root-region name = "Root1" >
+ <region name = "Root1" >
     <region-attributes id="root1" scope="local" caching-enabled="true" initial-capacity="25" load-factor="0.32" concurrency-level="10" lru-entries-limit = "35">
        <region-idle-time>
-         <expiration-attributes timeout="20" action="destroy"/> 
+         <expiration-attributes timeout="20s" action="destroy"/> 
        </region-idle-time>
        <entry-idle-time>
-         <expiration-attributes timeout="10" action="invalidate"/>
+         <expiration-attributes timeout="10s" action="invalidate"/>
        </entry-idle-time>
        <region-time-to-live>
-         <expiration-attributes timeout="0" action="local-destroy"/>
+         <expiration-attributes timeout="0s" action="local-destroy"/>
        </region-time-to-live>
        <entry-time-to-live>
-         <expiration-attributes timeout="0" action="local-invalidate"/>
+         <expiration-attributes timeout="0s" action="local-invalidate"/>
        </entry-time-to-live>
     </region-attributes>
 
@@ -54,30 +54,30 @@
     	<region-attributes refid="sub11" />
     </region>
 
- </root-region>
+ </region>
 
 
- <root-region name= "Root2">
+ <region name= "Root2">
     <region-attributes refid="root1" concurrency-level="16" >                                                         
       <region-time-to-live>
-        <expiration-attributes timeout="0" action="destroy"/>
+        <expiration-attributes timeout="0s" action="destroy"/>
       </region-time-to-live>
        <region-idle-time>
-        <expiration-attributes timeout="0" action="invalidate"/>
+        <expiration-attributes timeout="0s" action="invalidate"/>
       </region-idle-time>
     </region-attributes>
 
     <region name="SubRegion21">
          <region-attributes refid="sub11">
             <region-idle-time>
-               <expiration-attributes timeout="20" action="destroy"/>
+               <expiration-attributes timeout="20s" action="destroy"/>
             </region-idle-time>
             <entry-idle-time>
-               <expiration-attributes timeout="10" action="invalidate"/>
+               <expiration-attributes timeout="10s" action="invalidate"/>
             </entry-idle-time>
          </region-attributes>
     </region>
 
- </root-region>
+ </region>
 
 </client-cache>
diff --git a/cppcache/integration-test/valid_cache_region_refid.xml b/cppcache/integration-test/valid_cache_region_refid.xml
index f900cda0..da2d2123 100644
--- a/cppcache/integration-test/valid_cache_region_refid.xml
+++ b/cppcache/integration-test/valid_cache_region_refid.xml
@@ -19,24 +19,24 @@
 
 
 <!-- Well-formed and valid xml file -->
-<client-cache xmlns="http://geode.apache.org/schema/cache"
+<client-cache xmlns="http://geode.apache.org/schema/cpp-cache"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-              xsi:schemaLocation="http://geode.apache.org/schema/cache http://geode.apache.org/schema/cache/cache-1.0.xsd"
+              xsi:schemaLocation="http://geode.apache.org/schema/cpp-cache http://geode.apache.org/schema/cpp-cache/cpp-cache-1.0.xsd"
               version="1.0">
 
- <root-region name = "Root1" >
+ <region name = "Root1" >
     <region-attributes id="root1" scope="local" caching-enabled="true" initial-capacity="25" load-factor="0.32" concurrency-level="10" lru-entries-limit = "35">
        <region-idle-time>
-         <expiration-attributes timeout="20" action="destroy"/> 
+         <expiration-attributes timeout="20s" action="destroy"/> 
        </region-idle-time>
        <entry-idle-time>
-         <expiration-attributes timeout="10" action="invalidate"/>
+         <expiration-attributes timeout="10s" action="invalidate"/>
        </entry-idle-time>
        <region-time-to-live>
-         <expiration-attributes timeout="0" action="local-destroy"/>
+         <expiration-attributes timeout="0s" action="local-destroy"/>
        </region-time-to-live>
        <entry-time-to-live>
-         <expiration-attributes timeout="0" action="local-invalidate"/>
+         <expiration-attributes timeout="0s" action="local-invalidate"/>
        </entry-time-to-live>
     </region-attributes>
 
@@ -53,29 +53,29 @@
     <region name="SubRegion2" refid="sub11">
     </region>
 
- </root-region>
+ </region>
 
 
- <root-region name= "Root2" refid="root1">
+ <region name= "Root2" refid="root1">
     <region-attributes concurrency-level="16" >                                                         
       <region-time-to-live>
-        <expiration-attributes timeout="0" action="destroy"/>
+        <expiration-attributes timeout="0s" action="destroy"/>
       </region-time-to-live>
        <region-idle-time>
-        <expiration-attributes timeout="0" action="invalidate"/>
+        <expiration-attributes timeout="0s" action="invalidate"/>
       </region-idle-time>
     </region-attributes>
 
     <region name="SubRegion21" refid="sub1">
          <region-attributes refid="sub11">
             <region-idle-time>
-               <expiration-attributes timeout="20" action="destroy"/>
+               <expiration-attributes timeout="20s" action="destroy"/>
             </region-idle-time>
             <entry-idle-time>
-               <expiration-attributes timeout="10" action="invalidate"/>
+               <expiration-attributes timeout="10s" action="invalidate"/>
             </entry-idle-time>
          </region-attributes>
      </region>
- </root-region>
+ </region>
 
 </client-cache>
diff --git a/cppcache/integration-test/valid_overflowAttr.xml b/cppcache/integration-test/valid_overflowAttr.xml
index 8eed3e44..7b170028 100644
--- a/cppcache/integration-test/valid_overflowAttr.xml
+++ b/cppcache/integration-test/valid_overflowAttr.xml
@@ -19,24 +19,24 @@
 
 
 <!-- Well-formed and valid xml file -->
-<client-cache xmlns="http://geode.apache.org/schema/cache"
+<client-cache xmlns="http://geode.apache.org/schema/cpp-cache"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-              xsi:schemaLocation="http://geode.apache.org/schema/cache http://geode.apache.org/schema/cache/cache-1.0.xsd"
+              xsi:schemaLocation="http://geode.apache.org/schema/cpp-cache http://geode.apache.org/schema/cpp-cache/cpp-cache-1.0.xsd"
               version="1.0">
  
  <region name = "Root1" >
     <region-attributes scope="local"  caching-enabled="true" initial-capacity="25" load-factor="0.32" concurrency-level="10" lru-entries-limit = "35" disk-policy="overflows">
        <region-idle-time>
-         <expiration-attributes timeout="20" action="destroy"/> 
+         <expiration-attributes timeout="20s" action="destroy"/> 
        </region-idle-time>
        <entry-idle-time>
-         <expiration-attributes timeout="10" action="invalidate"/>
+         <expiration-attributes timeout="10s" action="invalidate"/>
        </entry-idle-time>
        <region-time-to-live>
-         <expiration-attributes timeout="0" action="local-destroy"/>
+         <expiration-attributes timeout="0s" action="local-destroy"/>
        </region-time-to-live>
        <entry-time-to-live>
-         <expiration-attributes timeout="0" action="local-invalidate"/>
+         <expiration-attributes timeout="0s" action="local-invalidate"/>
        </entry-time-to-live>
        <persistence-manager library-name="SqLiteImpl" library-function-name="createSqLiteInstance">
          <properties>
@@ -79,16 +79,16 @@
  <region name= "Root2">
     <region-attributes scope="local" caching-enabled="true" initial-capacity="16" load-factor="0.75" concurrency-level="16" lru-entries-limit = "35" disk-policy="overflows">         
       <region-time-to-live>
-        <expiration-attributes timeout="0" action="destroy"/>
+        <expiration-attributes timeout="0s" action="destroy"/>
       </region-time-to-live>
        <region-idle-time>
-        <expiration-attributes timeout="0" action="invalidate"/>
+        <expiration-attributes timeout="0s" action="invalidate"/>
       </region-idle-time>
       <entry-time-to-live>
-        <expiration-attributes timeout="0" action="destroy"/>
+        <expiration-attributes timeout="0s" action="destroy"/>
       </entry-time-to-live>
       <entry-idle-time>
-        <expiration-attributes timeout="0" action="invalidate"/>
+        <expiration-attributes timeout="0s" action="invalidate"/>
       </entry-idle-time>
        <persistence-manager library-name="SqLiteImpl" library-function-name="createSqLiteInstance">
          <properties>
@@ -102,10 +102,10 @@
     <region name="SubRegion21">
          <region-attributes scope="local" caching-enabled="true" initial-capacity="16" load-factor="0.75" concurrency-level="16">
             <region-idle-time>
-               <expiration-attributes timeout="20" action="destroy"/>
+               <expiration-attributes timeout="20s" action="destroy"/>
             </region-idle-time>
             <entry-idle-time>
-               <expiration-attributes timeout="10" action="invalidate"/>
+               <expiration-attributes timeout="10s" action="invalidate"/>
             </entry-idle-time>
          </region-attributes>
     </region>
diff --git a/cppcache/src/AdminRegion.hpp b/cppcache/src/AdminRegion.hpp
index 2123a2e4..3efdfdf7 100644
--- a/cppcache/src/AdminRegion.hpp
+++ b/cppcache/src/AdminRegion.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_ADMINREGION_H_
-#define GEODE_ADMINREGION_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,26 +15,36 @@
  * limitations under the License.
  */
 
-#include <geode/geode_types.hpp>
-#include "ThinClientCacheDistributionManager.hpp"
-#include "ReadWriteLock.hpp"
-#include <geode/Serializable.hpp>
+#pragma once
+
+#ifndef GEODE_ADMINREGION_H_
+#define GEODE_ADMINREGION_H_
+
 #include <memory>
-//#include <statistics/HostStatSampler.hpp>
+#include <string>
 
+#include <geode/Serializable.hpp>
+#include <geode/Cacheable.hpp>
+#include <geode/geode_types.hpp>
+
+#include "ReadWriteLock.hpp"
 #include "NonCopyable.hpp"
+
 namespace apache {
 namespace geode {
+
 namespace statistics {
+
 class HostStatSampler;
+
 }  // namespace statistics
-}  // namespace geode
-}  // namespace apache
 
-namespace apache {
-namespace geode {
 namespace client {
+
 class CacheImpl;
+class ThinClientBaseDM;
+class TcrConnectionManager;
+
 class AdminRegion : private NonCopyable,
                     private NonAssignable,
                     public std::enable_shared_from_this<AdminRegion> {
diff --git a/cppcache/src/AttributesFactory.cpp b/cppcache/src/AttributesFactory.cpp
index 4d7535d9..d45d193e 100644
--- a/cppcache/src/AttributesFactory.cpp
+++ b/cppcache/src/AttributesFactory.cpp
@@ -71,24 +71,25 @@ void AttributesFactory::setPartitionResolver(const char* lib,
 }
 
 void AttributesFactory::setEntryIdleTimeout(ExpirationAction::Action action,
-                                            int idleTimeout) {
+                                            std::chrono::seconds idleTimeout) {
   m_regionAttributes.m_entryIdleTimeout = idleTimeout;
   m_regionAttributes.m_entryIdleTimeoutExpirationAction = action;
 }
 
 void AttributesFactory::setEntryTimeToLive(ExpirationAction::Action action,
-                                           int timeToLive) {
+                                           std::chrono::seconds timeToLive) {
   m_regionAttributes.m_entryTimeToLive = timeToLive;
   m_regionAttributes.m_entryTimeToLiveExpirationAction = action;
 }
 
 void AttributesFactory::setRegionIdleTimeout(ExpirationAction::Action action,
-                                             int idleTimeout) {
+                                             std::chrono::seconds idleTimeout) {
   m_regionAttributes.m_regionIdleTimeout = idleTimeout;
   m_regionAttributes.m_regionIdleTimeoutExpirationAction = action;
 }
+
 void AttributesFactory::setRegionTimeToLive(ExpirationAction::Action action,
-                                            int timeToLive) {
+                                            std::chrono::seconds timeToLive) {
   m_regionAttributes.m_regionTimeToLive = timeToLive;
   m_regionAttributes.m_regionTimeToLiveExpirationAction = action;
 }
@@ -121,12 +122,12 @@ std::unique_ptr<RegionAttributes> AttributesFactory::createRegionAttributes() {
 
 void AttributesFactory::validateAttributes(RegionAttributes& attrs) {
   if (!attrs.m_caching) {
-    if (attrs.m_entryTimeToLive != 0) {
+    if (attrs.m_entryTimeToLive != std::chrono::seconds::zero()) {
       throw IllegalStateException(
           "Entry TimeToLive use is incompatible with disabled caching");
     }
 
-    if (attrs.m_entryIdleTimeout != 0) {
+    if (attrs.m_entryIdleTimeout != std::chrono::seconds::zero()) {
       throw IllegalStateException(
           "Entry IdleTimeout use is incompatible with disabled caching");
     }
diff --git a/cppcache/src/AttributesMutator.cpp b/cppcache/src/AttributesMutator.cpp
index 67042f2e..dbd5dabc 100644
--- a/cppcache/src/AttributesMutator.cpp
+++ b/cppcache/src/AttributesMutator.cpp
@@ -27,102 +27,54 @@ AttributesMutator::AttributesMutator(const RegionPtr& region)
 
 AttributesMutator::~AttributesMutator() { m_region = nullptr; }
 
-/** Sets the idleTimeout duration for region entries.
- * @param idleTimeout the idleTimeout in seconds for entries in this region.
- * @return the previous value.
- * @throw IllegalStateException if the new idleTimeout changes entry expiration
- * from
- *   disabled to enabled or enabled to disabled.
- */
-int32_t AttributesMutator::setEntryIdleTimeout(int32_t idleTimeout) {
-  RegionInternal* rImpl = dynamic_cast<RegionInternal*>(m_region.get());
-  return rImpl->adjustEntryExpiryDuration(idleTimeout);
+std::chrono::seconds AttributesMutator::setEntryIdleTimeout(
+    std::chrono::seconds idleTimeout) {
+  return std::static_pointer_cast<RegionInternal>(m_region)
+      ->adjustEntryExpiryDuration(idleTimeout);
 }
 
-/** Set the idleTimeout Action for region entries.
- * @param action the idleTimeout ExpirationAction::Action for entries in this
- * region.
- * @return the previous value.
- */
 ExpirationAction::Action AttributesMutator::setEntryIdleTimeoutAction(
     ExpirationAction::Action action) {
   RegionInternal* rImpl = dynamic_cast<RegionInternal*>(m_region.get());
   return rImpl->adjustEntryExpiryAction(action);
 }
 
-/** Sets the timeToLive duration for region entries.
- * @param timeToLive the timeToLive in seconds for entries in this region.
- * @return the previous value.
- * @throw IllegalStateException if the new timeToLive changes entry expiration
- * from
- *   disabled to enabled or enabled to disabled.
- */
-int32_t AttributesMutator::setEntryTimeToLive(int32_t timeToLive) {
+std::chrono::seconds AttributesMutator::setEntryTimeToLive(
+    std::chrono::seconds timeToLive) {
   RegionInternal* rImpl = dynamic_cast<RegionInternal*>(m_region.get());
   return rImpl->adjustEntryExpiryDuration(timeToLive);
 }
 
-/** Set the timeToLive Action for region entries.
- * @param action the timeToLive ExpirationAction::Action for entries in this
- * region.
- * @return the previous value.
- */
 ExpirationAction::Action AttributesMutator::setEntryTimeToLiveAction(
     ExpirationAction::Action action) {
   RegionInternal* rImpl = dynamic_cast<RegionInternal*>(m_region.get());
   return rImpl->adjustEntryExpiryAction(action);
 }
 
-/** Sets the idleTimeout duration for the region itself.
- * @param idleTimeout the ExpirationAttributes for this region idleTimeout
- * @return the previous value.
- * @throw IllegalStateException if the new idleTimeout changes region expiration
- * from
- *   disabled to enabled or enabled to disabled.
- */
-int32_t AttributesMutator::setRegionIdleTimeout(int32_t idleTimeout) {
+std::chrono::seconds AttributesMutator::setRegionIdleTimeout(
+    std::chrono::seconds idleTimeout) {
   RegionInternal* rImpl = dynamic_cast<RegionInternal*>(m_region.get());
   return rImpl->adjustRegionExpiryDuration(idleTimeout);
 }
 
-/** Set the idleTimeout Action for the region itself.
- * @param action the idleTimeout ExpirationAction::Action for this region.
- * @return the previous value.
- */
 ExpirationAction::Action AttributesMutator::setRegionIdleTimeoutAction(
     ExpirationAction::Action action) {
   RegionInternal* rImpl = dynamic_cast<RegionInternal*>(m_region.get());
   return rImpl->adjustRegionExpiryAction(action);
 }
 
-/** Sets the timeToLive duration for the region itself.
- * @param timeToLive the ExpirationAttributes for this region timeToLive
- * @return the previous value.
- * @throw IllegalStateException if the new timeToLive changes region expiration
- * from
- *   disabled to enabled or enabled to disabled.
- */
-int32_t AttributesMutator::setRegionTimeToLive(int32_t timeToLive) {
+std::chrono::seconds AttributesMutator::setRegionTimeToLive(
+    std::chrono::seconds timeToLive) {
   RegionInternal* rImpl = dynamic_cast<RegionInternal*>(m_region.get());
   return rImpl->adjustRegionExpiryDuration(timeToLive);
 }
 
-/** Set the timeToLive Action for the region itself.
- * @param action the timeToLive ExpirationAction::Action for this region.
- * @return the previous value.
- */
 ExpirationAction::Action AttributesMutator::setRegionTimeToLiveAction(
     ExpirationAction::Action action) {
   RegionInternal* rImpl = dynamic_cast<RegionInternal*>(m_region.get());
   return rImpl->adjustRegionExpiryAction(action);
 }
 
-/** Sets the Maximum entry count in the region before LRU eviction.
- * @param entriesLimit the number of entries to allow.
- * @return the previous value.
- * @throw IllegalStateException if the new entriesLimit changes LRU from
- *   disabled to enabled or enabled to disabled.
- */
 uint32_t AttributesMutator::setLruEntriesLimit(uint32_t entriesLimit) {
   RegionInternal* rImpl = dynamic_cast<RegionInternal*>(m_region.get());
   return rImpl->adjustLruEntriesLimit(entriesLimit);
diff --git a/cppcache/src/CacheFactory.cpp b/cppcache/src/CacheFactory.cpp
index e754f913..cb6e1806 100644
--- a/cppcache/src/CacheFactory.cpp
+++ b/cppcache/src/CacheFactory.cpp
@@ -172,8 +172,8 @@ CacheFactoryPtr CacheFactory::set(const char* name, const char* value) {
 }
 
 CacheFactoryPtr CacheFactory::setAuthInitialize(
-    const AuthInitializePtr& authInitialize) {
-  this->authInitialize = authInitialize;
+    const AuthInitializePtr& handler) {
+  this->authInitialize = handler;
   return shared_from_this();
 }
 
@@ -186,6 +186,7 @@ CacheFactoryPtr CacheFactory::setPdxReadSerialized(bool prs) {
   pdxReadSerialized = prs;
   return shared_from_this();
 }
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/src/CacheTransactionManagerImpl.cpp b/cppcache/src/CacheTransactionManagerImpl.cpp
index 4a795e64..28bf287a 100644
--- a/cppcache/src/CacheTransactionManagerImpl.cpp
+++ b/cppcache/src/CacheTransactionManagerImpl.cpp
@@ -361,13 +361,15 @@ TransactionIdPtr CacheTransactionManagerImpl::suspend() {
   txState->releaseStickyConnection();
 
   // set the expiry handler for the suspended transaction
-  auto& sysProp = m_cache->getDistributedSystem().getSystemProperties();
-  SuspendedTxExpiryHandler* handler = new SuspendedTxExpiryHandler(
-      this, txState->getTransactionId(), sysProp.suspendedTxTimeout());
+  auto suspendedTxTimeout = m_cache->getDistributedSystem()
+                                .getSystemProperties()
+                                .suspendedTxTimeout();
+  auto handler = new SuspendedTxExpiryHandler(this, txState->getTransactionId(),
+                                              suspendedTxTimeout);
   long id = CacheRegionHelper::getCacheImpl(m_cache)
                 ->getExpiryTaskManager()
-                .scheduleExpiryTask(handler, sysProp.suspendedTxTimeout() * 60,
-                                    0, false);
+                .scheduleExpiryTask(handler, suspendedTxTimeout,
+                                    std::chrono::seconds::zero(), false);
   txState->setSuspendedExpiryTaskId(id);
 
   // add the transaction state to the list of suspended transactions
@@ -423,8 +425,8 @@ bool CacheTransactionManagerImpl::tryResume(TransactionIdPtr transactionId,
   return true;
 }
 
-bool CacheTransactionManagerImpl::tryResume(TransactionIdPtr transactionId,
-                                            int32_t waitTimeInMillisec) {
+bool CacheTransactionManagerImpl::tryResume(
+    TransactionIdPtr transactionId, std::chrono::milliseconds waitTime) {
   // get the current state of the thread
   if (TSSTXStateWrapper::s_geodeTSSTXState->getTXState() != nullptr) {
     LOGFINE("A transaction is already in progress. Cannot resume transaction.");
@@ -434,9 +436,8 @@ bool CacheTransactionManagerImpl::tryResume(TransactionIdPtr transactionId,
   if (!exists(transactionId)) return false;
 
   // get the transaction state of the suspended transaction
-  TXState* txState = removeSuspendedTxUntil(
-      (std::static_pointer_cast<TXId>(transactionId))->getId(),
-      waitTimeInMillisec);
+  TXState* txState = removeSuspendedTx(
+      (std::static_pointer_cast<TXId>(transactionId))->getId(), waitTime);
   if (txState == nullptr) return false;
 
   resumeTxUsingTxState(txState);
@@ -542,14 +543,12 @@ TXState* CacheTransactionManagerImpl::removeSuspendedTx(int32_t txId) {
   m_suspendedTXs.erase(it);
   return rettxState;
 }
-TXState* CacheTransactionManagerImpl::removeSuspendedTxUntil(
-    int32_t txId, int32_t waitTimeInMillisec) {
+TXState* CacheTransactionManagerImpl::removeSuspendedTx(
+    int32_t txId, std::chrono::milliseconds waitTime) {
   ACE_Guard<ACE_Recursive_Thread_Mutex> _guard(m_suspendedTxLock);
   TXState* txState = nullptr;
   ACE_Time_Value currTime(ACE_OS::gettimeofday());
   ACE_Time_Value stopAt(currTime);
-  ACE_Time_Value waitTime;
-  waitTime.msec(waitTimeInMillisec);
   stopAt += waitTime;
 
   do {
diff --git a/cppcache/src/CacheTransactionManagerImpl.hpp b/cppcache/src/CacheTransactionManagerImpl.hpp
index 3617a11b..0ca7d535 100644
--- a/cppcache/src/CacheTransactionManagerImpl.hpp
+++ b/cppcache/src/CacheTransactionManagerImpl.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_CACHETRANSACTIONMANAGERIMPL_H_
-#define GEODE_CACHETRANSACTIONMANAGERIMPL_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -19,12 +14,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-/*
- * CacheTransactionManagerImpl.h
- *
- *  Created on: 04-Feb-2011
- *      Author: ankurs
- */
+
+#pragma once
+
+#ifndef GEODE_CACHETRANSACTIONMANAGERIMPL_H_
+#define GEODE_CACHETRANSACTIONMANAGERIMPL_H_
 
 #include <geode/CacheTransactionManager.hpp>
 
@@ -45,20 +39,20 @@ class CacheTransactionManagerImpl
   CacheTransactionManagerImpl(Cache* cache);
   virtual ~CacheTransactionManagerImpl();
 
-  virtual void begin();
-  virtual void commit();
-  virtual void rollback();
-  virtual bool exists();
-  virtual TransactionIdPtr suspend();
-  virtual void resume(TransactionIdPtr transactionId);
-  virtual bool isSuspended(TransactionIdPtr transactionId);
-  virtual bool tryResume(TransactionIdPtr transactionId);
+  virtual void begin() override;
+  virtual void commit() override;
+  virtual void rollback() override;
+  virtual bool exists() override;
+  virtual TransactionIdPtr suspend() override;
+  virtual void resume(TransactionIdPtr transactionId) override;
+  virtual bool isSuspended(TransactionIdPtr transactionId) override;
+  virtual bool tryResume(TransactionIdPtr transactionId) override;
   bool tryResume(TransactionIdPtr transactionId, bool cancelExpiryTask);
   virtual bool tryResume(TransactionIdPtr transactionId,
-                         int32_t waitTimeInMillisec);
-  virtual bool exists(TransactionIdPtr transactionId);
+                         std::chrono::milliseconds waitTime) override;
+  virtual bool exists(TransactionIdPtr transactionId) override;
 
-  virtual TransactionIdPtr getTransactionId();
+  virtual TransactionIdPtr getTransactionId() override;
 
   TXState* getSuspendedTx(int32_t txId);
 
@@ -73,7 +67,7 @@ class CacheTransactionManagerImpl
   GfErrType rollback(TXState* txState, bool callListener);
   void addSuspendedTx(int32_t txId, TXState* txState);
   TXState* removeSuspendedTx(int32_t txId);
-  TXState* removeSuspendedTxUntil(int32_t txId, int32_t waitTimeInSec);
+  TXState* removeSuspendedTx(int32_t txId, std::chrono::milliseconds waitTime);
   bool isSuspendedTx(int32_t txId);
   void addTx(int32_t txId);
   bool removeTx(int32_t txId);
diff --git a/cppcache/src/CacheXmlParser.cpp b/cppcache/src/CacheXmlParser.cpp
index 52ee6034..2f770429 100644
--- a/cppcache/src/CacheXmlParser.cpp
+++ b/cppcache/src/CacheXmlParser.cpp
@@ -14,10 +14,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#include "CacheXmlParser.hpp"
-#include "CacheRegionHelper.hpp"
+
+#include <chrono>
+
+#include <geode/util/chrono/duration.hpp>
 #include <geode/PoolManager.hpp>
 #include <geode/PoolFactory.hpp>
+
+#include "CacheXmlParser.hpp"
+#include "CacheRegionHelper.hpp"
 #include "AutoDelete.hpp"
 #include "CacheImpl.hpp"
 
@@ -634,7 +639,9 @@ void CacheXmlParser::endPool() {
 void CacheXmlParser::setPoolInfo(PoolFactory* factory, const char* name,
                                  const char* value) {
   if (strcmp(name, FREE_CONNECTION_TIMEOUT) == 0) {
-    factory->setFreeConnectionTimeout(atoi(value));
+    factory->setFreeConnectionTimeout(
+        util::chrono::duration::from_string<std::chrono::milliseconds>(
+            std::string(value)));
   } else if (strcmp(name, MULTIUSER_SECURE_MODE) == 0) {
     if (ACE_OS::strcasecmp(value, "true") == 0) {
       factory->setMultiuserAuthentication(true);
@@ -642,19 +649,29 @@ void CacheXmlParser::setPoolInfo(PoolFactory* factory, const char* name,
       factory->setMultiuserAuthentication(false);
     }
   } else if (strcmp(name, IDLE_TIMEOUT) == 0) {
-    factory->setIdleTimeout(atoi(value));
+    factory->setIdleTimeout(
+        util::chrono::duration::from_string<std::chrono::milliseconds>(
+            std::string(value)));
   } else if (strcmp(name, LOAD_CONDITIONING_INTERVAL) == 0) {
-    factory->setLoadConditioningInterval(atoi(value));
+    factory->setLoadConditioningInterval(
+        util::chrono::duration::from_string<std::chrono::milliseconds>(
+            std::string(value)));
   } else if (strcmp(name, MAX_CONNECTIONS) == 0) {
     factory->setMaxConnections(atoi(value));
   } else if (strcmp(name, MIN_CONNECTIONS) == 0) {
     factory->setMinConnections(atoi(value));
   } else if (strcmp(name, PING_INTERVAL) == 0) {
-    factory->setPingInterval(atoi(value));
+    factory->setPingInterval(
+        util::chrono::duration::from_string<std::chrono::milliseconds>(
+            std::string(value)));
   } else if (strcmp(name, UPDATE_LOCATOR_LIST_INTERVAL) == 0) {
-    factory->setUpdateLocatorListInterval(atoi(value));
+    factory->setUpdateLocatorListInterval(
+        util::chrono::duration::from_string<std::chrono::milliseconds>(
+            std::string(value)));
   } else if (strcmp(name, READ_TIMEOUT) == 0) {
-    factory->setReadTimeout(atoi(value));
+    factory->setReadTimeout(
+        util::chrono::duration::from_string<std::chrono::milliseconds>(
+            std::string(value)));
   } else if (strcmp(name, RETRY_ATTEMPTS) == 0) {
     factory->setRetryAttempts(atoi(value));
   } else if (strcmp(name, SERVER_GROUP) == 0) {
@@ -662,9 +679,13 @@ void CacheXmlParser::setPoolInfo(PoolFactory* factory, const char* name,
   } else if (strcmp(name, SOCKET_BUFFER_SIZE) == 0) {
     factory->setSocketBufferSize(atoi(value));
   } else if (strcmp(name, STATISTIC_INTERVAL) == 0) {
-    factory->setStatisticInterval(atoi(value));
+    factory->setStatisticInterval(
+        util::chrono::duration::from_string<std::chrono::milliseconds>(
+            std::string(value)));
   } else if (strcmp(name, SUBSCRIPTION_ACK_INTERVAL) == 0) {
-    factory->setSubscriptionAckInterval(atoi(value));
+    factory->setSubscriptionAckInterval(
+        util::chrono::duration::from_string<std::chrono::milliseconds>(
+            std::string(value)));
   } else if (strcmp(name, SUBSCRIPTION_ENABLED) == 0) {
     if (ACE_OS::strcasecmp(value, "true") == 0) {
       factory->setSubscriptionEnabled(true);
@@ -672,7 +693,9 @@ void CacheXmlParser::setPoolInfo(PoolFactory* factory, const char* name,
       factory->setSubscriptionEnabled(false);
     }
   } else if (strcmp(name, SUBSCRIPTION_MTT) == 0) {
-    factory->setSubscriptionMessageTrackingTimeout(atoi(value));
+    factory->setSubscriptionMessageTrackingTimeout(
+        util::chrono::duration::from_string<std::chrono::milliseconds>(
+            std::string(value)));
   } else if (strcmp(name, SUBSCRIPTION_REDUNDANCY) == 0) {
     factory->setSubscriptionRedundancy(atoi(value));
   } else if (strcmp(name, THREAD_LOCAL_CONNECTIONS) == 0) {
@@ -1045,19 +1068,20 @@ void CacheXmlParser::startExpirationAttributes(const xmlChar** atts) {
         "<expirartion-attributes>";
     throw CacheXmlException(s.c_str());
   }
-  char* timeOut = nullptr;
-  int timeOutInt = 0;
+  std::string timeOut;
+  std::chrono::seconds timeOutSeconds;
   ExpirationAction::Action expire = ExpirationAction::INVALID_ACTION;
   for (int i = 0; (atts[i] != nullptr); i++) {
     if (strcmp(TIMEOUT, (char*)atts[i]) == 0) {
       i++;
-      timeOut = (char*)atts[i];
-      if (strcmp(timeOut, "") == 0) {
+      timeOut = std::string((char*)atts[i]);
+      if (timeOut.empty()) {
         std::string s =
             "XML:Value for attribute <timeout> needs to be specified";
         throw CacheXmlException(s.c_str());
       }
-      timeOutInt = atoi(timeOut);
+      timeOutSeconds =
+          util::chrono::duration::from_string<std::chrono::seconds>(timeOut);
     } else if (strcmp(ACTION, (char*)atts[i]) == 0) {
       i++;
       char* action = (char*)atts[i];
@@ -1096,14 +1120,15 @@ void CacheXmlParser::startExpirationAttributes(const xmlChar** atts) {
       throw CacheXmlException(s.c_str());
     }
   }
-  if (timeOut == nullptr || strcmp(timeOut, "") == 0) {
+  if (timeOut.empty()) {
     std::string s =
         "XML:The attribute <timeout> not specified in "
         "<expiration-attributes>.";
     throw CacheXmlException(s.c_str());
   }
 
-  auto expireAttr = std::make_shared<ExpirationAttributes>(timeOutInt, expire);
+  auto expireAttr =
+      std::make_shared<ExpirationAttributes>(timeOutSeconds, expire);
   if (!expireAttr) {
     throw UnknownException(
         "CacheXmlParser::startExpirationAttributes:Out of memeory");
@@ -1653,6 +1678,7 @@ void CacheXmlParser::endEntryIdleTime() {
       std::static_pointer_cast<ExpirationAttributes>(_stack.top());
   _stack.pop();
   auto attrsFactory = std::static_pointer_cast<AttributesFactory>(_stack.top());
+  // TODO GEODE-3136: consider string parser here.
   attrsFactory->setEntryIdleTimeout(expireAttr->getAction(),
                                     expireAttr->getTimeout());
   m_flagExpirationAttribute = false;
diff --git a/cppcache/src/ClientMetadataService.cpp b/cppcache/src/ClientMetadataService.cpp
index 3fc7ef43..f313ae6c 100644
--- a/cppcache/src/ClientMetadataService.cpp
+++ b/cppcache/src/ClientMetadataService.cpp
@@ -32,7 +32,7 @@ namespace client {
 const char* ClientMetadataService::NC_CMDSvcThread = "NC CMDSvcThread";
 ClientMetadataService::~ClientMetadataService() {
   delete m_regionQueue;
-  if (m_bucketWaitTimeout > 0) {
+  if (m_bucketWaitTimeout > std::chrono::milliseconds::zero()) {
     try {
       std::map<std::string, PRbuckets*>::iterator bi;
       for (bi = m_bucketStatus.begin(); bi != m_bucketStatus.end(); ++bi) {
@@ -46,9 +46,6 @@ ClientMetadataService::~ClientMetadataService() {
 }
 
 ClientMetadataService::ClientMetadataService(Pool* pool)
-    /* adongre
-     * CID 28928: Uninitialized scalar field (UNINIT_CTOR)
-     */
     : m_run(false)
 
 {
@@ -144,7 +141,8 @@ void ClientMetadataService::getClientPRMetadata(const char* regionFullPath) {
       cptr = std::make_shared<ClientMetadata>(reply.getNumBuckets(),
                                               reply.getColocatedWith(), tcrdm,
                                               reply.getFpaSet());
-      if (m_bucketWaitTimeout > 0 && reply.getNumBuckets() > 0) {
+      if (m_bucketWaitTimeout > std::chrono::milliseconds::zero() &&
+          reply.getNumBuckets() > 0) {
         WriteGuard guard(m_PRbucketStatusLock);
         m_bucketStatus[regionFullPath] = new PRbuckets(reply.getNumBuckets());
       }
@@ -463,7 +461,7 @@ void ClientMetadataService::markPrimaryBucketForTimeout(
     const RegionPtr& region, const CacheableKeyPtr& key,
     const CacheablePtr& value, const SerializablePtr& aCallbackArgument,
     bool isPrimary, BucketServerLocationPtr& serverLocation, int8_t& version) {
-  if (m_bucketWaitTimeout == 0) return;
+  if (m_bucketWaitTimeout == std::chrono::milliseconds::zero()) return;
 
   WriteGuard guard(m_PRbucketStatusLock);
 
@@ -810,7 +808,7 @@ void ClientMetadataService::markPrimaryBucketForTimeoutButLookSecondaryBucket(
     const RegionPtr& region, const CacheableKeyPtr& key,
     const CacheablePtr& value, const SerializablePtr& aCallbackArgument,
     bool isPrimary, BucketServerLocationPtr& serverLocation, int8_t& version) {
-  if (m_bucketWaitTimeout == 0) return;
+  if (m_bucketWaitTimeout == std::chrono::milliseconds::zero()) return;
 
   WriteGuard guard(m_PRbucketStatusLock);
 
@@ -862,7 +860,7 @@ void ClientMetadataService::markPrimaryBucketForTimeoutButLookSecondaryBucket(
 
 bool ClientMetadataService::isBucketMarkedForTimeout(const char* regionFullPath,
                                                      int32_t bucketid) {
-  if (m_bucketWaitTimeout == 0) return false;
+  if (m_bucketWaitTimeout == std::chrono::milliseconds::zero()) return false;
 
   ReadGuard guard(m_PRbucketStatusLock);
 
diff --git a/cppcache/src/ClientMetadataService.hpp b/cppcache/src/ClientMetadataService.hpp
index 506c3516..19b236d3 100644
--- a/cppcache/src/ClientMetadataService.hpp
+++ b/cppcache/src/ClientMetadataService.hpp
@@ -53,11 +53,11 @@ class BucketStatus {
 
  public:
   BucketStatus() : m_lastTimeout(ACE_Time_Value::zero) {}
-  bool isTimedoutAndReset(uint32_t millis) {
+  bool isTimedoutAndReset(std::chrono::milliseconds millis) {
     if (m_lastTimeout == ACE_Time_Value::zero) {
       return false;
     } else {
-      ACE_Time_Value to(0, millis * 1000);
+      ACE_Time_Value to(millis);
       to += m_lastTimeout;
       if (to > ACE_OS::gettimeofday()) {
         return true;  // timeout as buckste not recovered yet
@@ -84,28 +84,13 @@ class PRbuckets {
   PRbuckets(int32_t nBuckets) { m_buckets = new BucketStatus[nBuckets]; }
   ~PRbuckets() { delete[] m_buckets; }
 
-  bool isBucketTimedOut(int32_t bucketId, uint32_t millis) {
+  bool isBucketTimedOut(int32_t bucketId, std::chrono::milliseconds millis) {
     return m_buckets[bucketId].isTimedoutAndReset(millis);
   }
 
   void setBucketTimeout(int32_t bucketId) { m_buckets[bucketId].setTimeout(); }
 };
 
-/* adongre
- * CID 28726: Other violation (MISSING_COPY)
- * Class "apache::geode::client::ClientMetadataService" owns resources that are
- * managed
- * in its constructor and destructor but has no user-written copy constructor.
- *
- * CID 28712: Other violation (MISSING_ASSIGN)
- * Class "apache::geode::client::ClientMetadataService" owns resources that are
- * managed
- * in its constructor and destructor but has no user-written assignment
- * operator.
- *
- * FIX : Make the class NonCopyabl3
- */
-
 class ClientMetadataService : public ACE_Task_Base,
                               private NonCopyable,
                               private NonAssignable {
@@ -228,7 +213,7 @@ class ClientMetadataService : public ACE_Task_Base,
 
   ACE_RW_Thread_Mutex m_PRbucketStatusLock;
   std::map<std::string, PRbuckets*> m_bucketStatus;
-  uint32_t m_bucketWaitTimeout;
+  std::chrono::milliseconds m_bucketWaitTimeout;
   static const char* NC_CMDSvcThread;
 };
 }  // namespace client
diff --git a/cppcache/src/ClientProxyMembershipID.cpp b/cppcache/src/ClientProxyMembershipID.cpp
index 4b3d7186..d9aa1fb1 100644
--- a/cppcache/src/ClientProxyMembershipID.cpp
+++ b/cppcache/src/ClientProxyMembershipID.cpp
@@ -73,7 +73,7 @@ ClientProxyMembershipID::~ClientProxyMembershipID() {
 ClientProxyMembershipID::ClientProxyMembershipID(
     std::string dsName, std::string randString, const char* hostname,
     uint32_t hostAddr, uint32_t hostPort, const char* durableClientId,
-    const uint32_t durableClntTimeOut)
+    const std::chrono::seconds durableClntTimeOut)
     : m_hostAddrAsUInt32(hostAddr) {
   int32_t vmPID = ACE_OS::getpid();
   initObjectVars(hostname, reinterpret_cast<uint8_t*>(&m_hostAddrAsUInt32), 4,
@@ -87,13 +87,14 @@ ClientProxyMembershipID::ClientProxyMembershipID(
     uint8_t* hostAddr, uint32_t hostAddrLen, uint32_t hostPort,
     const char* dsname, const char* uniqueTag, uint32_t vmViewId) {
   int32_t vmPID = ACE_OS::getpid();
-  initObjectVars("localhost", hostAddr, hostAddrLen, false, hostPort, "", 0,
-                 DCPORT, vmPID, VMKIND, 0, dsname, uniqueTag, vmViewId);
+  initObjectVars("localhost", hostAddr, hostAddrLen, false, hostPort, "",
+                 std::chrono::seconds::zero(), DCPORT, vmPID, VMKIND, 0, dsname,
+                 uniqueTag, vmViewId);
 }
 void ClientProxyMembershipID::initObjectVars(
     const char* hostname, uint8_t* hostAddr, uint32_t hostAddrLen,
     bool hostAddrLocalMem, uint32_t hostPort, const char* durableClientId,
-    const uint32_t durableClntTimeOut, int32_t dcPort, int32_t vPID,
+    const std::chrono::seconds durableClntTimeOut, int32_t dcPort, int32_t vPID,
     int8_t vmkind, int8_t splitBrainFlag, const char* dsname,
     const char* uniqueTag, uint32_t vmViewId) {
   DataOutputInternal m_memID;
@@ -138,10 +139,11 @@ void ClientProxyMembershipID::initObjectVars(
   m_memID.write(static_cast<int8_t>(GeodeTypeIds::CacheableASCIIString));
   m_memID.writeASCII(uniqueTag);
 
-  if (durableClientId != nullptr && durableClntTimeOut != 0) {
+  if (durableClientId != nullptr &&
+      durableClntTimeOut != std::chrono::seconds::zero()) {
     m_memID.write(static_cast<int8_t>(GeodeTypeIds::CacheableASCIIString));
     m_memID.writeASCII(durableClientId);
-    CacheableInt32Ptr int32ptr = CacheableInt32::create(durableClntTimeOut);
+    const auto int32ptr = CacheableInt32::create(durableClntTimeOut.count());
     int32ptr->toData(m_memID);
   }
   writeVersion(Version::getOrdinal(), m_memID);
@@ -217,7 +219,7 @@ void ClientProxyMembershipID::toData(DataOutput& output) const {
 void ClientProxyMembershipID::fromData(DataInput& input) {
   // deserialization for PR FX HA
   uint8_t* hostAddr;
-  int32_t len, hostPort, dcport, vPID, durableClntTimeOut;
+  int32_t len, hostPort, dcport, vPID;
   CacheableStringPtr hostname, dsName, uniqueTag, durableClientId;
   int8_t splitbrain, vmKind;
 
@@ -241,7 +243,7 @@ void ClientProxyMembershipID::fromData(DataInput& input) {
   dsName = input.readObject<CacheableString>();           // name
   uniqueTag = input.readObject<CacheableString>();        // unique tag
   durableClientId = input.readObject<CacheableString>();  // durable client id
-  durableClntTimeOut = input.readInt32();  // durable client timeout
+  auto durableClntTimeOut = std::chrono::seconds(input.readInt32());  // durable client timeout
   int32_t vmViewId = 0;
   readVersion(splitbrain, input);
 
@@ -294,12 +296,14 @@ Serializable* ClientProxyMembershipID::readEssentialData(DataInput& input) {
 
   if (vmKind != ClientProxyMembershipID::LONER_DM_TYPE) {
     // initialize the object with the values read and some dummy values
-    initObjectVars("", hostAddr, len, true, hostPort, "", 0, DCPORT, 0, vmKind,
-                   0, dsName->asChar(), nullptr, vmViewId);
+    initObjectVars("", hostAddr, len, true, hostPort, "",
+                   std::chrono::seconds::zero(), DCPORT, 0, vmKind, 0,
+                   dsName->asChar(), nullptr, vmViewId);
   } else {
     // initialize the object with the values read and some dummy values
-    initObjectVars("", hostAddr, len, true, hostPort, "", 0, DCPORT, 0, vmKind,
-                   0, dsName->asChar(), uniqueTag->asChar(), vmViewId);
+    initObjectVars("", hostAddr, len, true, hostPort, "",
+                   std::chrono::seconds::zero(), DCPORT, 0, vmKind, 0,
+                   dsName->asChar(), uniqueTag->asChar(), vmViewId);
   }
 
   readAdditionalData(input);
diff --git a/cppcache/src/ClientProxyMembershipID.hpp b/cppcache/src/ClientProxyMembershipID.hpp
index 02f46535..991e0c7e 100644
--- a/cppcache/src/ClientProxyMembershipID.hpp
+++ b/cppcache/src/ClientProxyMembershipID.hpp
@@ -43,7 +43,8 @@ class ClientProxyMembershipID : public DSMemberForVersionStamp {
                           const char* hostname, uint32_t hostAddr,
                           uint32_t hostPort,
                           const char* durableClientId = nullptr,
-                          const uint32_t durableClntTimeOut = 0);
+                          const std::chrono::seconds durableClntTimeOut =
+                              std::chrono::seconds::zero());
 
   // This constructor is only for testing and should not be used for any
   // other purpose. See testEntriesMapForVersioning.cpp for more details
@@ -73,10 +74,10 @@ class ClientProxyMembershipID : public DSMemberForVersionStamp {
   void initObjectVars(const char* hostname, uint8_t* hostAddr,
                       uint32_t hostAddrLen, bool hostAddrLocalMem,
                       uint32_t hostPort, const char* durableClientId,
-                      const uint32_t durableClntTimeOut, int32_t dcPort,
-                      int32_t vPID, int8_t vmkind, int8_t splitBrainFlag,
-                      const char* dsname, const char* uniqueTag,
-                      uint32_t vmViewId);
+                      const std::chrono::seconds durableClntTimeOut,
+                      int32_t dcPort, int32_t vPID, int8_t vmkind,
+                      int8_t splitBrainFlag, const char* dsname,
+                      const char* uniqueTag, uint32_t vmViewId);
 
   std::string getDSName() const { return m_dsname; }
   std::string getUniqueTag() const { return m_uniqueTag; }
diff --git a/cppcache/src/ClientProxyMembershipIDFactory.cpp b/cppcache/src/ClientProxyMembershipIDFactory.cpp
index f9bf982d..18463dc8 100644
--- a/cppcache/src/ClientProxyMembershipIDFactory.cpp
+++ b/cppcache/src/ClientProxyMembershipIDFactory.cpp
@@ -33,7 +33,8 @@ ClientProxyMembershipIDFactory::ClientProxyMembershipIDFactory(
 
 std::unique_ptr<ClientProxyMembershipID> ClientProxyMembershipIDFactory::create(
     const char* hostname, uint32_t hostAddr, uint32_t hostPort,
-    const char* durableClientId, const uint32_t durableClntTimeOut) {
+    const char* durableClientId,
+    const std::chrono::seconds durableClntTimeOut) {
   return std::unique_ptr<ClientProxyMembershipID>(new ClientProxyMembershipID(
       dsName, randString, hostname, hostAddr, hostPort, durableClientId,
       durableClntTimeOut));
diff --git a/cppcache/src/ClientProxyMembershipIDFactory.hpp b/cppcache/src/ClientProxyMembershipIDFactory.hpp
index a24abbf6..08b833a8 100644
--- a/cppcache/src/ClientProxyMembershipIDFactory.hpp
+++ b/cppcache/src/ClientProxyMembershipIDFactory.hpp
@@ -35,7 +35,8 @@ class ClientProxyMembershipIDFactory {
   std::unique_ptr<ClientProxyMembershipID> create(
       const char* hostname, uint32_t hostAddr, uint32_t hostPort,
       const char* durableClientId = nullptr,
-      const uint32_t durableClntTimeOut = 0);
+      const std::chrono::seconds durableClntTimeOut =
+          std::chrono::seconds::zero());
 
  private:
   std::string dsName;
diff --git a/cppcache/src/Connector.hpp b/cppcache/src/Connector.hpp
index b7094c05..ec722d2d 100644
--- a/cppcache/src/Connector.hpp
+++ b/cppcache/src/Connector.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_CONNECTOR_H_
-#define GEODE_CONNECTOR_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,20 +15,32 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_CONNECTOR_H_
+#define GEODE_CONNECTOR_H_
+
+#include <chrono>
+
 #include <geode/geode_globals.hpp>
 #include <geode/ExceptionTypes.hpp>
 
-/*
-These are superseded by the connect-timeout system property for SR # 6525.
-*/
-#define DEFAULT_TIMEOUT_SECONDS 15
-#define DEFAULT_CONNECT_TIMEOUT 10
-#define DEFAULT_READ_TIMEOUT_SECS DEFAULT_TIMEOUT_SECONDS
-#define DEFAULT_WRITE_TIMEOUT DEFAULT_TIMEOUT_SECONDS
-
 namespace apache {
 namespace geode {
 namespace client {
+
+constexpr std::chrono::microseconds DEFAULT_CONNECT_TIMEOUT =
+    std::chrono::seconds(10);
+
+constexpr std::chrono::milliseconds DEFAULT_TIMEOUT_SECONDS =
+    std::chrono::seconds(15);
+
+constexpr std::chrono::milliseconds DEFAULT_READ_TIMEOUT_SECS =
+    DEFAULT_TIMEOUT_SECONDS;
+
+constexpr std::chrono::milliseconds DEFAULT_WRITE_TIMEOUT =
+    DEFAULT_TIMEOUT_SECONDS;
+
 class Connector {
  public:
   /* create one socket connection with settings */
@@ -67,8 +74,8 @@ class Connector {
    * @exception  GeodeIOException, TimeoutException, IllegalArgumentException,
    * OutOfMemoryException.
    */
-  virtual int32_t receive(char *b, int32_t len, uint32_t waitSeconds,
-                          uint32_t waitMicroSeconds) = 0;
+  virtual int32_t receive(char *b, int32_t len,
+                          std::chrono::microseconds waitSeconds) = 0;
 
   /**
    * Writes <code>len</code> bytes from the specified byte array
@@ -81,8 +88,8 @@ class Connector {
    * @return     the actual number of bytes written.
    * @exception  GeodeIOException, TimeoutException, IllegalArgumentException.
    */
-  virtual int32_t send(const char *b, int32_t len, uint32_t waitSeconds,
-                       uint32_t waitMicroSeconds) = 0;
+  virtual int32_t send(const char *b, int32_t len,
+                       std::chrono::microseconds waitSeconds) = 0;
 
   /**
    * Initialises the connection.
diff --git a/cppcache/src/CqQueryImpl.cpp b/cppcache/src/CqQueryImpl.cpp
index f44145a3..34887c1e 100644
--- a/cppcache/src/CqQueryImpl.cpp
+++ b/cppcache/src/CqQueryImpl.cpp
@@ -14,17 +14,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 #include <geode/VectorT.hpp>
-#include "CqQueryImpl.hpp"
 #include <geode/CqAttributesFactory.hpp>
+#include <geode/ExceptionTypes.hpp>
+
+#include "CqQueryImpl.hpp"
 #include "CqAttributesMutatorImpl.hpp"
-#include "util/Log.hpp"
 #include "ResultSetImpl.hpp"
 #include "StructSetImpl.hpp"
-#include <geode/ExceptionTypes.hpp>
 #include "ThinClientRegion.hpp"
 #include "ReadWriteLock.hpp"
 #include "ThinClientRegion.hpp"
+#include "util/bounds.hpp"
+#include "util/Log.hpp"
+
 using namespace apache::geode::client;
 
 CqQueryImpl::CqQueryImpl(const CqServicePtr& cqService,
@@ -359,7 +363,10 @@ bool CqQueryImpl::executeCq(TcrMessage::MsgType requestType) {
 }
 
 // for EXECUTE_INITIAL_RESULTS_REQUEST :
-CqResultsPtr CqQueryImpl::executeWithInitialResults(uint32_t timeout) {
+CqResultsPtr CqQueryImpl::executeWithInitialResults(
+    std::chrono::milliseconds timeout) {
+  util::PROTOCOL_OPERATION_TIMEOUT_BOUNDS(timeout);
+
   GuardUserAttribures gua;
   if (m_proxyCache != nullptr) {
     gua.setProxyCache(m_proxyCache);
@@ -381,6 +388,7 @@ CqResultsPtr CqQueryImpl::executeWithInitialResults(uint32_t timeout) {
                                     ->createDataOutput(),
                                 m_cqName, m_queryString, CqState::RUNNING,
                                 isDurable(), m_tccdm);
+
   TcrMessageReply reply(true, m_tccdm);
   auto resultCollector = (new ChunkedQueryResponse(reply));
   reply.setChunkedResultHandler(
@@ -474,7 +482,7 @@ void CqQueryImpl::sendStopOrClose(TcrMessage::MsgType requestType) {
                              .getCacheImpl()
                              ->getCache()
                              ->createDataOutput(),
-                         m_cqName, -1, m_tccdm);
+                         m_cqName, std::chrono::milliseconds(-1), m_tccdm);
     err = m_tccdm->sendSyncRequest(msg, reply);
   } else if (requestType == TcrMessage::CLOSECQ_MSG_TYPE) {
     TcrMessageCloseCQ msg(m_cqService->getDM()
@@ -482,7 +490,7 @@ void CqQueryImpl::sendStopOrClose(TcrMessage::MsgType requestType) {
                               .getCacheImpl()
                               ->getCache()
                               ->createDataOutput(),
-                          m_cqName, -1, m_tccdm);
+                          m_cqName, std::chrono::milliseconds(-1), m_tccdm);
     err = m_tccdm->sendSyncRequest(msg, reply);
   }
 
diff --git a/cppcache/src/CqQueryImpl.hpp b/cppcache/src/CqQueryImpl.hpp
index 8a7920ae..30572045 100644
--- a/cppcache/src/CqQueryImpl.hpp
+++ b/cppcache/src/CqQueryImpl.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_CQQUERYIMPL_H_
-#define GEODE_CQQUERYIMPL_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,6 +15,11 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_CQQUERYIMPL_H_
+#define GEODE_CQQUERYIMPL_H_
+
 #include <geode/geode_globals.hpp>
 #include <geode/geode_types.hpp>
 
@@ -94,16 +94,17 @@ class CqQueryImpl : public CqQuery,
  public:
   CqQueryImpl(const CqServicePtr& cqService, const std::string& cqName,
               const std::string& queryString,
-              const CqAttributesPtr& cqAttributes, statistics::StatisticsFactory* factory,
+              const CqAttributesPtr& cqAttributes,
+              statistics::StatisticsFactory* factory,
               const bool isDurable = false,
               const UserAttributesPtr& userAttributesPtr = nullptr);
 
-  ~CqQueryImpl();
+  virtual ~CqQueryImpl();
 
   /**
    * returns CQ name
    */
-  const char* getName() const;
+  const char* getName() const override;
 
   /**
    * sets the CqName.
@@ -122,7 +123,7 @@ class CqQueryImpl : public CqQuery,
    *        On Server side, takes care of repository cleanup.
    * @throws CqException
    */
-  void close();
+  void close() override;
 
   /**
    * Closes the Query.
@@ -148,24 +149,24 @@ class CqQueryImpl : public CqQuery,
   /**
    * Returns the QueryString of this CQ.
    */
-  const char* getQueryString() const;
+  const char* getQueryString() const override;
 
   /**
    * Return the query after replacing region names with parameters
    * @return the Query for the query string
    */
-  QueryPtr getQuery() const;
+  QueryPtr getQuery() const override;
 
   /**
    * @see org.apache.geode.cache.query.CqQuery#getStatistics()
    */
-  const CqStatisticsPtr getStatistics() const;
+  const CqStatisticsPtr getStatistics() const override;
 
   CqQueryVsdStats& getVsdStats() {
     return *dynamic_cast<CqQueryVsdStats*>(m_stats.get());
   }
 
-  const CqAttributesPtr getCqAttributes() const;
+  const CqAttributesPtr getCqAttributes() const override;
 
   RegionPtr getCqBaseRegion();
 
@@ -183,7 +184,7 @@ class CqQueryImpl : public CqQuery,
   /**
    * Start or resume executing the query.
    */
-  void execute();
+  void execute() override;
 
   void executeAfterFailover();
 
@@ -196,7 +197,7 @@ class CqQueryImpl : public CqQuery,
    * Start or resume executing the query.
    * Gets or updates the CQ results and returns them.
    */
-  CqResultsPtr executeWithInitialResults(uint32_t timeout);
+  CqResultsPtr executeWithInitialResults(std::chrono::milliseconds timeout) override;
 
   /**
    * This is called when the new server comes-up.
@@ -208,13 +209,13 @@ class CqQueryImpl : public CqQuery,
   /**
    * Stop or pause executing the query.
    */
-  void stop();
+  void stop() override;
 
   /**
    * Return the state of this query.
    * @return STOPPED RUNNING or CLOSED
    */
-  CqState::StateType getState();
+  CqState::StateType getState() override;
 
   /**
    * Sets the state of the cq.
@@ -222,7 +223,7 @@ class CqQueryImpl : public CqQuery,
    */
   void setCqState(CqState::StateType state);
 
-  const CqAttributesMutatorPtr getCqAttributesMutator() const;
+  const CqAttributesMutatorPtr getCqAttributesMutator() const override;
 
   /**
    * @return Returns the cqOperation.
@@ -244,25 +245,25 @@ class CqQueryImpl : public CqQuery,
    * Return true if the CQ is in running state
    * @return true if running, false otherwise
    */
-  bool isRunning();
+  bool isRunning() override;
 
   /**
    * Return true if the CQ is in Sstopped state
    * @return true if stopped, false otherwise
    */
-  bool isStopped();
+  bool isStopped() override;
 
   /**
    * Return true if the CQ is closed
    * @return true if closed, false otherwise
    */
-  bool isClosed();
+  bool isClosed() override;
 
   /**
    * Return true if the CQ is durable
    * @return true if durable, false otherwise
    */
-  bool isDurable();
+  bool isDurable() override;
 
   inline ThinClientBaseDM* getDM() { return m_tccdm; }
 
@@ -275,6 +276,7 @@ class CqQueryImpl : public CqQuery,
 
   FRIEND_STD_SHARED_PTR(CqQueryImpl)
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/src/DefaultResultCollector.cpp b/cppcache/src/DefaultResultCollector.cpp
new file mode 100644
index 00000000..305e5c9d
--- /dev/null
+++ b/cppcache/src/DefaultResultCollector.cpp
@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <geode/DefaultResultCollector.hpp>
+
+using namespace apache::geode::client;
+
+DefaultResultCollector::DefaultResultCollector()
+    : resultList(CacheableVector::create()), ready(false) {}
+
+DefaultResultCollector::~DefaultResultCollector() noexcept {}
+
+CacheableVectorPtr DefaultResultCollector::getResult(
+    std::chrono::milliseconds timeout) {
+  std::unique_lock<std::mutex> lk(readyMutex);
+  if (readyCondition.wait_for(lk, timeout, [this] { return ready; })) {
+    return resultList;
+  }
+
+  throw FunctionExecutionException(
+      "Result is not ready, endResults callback is called before invoking "
+      "getResult() method");
+}
+
+void DefaultResultCollector::addResult(const CacheablePtr& result) {
+  resultList->push_back(result);
+}
+
+void DefaultResultCollector::endResults() {
+  {
+    std::lock_guard<std::mutex> lk(readyMutex);
+    ready = true;
+  }
+  readyCondition.notify_all();
+}
+
+void DefaultResultCollector::clearResults() { resultList->clear(); }
diff --git a/cppcache/src/EntriesMapFactory.cpp b/cppcache/src/EntriesMapFactory.cpp
index b8e3254b..1624b230 100644
--- a/cppcache/src/EntriesMapFactory.cpp
+++ b/cppcache/src/EntriesMapFactory.cpp
@@ -39,8 +39,8 @@ EntriesMap* EntriesMapFactory::createMap(RegionInternal* region,
   uint8_t concurrency = attrs->getConcurrencyLevel();
   /** @TODO will need a statistics entry factory... */
   uint32_t lruLimit = attrs->getLruEntriesLimit();
-  uint32_t ttl = attrs->getEntryTimeToLive();
-  uint32_t idle = attrs->getEntryIdleTimeout();
+  const auto& ttl = attrs->getEntryTimeToLive();
+  const auto& idle = attrs->getEntryIdleTimeout();
   bool concurrencyChecksEnabled = attrs->getConcurrencyChecksEnabled();
   bool heapLRUEnabled = false;
 
@@ -60,7 +60,7 @@ EntriesMap* EntriesMapFactory::createMap(RegionInternal* region,
     } else {
       return nullptr;
     }
-    if (ttl != 0 || idle != 0) {
+    if (ttl.count() != 0 || idle.count() != 0) {
       result = new LRUEntriesMap(
           &expiryTaskmanager,
           std::unique_ptr<LRUExpEntryFactory>(
@@ -75,7 +75,7 @@ EntriesMap* EntriesMapFactory::createMap(RegionInternal* region,
           region, lruEvictionAction, lruLimit, concurrencyChecksEnabled,
           concurrency, heapLRUEnabled);
     }
-  } else if (ttl != 0 || idle != 0) {
+  } else if (ttl.count() > 0 || idle.count() > 0) {
     // create entries with a ExpEntryFactory.
     result = new ConcurrentEntriesMap(
         &expiryTaskmanager,
diff --git a/cppcache/src/EntryExpiryHandler.cpp b/cppcache/src/EntryExpiryHandler.cpp
index fec863d1..cfd974cc 100644
--- a/cppcache/src/EntryExpiryHandler.cpp
+++ b/cppcache/src/EntryExpiryHandler.cpp
@@ -48,7 +48,7 @@ int EntryExpiryHandler::handle_timeout(const ACE_Time_Value& current_time,
     uint32_t curr_time = static_cast<uint32_t>(current_time.sec());
 
     uint32_t lastTimeForExp = expProps.getLastAccessTime();
-    if (m_regionPtr->getAttributes()->getEntryTimeToLive() > 0) {
+    if (m_regionPtr->getAttributes()->getEntryTimeToLive().count() > 0) {
       lastTimeForExp = expProps.getLastModifiedTime();
     }
 
diff --git a/cppcache/src/EventIdMap.cpp b/cppcache/src/EventIdMap.cpp
index 778205c4..26df600e 100644
--- a/cppcache/src/EventIdMap.cpp
+++ b/cppcache/src/EventIdMap.cpp
@@ -20,7 +20,9 @@ using namespace apache::geode::client;
 
 EventIdMap::~EventIdMap() { clear(); }
 
-void EventIdMap::init(int32_t expirySecs) { m_expiry = expirySecs; }
+void EventIdMap::init(std::chrono::milliseconds expirySecs) {
+  m_expiry = expirySecs;
+}
 
 void EventIdMap::clear() {
   GUARD_MAP;
@@ -170,12 +172,12 @@ EventSequence::EventSequence(int64_t seqNum) {
 
 EventSequence::~EventSequence() { clear(); }
 
-void EventSequence::touch(int32_t ageSecs) {
+void EventSequence::touch(std::chrono::milliseconds ageSecs) {
   m_deadline = ACE_OS::gettimeofday();
   m_deadline += ageSecs;
 }
 
-void EventSequence::touch(int64_t seqNum, int32_t ageSecs) {
+void EventSequence::touch(int64_t seqNum, std::chrono::milliseconds ageSecs) {
   touch(ageSecs);
   m_seqNum = seqNum;
   m_acked = false;
diff --git a/cppcache/src/EventIdMap.hpp b/cppcache/src/EventIdMap.hpp
index 1ae44bc2..911d83da 100644
--- a/cppcache/src/EventIdMap.hpp
+++ b/cppcache/src/EventIdMap.hpp
@@ -65,7 +65,7 @@ class CPPCACHE_EXPORT EventIdMap {
                              dereference_equal_to<EventSourcePtr>>
       map_type;
 
-  int32_t m_expiry;
+  std::chrono::milliseconds m_expiry;
   map_type m_map;
   ACE_Recursive_Thread_Mutex m_lock;
 
@@ -79,7 +79,7 @@ class CPPCACHE_EXPORT EventIdMap {
   void clear();
 
   /** Initialize with preset expiration time in seconds */
-  void init(int32_t expirySecs);
+  void init(std::chrono::milliseconds expirySecs);
 
   ~EventIdMap();
 
@@ -146,10 +146,10 @@ class CPPCACHE_EXPORT EventSequence {
   EventSequence(int64_t seqNum);
   ~EventSequence();
 
-  void touch(int32_t ageSecs);  // update deadline
-  void touch(
-      int64_t seqNum,
-      int32_t ageSecs);  // update deadline, clear acked flag and set seqNum
+  // update deadline
+  void touch(std::chrono::milliseconds ageSecs);
+  // update deadline, clear acked flag and set seqNum
+  void touch(int64_t seqNum, std::chrono::milliseconds ageSecs);
 
   // Accessors:
 
diff --git a/cppcache/src/Exception.cpp b/cppcache/src/Exception.cpp
index 49967bf7..b873a2ea 100644
--- a/cppcache/src/Exception.cpp
+++ b/cppcache/src/Exception.cpp
@@ -64,6 +64,8 @@ Exception::Exception(const char* msg1, const char* msg2, bool forceTrace,
   m_message = CacheableString::createNoCopy(msg, static_cast<int32_t>(len));
 }
 
+Exception::Exception(const std::string& msg1) : Exception(msg1.c_str()) {}
+
 Exception::~Exception() {}
 
 const char _exception_name_Exception[] = "apache::geode::client::Exception";
@@ -111,11 +113,6 @@ size_t Exception::getStackTrace(char* buffer, size_t maxLength) const {
 
 #endif
 
-Exception::Exception(const Exception& other)
-    : m_message(other.m_message),
-      m_stack(other.m_stack),
-      m_cause(other.m_cause) {}
-
 Exception::Exception(const CacheableStringPtr& message,
                      const StackTracePtr& stack, const ExceptionPtr& cause)
     : m_message(message), m_stack(stack), m_cause(cause) {}
diff --git a/cppcache/src/ExecutionImpl.cpp b/cppcache/src/ExecutionImpl.cpp
index 2ab024f2..dc0fffb1 100644
--- a/cppcache/src/ExecutionImpl.cpp
+++ b/cppcache/src/ExecutionImpl.cpp
@@ -14,15 +14,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 #include <geode/geode_globals.hpp>
 #include <geode/geode_types.hpp>
-#include "ExecutionImpl.hpp"
 #include <geode/ExceptionTypes.hpp>
+#include <geode/DefaultResultCollector.hpp>
+
+#include "ExecutionImpl.hpp"
 #include "ThinClientRegion.hpp"
 #include "ThinClientPoolDM.hpp"
 #include "NoResult.hpp"
 #include "UserAttributes.hpp"
-// using namespace apache::geode::client;
 
 FunctionToFunctionAttributes ExecutionImpl::m_func_attrs;
 ACE_Recursive_Thread_Mutex ExecutionImpl::m_func_attrs_lock;
@@ -72,14 +74,15 @@ std::vector<int8_t>* ExecutionImpl::getFunctionAttributes(const char* func) {
 ResultCollectorPtr ExecutionImpl::execute(const CacheableVectorPtr& routingObj,
                                           const CacheablePtr& args,
                                           const ResultCollectorPtr& rs,
-                                          const char* func, uint32_t timeout) {
+                                          const char* func, std::chrono::milliseconds timeout) {
   m_routingObj = routingObj;
   m_args = args;
   m_rc = rs;
   return execute(func, timeout);
 }
 
-ResultCollectorPtr ExecutionImpl::execute(const char* fn, uint32_t timeout) {
+ResultCollectorPtr ExecutionImpl::execute(const char* fn,
+                                          std::chrono::milliseconds timeout) {
   std::string func = fn;
   LOGDEBUG("ExecutionImpl::execute: ");
   GuardUserAttribures gua;
@@ -126,7 +129,7 @@ ResultCollectorPtr ExecutionImpl::execute(const char* fn, uint32_t timeout) {
   if (serverHasResult == false) {
     m_rc = std::make_shared<NoResult>();
   } else if (m_rc == nullptr) {
-    m_rc = std::make_shared<ResultCollector>();
+    m_rc = std::make_shared<DefaultResultCollector>();
   }
 
   uint8_t isHAHasResultOptimizeForWrite = 0;
@@ -401,7 +404,7 @@ void ExecutionImpl::addResults(ResultCollectorPtr& collector,
   }
 }
 void ExecutionImpl::executeOnAllServers(std::string& func, uint8_t getResult,
-                                        uint32_t timeout) {
+                                        std::chrono::milliseconds timeout) {
   ThinClientPoolDM* tcrdm = dynamic_cast<ThinClientPoolDM*>(m_pool.get());
   if (tcrdm == nullptr) {
     throw IllegalArgumentException(
@@ -441,10 +444,9 @@ void ExecutionImpl::executeOnAllServers(std::string& func, uint8_t getResult,
     }
   }
 }
-CacheableVectorPtr ExecutionImpl::executeOnPool(std::string& func,
-                                                uint8_t getResult,
-                                                int32_t retryAttempts,
-                                                uint32_t timeout) {
+CacheableVectorPtr ExecutionImpl::executeOnPool(
+    std::string& func, uint8_t getResult, int32_t retryAttempts,
+    std::chrono::milliseconds timeout) {
   ThinClientPoolDM* tcrdm = dynamic_cast<ThinClientPoolDM*>(m_pool.get());
   if (tcrdm == nullptr) {
     throw IllegalArgumentException(
diff --git a/cppcache/src/ExecutionImpl.hpp b/cppcache/src/ExecutionImpl.hpp
index 4926e83c..288e2ce8 100644
--- a/cppcache/src/ExecutionImpl.hpp
+++ b/cppcache/src/ExecutionImpl.hpp
@@ -33,6 +33,7 @@
 namespace apache {
 namespace geode {
 namespace client {
+
 typedef std::map<std::string, std::vector<int8_t>*> FunctionToFunctionAttributes;
 
 class ExecutionImpl : public Execution {
@@ -55,17 +56,21 @@ class ExecutionImpl : public Execution {
         m_allServer(allServer),
         m_pool(pool),
         m_proxyCache(proxyCache) {}
-  virtual ExecutionPtr withFilter(CacheableVectorPtr routingObj);
-  virtual ExecutionPtr withArgs(CacheablePtr args);
-  virtual ExecutionPtr withCollector(ResultCollectorPtr rs);
+  virtual ExecutionPtr withFilter(CacheableVectorPtr routingObj) override;
+  virtual ExecutionPtr withArgs(CacheablePtr args) override;
+  virtual ExecutionPtr withCollector(ResultCollectorPtr rs) override;
   // java function has hasResult property. we put the hasResult argument
   // here as a kluge.
   virtual ResultCollectorPtr execute(const CacheableVectorPtr& routingObj,
                                      const CacheablePtr& args,
                                      const ResultCollectorPtr& rs,
-                                     const char* func, uint32_t timeout);
+                                     const char* func, std::chrono::milliseconds timeout) override;
+
   virtual ResultCollectorPtr execute(
-      const char* func, uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
+      const char* func,
+      std::chrono::milliseconds timeout =
+          DEFAULT_QUERY_RESPONSE_TIMEOUT) override;
+
   static void addResults(ResultCollectorPtr& collector,
                          const CacheableVectorPtr& results);
 
@@ -100,11 +105,15 @@ class ExecutionImpl : public Execution {
   static ACE_Recursive_Thread_Mutex m_func_attrs_lock;
   static FunctionToFunctionAttributes m_func_attrs;
   //  std::vector<int8_t> m_attributes;
+
   CacheableVectorPtr executeOnPool(
       std::string& func, uint8_t getResult, int32_t retryAttempts,
-      uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
-  void executeOnAllServers(std::string& func, uint8_t getResult,
-                           uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
+      std::chrono::milliseconds timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
+
+  void executeOnAllServers(
+      std::string& func, uint8_t getResult,
+      std::chrono::milliseconds timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
+
   std::vector<int8_t>* getFunctionAttributes(const char* func);
   GfErrType getFuncAttributes(const char* func, std::vector<int8_t>** attr);
 
diff --git a/cppcache/src/ExpirationAttributes.cpp b/cppcache/src/ExpirationAttributes.cpp
index 25e2c510..4bc3436b 100644
--- a/cppcache/src/ExpirationAttributes.cpp
+++ b/cppcache/src/ExpirationAttributes.cpp
@@ -22,10 +22,17 @@ ExpirationAttributes::ExpirationAttributes()
     : m_action(ExpirationAction::INVALIDATE), m_timeout(0) {}
 
 ExpirationAttributes::ExpirationAttributes(
-    const int expirationTime, const ExpirationAction::Action expirationAction)
+    const std::chrono::seconds& expirationTime,
+    const ExpirationAction::Action expirationAction)
     : m_action(ExpirationAction::INVALIDATE), m_timeout(expirationTime) {}
-int ExpirationAttributes::getTimeout() const { return m_timeout; }
-void ExpirationAttributes::setTimeout(int timeout) { m_timeout = timeout; }
+const std::chrono::seconds& ExpirationAttributes::getTimeout() const {
+  return m_timeout;
+}
+
+void ExpirationAttributes::setTimeout(const std::chrono::seconds& timeout) {
+  m_timeout = timeout;
+}
+
 ExpirationAction::Action ExpirationAttributes::getAction() const {
   return m_action;
 }
diff --git a/cppcache/src/ExpiryTaskManager.cpp b/cppcache/src/ExpiryTaskManager.cpp
index 7ac4cd16..4130f4bc 100644
--- a/cppcache/src/ExpiryTaskManager.cpp
+++ b/cppcache/src/ExpiryTaskManager.cpp
@@ -58,7 +58,20 @@ long ExpiryTaskManager::scheduleExpiryTask(ACE_Event_Handler* handler,
 
   ACE_Time_Value expTimeValue(expTime);
   ACE_Time_Value intervalValue(interval);
-  LOGFINER("Scheduled expiration ... in %d seconds.", expTime);
+  return m_reactor->schedule_timer(handler, 0, expTimeValue, intervalValue);
+}
+
+long ExpiryTaskManager::scheduleExpiryTask(
+    ACE_Event_Handler* handler, const std::chrono::microseconds expTime,
+    const std::chrono::microseconds interval, const bool cancelExistingTask) {
+  LOGFINER("ExpiryTaskManager: expTime %d, interval %d, cancelExistingTask %d",
+           expTime.count(), interval.count(), cancelExistingTask);
+  if (cancelExistingTask) {
+    m_reactor->cancel_timer(handler, 1);
+  }
+
+  const ACE_Time_Value expTimeValue(expTime);
+  const ACE_Time_Value intervalValue(interval);
   return m_reactor->schedule_timer(handler, 0, expTimeValue, intervalValue);
 }
 
diff --git a/cppcache/src/ExpiryTaskManager.hpp b/cppcache/src/ExpiryTaskManager.hpp
index 9b00e03b..64983a00 100644
--- a/cppcache/src/ExpiryTaskManager.hpp
+++ b/cppcache/src/ExpiryTaskManager.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_EXPIRYTASKMANAGER_H_
-#define GEODE_EXPIRYTASKMANAGER_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -19,12 +14,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
+#pragma once
+
+#ifndef GEODE_EXPIRYTASKMANAGER_H_
+#define GEODE_EXPIRYTASKMANAGER_H_
+
+#include <chrono>
+
 #include <ace/Reactor.h>
 #include <ace/Task.h>
 #include <ace/Timer_Heap.h>
-#include "ReadWriteLock.hpp"
 
 #include <geode/geode_globals.hpp>
+#include <geode/util/chrono/duration.hpp>
+
+#include "ReadWriteLock.hpp"
 #include "util/Log.hpp"
 
 /**
@@ -230,10 +235,35 @@ class CPPCACHE_EXPORT ExpiryTaskManager : public ACE_Task_Base {
                           bool cancelExistingTask = false);
 
   long scheduleExpiryTask(ACE_Event_Handler* handler,
+                          const std::chrono::microseconds expTime,
+                          const std::chrono::microseconds interval,
+                          const bool cancelExistingTask = false);
+
+  long scheduleExpiryTask(ACE_Event_Handler* handler,
                           ACE_Time_Value expTimeValue,
                           ACE_Time_Value intervalVal,
                           bool cancelExistingTask = false);
 
+  template <class ExpRep, class ExpPeriod, class IntRep, class IntPeriod>
+  long scheduleExpiryTask(ACE_Event_Handler* handler,
+                          std::chrono::duration<ExpRep, ExpPeriod> expTime,
+                          std::chrono::duration<IntRep, IntPeriod> interval,
+                          bool cancelExistingTask) {
+    LOGFINER(
+        "ExpiryTaskManager: expTime %s, interval %s, cancelExistingTask %d",
+        util::chrono::duration::to_string(expTime).c_str(),
+        util::chrono::duration::to_string(interval).c_str(),
+        cancelExistingTask);
+    if (cancelExistingTask) {
+      m_reactor->cancel_timer(handler, 1);
+    }
+
+    ACE_Time_Value expTimeValue(expTime);
+    ACE_Time_Value intervalValue(interval);
+    LOGFINER("Scheduled expiration ... in %d seconds.", expTime.count());
+    return m_reactor->schedule_timer(handler, 0, expTimeValue, intervalValue);
+  }
+
   /**
    * for resetting the interval an already registered task.
    * returns '0' if successful '-1' on failure.
diff --git a/cppcache/src/FairQueue.hpp b/cppcache/src/FairQueue.hpp
index d87305f7..123380a8 100644
--- a/cppcache/src/FairQueue.hpp
+++ b/cppcache/src/FairQueue.hpp
@@ -49,7 +49,7 @@ class FairQueue {
   }
 
   /** wait sec time until notified */
-  T* getUntil(int64_t& sec) {
+  T* getUntil(std::chrono::microseconds& sec) {
     bool isClosed;
     T* mp = getNoGetLock(isClosed);
 
@@ -140,7 +140,8 @@ class FairQueue {
   }
 
   template <typename U>
-  T* getUntilWithToken(int64_t& sec, bool& isClosed, U* excludeList = nullptr) {
+  T* getUntilWithToken(std::chrono::microseconds& sec, bool& isClosed,
+                       U* excludeList = nullptr) {
     T* mp = nullptr;
 
     ACE_Guard<ACE_Token> _guard(m_queueGetLock);
@@ -164,7 +165,7 @@ class FairQueue {
         }
       } while (mp == nullptr && (currTime = ACE_OS::gettimeofday()) < stopAt &&
                !isClosed);
-      sec = (stopAt - currTime).sec();
+      sec = std::chrono::microseconds((stopAt - currTime).usec());
     }
 
     return mp;
diff --git a/cppcache/src/InternalCacheTransactionManager2PC.hpp b/cppcache/src/InternalCacheTransactionManager2PC.hpp
index 22b664da..a6df810f 100644
--- a/cppcache/src/InternalCacheTransactionManager2PC.hpp
+++ b/cppcache/src/InternalCacheTransactionManager2PC.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_INTERNALCACHETRANSACTIONMANAGER2PC_H_
-#define GEODE_INTERNALCACHETRANSACTIONMANAGER2PC_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,6 +15,11 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_INTERNALCACHETRANSACTIONMANAGER2PC_H_
+#define GEODE_INTERNALCACHETRANSACTIONMANAGER2PC_H_
+
 #include <geode/CacheTransactionManager.hpp>
 
 namespace apache {
diff --git a/cppcache/src/InternalCacheTransactionManager2PCImpl.hpp b/cppcache/src/InternalCacheTransactionManager2PCImpl.hpp
index d4721c4e..34fcbb58 100644
--- a/cppcache/src/InternalCacheTransactionManager2PCImpl.hpp
+++ b/cppcache/src/InternalCacheTransactionManager2PCImpl.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_INTERNALCACHETRANSACTIONMANAGER2PCIMPL_H_
-#define GEODE_INTERNALCACHETRANSACTIONMANAGER2PCIMPL_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -19,12 +14,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-/*
- * CacheTransactionManager2PCImpl.h
- *
- *  Created on: 13-Nov-2011
- *      Author: sshcherbakov
- */
+
+#pragma once
+
+#ifndef GEODE_INTERNALCACHETRANSACTIONMANAGER2PCIMPL_H_
+#define GEODE_INTERNALCACHETRANSACTIONMANAGER2PCIMPL_H_
 
 #include "InternalCacheTransactionManager2PC.hpp"
 #include "CacheTransactionManagerImpl.hpp"
@@ -40,9 +34,9 @@ class InternalCacheTransactionManager2PCImpl
   InternalCacheTransactionManager2PCImpl(Cache* cache);
   virtual ~InternalCacheTransactionManager2PCImpl();
 
-  virtual void prepare();
-  virtual void commit();
-  virtual void rollback();
+  virtual void prepare() override;
+  virtual void commit() override;
+  virtual void rollback() override;
 
  private:
   void afterCompletion(int32_t status);
@@ -52,6 +46,7 @@ class InternalCacheTransactionManager2PCImpl
   InternalCacheTransactionManager2PCImpl(
       const InternalCacheTransactionManager2PCImpl& other);
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/src/LocalRegion.cpp b/cppcache/src/LocalRegion.cpp
index 8dfedeed..eb367336 100644
--- a/cppcache/src/LocalRegion.cpp
+++ b/cppcache/src/LocalRegion.cpp
@@ -14,14 +14,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 #include <vector>
-#include <tuple>
 
-#include "LocalRegion.hpp"
-#include "util/Log.hpp"
 #include <geode/SystemProperties.hpp>
 #include <geode/PoolManager.hpp>
 
+#include "LocalRegion.hpp"
 #include "CacheImpl.hpp"
 #include "CacheRegionHelper.hpp"
 #include "CacheableToken.hpp"
@@ -33,7 +32,8 @@
 #include "RegionGlobalLocks.hpp"
 #include "TXState.hpp"
 #include "VersionTag.hpp"
-#include "statistics/StatisticsManager.hpp"
+#include "util/bounds.hpp"
+#include "util/Log.hpp"
 
 namespace apache {
 namespace geode {
@@ -145,7 +145,8 @@ void LocalRegion::invalidateRegion(const SerializablePtr& aCallbackArgument) {
   GfErrTypeToException("Region::invalidateRegion", err);
 }
 
-void LocalRegion::localInvalidateRegion(const SerializablePtr& aCallbackArgument) {
+void LocalRegion::localInvalidateRegion(
+    const SerializablePtr& aCallbackArgument) {
   GfErrType err =
       invalidateRegionNoThrow(aCallbackArgument, CacheEventFlags::LOCAL);
   GfErrTypeToException("Region::localInvalidateRegion", err);
@@ -346,15 +347,13 @@ void LocalRegion::localPut(const CacheableKeyPtr& key,
   GfErrTypeToException("Region::localPut", err);
 }
 
-void LocalRegion::putAll(const HashMapOfCacheable& map, uint32_t timeout,
+void LocalRegion::putAll(const HashMapOfCacheable& map,
+                         std::chrono::milliseconds timeout,
                          const SerializablePtr& aCallbackArgument) {
-  if ((timeout * 1000) >= 0x7fffffff) {
-    throw IllegalArgumentException(
-        "Region::putAll: timeout parameter "
-        "greater than maximum allowed (2^31/1000 i.e 2147483).");
-  }
-  int64_t sampleStartNanos = startStatOpTime();
-  GfErrType err = putAllNoThrow(map, timeout, aCallbackArgument);
+  util::PROTOCOL_OPERATION_TIMEOUT_BOUNDS(timeout);
+
+  auto sampleStartNanos = startStatOpTime();
+  auto err = putAllNoThrow(map, timeout, aCallbackArgument);
   updateStatOpTime(m_regionStats->getStat(), m_regionStats->getPutAllTimeId(),
                    sampleStartNanos);
   // handleReplay(err, nullptr);
@@ -651,19 +650,18 @@ void LocalRegion::setPersistenceManager(PersistenceManagerPtr& pmPtr) {
 
 void LocalRegion::setRegionExpiryTask() {
   if (regionExpiryEnabled()) {
-    RegionInternalPtr rptr =
-        std::static_pointer_cast<RegionInternal>(shared_from_this());
-    uint32_t duration = getRegionExpiryDuration();
-    RegionExpiryHandler* handler =
-        new RegionExpiryHandler(rptr, getRegionExpiryAction(), duration);
-    long expiryTaskId =
+    auto rptr = std::static_pointer_cast<RegionInternal>(shared_from_this());
+    const auto& duration = getRegionExpiryDuration();
+    auto handler = new RegionExpiryHandler(rptr, getRegionExpiryAction(),
+                                           duration.count());
+    int64_t expiryTaskId =
         rptr->getCacheImpl()->getExpiryTaskManager().scheduleExpiryTask(
-            handler, duration, 0);
+            handler, duration.count(), 0);
     handler->setExpiryTaskId(expiryTaskId);
     LOGFINE(
         "expiry for region [%s], expiry task id = %d, duration = %d, "
         "action = %d",
-        m_fullPath.c_str(), expiryTaskId, duration, getRegionExpiryAction());
+        m_fullPath.c_str(), expiryTaskId, duration.count(), getRegionExpiryAction());
   }
 }
 
@@ -672,13 +670,12 @@ void LocalRegion::registerEntryExpiryTask(MapEntryImplPtr& entry) {
   // the entry will register the expiry task for that entry
   ExpEntryProperties& expProps = entry->getExpProperties();
   expProps.initStartTime();
-  RegionInternalPtr rptr =
-      std::static_pointer_cast<RegionInternal>(shared_from_this());
-  uint32_t duration = getEntryExpiryDuration();
-  EntryExpiryHandler* handler =
-      new EntryExpiryHandler(rptr, entry, getEntryExpirationAction(), duration);
-  long id = rptr->getCacheImpl()->getExpiryTaskManager().scheduleExpiryTask(
-      handler, duration, 0);
+  auto rptr = std::static_pointer_cast<RegionInternal>(shared_from_this());
+  const auto& duration = getEntryExpiryDuration();
+  auto handler = new EntryExpiryHandler(rptr, entry, getEntryExpirationAction(),
+                                        duration.count());
+  int64_t id = rptr->getCacheImpl()->getExpiryTaskManager().scheduleExpiryTask(
+      handler, duration.count(), 0);
   if (Log::finestEnabled()) {
     CacheableKeyPtr key;
     entry->getKeyI(key);
@@ -686,7 +683,7 @@ void LocalRegion::registerEntryExpiryTask(MapEntryImplPtr& entry) {
         "entry expiry in region [%s], key [%s], task id = %d, "
         "duration = %d, action = %d",
         m_fullPath.c_str(), Utils::getCacheableKeyString(key)->asChar(), id,
-        duration, getEntryExpirationAction());
+        duration.count(), getEntryExpirationAction());
   }
   expProps.setExpiryTaskId(id);
 }
@@ -1807,11 +1804,10 @@ GfErrType LocalRegion::destroyNoThrow(const CacheableKeyPtr& key,
                                        versionTag);
 }
 
-GfErrType LocalRegion::destroyNoThrowTX(const CacheableKeyPtr& key,
-                                        const SerializablePtr& aCallbackArgument,
-                                        int updateCount,
-                                        const CacheEventFlags eventFlags,
-                                        VersionTagPtr versionTag) {
+GfErrType LocalRegion::destroyNoThrowTX(
+    const CacheableKeyPtr& key, const SerializablePtr& aCallbackArgument,
+    int updateCount, const CacheEventFlags eventFlags,
+    VersionTagPtr versionTag) {
   CacheablePtr oldValue;
   return updateNoThrowTX<DestroyActions>(key, nullptr, aCallbackArgument,
                                          oldValue, updateCount, eventFlags,
@@ -1840,22 +1836,20 @@ GfErrType LocalRegion::removeNoThrowEx(const CacheableKeyPtr& key,
                                         versionTag);
 }
 
-GfErrType LocalRegion::invalidateNoThrow(const CacheableKeyPtr& key,
-                                         const SerializablePtr& aCallbackArgument,
-                                         int updateCount,
-                                         const CacheEventFlags eventFlags,
-                                         VersionTagPtr versionTag) {
+GfErrType LocalRegion::invalidateNoThrow(
+    const CacheableKeyPtr& key, const SerializablePtr& aCallbackArgument,
+    int updateCount, const CacheEventFlags eventFlags,
+    VersionTagPtr versionTag) {
   CacheablePtr oldValue;
   return updateNoThrow<InvalidateActions>(key, nullptr, aCallbackArgument,
                                           oldValue, updateCount, eventFlags,
                                           versionTag);
 }
 
-GfErrType LocalRegion::invalidateNoThrowTX(const CacheableKeyPtr& key,
-                                           const SerializablePtr& aCallbackArgument,
-                                           int updateCount,
-                                           const CacheEventFlags eventFlags,
-                                           VersionTagPtr versionTag) {
+GfErrType LocalRegion::invalidateNoThrowTX(
+    const CacheableKeyPtr& key, const SerializablePtr& aCallbackArgument,
+    int updateCount, const CacheEventFlags eventFlags,
+    VersionTagPtr versionTag) {
   CacheablePtr oldValue;
   return updateNoThrowTX<InvalidateActions>(key, nullptr, aCallbackArgument,
                                             oldValue, updateCount, eventFlags,
@@ -1863,7 +1857,7 @@ GfErrType LocalRegion::invalidateNoThrowTX(const CacheableKeyPtr& key,
 }
 
 GfErrType LocalRegion::putAllNoThrow(const HashMapOfCacheable& map,
-                                     uint32_t timeout,
+                                     std::chrono::milliseconds timeout,
                                      const SerializablePtr& aCallbackArgument) {
   CHECK_DESTROY_PENDING_NOTHROW(TryReadGuard);
   GfErrType err = GF_NOERR;
@@ -2039,8 +2033,9 @@ GfErrType LocalRegion::putAllNoThrow(const HashMapOfCacheable& map,
   return err;
 }
 
-GfErrType LocalRegion::removeAllNoThrow(const VectorOfCacheableKey& keys,
-                                        const SerializablePtr& aCallbackArgument) {
+GfErrType LocalRegion::removeAllNoThrow(
+    const VectorOfCacheableKey& keys,
+    const SerializablePtr& aCallbackArgument) {
   // 1. check destroy pending
   CHECK_DESTROY_PENDING_NOTHROW(TryReadGuard);
   GfErrType err = GF_NOERR;
@@ -2133,8 +2128,9 @@ void LocalRegion::localClear(const SerializablePtr& aCallbackArgument) {
   GfErrType err = localClearNoThrow(aCallbackArgument, CacheEventFlags::LOCAL);
   if (err != GF_NOERR) GfErrTypeToException("LocalRegion::localClear", err);
 }
-GfErrType LocalRegion::localClearNoThrow(const SerializablePtr& aCallbackArgument,
-                                         const CacheEventFlags eventFlags) {
+GfErrType LocalRegion::localClearNoThrow(
+    const SerializablePtr& aCallbackArgument,
+    const CacheEventFlags eventFlags) {
   bool cachingEnabled = m_regionAttributes->getCachingEnabled();
   /*Update the stats for clear*/
   m_regionStats->incClears();
@@ -2221,7 +2217,8 @@ GfErrType LocalRegion::invalidateLocal(const char* name,
 }
 
 GfErrType LocalRegion::invalidateRegionNoThrow(
-    const SerializablePtr& aCallbackArgument, const CacheEventFlags eventFlags) {
+    const SerializablePtr& aCallbackArgument,
+    const CacheEventFlags eventFlags) {
   CHECK_DESTROY_PENDING_NOTHROW(TryReadGuard);
   GfErrType err = GF_NOERR;
 
@@ -2782,7 +2779,7 @@ ExpirationAction::Action LocalRegion::adjustRegionExpiryAction(
   CHECK_DESTROY_PENDING(TryReadGuard, LocalRegion::adjustRegionExpiryAction);
 
   RegionAttributesPtr attrs = m_regionAttributes;
-  bool hadExpiry = (getRegionExpiryDuration() != 0);
+  bool hadExpiry = (getRegionExpiryDuration().count() != 0);
   if (!hadExpiry) {
     throw IllegalStateException(
         "Cannot change region ExpirationAction for region created without "
@@ -2802,7 +2799,7 @@ ExpirationAction::Action LocalRegion::adjustEntryExpiryAction(
   CHECK_DESTROY_PENDING(TryReadGuard, LocalRegion::adjustEntryExpiryAction);
 
   RegionAttributesPtr attrs = m_regionAttributes;
-  bool hadExpiry = (getEntryExpiryDuration() != 0);
+  bool hadExpiry = (getEntryExpiryDuration().count() != 0);
   if (!hadExpiry) {
     throw IllegalStateException(
         "Cannot change entry ExpirationAction for region created without "
@@ -2817,18 +2814,18 @@ ExpirationAction::Action LocalRegion::adjustEntryExpiryAction(
   return oldValue;
 }
 
-int32_t LocalRegion::adjustRegionExpiryDuration(int32_t duration) {
+std::chrono::seconds LocalRegion::adjustRegionExpiryDuration(
+    const std::chrono::seconds& duration) {
   CHECK_DESTROY_PENDING(TryReadGuard, LocalRegion::adjustRegionExpiryDuration);
 
-  RegionAttributesPtr attrs = m_regionAttributes;
-  bool hadExpiry = (getEntryExpiryDuration() != 0);
+  bool hadExpiry = (getEntryExpiryDuration().count() != 0);
   if (!hadExpiry) {
     throw IllegalStateException(
         "Cannot change region  expiration duration for region created "
         "without "
         "region expiry.");
   }
-  int32_t oldValue = getRegionExpiryDuration();
+  const auto& oldValue = getRegionExpiryDuration();
 
   setRegionTimeToLive(duration);
   setRegionIdleTimeout(duration);
@@ -2836,17 +2833,18 @@ int32_t LocalRegion::adjustRegionExpiryDuration(int32_t duration) {
   return oldValue;
 }
 
-int32_t LocalRegion::adjustEntryExpiryDuration(int32_t duration) {
+std::chrono::seconds LocalRegion::adjustEntryExpiryDuration(
+    const std::chrono::seconds& duration) {
   CHECK_DESTROY_PENDING(TryReadGuard, LocalRegion::adjustEntryExpiryDuration);
 
-  RegionAttributesPtr attrs = m_regionAttributes;
-  bool hadExpiry = (getEntryExpiryDuration() != 0);
+  bool hadExpiry = (getEntryExpiryDuration().count() != 0);
   if (!hadExpiry) {
     throw IllegalStateException(
         "Cannot change entry expiration duration for region created without "
         "entry expiry.");
   }
-  int32_t oldValue = getEntryExpiryDuration();
+  auto oldValue = getEntryExpiryDuration();
+
   setEntryTimeToLive(duration);
   setEntryIdleTimeout(duration);
 
@@ -2865,8 +2863,8 @@ bool LocalRegion::isStatisticsEnabled() {
 }
 
 bool LocalRegion::useModifiedTimeForRegionExpiry() {
-  uint32_t region_ttl = m_regionAttributes->getRegionTimeToLive();
-  if (region_ttl > 0) {
+  const auto& region_ttl = m_regionAttributes->getRegionTimeToLive();
+  if (region_ttl.count() > 0) {
     return true;
   } else {
     return false;
@@ -2874,8 +2872,7 @@ bool LocalRegion::useModifiedTimeForRegionExpiry() {
 }
 
 bool LocalRegion::useModifiedTimeForEntryExpiry() {
-  uint32_t entry_ttl = m_regionAttributes->getEntryTimeToLive();
-  if (entry_ttl > 0) {
+  if (m_regionAttributes->getEntryTimeToLive().count() > 0) {
     return true;
   } else {
     return false;
@@ -2884,7 +2881,7 @@ bool LocalRegion::useModifiedTimeForEntryExpiry() {
 
 bool LocalRegion::isEntryIdletimeEnabled() {
   if (m_regionAttributes->getCachingEnabled() &&
-      0 != m_regionAttributes->getEntryIdleTimeout()) {
+      0 != m_regionAttributes->getEntryIdleTimeout().count()) {
     return true;
   } else {
     return false;
@@ -2892,8 +2889,7 @@ bool LocalRegion::isEntryIdletimeEnabled() {
 }
 
 ExpirationAction::Action LocalRegion::getEntryExpirationAction() const {
-  uint32_t entry_ttl = m_regionAttributes->getEntryTimeToLive();
-  if (entry_ttl > 0) {
+  if (m_regionAttributes->getEntryTimeToLive().count() > 0) {
     return m_regionAttributes->getEntryTimeToLiveAction();
   } else {
     return m_regionAttributes->getEntryIdleTimeoutAction();
@@ -2901,29 +2897,29 @@ ExpirationAction::Action LocalRegion::getEntryExpirationAction() const {
 }
 
 ExpirationAction::Action LocalRegion::getRegionExpiryAction() const {
-  uint32_t region_ttl = m_regionAttributes->getRegionTimeToLive();
-  if (region_ttl > 0) {
+  const auto& region_ttl = m_regionAttributes->getRegionTimeToLive();
+  if (region_ttl.count() > 0) {
     return m_regionAttributes->getRegionTimeToLiveAction();
   } else {
     return m_regionAttributes->getRegionIdleTimeoutAction();
   }
 }
 
-uint32_t LocalRegion::getRegionExpiryDuration() const {
-  uint32_t region_ttl = m_regionAttributes->getRegionTimeToLive();
-  uint32_t region_idle = m_regionAttributes->getRegionIdleTimeout();
-  if (region_ttl > 0) {
+std::chrono::seconds LocalRegion::getRegionExpiryDuration() const {
+  const auto& region_ttl = m_regionAttributes->getRegionTimeToLive();
+  const auto& region_idle = m_regionAttributes->getRegionIdleTimeout();
+  if (region_ttl.count() > 0) {
     return region_ttl;
   } else {
     return region_idle;
   }
 }
 
-uint32_t LocalRegion::getEntryExpiryDuration() const {
-  uint32_t entry_ttl = m_regionAttributes->getEntryTimeToLive();
-  uint32_t entry_idle = m_regionAttributes->getEntryIdleTimeout();
+std::chrono::seconds LocalRegion::getEntryExpiryDuration() const {
+  const auto& entry_ttl = m_regionAttributes->getEntryTimeToLive();
+  const auto& entry_idle = m_regionAttributes->getEntryIdleTimeout();
 
-  if (entry_ttl > 0) {
+  if (entry_ttl.count() > 0) {
     return entry_ttl;
   } else {
     return entry_idle;
@@ -2933,24 +2929,23 @@ uint32_t LocalRegion::getEntryExpiryDuration() const {
 /** methods to be overridden by derived classes*/
 GfErrType LocalRegion::unregisterKeysBeforeDestroyRegion() { return GF_NOERR; }
 
-GfErrType LocalRegion::getNoThrow_remote(const CacheableKeyPtr& keyPtr,
-                                         CacheablePtr& valPtr,
-                                         const SerializablePtr& aCallbackArgument,
-                                         VersionTagPtr& versionTag) {
+GfErrType LocalRegion::getNoThrow_remote(
+    const CacheableKeyPtr& keyPtr, CacheablePtr& valPtr,
+    const SerializablePtr& aCallbackArgument, VersionTagPtr& versionTag) {
   return GF_NOERR;
 }
 
-GfErrType LocalRegion::putNoThrow_remote(const CacheableKeyPtr& keyPtr,
-                                         const CacheablePtr& cvalue,
-                                         const SerializablePtr& aCallbackArgument,
-                                         VersionTagPtr& versionTag,
-                                         bool checkDelta) {
+GfErrType LocalRegion::putNoThrow_remote(
+    const CacheableKeyPtr& keyPtr, const CacheablePtr& cvalue,
+    const SerializablePtr& aCallbackArgument, VersionTagPtr& versionTag,
+    bool checkDelta) {
   return GF_NOERR;
 }
 
 GfErrType LocalRegion::putAllNoThrow_remote(
     const HashMapOfCacheable& map,
-    VersionedCacheableObjectPartListPtr& putAllResponse, uint32_t timeout,
+    VersionedCacheableObjectPartListPtr& putAllResponse,
+    std::chrono::milliseconds timeout,
     const SerializablePtr& aCallbackArgument) {
   return GF_NOERR;
 }
diff --git a/cppcache/src/LocalRegion.hpp b/cppcache/src/LocalRegion.hpp
index 7fb0fe1b..e22657a4 100644
--- a/cppcache/src/LocalRegion.hpp
+++ b/cppcache/src/LocalRegion.hpp
@@ -134,97 +134,111 @@ class CPPCACHE_EXPORT LocalRegion : public RegionInternal {
               bool enableTimeStatistics = true);
   virtual ~LocalRegion();
 
-  const char* getName() const;
-  const char* getFullPath() const;
-  RegionPtr getParentRegion() const;
-  RegionAttributesPtr getAttributes() const { return m_regionAttributes; }
-  AttributesMutatorPtr getAttributesMutator() const {
+  const char* getName() const override;
+  const char* getFullPath() const override;
+  RegionPtr getParentRegion() const override;
+  RegionAttributesPtr getAttributes() const override {
+    return m_regionAttributes;
+  }
+  AttributesMutatorPtr getAttributesMutator() const override {
     return std::make_shared<AttributesMutator>(
         std::const_pointer_cast<LocalRegion>(
             std::static_pointer_cast<const LocalRegion>(shared_from_this())));
   }
-  void updateAccessAndModifiedTime(bool modified);
-  CacheStatisticsPtr getStatistics() const;
-  virtual void clear(const SerializablePtr& aCallbackArgument = nullptr);
-  virtual void localClear(const SerializablePtr& aCallbackArgument = nullptr);
+  void updateAccessAndModifiedTime(bool modified) override;
+  CacheStatisticsPtr getStatistics() const override;
+  virtual void clear(
+      const SerializablePtr& aCallbackArgument = nullptr) override;
+  virtual void localClear(
+      const SerializablePtr& aCallbackArgument = nullptr) override;
   GfErrType localClearNoThrow(
       const SerializablePtr& aCallbackArgument = nullptr,
       const CacheEventFlags eventFlags = CacheEventFlags::NORMAL);
-  void invalidateRegion(const SerializablePtr& aCallbackArgument = nullptr);
-  void localInvalidateRegion(const SerializablePtr& aCallbackArgument = nullptr);
-  void destroyRegion(const SerializablePtr& aCallbackArgument = nullptr);
-  void localDestroyRegion(const SerializablePtr& aCallbackArgument = nullptr);
-  RegionPtr getSubregion(const char* path);
-  RegionPtr createSubregion(const char* subregionName,
-                            const RegionAttributesPtr& aRegionAttributes);
-  VectorOfRegion subregions(const bool recursive);
-  RegionEntryPtr getEntry(const CacheableKeyPtr& key);
+  void invalidateRegion(
+      const SerializablePtr& aCallbackArgument = nullptr) override;
+  void localInvalidateRegion(
+      const SerializablePtr& aCallbackArgument = nullptr) override;
+  void destroyRegion(
+      const SerializablePtr& aCallbackArgument = nullptr) override;
+  void localDestroyRegion(
+      const SerializablePtr& aCallbackArgument = nullptr) override;
+  RegionPtr getSubregion(const char* path) override;
+  RegionPtr createSubregion(
+      const char* subregionName,
+      const RegionAttributesPtr& aRegionAttributes) override;
+  VectorOfRegion subregions(const bool recursive) override;
+  RegionEntryPtr getEntry(const CacheableKeyPtr& key) override;
   void getEntry(const CacheableKeyPtr& key, CacheablePtr& valuePtr);
   CacheablePtr get(const CacheableKeyPtr& key,
-                   const SerializablePtr& aCallbackArgument);
+                   const SerializablePtr& aCallbackArgument) override;
   void put(const CacheableKeyPtr& key, const CacheablePtr& value,
-           const SerializablePtr& aCallbackArgument = nullptr);
+           const SerializablePtr& aCallbackArgument = nullptr) override;
   void localPut(const CacheableKeyPtr& key, const CacheablePtr& value,
-                const SerializablePtr& aCallbackArgument = nullptr);
+                const SerializablePtr& aCallbackArgument = nullptr) override;
   void create(const CacheableKeyPtr& key, const CacheablePtr& value,
-              const SerializablePtr& aCallbackArgument = nullptr);
+              const SerializablePtr& aCallbackArgument = nullptr) override;
   void localCreate(const CacheableKeyPtr& key, const CacheablePtr& value,
-                   const SerializablePtr& aCallbackArgument = nullptr);
+                   const SerializablePtr& aCallbackArgument = nullptr) override;
   void invalidate(const CacheableKeyPtr& key,
-                  const SerializablePtr& aCallbackArgument = nullptr);
-  void localInvalidate(const CacheableKeyPtr& key,
-                       const SerializablePtr& aCallbackArgument = nullptr);
+                  const SerializablePtr& aCallbackArgument = nullptr) override;
+  void localInvalidate(
+      const CacheableKeyPtr& key,
+      const SerializablePtr& aCallbackArgument = nullptr) override;
   void destroy(const CacheableKeyPtr& key,
-               const SerializablePtr& aCallbackArgument = nullptr);
-  void localDestroy(const CacheableKeyPtr& key,
-                    const SerializablePtr& aCallbackArgument = nullptr);
+               const SerializablePtr& aCallbackArgument = nullptr) override;
+  void localDestroy(
+      const CacheableKeyPtr& key,
+      const SerializablePtr& aCallbackArgument = nullptr) override;
   bool remove(const CacheableKeyPtr& key, const CacheablePtr& value,
-              const SerializablePtr& aCallbackArgument = nullptr);
+              const SerializablePtr& aCallbackArgument = nullptr) override;
   bool removeEx(const CacheableKeyPtr& key,
-                const SerializablePtr& aCallbackArgument = nullptr);
+                const SerializablePtr& aCallbackArgument = nullptr) override;
   bool localRemove(const CacheableKeyPtr& key, const CacheablePtr& value,
-                   const SerializablePtr& aCallbackArgument = nullptr);
+                   const SerializablePtr& aCallbackArgument = nullptr) override;
   bool localRemoveEx(const CacheableKeyPtr& key,
-                     const SerializablePtr& aCallbackArgument = nullptr);
-  VectorOfCacheableKey keys();
-  VectorOfCacheableKey serverKeys();
-  VectorOfCacheable values();
-  VectorOfRegionEntry entries(bool recursive);
+                     const SerializablePtr& aCallbackArgument = nullptr) override;
+  VectorOfCacheableKey keys() override;
+  VectorOfCacheableKey serverKeys() override;
+  VectorOfCacheable values() override;
+  VectorOfRegionEntry entries(bool recursive) override;
 
   HashMapOfCacheable getAll(const VectorOfCacheableKey& keys,
-                            const SerializablePtr& aCallbackArgument = nullptr);
+                            const SerializablePtr& aCallbackArgument = nullptr) override;
 
   HashMapOfCacheable getAll_internal(const VectorOfCacheableKey& keys,
                                      const SerializablePtr& aCallbackArgument,
-                                     bool addToLocalCache);
+                                     bool addToLocalCache) override;
 
   void putAll(const HashMapOfCacheable& map,
-              uint32_t timeout = DEFAULT_RESPONSE_TIMEOUT,
-              const SerializablePtr& aCallbackArgument = nullptr);
+              std::chrono::milliseconds timeout = DEFAULT_RESPONSE_TIMEOUT,
+              const SerializablePtr& aCallbackArgument = nullptr) override;
   void removeAll(const VectorOfCacheableKey& keys,
-                 const SerializablePtr& aCallbackArgument = nullptr);
-  uint32_t size();
+                 const SerializablePtr& aCallbackArgument = nullptr) override;
+  uint32_t size() override;
   virtual uint32_t size_remote();
-  RegionServicePtr getRegionService() const;
+  RegionServicePtr getRegionService() const override;
   virtual bool containsValueForKey_remote(const CacheableKeyPtr& keyPtr) const;
-  bool containsValueForKey(const CacheableKeyPtr& keyPtr) const;
-  bool containsKey(const CacheableKeyPtr& keyPtr) const;
-  virtual bool containsKeyOnServer(const CacheableKeyPtr& keyPtr) const;
-  virtual VectorOfCacheableKey getInterestList() const;
-  virtual VectorOfCacheableString getInterestListRegex() const;
+  bool containsValueForKey(const CacheableKeyPtr& keyPtr) const  override;
+  bool containsKey(const CacheableKeyPtr& keyPtr) const override;
+  virtual bool containsKeyOnServer(const CacheableKeyPtr& keyPtr) const override;
+  virtual VectorOfCacheableKey getInterestList() const override;
+  virtual VectorOfCacheableString getInterestListRegex() const override;
 
   /** @brief Public Methods from RegionInternal
    *  There are all virtual methods
    */
-  PersistenceManagerPtr getPersistenceManager() { return m_persistenceManager; }
-  void setPersistenceManager(PersistenceManagerPtr& pmPtr);
+  PersistenceManagerPtr getPersistenceManager() override {
+    return m_persistenceManager;
+  }
+  void setPersistenceManager(PersistenceManagerPtr& pmPtr) override;
 
-  virtual GfErrType getNoThrow(const CacheableKeyPtr& key, CacheablePtr& value,
-                               const SerializablePtr& aCallbackArgument);
+  virtual GfErrType getNoThrow(
+      const CacheableKeyPtr& key, CacheablePtr& value,
+      const SerializablePtr& aCallbackArgument) override;
   virtual GfErrType getAllNoThrow(
       const VectorOfCacheableKey& keys, const HashMapOfCacheablePtr& values,
       const HashMapOfExceptionPtr& exceptions, const bool addToLocalCache,
-      const SerializablePtr& aCallbackArgument = nullptr);
+      const SerializablePtr& aCallbackArgument = nullptr) override;
   virtual GfErrType putNoThrow(const CacheableKeyPtr& key,
                                const CacheablePtr& value,
                                const SerializablePtr& aCallbackArgument,
@@ -232,7 +246,7 @@ class CPPCACHE_EXPORT LocalRegion : public RegionInternal {
                                const CacheEventFlags eventFlags,
                                VersionTagPtr versionTag,
                                DataInput* delta = nullptr,
-                               EventIdPtr eventId = nullptr);
+                               EventIdPtr eventId = nullptr) override;
   virtual GfErrType putNoThrowTX(const CacheableKeyPtr& key,
                                  const CacheablePtr& value,
                                  const SerializablePtr& aCallbackArgument,
@@ -246,12 +260,12 @@ class CPPCACHE_EXPORT LocalRegion : public RegionInternal {
                                   const SerializablePtr& aCallbackArgument,
                                   int updateCount,
                                   const CacheEventFlags eventFlags,
-                                  VersionTagPtr versionTag);
+                                  VersionTagPtr versionTag) override;
   virtual GfErrType destroyNoThrow(const CacheableKeyPtr& key,
                                    const SerializablePtr& aCallbackArgument,
                                    int updateCount,
                                    const CacheEventFlags eventFlags,
-                                   VersionTagPtr versionTag);
+                                   VersionTagPtr versionTag) override;
   virtual GfErrType destroyNoThrowTX(const CacheableKeyPtr& key,
                                      const SerializablePtr& aCallbackArgument,
                                      int updateCount,
@@ -262,7 +276,7 @@ class CPPCACHE_EXPORT LocalRegion : public RegionInternal {
                                   const SerializablePtr& aCallbackArgument,
                                   int updateCount,
                                   const CacheEventFlags eventFlags,
-                                  VersionTagPtr versionTag);
+                                  VersionTagPtr versionTag) override;
   virtual GfErrType removeNoThrowEx(const CacheableKeyPtr& key,
                                     const SerializablePtr& aCallbackArgument,
                                     int updateCount,
@@ -270,7 +284,7 @@ class CPPCACHE_EXPORT LocalRegion : public RegionInternal {
                                     VersionTagPtr versionTag);
   virtual GfErrType putAllNoThrow(
       const HashMapOfCacheable& map,
-      uint32_t timeout = DEFAULT_RESPONSE_TIMEOUT,
+      std::chrono::milliseconds timeout = DEFAULT_RESPONSE_TIMEOUT,
       const SerializablePtr& aCallbackArgument = nullptr);
   virtual GfErrType removeAllNoThrow(
       const VectorOfCacheableKey& keys,
@@ -279,17 +293,17 @@ class CPPCACHE_EXPORT LocalRegion : public RegionInternal {
                                       const SerializablePtr& aCallbackArgument,
                                       int updateCount,
                                       const CacheEventFlags eventFlags,
-                                      VersionTagPtr versionTag);
+                                      VersionTagPtr versionTag) override;
   virtual GfErrType invalidateNoThrowTX(const CacheableKeyPtr& keyPtr,
                                         const SerializablePtr& aCallbackArgument,
                                         int updateCount,
                                         const CacheEventFlags eventFlags,
                                         VersionTagPtr versionTag);
   GfErrType invalidateRegionNoThrow(const SerializablePtr& aCallbackArgument,
-                                    const CacheEventFlags eventFlags);
+                                    const CacheEventFlags eventFlags) override;
   GfErrType destroyRegionNoThrow(const SerializablePtr& aCallbackArgument,
                                  bool removeFromParent,
-                                 const CacheEventFlags eventFlags);
+                                 const CacheEventFlags eventFlags) override;
   void tombstoneOperationNoThrow(const CacheableHashMapPtr& tombstoneVersions,
                                  const CacheableHashSetPtr& tombstoneKeys);
 
@@ -307,46 +321,50 @@ class CPPCACHE_EXPORT LocalRegion : public RegionInternal {
                             const CacheEventFlags eventFlags,
                             VersionTagPtr versionTag);
 
-  void setRegionExpiryTask();
-  void acquireReadLock() { m_rwLock.acquire_read(); }
-  void releaseReadLock() { m_rwLock.release(); }
+  void setRegionExpiryTask() override;
+  void acquireReadLock() override { m_rwLock.acquire_read(); }
+  void releaseReadLock() override { m_rwLock.release(); }
 
   // behaviors for attributes mutator
-  uint32_t adjustLruEntriesLimit(uint32_t limit);
+  uint32_t adjustLruEntriesLimit(uint32_t limit) override;
   ExpirationAction::Action adjustRegionExpiryAction(
-      ExpirationAction::Action action);
+      ExpirationAction::Action action) override;
   ExpirationAction::Action adjustEntryExpiryAction(
-      ExpirationAction::Action action);
-  int32_t adjustRegionExpiryDuration(int32_t duration);
-  int32_t adjustEntryExpiryDuration(int32_t duration);
+      ExpirationAction::Action action) override;
+  std::chrono::seconds adjustRegionExpiryDuration(
+      const std::chrono::seconds& duration) override;
+  std::chrono::seconds adjustEntryExpiryDuration(
+      const std::chrono::seconds& duration) override;
 
   // other public methods
-  RegionStats* getRegionStats() { return m_regionStats; }
-  inline bool cacheEnabled() { return m_regionAttributes->getCachingEnabled(); }
+  RegionStats* getRegionStats() override { return m_regionStats; }
+  inline bool cacheEnabled() override {
+    return m_regionAttributes->getCachingEnabled();
+  }
   inline bool cachelessWithListener() {
     return !m_regionAttributes->getCachingEnabled() && (m_listener != nullptr);
   }
-  virtual bool isDestroyed() const { return m_destroyPending; }
+  virtual bool isDestroyed() const override { return m_destroyPending; }
   /* above public methods are inherited from RegionInternal */
 
-  virtual void adjustCacheListener(const CacheListenerPtr& aListener);
+  virtual void adjustCacheListener(const CacheListenerPtr& aListener) override;
   virtual void adjustCacheListener(const char* libpath,
-                                   const char* factoryFuncName);
-  virtual void adjustCacheLoader(const CacheLoaderPtr& aLoader);
+                                   const char* factoryFuncName) override;
+  virtual void adjustCacheLoader(const CacheLoaderPtr& aLoader) override;
   virtual void adjustCacheLoader(const char* libpath,
-                                 const char* factoryFuncName);
-  virtual void adjustCacheWriter(const CacheWriterPtr& aWriter);
+                                 const char* factoryFuncName) override;
+  virtual void adjustCacheWriter(const CacheWriterPtr& aWriter) override;
   virtual void adjustCacheWriter(const char* libpath,
-                                 const char* factoryFuncName);
-  virtual CacheImpl* getCacheImpl() const;
-  virtual void evict(int32_t percentage);
+                                 const char* factoryFuncName) override;
+  virtual CacheImpl* getCacheImpl() const override;
+  virtual void evict(int32_t percentage) override;
 
   virtual void acquireGlobals(bool isFailover){};
   virtual void releaseGlobals(bool isFailover){};
 
   virtual bool getProcessedMarker() { return true; }
   EntriesMap* getEntryMap() { return m_entries; }
-  virtual TombstoneListPtr getTombstoneList();
+  virtual TombstoneListPtr getTombstoneList() override;
 
  protected:
   /* virtual protected methods */
@@ -363,7 +381,8 @@ class CPPCACHE_EXPORT LocalRegion : public RegionInternal {
   virtual GfErrType putAllNoThrow_remote(
       const HashMapOfCacheable& map,
       VersionedCacheableObjectPartListPtr& versionedObjPartList,
-      uint32_t timeout, const SerializablePtr& aCallbackArgument);
+      std::chrono::milliseconds timeout,
+      const SerializablePtr& aCallbackArgument);
   virtual GfErrType removeAllNoThrow_remote(
       const VectorOfCacheableKey& keys,
       VersionedCacheableObjectPartListPtr& versionedObjPartList,
@@ -395,7 +414,7 @@ class CPPCACHE_EXPORT LocalRegion : public RegionInternal {
   virtual GfErrType destroyRegionNoThrow_remote(
       const SerializablePtr& aCallbackArgument);
   virtual GfErrType unregisterKeysBeforeDestroyRegion();
-  virtual const PoolPtr& getPool() { return m_attachedPool; }
+  virtual const PoolPtr& getPool() override { return m_attachedPool; }
 
   void setPool(const PoolPtr& p) { m_attachedPool = p; }
 
@@ -475,7 +494,8 @@ class CPPCACHE_EXPORT LocalRegion : public RegionInternal {
       const SerializablePtr& aCallbackArgument, CacheEventFlags eventFlags,
       RegionEventType type);
   // functions related to expirations.
-  void updateAccessAndModifiedTimeForEntry(MapEntryImplPtr& ptr, bool modified);
+  void updateAccessAndModifiedTimeForEntry(MapEntryImplPtr& ptr,
+                                           bool modified) override;
   void registerEntryExpiryTask(MapEntryImplPtr& entry);
   VectorOfRegion subregions_internal(const bool recursive);
   void entries_internal(VectorOfRegionEntry& me, const bool recursive);
@@ -488,8 +508,8 @@ class CPPCACHE_EXPORT LocalRegion : public RegionInternal {
   bool isEntryIdletimeEnabled();
   ExpirationAction::Action getEntryExpirationAction() const;
   ExpirationAction::Action getRegionExpiryAction() const;
-  uint32_t getRegionExpiryDuration() const;
-  uint32_t getEntryExpiryDuration() const;
+  std::chrono::seconds getRegionExpiryDuration() const;
+  std::chrono::seconds getEntryExpiryDuration() const;
   void invokeAfterAllEndPointDisconnected();
   // Disallow copy constructor and assignment operator.
   LocalRegion(const LocalRegion&);
diff --git a/cppcache/src/NoResult.hpp b/cppcache/src/NoResult.hpp
index b15f36cb..879b931c 100644
--- a/cppcache/src/NoResult.hpp
+++ b/cppcache/src/NoResult.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_NORESULT_H_
-#define GEODE_NORESULT_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,6 +15,11 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_NORESULT_H_
+#define GEODE_NORESULT_H_
+
 #include <geode/geode_globals.hpp>
 #include <geode/geode_types.hpp>
 #include <geode/ExceptionTypes.hpp>
@@ -43,25 +43,29 @@ namespace client {
  */
 class CPPCACHE_EXPORT NoResult : public ResultCollector {
  public:
-  NoResult() {}
-  ~NoResult() {}
-  inline void addResult(const CacheablePtr& resultOfSingleExecution) {
+  NoResult() = default;
+  virtual ~NoResult() override = default;
+
+  inline void addResult(const CacheablePtr& resultOfSingleExecution) override {
     throw UnsupportedOperationException("can not add to NoResult");
   }
 
-  inline void endResults() {
+  inline void endResults() override {
     throw UnsupportedOperationException("can not close on NoResult");
   }
 
   inline CacheableVectorPtr getResult(
-      uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) {
+      std::chrono::milliseconds timeout =
+          DEFAULT_QUERY_RESPONSE_TIMEOUT) override {
     throw FunctionExecutionException(
         "Cannot return any result, as Function.hasResult() is false");
   }
-  inline void clearResults() {
+
+  inline void clearResults() override {
     throw UnsupportedOperationException("can not clear results on NoResult");
   }
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/src/Pool.cpp b/cppcache/src/Pool.cpp
index 12c4c688..d131b09a 100644
--- a/cppcache/src/Pool.cpp
+++ b/cppcache/src/Pool.cpp
@@ -30,45 +30,68 @@ using namespace apache::geode::client;
 Pool::Pool(PoolAttributesPtr attr) : m_attrs(attr) {}
 Pool::~Pool() {}
 
-int Pool::getFreeConnectionTimeout() const {
+std::chrono::milliseconds Pool::getFreeConnectionTimeout() const {
   return m_attrs->getFreeConnectionTimeout();
 }
-int Pool::getLoadConditioningInterval() const {
+
+std::chrono::milliseconds Pool::getLoadConditioningInterval() const {
   return m_attrs->getLoadConditioningInterval();
 }
+
 int Pool::getSocketBufferSize() const { return m_attrs->getSocketBufferSize(); }
-int Pool::getReadTimeout() const { return m_attrs->getReadTimeout(); }
+
+std::chrono::milliseconds Pool::getReadTimeout() const {
+  return m_attrs->getReadTimeout();
+}
+
 int Pool::getMinConnections() const { return m_attrs->getMinConnections(); }
+
 int Pool::getMaxConnections() const { return m_attrs->getMaxConnections(); }
-long Pool::getIdleTimeout() const { return m_attrs->getIdleTimeout(); }
-long Pool::getPingInterval() const { return m_attrs->getPingInterval(); }
-long Pool::getUpdateLocatorListInterval() const {
+
+std::chrono::milliseconds Pool::getIdleTimeout() const {
+  return m_attrs->getIdleTimeout();
+}
+
+std::chrono::milliseconds Pool::getPingInterval() const {
+  return m_attrs->getPingInterval();
+}
+
+std::chrono::milliseconds Pool::getUpdateLocatorListInterval() const {
   return m_attrs->getUpdateLocatorListInterval();
 }
-int Pool::getStatisticInterval() const {
+
+std::chrono::milliseconds Pool::getStatisticInterval() const {
   return m_attrs->getStatisticInterval();
 }
+
 int Pool::getRetryAttempts() const { return m_attrs->getRetryAttempts(); }
-// bool Pool::getThreadLocalConnections() const { return false; }
+
 bool Pool::getSubscriptionEnabled() const {
   return m_attrs->getSubscriptionEnabled();
 }
+
 int Pool::getSubscriptionRedundancy() const {
   return m_attrs->getSubscriptionRedundancy();
 }
-int Pool::getSubscriptionMessageTrackingTimeout() const {
+
+std::chrono::milliseconds Pool::getSubscriptionMessageTrackingTimeout() const {
   return m_attrs->getSubscriptionMessageTrackingTimeout();
 }
-int Pool::getSubscriptionAckInterval() const {
+
+std::chrono::milliseconds Pool::getSubscriptionAckInterval() const {
   return m_attrs->getSubscriptionAckInterval();
 }
+
 const char* Pool::getServerGroup() const { return m_attrs->getServerGroup(); }
+
 bool Pool::getThreadLocalConnections() const {
   return m_attrs->getThreadLocalConnectionSetting();
 }
+
 bool Pool::getMultiuserAuthentication() const {
   return m_attrs->getMultiuserSecureModeEnabled();
 }
+
 RegionServicePtr Pool::createSecureUserCache(PropertiesPtr credentials,
                                              CacheImpl* cacheImpl) {
   if (this->getMultiuserAuthentication()) {
diff --git a/cppcache/src/PoolAttributes.hpp b/cppcache/src/PoolAttributes.hpp
index c7403c86..c9f288e0 100644
--- a/cppcache/src/PoolAttributes.hpp
+++ b/cppcache/src/PoolAttributes.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_POOLATTRIBUTES_H_
-#define GEODE_POOLATTRIBUTES_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -19,9 +14,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
+#pragma once
+
+#ifndef GEODE_POOLATTRIBUTES_H_
+#define GEODE_POOLATTRIBUTES_H_
+
 #include <string>
 #include <vector>
-#include "ace/OS.h"
+#include <chrono>
+
+#include <ace/OS.h>
+
 #include <geode/geode_globals.hpp>
 #include <geode/geode_types.hpp>
 #include <geode/ExceptionTypes.hpp>
@@ -33,90 +37,136 @@
 namespace apache {
 namespace geode {
 namespace client {
+
 class PoolAttributes {
  public:
   PoolAttributes();
 
-  int getFreeConnectionTimeout() const { return m_freeConnTimeout; }
-  void setFreeConnectionTimeout(int connectionTimeout) {
+  const std::chrono::milliseconds& getFreeConnectionTimeout() const {
+    return m_freeConnTimeout;
+  }
+
+  void setFreeConnectionTimeout(
+      const std::chrono::milliseconds& connectionTimeout) {
     m_freeConnTimeout = connectionTimeout;
   }
 
-  int getLoadConditioningInterval() const { return m_loadCondInterval; }
-  void setLoadConditioningInterval(int loadConditioningInterval) {
+  const std::chrono::milliseconds& getLoadConditioningInterval() const {
+    return m_loadCondInterval;
+  }
+
+  void setLoadConditioningInterval(
+      const std::chrono::milliseconds& loadConditioningInterval) {
     m_loadCondInterval = loadConditioningInterval;
   }
 
   int getSocketBufferSize() const { return m_sockBufferSize; }
+
   void setSocketBufferSize(int bufferSize) { m_sockBufferSize = bufferSize; }
 
-  int getReadTimeout() const { return m_readTimeout; }
-  void setReadTimeout(int timeout) { m_readTimeout = timeout; }
+  const std::chrono::milliseconds& getReadTimeout() const {
+    return m_readTimeout;
+  }
+
+  void setReadTimeout(const std::chrono::milliseconds& timeout) {
+    m_readTimeout = timeout;
+  }
+
   bool getThreadLocalConnectionSetting() { return m_isThreadLocalConn; }
+
   void setThreadLocalConnectionSetting(bool isThreadLocal) {
     m_isThreadLocalConn = isThreadLocal;
   }
+
   int getMinConnections() const { return m_minConns; }
+
   void setMinConnections(int minConnections) { m_minConns = minConnections; }
 
   int getMaxConnections() const { return m_maxConns; }
+
   void setMaxConnections(int maxConnections) { m_maxConns = maxConnections; }
 
-  long getIdleTimeout() const { return m_idleTimeout; }
-  void setIdleTimeout(long idleTimeout) { m_idleTimeout = idleTimeout; }
+  const std::chrono::milliseconds& getIdleTimeout() const {
+    return m_idleTimeout;
+  }
+
+  void setIdleTimeout(const std::chrono::milliseconds& idleTimeout) {
+    m_idleTimeout = idleTimeout;
+  }
 
   int getRetryAttempts() const { return m_retryAttempts; }
+
   void setRetryAttempts(int retryAttempts) { m_retryAttempts = retryAttempts; }
 
-  long getPingInterval() const { return m_pingInterval; }
+  const std::chrono::milliseconds& getPingInterval() const {
+    return m_pingInterval;
+  }
 
-  void setPingInterval(long pingInterval) { m_pingInterval = pingInterval; }
+  void setPingInterval(const std::chrono::milliseconds& pingInterval) {
+    m_pingInterval = pingInterval;
+  }
 
-  long getUpdateLocatorListInterval() const {
+  const std::chrono::milliseconds& getUpdateLocatorListInterval() const {
     return m_updateLocatorListInterval;
   }
 
-  void setUpdateLocatorListInterval(long updateLocatorListInterval) {
+  void setUpdateLocatorListInterval(
+      const std::chrono::milliseconds& updateLocatorListInterval) {
     m_updateLocatorListInterval = updateLocatorListInterval;
   }
 
-  int getStatisticInterval() const { return m_statsInterval; }
-  void setStatisticInterval(int statisticInterval) {
+  const std::chrono::milliseconds& getStatisticInterval() const {
+    return m_statsInterval;
+  }
+
+  void setStatisticInterval(
+      const std::chrono::milliseconds& statisticInterval) {
     m_statsInterval = statisticInterval;
   }
 
   const char* getServerGroup() const { return m_serverGrp.c_str(); }
+
   void setServerGroup(const char* group) { m_serverGrp = group; }
 
   bool getSubscriptionEnabled() const { return m_subsEnabled; }
+
   void setSubscriptionEnabled(bool enabled) { m_subsEnabled = enabled; }
 
   int getSubscriptionRedundancy() const { return m_redundancy; }
+
   void setSubscriptionRedundancy(int redundancy) { m_redundancy = redundancy; }
 
-  int getSubscriptionMessageTrackingTimeout() const {
+  const std::chrono::milliseconds& getSubscriptionMessageTrackingTimeout()
+      const {
     return m_msgTrackTimeout;
   }
-  void setSubscriptionMessageTrackingTimeout(int messageTrackingTimeout) {
+
+  void setSubscriptionMessageTrackingTimeout(
+      const std::chrono::milliseconds& messageTrackingTimeout) {
     m_msgTrackTimeout = messageTrackingTimeout;
   }
 
-  int getSubscriptionAckInterval() const { return m_subsAckInterval; }
+  const std::chrono::milliseconds& getSubscriptionAckInterval() const {
+    return m_subsAckInterval;
+  }
+
+  void setSubscriptionAckInterval(
+      const std::chrono::milliseconds& ackInterval) {
+    m_subsAckInterval = ackInterval;
+  }
 
   bool getPRSingleHopEnabled() const { return m_isPRSingleHopEnabled; }
 
   void setPRSingleHopEnabled(bool enabled) { m_isPRSingleHopEnabled = enabled; }
 
-  void setSubscriptionAckInterval(int ackInterval) {
-    m_subsAckInterval = ackInterval;
-  }
-
   bool getMultiuserSecureModeEnabled() const { return m_multiuserSecurityMode; }
+
   void setMultiuserSecureModeEnabled(bool multiuserSecureMode) {
     m_multiuserSecurityMode = multiuserSecureMode;
   }
 
   void addLocator(const char* host, int port);
+
   void addServer(const char* host, int port);
 
   PoolAttributesPtr clone();
@@ -126,21 +176,21 @@ class PoolAttributes {
 
  private:
   bool m_isThreadLocalConn;
-  int m_freeConnTimeout;
-  int m_loadCondInterval;
+  std::chrono::milliseconds m_freeConnTimeout;
+  std::chrono::milliseconds m_loadCondInterval;
   int m_sockBufferSize;
-  int m_readTimeout;
+  std::chrono::milliseconds m_readTimeout;
   int m_minConns;
   int m_maxConns;
   int m_retryAttempts;
-  int m_statsInterval;
+  std::chrono::milliseconds m_statsInterval;
   int m_redundancy;
-  int m_msgTrackTimeout;
-  int m_subsAckInterval;
+  std::chrono::milliseconds m_msgTrackTimeout;
+  std::chrono::milliseconds m_subsAckInterval;
 
-  long m_idleTimeout;
-  long m_pingInterval;
-  long m_updateLocatorListInterval;
+  std::chrono::milliseconds m_idleTimeout;
+  std::chrono::milliseconds m_pingInterval;
+  std::chrono::milliseconds m_updateLocatorListInterval;
 
   bool m_subsEnabled;
   bool m_multiuserSecurityMode;
diff --git a/cppcache/src/PoolFactory.cpp b/cppcache/src/PoolFactory.cpp
index 4b77280d..22f1cbd0 100644
--- a/cppcache/src/PoolFactory.cpp
+++ b/cppcache/src/PoolFactory.cpp
@@ -14,23 +14,55 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#include <CacheImpl.hpp>
+
+#include <ace/Recursive_Thread_Mutex.h>
+#include <ace/INET_Addr.h>
+
 #include <geode/PoolFactory.hpp>
 #include <geode/Pool.hpp>
-#include <PoolAttributes.hpp>
-#include <ThinClientPoolDM.hpp>
-#include <ThinClientPoolHADM.hpp>
 #include <geode/SystemProperties.hpp>
 #include <geode/PoolManager.hpp>
-#include <ace/Recursive_Thread_Mutex.h>
-#include <ace/INET_Addr.h>
-#include <ThinClientPoolStickyDM.hpp>
-#include <ThinClientPoolStickyHADM.hpp>
+
+#include "CacheImpl.hpp"
+#include "PoolAttributes.hpp"
+#include "ThinClientPoolDM.hpp"
+#include "ThinClientPoolHADM.hpp"
+#include "ThinClientPoolStickyDM.hpp"
+#include "ThinClientPoolStickyHADM.hpp"
 #include "CacheRegionHelper.hpp"
+
 using namespace apache::geode::client;
 
 constexpr const char* PoolFactory::DEFAULT_SERVER_GROUP;
 
+const std::chrono::milliseconds PoolFactory::DEFAULT_FREE_CONNECTION_TIMEOUT =
+    std::chrono::seconds{10};
+
+const std::chrono::milliseconds
+    PoolFactory::DEFAULT_LOAD_CONDITIONING_INTERVAL = std::chrono::minutes{5};
+
+const std::chrono::milliseconds PoolFactory::DEFAULT_READ_TIMEOUT =
+    std::chrono::seconds{10};
+
+const std::chrono::milliseconds PoolFactory::DEFAULT_IDLE_TIMEOUT =
+    std::chrono::seconds{5};
+
+const std::chrono::milliseconds PoolFactory::DEFAULT_PING_INTERVAL =
+    std::chrono::seconds{10};
+
+const std::chrono::milliseconds
+    PoolFactory::DEFAULT_UPDATE_LOCATOR_LIST_INTERVAL = std::chrono::seconds{5};
+
+const std::chrono::milliseconds PoolFactory::DEFAULT_STATISTIC_INTERVAL =
+    std::chrono::milliseconds{-1};
+
+const std::chrono::milliseconds
+    PoolFactory::DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT =
+        std::chrono::seconds{900};
+
+const std::chrono::milliseconds PoolFactory::DEFAULT_SUBSCRIPTION_ACK_INTERVAL =
+    std::chrono::seconds{100};
+
 PoolFactory::PoolFactory(const Cache& cache)
     : m_attrs(std::make_shared<PoolAttributes>()),
       m_isSubscriptionRedundancy(false),
@@ -39,69 +71,134 @@ PoolFactory::PoolFactory(const Cache& cache)
 
 PoolFactory::~PoolFactory() {}
 
-void PoolFactory::setFreeConnectionTimeout(int connectionTimeout) {
+void PoolFactory::setFreeConnectionTimeout(
+    std::chrono::milliseconds connectionTimeout) {
+  // TODO GEODE-3136 - Is this true?
+  if (connectionTimeout <= std::chrono::milliseconds::zero()) {
+    throw std::invalid_argument("connectionTimeout must greater than 0.");
+  }
+
   m_attrs->setFreeConnectionTimeout(connectionTimeout);
 }
-void PoolFactory::setLoadConditioningInterval(int loadConditioningInterval) {
+
+void PoolFactory::setLoadConditioningInterval(
+    std::chrono::milliseconds loadConditioningInterval) {
+  // TODO GEODE-3136 - Is this true?
+  if (loadConditioningInterval <= std::chrono::milliseconds::zero()) {
+    throw std::invalid_argument(
+        "loadConditioningInterval must greater than 0.");
+  }
+
   m_attrs->setLoadConditioningInterval(loadConditioningInterval);
 }
+
 void PoolFactory::setSocketBufferSize(int bufferSize) {
   m_attrs->setSocketBufferSize(bufferSize);
 }
+
 void PoolFactory::setThreadLocalConnections(bool threadLocalConnections) {
   m_attrs->setThreadLocalConnectionSetting(threadLocalConnections);
 }
-void PoolFactory::setReadTimeout(int timeout) {
+
+void PoolFactory::setReadTimeout(std::chrono::milliseconds timeout) {
+  // TODO GEODE-3136 - Is this true?
+  if (timeout <= std::chrono::milliseconds::zero()) {
+    throw std::invalid_argument("timeout must greater than 0.");
+  }
+
   m_attrs->setReadTimeout(timeout);
 }
+
 void PoolFactory::setMinConnections(int minConnections) {
   m_attrs->setMinConnections(minConnections);
 }
+
 void PoolFactory::setMaxConnections(int maxConnections) {
   m_attrs->setMaxConnections(maxConnections);
 }
-void PoolFactory::setIdleTimeout(long idleTimeout) {
+
+void PoolFactory::setIdleTimeout(std::chrono::milliseconds idleTimeout) {
   m_attrs->setIdleTimeout(idleTimeout);
 }
+
 void PoolFactory::setRetryAttempts(int retryAttempts) {
   m_attrs->setRetryAttempts(retryAttempts);
 }
-void PoolFactory::setPingInterval(long pingInterval) {
+
+void PoolFactory::setPingInterval(std::chrono::milliseconds pingInterval) {
+  // TODO GEODE-3136 - Is this true?
+  if (pingInterval <= std::chrono::milliseconds::zero()) {
+    throw std::invalid_argument("timeout must greater than 0.");
+  }
+
   m_attrs->setPingInterval(pingInterval);
 }
-void PoolFactory::setUpdateLocatorListInterval(long updateLocatorListInterval) {
+
+void PoolFactory::setUpdateLocatorListInterval(
+    const std::chrono::milliseconds updateLocatorListInterval) {
+  // TODO GEODE-3136 - Is this true?
+  if (updateLocatorListInterval < std::chrono::milliseconds::zero()) {
+    throw std::invalid_argument("timeout must be positive.");
+  }
+
   m_attrs->setUpdateLocatorListInterval(updateLocatorListInterval);
 }
-void PoolFactory::setStatisticInterval(int statisticInterval) {
+
+void PoolFactory::setStatisticInterval(
+    std::chrono::milliseconds statisticInterval) {
+  // TODO GEODE-3136 - Consider 0 to disable
+  if (statisticInterval.count() <= -1) {
+    throw std::invalid_argument("timeout must greater than -1.");
+  }
+
   m_attrs->setStatisticInterval(statisticInterval);
 }
+
 void PoolFactory::setServerGroup(const char* group) {
   m_attrs->setServerGroup(group);
 }
+
 void PoolFactory::addLocator(const char* host, int port) {
   addCheck(host, port);
   m_attrs->addLocator(host, port);
   m_addedServerOrLocator = true;
 }
+
 void PoolFactory::addServer(const char* host, int port) {
   addCheck(host, port);
   m_attrs->addServer(host, port);
   m_addedServerOrLocator = true;
 }
+
 void PoolFactory::setSubscriptionEnabled(bool enabled) {
   m_attrs->setSubscriptionEnabled(enabled);
 }
+
 void PoolFactory::setSubscriptionRedundancy(int redundancy) {
   m_isSubscriptionRedundancy = true;
   m_attrs->setSubscriptionRedundancy(redundancy);
 }
+
 void PoolFactory::setSubscriptionMessageTrackingTimeout(
-    int messageTrackingTimeout) {
+    std::chrono::milliseconds messageTrackingTimeout) {
+  // TODO GEODE-3136 - Is this true?
+  if (messageTrackingTimeout <= std::chrono::milliseconds::zero()) {
+    throw std::invalid_argument("timeout must greater than 0.");
+  }
+
   m_attrs->setSubscriptionMessageTrackingTimeout(messageTrackingTimeout);
 }
-void PoolFactory::setSubscriptionAckInterval(int ackInterval) {
+
+void PoolFactory::setSubscriptionAckInterval(
+    std::chrono::milliseconds ackInterval) {
+  // TODO GEODE-3136 - Is this true?
+  if (ackInterval <= std::chrono::milliseconds::zero()) {
+    throw std::invalid_argument("timeout must greater than 0.");
+  }
+
   m_attrs->setSubscriptionAckInterval(ackInterval);
 }
+
 void PoolFactory::setMultiuserAuthentication(bool multiuserAuthentication) {
   m_attrs->setMultiuserSecureModeEnabled(multiuserAuthentication);
 }
diff --git a/cppcache/src/Properties.cpp b/cppcache/src/Properties.cpp
index d37092e3..3b532c71 100644
--- a/cppcache/src/Properties.cpp
+++ b/cppcache/src/Properties.cpp
@@ -130,10 +130,9 @@ void Properties::insert(const char* key, const int value) {
   if (key == nullptr) {
     throw NullPointerException("Properties::insert: Null key given.");
   }
-  char temp[64];
-  ACE_OS::snprintf(temp, 64, "%d", value);
   CacheableStringPtr keyptr = CacheableString::create(key);
-  CacheableStringPtr valptr = CacheableString::create(temp);
+  CacheableStringPtr valptr =
+      CacheableString::create(std::to_string(value).c_str());
   MAP->rebind(keyptr, valptr);
 }
 
diff --git a/cppcache/src/ProxyRegion.hpp b/cppcache/src/ProxyRegion.hpp
index 5501aa20..a568d616 100644
--- a/cppcache/src/ProxyRegion.hpp
+++ b/cppcache/src/ProxyRegion.hpp
@@ -54,181 +54,62 @@ class FunctionService;
  * This class wrapper around real region
  */
 class CPPCACHE_EXPORT ProxyRegion : public Region {
-  /** @brief Public Methods
-   */
  public:
-  /** return single name of region. The storage is backed by the region. */
-  virtual const char* getName() const { return m_realRegion->getName(); }
-  // virtual uint64_t getUpdateReceived() const { return 0; };
+  virtual const char* getName() const override { return m_realRegion->getName(); }
 
-  /** return the full path of the region as can be used to lookup the
-   * region from Cache::getRegion. The storage is backed by the region.
-   */
-  virtual const char* getFullPath() const {
+  virtual const char* getFullPath() const override {
     return m_realRegion->getFullPath();
   }
 
-  /** Returns the parent region, or nullptr if a root region.
-   * @throws RegionDestroyedException
-   */
-  virtual RegionPtr getParentRegion() const {
+  virtual RegionPtr getParentRegion() const override {
     return m_realRegion->getParentRegion();
   }
 
-  /** Return the RegionAttributes for this region.
-   */
-  virtual RegionAttributesPtr getAttributes() const {
+  virtual RegionAttributesPtr getAttributes() const override {
     return m_realRegion->getAttributes();
   }
 
-  /** Return the a mutator object for changing a subset of the region
-   * attributes.
-   * @throws RegionDestroyedException.
-   */
-  virtual AttributesMutatorPtr getAttributesMutator() const {
+  virtual AttributesMutatorPtr getAttributesMutator() const override {
     throw UnsupportedOperationException("Region.getAttributesMutator()");
   }
 
-  // virtual void updateAccessOrModifiedTime() = 0;
-
-  virtual CacheStatisticsPtr getStatistics() const {
+  virtual CacheStatisticsPtr getStatistics() const override {
     return m_realRegion->getStatistics();
   }
 
-  /** Invalidates this region. The invalidation will cascade to
-   * all the subregions and cached entries. After
-   * the <code>invalidateRegion</code> , the region and the entries in it still
-   * exist. In order to remove all the entries and the region,
-   * <code>destroyRegion</code> should be used.
-   *
-   * @param aCallbackArgument a user-defined parameter to pass to callback
-   * events triggered by this method. Can be nullptr. If it is sent on the wire,
-   * it has to be Serializable.
-   * @throws CacheListenerException if CacheListener throws an exception; if
-   * this occurs some subregions may have already been successfully invalidated
-   * @throws RegionDestroyedException if the region is no longer valid
-   * @see   destroyRegion
-   * @see   CacheListener::afterRegionInvalidate
-   * This operation is not distributed.
-   */
   virtual void invalidateRegion(
-      const SerializablePtr& aCallbackArgument = nullptr) {
+      const SerializablePtr& aCallbackArgument = nullptr) override {
     throw UnsupportedOperationException("Region.invalidateRegion()");
   }
 
-  /** Invalidates this region. The invalidation will cascade to
-  * all the subregions and cached entries. After
-  * the <code>invalidateRegion</code> , the region and the entries in it still
-  * exist. In order to remove all the entries and the region,
-  * <code>destroyRegion</code> should be used. The region invalidate will not be
-  distributed
-  * to other caches
-  *
-  * @param aCallbackArgument a user-defined parameter to pass to callback events
-  *        triggered by this method.
-  *        Can be nullptr. If it is sent on the wire, it has to be Serializable.
-  * @throws CacheListenerException if CacheListener throws an exception; if this
-  *         occurs some subregions may have already been successfully
-  invalidated
-  * @throws RegionDestroyedException if the region is no longer valid
-  * @see   destroyRegion
-  * @see   CacheListener::afterRegionInvalidate
-
-  */
   virtual void localInvalidateRegion(
-      const SerializablePtr& aCallbackArgument = nullptr) {
+      const SerializablePtr& aCallbackArgument = nullptr) override {
     throw UnsupportedOperationException("Region.localInvalidateRegion()");
   }
 
-  /** Destroys the whole region and provides a user-defined parameter
-   * object to any <code>CacheWriter</code> invoked in the process.
-   * Destroy cascades to all entries
-   * and subregions. After the destroy, this region object cannot be used
-   * any more. Any attempt to use this region object will get a
-   * <code>RegionDestroyedException</code> exception.
-   *
-   * The region destroy not only destroys the local region but also destroys the
-   * server region. However, if server region destroy fails throwing back
-   * <code>CacheServerException</code> or security exception,
-   * the local region is still destroyed.
-   *
-   * @param aCallbackArgument a user-defined parameter to pass to callback
-   * events triggered by this call. Can be nullptr. If it is sent on the wire,
-   * it has to be Serializable.
-   * @throws CacheWriterException if CacheWriter aborts the operation; if this
-   *         occurs some subregions may have already been successfully
-   * destroyed.
-   * @throws CacheListenerException if CacheListener throws an exception; if
-   * this occurs some subregions may have already been successfully invalidated
-   * @throws CacheServerException If an exception is received from the Java
-   * cache server. Only for Native Client regions.
-   * @throws NotConnectedException if not connected to the geode system because
-   * the client
-   *         cannot establish usable connections to any of the servers given to
-   * it
-   * @throws MessageExcepton If the message received from server could not be
-   *         handled. This will be the case when an unregistered typeId is
-   *         received in the reply or reply is not well formed.
-   *         More information can be found in the log.
-   * @throws TimeoutException if operation timed out
-   * @see  invalidateRegion
-   */
-  virtual void destroyRegion(const SerializablePtr& aCallbackArgument = nullptr) {
+  virtual void destroyRegion(
+      const SerializablePtr& aCallbackArgument = nullptr) override {
     GuardUserAttribures gua(m_proxyCache);
     m_realRegion->destroyRegion(aCallbackArgument);
   }
 
-  /**
-   * Removes all entries from this region and provides a user-defined parameter
-   * object to any <code>CacheWriter</code> or <code>CacheListener</code>
-   * invoked in the process. Clear will be distributed to other caches if the
-   * scope is not ScopeType::LOCAL.
-   * @see CacheListener#afterRegionClear
-   * @see CacheWriter#beforeRegionClear
-   */
-  virtual void clear(const SerializablePtr& aCallbackArgument = nullptr) {
+  virtual void clear(
+      const SerializablePtr& aCallbackArgument = nullptr) override {
     GuardUserAttribures gua(m_proxyCache);
     m_realRegion->clear(aCallbackArgument);
   }
 
-  /**
-   * Removes all entries from this region and provides a user-defined parameter
-   * object to any <code>CacheWriter</code> or <code>CacheListener</code>
-   * invoked in the process. Clear will not be distributed to other caches.
-   * @see CacheListener#afterRegionClear
-   * @see CacheWriter#beforeRegionClear
-   */
-  virtual void localClear(const SerializablePtr& aCallbackArgument = nullptr) {
+  virtual void localClear(
+      const SerializablePtr& aCallbackArgument = nullptr) override {
     throw UnsupportedOperationException("localClear()");
   }
 
-  /** Destroys the whole region and provides a user-defined parameter
-   * object to any <code>CacheWriter</code> invoked in the process.
-   * Destroy cascades to all entries
-   * and subregions. After the destroy, this region object cannot be used
-   * any more. Any attempt to use this region object will get a
-   * <code>RegionDestroyedException</code> exception. The region destroy is not
-   * distributed to other caches.
-   *
-   * @param aCallbackArgument a user-defined parameter to pass to callback
-   * events triggered by this call. Can be nullptr. If it is sent on the wire,
-   * it has to be Serializable.
-   * @throws CacheWriterException if CacheWriter aborts the operation; if this
-   *         occurs some subregions may have already been successfully
-   * destroyed.
-   * @throws CacheListenerException if CacheListener throws an exception; if
-   * this occurs some subregions may have already been successfully invalidated
-   *
-   * @see  localInvalidateRegion
-   */
   virtual void localDestroyRegion(
-      const SerializablePtr& aCallbackArgument = nullptr) {
+      const SerializablePtr& aCallbackArgument = nullptr) override {
     throw UnsupportedOperationException("Region.localDestroyRegion()");
   }
 
-  /** Returns the subregion identified by the path, nullptr if no such subregion
-   */
-  virtual RegionPtr getSubregion(const char* path) {
+  virtual RegionPtr getSubregion(const char* path) override {
     LOGDEBUG("ProxyRegion getSubregion");
     auto rPtr = std::static_pointer_cast<RegionInternal>(
         m_realRegion->getSubregion(path));
@@ -238,30 +119,14 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
     return std::make_shared<ProxyRegion>(m_proxyCache, rPtr);
   }
 
-  /** Creates a subregion with the specified attributes */
   virtual RegionPtr createSubregion(
-      const char* subregionName, const RegionAttributesPtr& aRegionAttributes) {
+      const char* subregionName,
+      const RegionAttributesPtr& aRegionAttributes) override {
     throw UnsupportedOperationException("createSubregion()");
     return nullptr;
-    /*LOGDEBUG("ProxyRegion getSubregion");
-    RegionPtr rPtr = m_realRegion->createSubregion(subregionName,
-    aRegionAttributes);
-
-    if(rPtr == nullptr)
-      return rPtr;
-
-    auto prPtr = std::make_shared<ProxyRegion>(m_proxyCache.get(), rPtr);
-    return prPtr;*/
   }
 
-  /** Populates the passed in VectorOfRegion with subregions of the current
-   * region
-   * @param recursive determines whether the method recursively fills in
-   * subregions
-   * @param[out] sr subregions
-   * @throws RegionDestroyedException
-   */
-  VectorOfRegion subregions(const bool recursive) {
+  VectorOfRegion subregions(const bool recursive) override {
     VectorOfRegion realVectorRegion = m_realRegion->subregions(recursive);
     VectorOfRegion proxyRegions(realVectorRegion.size());
 
@@ -277,10 +142,7 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
     return proxyRegions;
   }
 
-  /** Return the meta-object RegionEntry for key.
-   * @throws IllegalArgumentException, RegionDestroyedException.
-   */
-  virtual RegionEntryPtr getEntry(const CacheableKeyPtr& key) {
+  virtual RegionEntryPtr getEntry(const CacheableKeyPtr& key) override {
     return m_realRegion->getEntry(key);
   }
 
@@ -290,46 +152,9 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
     return getEntry(createKey(key));
   }
 
-  /** Returns the value associated with the specified key, passing the callback
-   * argument to any cache loaders that are invoked in the
-   * operation.
-   * If the value is not present locally then it is requested from the java
-   *server.
-   * If even that is unsuccessful then a local CacheLoader will be invoked if
-   *there is one.
-   * The value returned by get is not copied, so multi-threaded applications
-   * should not modify the value directly, but should use the update methods.
-   *<p>
-   * Updates the {@link CacheStatistics::getLastAccessedTime},
-   * {@link CacheStatistics::getHitCount}, {@link
-   *CacheStatistics::getMissCount}, and {@link
-   *CacheStatistics::getLastModifiedTime} (if a new value is loaded) for this
-   *region and the entry.
-   *
-   * @param key whose associated value is to be returned. The key Object must
-   * implement the equals and hashCode methods.
-   * @param aCallbackArgument an argument passed into the CacheLoader if
-   * loader is used. If it is sent on the wire, it has to be Serializable.
-   *
-   * @throws IllegalArgumentException if key is nullptr or aCallbackArgument is
-   *         not serializable and a remote CacheLoader needs to be invoked
-   * @throws CacheLoaderException if CacheLoader throws an exception
-   * @throws CacheServerException If an exception is received from the Java
-   *cache server. Only for Native Client regions.
-   * @throws NotConnectedException if it is not connected to the cache because
-   *the client
-   *         cannot establish usable connections to any of the servers given to
-   *it
-   * @throws MessageExcepton If the message received from server could not be
-   *         handled. This will be the case when an unregistered typeId is
-   *         received in the reply or reply is not well formed.
-   *         More information can be found in the log.
-   * @throws TimeoutException if operation timed out
-   * @throws RegionDestroyedException if the method is called on a destroyed
-   *region
-   **/
-  virtual CacheablePtr get(const CacheableKeyPtr& key,
-                           const SerializablePtr& aCallbackArgument = nullptr) {
+  virtual CacheablePtr get(
+      const CacheableKeyPtr& key,
+      const SerializablePtr& aCallbackArgument = nullptr) override {
     GuardUserAttribures gua(m_proxyCache);
     return m_realRegion->get(key, aCallbackArgument);
   }
@@ -341,50 +166,9 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
     return get(createKey(key), callbackArg);
   }
 
-  /** Places a new value into an entry in this region with the specified key,
-   * providing a user-defined parameter
-   * object to any <code>CacheWriter</code> invoked in the process.
-   * The same parameter is also passed to the <code>CacheListener</code>,
-   * if one is defined for this <code>Region</code>, invoked in the process.
-   * If there is already an entry associated with the specified key in this
-   * region,
-   * the entry's previous value is overwritten.
-   * The new put value is propogated to the java server to which it is connected
-   * with.
-   * <p>Updates the {@link CacheStatistics::getLastAccessedTime} and
-   * {@link CacheStatistics::getLastModifiedTime} for this region and the entry.
-   *
-   * If remote server put fails throwing back a
-   * <code>CacheServerException</code> or security exception, then local put is
-   * tried to rollback. However, if the entry has overflowed/evicted/expired
-   * then the rollback is aborted since it may be due to a more recent
-   * notification or update by another thread.
-   *
-   * @param key a key smart pointer associated with the value to be put into
-   * this region.
-   * @param value the value to be put into the cache
-   * @param aCallbackArgument an argument that is passed to the callback
-   * function
-   *
-   * @throws IllegalArgumentException if key or value is nullptr
-   * @throws CacheWriterException if CacheWriter aborts the operation
-   * @throws CacheListenerException if CacheListener throws an exception
-   * @throws RegionDestroyedException if region no longer valid
-   * @throws CacheServerException If an exception is received from the Java
-   * cache server.
-   * @throws NotConnectedException if it is not connected to the cache because
-   * the client
-   *         cannot establish usable connections to any of the servers given to
-   * it
-   * @throws MessageExcepton If the message received from server could not be
-   *         handled. This will be the case when an unregistered typeId is
-   *         received in the reply or reply is not well formed.
-   *         More information can be found in the log.
-   * @throws TimeoutException if operation timed out
-   * @throws OutOfMemoryException if  not enoough memory for the value
-   */
-  virtual void put(const CacheableKeyPtr& key, const CacheablePtr& value,
-                   const SerializablePtr& aCallbackArgument = nullptr) {
+  virtual void put(
+      const CacheableKeyPtr& key, const CacheablePtr& value,
+      const SerializablePtr& aCallbackArgument = nullptr) override {
     GuardUserAttribures gua(m_proxyCache);
     return m_realRegion->put(key, value, aCallbackArgument);
   }
@@ -410,60 +194,16 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
     put(key, createValue(value), arg);
   }
 
-  /**
-   * Places a set of new values in this region with the specified keys
-   * given as a map of key/value pairs.
-   * If there is already an entry associated with a specified key in this
-   * region, the entry's previous value is overwritten.
-   * <p>Updates the {@link CacheStatistics::getLastAccessedTime} and
-   * {@link CacheStatistics::getLastModifiedTime} for this region and
-   * the entries.
-   *
-   * @param map: A hashmap containing key-value pairs
-   * @param timeout: The time (in seconds) to wait for the response, optional.
-   *        This should be less than or equal to 2^31/1000 i.e. 2147483.
-   *        Default is 15 (seconds).
-   * @since 8.1
-   * @param aCallbackArgument an argument that is passed to the callback
-   * functions.
-   * It is ignored if nullptr. It must be serializable if this operation is
-   * distributed.
-   * @throws IllegalArgumentException If timeout
-   *         parameter is greater than 2^31/1000, ie 2147483.
-   */
-  virtual void putAll(const HashMapOfCacheable& map,
-                      uint32_t timeout = DEFAULT_RESPONSE_TIMEOUT,
-                      const SerializablePtr& aCallbackArgument = nullptr) {
+  virtual void putAll(
+      const HashMapOfCacheable& map,
+      std::chrono::milliseconds timeout = DEFAULT_RESPONSE_TIMEOUT,
+      const SerializablePtr& aCallbackArgument = nullptr) override {
     GuardUserAttribures gua(m_proxyCache);
     return m_realRegion->putAll(map, timeout, aCallbackArgument);
   }
 
-  /**
-   * Places a new value into an entry in this region with the specified key
-   * in the local cache only, providing a user-defined parameter
-   * object to any <code>CacheWriter</code> invoked in the process.
-   * The same parameter is also passed to the <code>CacheListener</code>,
-   * if one is defined for this <code>Region</code>, invoked in the process.
-   * If there is already an entry associated with the specified key in this
-   * region,
-   * the entry's previous value is overwritten.
-   * <p>Updates the {@link CacheStatistics::getLastAccessedTime} and
-   * {@link CacheStatistics::getLastModifiedTime} for this region and the entry.
-   *
-   * @param key a key smart pointer associated with the value to be put into
-   * this region.
-   * @param value the value to be put into the cache
-   * @param aCallbackArgument an argument that is passed to the callback
-   * functions
-   *
-   * @throws IllegalArgumentException if key or value is nullptr
-   * @throws CacheWriterException if CacheWriter aborts the operation
-   * @throws CacheListenerException if CacheListener throws an exception
-   * @throws RegionDestroyedException if region no longer valid
-   * @throws OutOfMemoryException if not enoough memory for the value
-   */
   virtual void localPut(const CacheableKeyPtr& key, const CacheablePtr& value,
-                        const SerializablePtr& aCallbackArgument = nullptr) {
+                        const SerializablePtr& aCallbackArgument = nullptr) override {
     throw UnsupportedOperationException("Region.localPut()");
   }
 
@@ -488,51 +228,9 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
     localPut(key, createValue(value), arg);
   }
 
-  /** Creates a new entry in this region with the specified key and value,
-   * providing a user-defined parameter
-   * object to any <code>CacheWriter</code> invoked in the process.
-   * The same parameter is also passed to the <code>CacheListener</code>,
-   * if one is defined for this <code>Region</code>, invoked in the process.
-   * The new entry is propogated to the java server also to which it is
-   * connected with. <p>Updates the {@link CacheStatistics::getLastAccessedTime}
-   * and
-   * {@link CacheStatistics::getLastModifiedTime} for this region and the entry.
-   * <p>
-   *
-   * If remote server put fails throwing back a
-   * <code>CacheServerException</code> or security exception, then local put is
-   * tried to rollback. However, if the entry has overflowed/evicted/expired
-   * then the rollback is aborted since it may be due to a more recent
-   * notification or update by another thread.
-   *
-   * @param key the key smart pointer for which to create the entry in this
-   * region.
-   * @param value the value for the new entry, which may be nullptr meaning
-   *              the new entry starts as if it had been locally invalidated.
-   * @param aCallbackArgument a user-defined parameter to pass to callback
-   * events triggered by this method. Can be nullptr. Should be serializable if
-   *        passed to remote callback events
-   * @throws IllegalArgumentException if key is nullptr or if the key, value, or
-   *         aCallbackArgument do not meet serializability requirements
-   * @throws CacheWriterException if CacheWriter aborts the operation
-   * @throws CacheListenerException if CacheListener throws an exception
-   * @throws RegionDestroyedException if region is no longer valid
-   * @throws CacheServerException If an exception is received from the Java
-   * cache server. Only for Native Client regions.
-   * @throws NotConnectedException if it is not connected to the cache because
-   * the client
-   *         cannot establish usable connections to any of the servers given to
-   * it
-   * @throws MessageExcepton If the message received from server could not be
-   *         handled. This will be the case when an unregistered typeId is
-   *         received in the reply or reply is not well formed.
-   *         More information can be found in the log.
-   * @throws TimeoutException if the operation timed out
-   * @throws OutOfMemoryException if no memory for new entry
-   * @throws EntryExistsException if an entry with this key already exists
-   */
-  virtual void create(const CacheableKeyPtr& key, const CacheablePtr& value,
-                      const SerializablePtr& aCallbackArgument = nullptr) {
+  virtual void create(
+      const CacheableKeyPtr& key, const CacheablePtr& value,
+      const SerializablePtr& aCallbackArgument = nullptr) override {
     GuardUserAttribures gua(m_proxyCache);
     m_realRegion->create(key, value, aCallbackArgument);
   }
@@ -558,34 +256,9 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
     create(key, createValue(value), arg);
   }
 
-  /** Creates a new entry in this region with the specified key and value
-   * in the local cache only, providing a user-defined parameter
-   * object to any <code>CacheWriter</code> invoked in the process.
-   * The same parameter is also passed to the <code>CacheListener</code>,
-   * if one is defined for this <code>Region</code>, invoked in the process.
-   * <p>Updates the {@link CacheStatistics::getLastAccessedTime} and
-   * {@link CacheStatistics::getLastModifiedTime} for this region and the entry.
-   * <p>
-   *
-   * @param key the key smart pointer for which to create the entry in this
-   * region.
-   * @param value the value for the new entry, which may be nullptr meaning
-   *              the new entry starts as if it had been locally invalidated.
-   * @param aCallbackArgument a user-defined parameter to pass to callback
-   * events
-   *        triggered by this method. Can be nullptr. Should be serializable if
-   *        passed to remote callback events
-   *
-   * @throws IllegalArgumentException if key or value is nullptr
-   * @throws CacheWriterException if CacheWriter aborts the operation
-   * @throws CacheListenerException if CacheListener throws an exception
-   * @throws RegionDestroyedException if region is no longer valid
-   * @throws OutOfMemoryException if no memory for new entry
-   * @throws EntryExistsException if an entry with this key already exists
-   */
   virtual void localCreate(const CacheableKeyPtr& key,
                            const CacheablePtr& value,
-                           const SerializablePtr& aCallbackArgument = nullptr) {
+                           const SerializablePtr& aCallbackArgument = nullptr) override {
     throw UnsupportedOperationException("Region.localCreate()");
   }
 
@@ -610,30 +283,9 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
     localCreate(key, createValue(value), arg);
   }
 
-  /** Invalidates the entry with the specified key,
-   * and provides a user-defined argument to the <code>CacheListener</code>.
-   * Invalidate only removes the value from the entry, the key is kept intact.
-   * To completely remove the entry, destroy should be used.
-   * The invalidate is not propogated to the Geode cache server to which it is
-   * connected with.
-   * <p>Updates the {@link CacheStatistics::getLastAccessedTime} and
-   * {@link CacheStatistics::getLastModifiedTime} for this region and the entry.
-   * <p>
-   *
-   * @param key the key of the value to be invalidated
-   * @param aCallbackArgument a user-defined parameter to pass to callback
-   * events triggered by this method. Can be nullptr. Should be serializable if
-   *        passed to remote callback events
-   * @throws IllegalArgumentException if key is nullptr
-   * @throws CacheListenerException if CacheListener throws an exception
-   * @throws EntryNotFoundException if this entry does not exist in this region
-   * locally
-   * @throws RegionDestroyedException if the region is destroyed
-   * @see destroy
-   * @see CacheListener::afterInvalidate
-   */
-  virtual void invalidate(const CacheableKeyPtr& key,
-                          const SerializablePtr& aCallbackArgument = nullptr) {
+  virtual void invalidate(
+      const CacheableKeyPtr& key,
+      const SerializablePtr& aCallbackArgument = nullptr) override {
     GuardUserAttribures gua(m_proxyCache);
     m_realRegion->invalidate(key, aCallbackArgument);
   }
@@ -644,28 +296,8 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
     invalidate(createKey(key), arg);
   }
 
-  /** Invalidates the entry with the specified key in the local cache only,
-   * and provides a user-defined argument to the <code>CacheListener</code>.
-   * Invalidate only removes the value from the entry, the key is kept intact.
-   * To completely remove the entry, destroy should be used.
-   * <p>Updates the {@link CacheStatistics::getLastAccessedTime} and
-   * {@link CacheStatistics::getLastModifiedTime} for this region and the entry.
-   * <p>
-   *
-   * @param key the key of the value to be invalidated
-   * @param aCallbackArgument a user-defined parameter to pass to callback
-   * events triggered by this method. Can be nullptr. Should be serializable if
-   *        passed to remote callback events
-   * @throws IllegalArgumentException if key is nullptr
-   * @throws CacheListenerException if CacheListener throws an exception
-   * @throws EntryNotFoundException if this entry does not exist in this region
-   * locally
-   * @throws RegionDestroyedException if the region is destroyed
-   * @see destroy
-   * @see CacheListener::afterInvalidate
-   */
   virtual void localInvalidate(const CacheableKeyPtr& key,
-                               const SerializablePtr& aCallbackArgument = nullptr) {
+                               const SerializablePtr& aCallbackArgument = nullptr) override {
     throw UnsupportedOperationException("Region.localInvalidate()");
   }
 
@@ -676,50 +308,9 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
     localInvalidate(createKey(key), arg);
   }
 
-  /** Destroys the entry with the specified key, and provides a user-defined
-   * parameter object to any <code>CacheWriter</code> invoked in the process.
-   * The same parameter is also passed to the <code>CacheListener</code>,
-   * if one is defined for this <code>Region</code>, invoked in the process.
-   * Destroy removes
-   * not only the value, but also the key and entry from this region.
-   *
-   * The destroy is propogated to the Geode cache server to which it is
-   * connected with. If the destroy fails due to an exception on server
-   * throwing back <code>CacheServerException</code> or security exception,
-   * then the local entry is still destroyed.
-   *
-   * <p>Updates the {@link CacheStatistics::getLastAccessedTime} and
-   * {@link CacheStatistics::getLastModifiedTime} for this region and the entry.
-   * <p>
-   *
-   * @param key the key of the entry to destroy
-   * @param aCallbackArgument a user-defined parameter to pass to callback
-   * events triggered by this method. Can be nullptr. If it is sent on the wire,
-   * it has to be Serializable.
-   * @throws IllegalArgumentException if key is nullptr
-   * @throws CacheWriterException if CacheWriter aborts the operation
-   * @throws CacheListenerException if CacheListener throws an exception
-   * @throws CacheServerException If an exception is received from the Geode
-   * cache server.
-   *         Only for Native Client regions.
-   * @throws NotConnectedException if it is not connected to the cache because
-   * the client
-   *         cannot establish usable connections to any of the servers given to
-   * it
-   * @throws MessageExcepton If the message received from server could not be
-   *         handled. This will be the case when an unregistered typeId is
-   *         received in the reply or reply is not well formed.
-   *         More information can be found in the log.
-   * @throws TimeoutException if the operation timed out
-   * @throws EntryNotFoundException if the entry does not exist in this region
-   * locally.
-   * @throws RegionDestroyedException if the region is destroyed.
-   * @see invalidate
-   * @see CacheListener::afterDestroy
-   * @see CacheWriter::beforeDestroy
-   */
-  virtual void destroy(const CacheableKeyPtr& key,
-                       const SerializablePtr& aCallbackArgument = nullptr) {
+  virtual void destroy(
+      const CacheableKeyPtr& key,
+      const SerializablePtr& aCallbackArgument = nullptr) override {
     GuardUserAttribures gua(m_proxyCache);
     m_realRegion->destroy(key, aCallbackArgument);
   }
@@ -730,32 +321,9 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
     destroy(createKey(key), arg);
   }
 
-  /** Destroys the entry with the specified key in the local cache only,
-   * and provides a user-defined parameter object to any
-   * <code>CacheWriter</code> invoked in the process.
-   * The same parameter is also passed to the <code>CacheListener</code>,
-   * if one is defined for this <code>Region</code>, invoked in the process.
-   * Destroy removes
-   * not only the value but also the key and entry from this region.
-   * <p>
-   * <p>Updates the {@link CacheStatistics::getLastAccessedTime} and
-   * {@link CacheStatistics::getLastModifiedTime} for this region and the entry.
-   * <p>
-   *
-   * @param key the key of the entry to destroy.
-   * @param aCallbackArgument the callback for user to pass in, default is
-   * nullptr.
-   * @throws IllegalArgumentException if key is nullptr
-   * @throws CacheWriterException if CacheWriter aborts the operation
-   * @throws CacheListenerException if CacheListener throws an exception
-   * @throws EntryNotFoundException if the entry does not exist in this region
-   * locally
-   * @see invalidate
-   * @see CacheListener::afterDestroy
-   * @see CacheWriter::beforeDestroy
-   */
-  virtual void localDestroy(const CacheableKeyPtr& key,
-                            const SerializablePtr& aCallbackArgument = nullptr) {
+  virtual void localDestroy(
+      const CacheableKeyPtr& key,
+      const SerializablePtr& aCallbackArgument = nullptr) override {
     throw UnsupportedOperationException("Region.localDestroy()");
   }
 
@@ -766,56 +334,9 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
     localDestroy(createKey(key), arg);
   }
 
-  /** Removes the entry with the specified key, value and provides a
-   * user-defined
-   * parameter object to any <code>CacheWriter</code> invoked in the process.
-   * The same parameter is also passed to the <code>CacheListener</code> and
-   * <code>CacheWriter</code>,
-   * if one is defined for this <code>Region</code>, invoked in the process.
-   * remove removes
-   * not only the value, but also the key and entry from this region.
-   *
-   * The remove is propogated to the Geode cache server to which it is
-   * connected with. If the destroy fails due to an exception on server
-   * throwing back <code>CacheServerException</code> or security exception,
-   * then the local entry is still removed.
-   *
-   * <p>Updates the {@link CacheStatistics::getLastAccessedTime} and
-   * {@link CacheStatistics::getLastModifiedTime} for this region and the entry.
-   * <p>
-   *
-   * @param key the key of the entry to remove
-   * @param value the value of the key to remove, it can be nullptr.
-   * @param aCallbackArgument a user-defined parameter to pass to callback
-   * events triggered by this method. Can be nullptr. If it is sent on the wire,
-   * it has to be Serializable.
-   * @throws IllegalArgumentException if key is nullptr
-   * @throws CacheWriterException if CacheWriter aborts the operation
-   * @throws CacheListenerException if CacheListener throws an exception
-   * @throws CacheServerException If an exception is received from the Geode
-   * cache server.
-   *         Only for Native Client regions.
-   * @throws NotConnectedException if it is not connected to the cache because
-   * the client
-   *         cannot establish usable connections to any of the servers given to
-   * it
-   *         For pools configured with locators, if no locators are available,
-   * the cause
-   *         of NotConnectedException is set to NoAvailableLocatorsException.
-   * @throws MessageExcepton If the message received from server could not be
-   *         handled. This will be the case when an unregistered typeId is
-   *         received in the reply or reply is not well formed.
-   *         More information can be found in the log.
-   * @throws TimeoutException if the operation timed out
-   * @throws RegionDestroyedException if the region is destroyed.
-   * @return the boolean true if an entry(key, value)has been removed or
-   * false if an entry(key, value) has not been removed.
-   * @see destroy
-   * @see CacheListener::afterDestroy
-   * @see CacheWriter::beforeDestroy
-   */
-  virtual bool remove(const CacheableKeyPtr& key, const CacheablePtr& value,
-                      const SerializablePtr& aCallbackArgument = nullptr) {
+  virtual bool remove(
+      const CacheableKeyPtr& key, const CacheablePtr& value,
+      const SerializablePtr& aCallbackArgument = nullptr) override {
     GuardUserAttribures gua(m_proxyCache);
     return m_realRegion->remove(key, value, aCallbackArgument);
   }
@@ -841,55 +362,9 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
     return remove(key, createValue(value), arg);
   }
 
-  /** Removes the entry with the specified key and provides a user-defined
-   * parameter object to any <code>CacheWriter</code> invoked in the process.
-   * The same parameter is also passed to the <code>CacheListener</code> and
-   * <code>CacheWriter</code>,
-   * if one is defined for this <code>Region</code>, invoked in the process.
-   * remove removes
-   * not only the value, but also the key and entry from this region.
-   *
-   * The remove is propogated to the Geode cache server to which it is
-   * connected with. If the destroy fails due to an exception on server
-   * throwing back <code>CacheServerException</code> or security exception,
-   * then the local entry is still removed.
-   *
-   * <p>Updates the {@link CacheStatistics::getLastAccessedTime} and
-   * {@link CacheStatistics::getLastModifiedTime} for this region and the entry.
-   * <p>
-   *
-   * @param key the key of the entry to remove
-   * @param aCallbackArgument a user-defined parameter to pass to callback
-   * events triggered by this method. Can be nullptr. If it is sent on the wire,
-   * it has to be Serializable.
-   * @throws IllegalArgumentException if key is nullptr
-   * @throws CacheWriterException if CacheWriter aborts the operation
-   * @throws CacheListenerException if CacheListener throws an exception
-   * @throws CacheServerException If an exception is received from the Geode
-   * cache server.
-   *         Only for Native Client regions.
-   * @throws NotConnectedException if it is not connected to the cache because
-   * the client
-   *         cannot establish usable connections to any of the servers given to
-   * it
-   *         For pools configured with locators, if no locators are available,
-   * the cause
-   *         of NotConnectedException is set to NoAvailableLocatorsException.
-   * @throws MessageExcepton If the message received from server could not be
-   *         handled. This will be the case when an unregistered typeId is
-   *         received in the reply or reply is not well formed.
-   *         More information can be found in the log.
-   * @throws TimeoutException if the operation timed out
-   * @throws RegionDestroyedException if the region is destroyed.
-   * @return the boolean true if an entry(key, value)has been removed or
-   * false if an entry(key, value) has not been removed.
-   * @see destroy
-   * @see CacheListener::afterDestroy
-   * @see CacheWriter::beforeDestroy
-   */
-
-  virtual bool removeEx(const CacheableKeyPtr& key,
-                        const SerializablePtr& aCallbackArgument = nullptr) {
+  virtual bool removeEx(
+      const CacheableKeyPtr& key,
+      const SerializablePtr& aCallbackArgument = nullptr) override {
     GuardUserAttribures gua(m_proxyCache);
     return m_realRegion->removeEx(key, aCallbackArgument);
   }
@@ -900,36 +375,9 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
     return removeEx(createKey(key), arg);
   }
 
-  /** Removes the entry with the specified key and value in the local cache
-   * only,
-   * and provides a user-defined parameter object to any
-   * <code>CacheWriter</code> invoked in the process.
-   * The same parameter is also passed to the <code>CacheListener</code> and
-   * <code>CacheWriter</code>,
-   * if one is defined for this <code>Region</code>, invoked in the process.
-   * Remove removes
-   * not only the value but also the key and entry from this region.
-   * <p>
-   * <p>Updates the {@link CacheStatistics::getLastAccessedTime} and
-   * {@link CacheStatistics::getLastModifiedTime} for this region and the entry.
-   * <p>
-   *
-   * @param key the key of the entry to remove.
-   * @param value the value of the entry to remove.
-   * @param aCallbackArgument the callback for user to pass in, default is
-   * nullptr.
-   * @throws IllegalArgumentException if key is nullptr
-   * @throws CacheWriterException if CacheWriter aborts the operation
-   * @throws CacheListenerException if CacheListener throws an exception
-   * @return the boolean true if an entry(key, value)has been removed or
-   * false if an entry(key, value) has not been removed.
-   * @see destroy
-   * @see CacheListener::afterDestroy
-   * @see CacheWriter::beforeDestroy
-   */
   virtual bool localRemove(const CacheableKeyPtr& key,
                            const CacheablePtr& value,
-                           const SerializablePtr& aCallbackArgument = nullptr) {
+                           const SerializablePtr& aCallbackArgument = nullptr) override {
     throw UnsupportedOperationException("Region.localRemove()");
     return false;
   }
@@ -955,33 +403,8 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
     return localRemove(key, createValue(value), arg);
   }
 
-  /** Removes the entry with the specified key in the local cache only,
-   * and provides a user-defined parameter object to any
-   * <code>CacheWriter</code> invoked in the process.
-   * The same parameter is also passed to the <code>CacheListener</code> and
-   * <code>CacheWriter</code>,
-   * if one is defined for this <code>Region</code>, invoked in the process.
-   * Remove removes
-   * not only the value but also the key and entry from this region.
-   * <p>
-   * <p>Updates the {@link CacheStatistics::getLastAccessedTime} and
-   * {@link CacheStatistics::getLastModifiedTime} for this region and the entry.
-   * <p>
-   *
-   * @param key the key of the entry to remove.
-   * @param aCallbackArgument the callback for user to pass in, default is
-   * nullptr.
-   * @throws IllegalArgumentException if key is nullptr
-   * @throws CacheWriterException if CacheWriter aborts the operation
-   * @throws CacheListenerException if CacheListener throws an exception
-   * @return the boolean true if an entry(key, value)has been removed or
-   * false if an entry(key, value) has not been removed.
-   * @see destroy
-   * @see CacheListener::afterDestroy
-   * @see CacheWriter::beforeDestroy
-   */
   virtual bool localRemoveEx(const CacheableKeyPtr& key,
-                             const SerializablePtr& aCallbackArgument = nullptr) {
+                             const SerializablePtr& aCallbackArgument = nullptr) override {
     throw UnsupportedOperationException("Region.localRemoveEx()");
     return false;
   }
@@ -997,62 +420,34 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
    * Return all the keys in the local process for this region. This includes
    * keys for which the entry is invalid.
    */
-  virtual VectorOfCacheableKey keys() {
+  virtual VectorOfCacheableKey keys() override {
     throw UnsupportedOperationException("Region.keys()");
     return VectorOfCacheableKey();
   }
 
-  /**
-   * Return the set of keys defined in the server process associated to this
-   * client and region. If a server has the region defined as a mirror, then
-   * this will be the entire keyset for the region across all PEER in the
-   * distributed system.
-   * The vector v will contain only the server keys. Any prior contents in the
-   * vector will be removed.
-   * @throws CacheServerException If an exception is received from the Geode
-   * cache server.
-   *         Only for Native Client regions.
-   * @throws NotConnectedException if it is not connected to the cache because
-   * the client
-   *         cannot establish usable connections to any of the servers given to
-   * it
-   * @throws MessageExcepton If the message received from server could not be
-   *         handled. This will be the case when an unregistered typeId is
-   *         received in the reply or reply is not well formed.
-   *         More information can be found in the log.
-   * @throws TimeoutException if there is a timeout getting the keys
-   * @throws UnsupportedOperationException if the member type is not CLIENT
-   *                                       or region is not a native client one.
-   */
-  virtual VectorOfCacheableKey serverKeys() {
+  virtual VectorOfCacheableKey serverKeys() override {
     GuardUserAttribures gua(m_proxyCache);
     return m_realRegion->serverKeys();
   }
 
-  /**
-   * Return all values in the local process for this region. No value is
-   * included for entries that are invalidated.
-   */
-  virtual VectorOfCacheable values() {
+  virtual VectorOfCacheable values() override {
     throw UnsupportedOperationException("Region.values()");
   }
 
-  virtual VectorOfRegionEntry entries(bool recursive) {
+  virtual VectorOfRegionEntry entries(bool recursive) override {
     throw UnsupportedOperationException("Region.entries()");
   }
 
-  virtual RegionServicePtr getRegionService() const {
+  virtual RegionServicePtr getRegionService() const override {
     return RegionServicePtr(m_proxyCache);
   }
 
-  virtual bool isDestroyed() const { return m_realRegion->isDestroyed(); }
+  virtual bool isDestroyed() const override {
+    return m_realRegion->isDestroyed();
+  }
 
-  /**
-   * This operations checks for the value in the local cache .
-   * It is not propagated to the Geode cache server
-   * to which it is connected.
-   */
-  virtual bool containsValueForKey(const CacheableKeyPtr& keyPtr) const {
+  virtual bool containsValueForKey(
+      const CacheableKeyPtr& keyPtr) const override {
     throw UnsupportedOperationException("Region.containsValueForKey()");
     return false;
   }
@@ -1068,42 +463,22 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
     return containsValueForKey(createKey(key));
   }
 
-  /**
-   * Only the client's cache is searched for the key. It does not go to the java
-   * server
-   * to which it is connected with.
-   */
-  virtual bool containsKey(const CacheableKeyPtr& keyPtr) const {
+  virtual bool containsKey(const CacheableKeyPtr& keyPtr) const override {
     throw UnsupportedOperationException("Region.containsKey()");
     return false;
   }
 
-  /**
-   * The cache of the server, to which it is connected with, is searched
-   * for the key to see if the key is present.
-   * @throws UnsupportedOperationException if the region's scope is
-   * ScopeType::LOCAL.
-   */
-  virtual bool containsKeyOnServer(const CacheableKeyPtr& keyPtr) const {
+  virtual bool containsKeyOnServer(
+      const CacheableKeyPtr& keyPtr) const override {
     GuardUserAttribures gua(m_proxyCache);
     return m_realRegion->containsKeyOnServer(keyPtr);
   }
-  /**
-   * Returns the list of keys on which this client is interested and will be
-   * notified of changes.
-   * @throws UnsupportedOperationException if the region's scope is
-   * ScopeType::LOCAL.
-   */
-  virtual VectorOfCacheableKey getInterestList() const {
+
+  virtual VectorOfCacheableKey getInterestList() const override {
     throw UnsupportedOperationException("Region.getInterestList()");
   }
-  /**
-   * Returns the list of regular expresssions on which this client is
-   * interested and will be notified of changes.
-   * @throws UnsupportedOperationException if the region's scope is
-   * ScopeType::LOCAL.
-   */
-  virtual VectorOfCacheableString getInterestListRegex() const {
+
+  virtual VectorOfCacheableString getInterestListRegex() const override {
     throw UnsupportedOperationException("Region.getInterestListRegex()");
   }
 
@@ -1118,381 +493,76 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
     return containsKey(createKey(key));
   }
 
-  /**
-   * Registers an array of keys for getting updates from the server.
-   * Valid only for a Native Client region when client notification
-   * ( {@link AttributesFactory::setClientNotification} ) is true.
-   *
-   * @param keys the array of keys
-   * @param isDurable flag to indicate whether this is a durable registration
-   * @param getInitialValues true to populate the cache with values of the keys
-   *   that were registered on the server
-   * @param receiveValues whether to act like notify-by-subscription is set
-   *
-   * @throws IllegalArgumentException If the array of keys is empty.
-   * @throws IllegalStateException If already registered interest for all keys.
-   * @throws EntryNotFoundException If an exception occurs while obtaining
-   *   values from server after register interest is complete. The actual cause
-   *   of the exception can be obtained using <code>Exception::getCause</code>.
-   *   If an application wants to undo the registration on server, or take
-   *   some other steps for the incomplete cache population then this is
-   *   the exception that should be caught.
-   * @throws UnsupportedOperationException If the region is not a Native Client
-   * region or
-   * {@link AttributesFactory::setClientNotification} is false.
-   * @throws CacheServerException If an exception is received from the Java
-   * cache server.
-   * @throws NotConnectedException if it is not connected to the cache because
-   * the client
-   *         cannot establish usable connections to any of the servers given to
-   * it
-   * @throws RegionDestroyedException If region destroy is pending.
-   * @throws UnknownException For other exceptions.
-   * @throws TimeoutException if operation timed out
-   */
   virtual void registerKeys(const VectorOfCacheableKey& keys,
                             bool isDurable = false,
                             bool getInitialValues = false,
-                            bool receiveValues = true) {
+                            bool receiveValues = true) override {
     throw UnsupportedOperationException("Region.registerKeys()");
   }
 
-  /**
-   * Unregisters an array of keys to stop getting updates for them.
-   * Valid only for a Native Client region when client notification
-   * ( {@link AttributesFactory::setClientNotification} ) is true.
-   *
-   * @param keys the array of keys
-   *
-   * @throws IllegalArgumentException If the array of keys is empty.
-   * @throws IllegalStateException If no keys were previously registered.
-   * @throws UnsupportedOperationException If the region is not a Native Client
-   * region or
-   * {@link AttributesFactory::setClientNotification} is false.
-   * @throws CacheServerException If an exception is received from the Java
-   * cache server.
-   * @throws NotConnectedException if it is not connected to the cache because
-   * the client
-   *         cannot establish usable connections to any of the servers given to
-   * it
-   * @throws RegionDestroyedException If region destroy is pending.
-   * @throws UnknownException For other exceptions.
-   * @throws TimeoutException if operation timed out
-   */
-  virtual void unregisterKeys(const VectorOfCacheableKey& keys) {
+  virtual void unregisterKeys(const VectorOfCacheableKey& keys) override {
     throw UnsupportedOperationException("Region.unregisterKeys()");
   }
 
-  /**
-   * Registers to get updates for all keys from the server.
-   * Valid only for a Native Client region when client notification
-   * ( {@link AttributesFactory::setClientNotification} ) is true.
-   *
-   * @param isDurable flag to indicate whether this is a durable registration
-   * @param resultKeys If non-nullptr then all the keys on the server that got
-   *   registered are returned. The vector is cleared at the start to discard
-   *   any existing keys in the vector.
-   * @param getInitialValues true to populate the cache with values of all keys
-   *   from the server
-   * @param receiveValues whether to act like notify-by-subscription is set
-   *
-   * @throws EntryNotFoundException If an exception occurs while obtaining
-   *   values from server after register interest is complete. The actual cause
-   *   of the exception can be obtained using <code>Exception::getCause</code>.
-   *   If an application wants to undo the registration on server, or take
-   *   some other steps for the incomplete cache population then this is
-   *   the exception that should be caught.
-   * @throws UnsupportedOperationException If the region is not a Native Client
-   * region or
-   * {@link AttributesFactory::setClientNotification} is false.
-   * @throws CacheServerException If an exception is received from the Java
-   * cache server.
-   * @throws NotConnectedException if it is not connected to the cache because
-   * the client
-   *         cannot establish usable connections to any of the servers given to
-   * it
-   * @throws RegionDestroyedException If region destroy is pending.
-   * @throws UnknownException For other exceptions.
-   * @throws TimeoutException if operation timed out
-   */
   virtual void registerAllKeys(bool isDurable = false,
                                bool getInitialValues = false,
-                               bool receiveValues = true) {
+                               bool receiveValues = true) override {
     throw UnsupportedOperationException("Region.registerAllKeys()");
   }
 
-  /**
-   * Registers to get updates for all keys from the server.
-   * Valid only for a Native Client region when client notification
-   * ( {@link AttributesFactory::setClientNotification} ) is true.
-   *
-   * @throws IllegalStateException If not previously registered all keys.
-   * @throws UnsupportedOperationException If the region is not a Native Client
-   * region or
-   * {@link AttributesFactory::setClientNotification} is false.
-   * @throws CacheServerException If an exception is received from the Java
-   * cache server.
-   * @throws NotConnectedException if it is not connected to the cache because
-   * the client
-   *         cannot establish usable connections to any of the servers given to
-   * it
-   * @throws RegionDestroyedException If region destroy is pending.
-   * @throws UnknownException For other exceptions.
-   * @throws TimeoutException if operation timed out
-   */
-  virtual void unregisterAllKeys() {
+  virtual void unregisterAllKeys() override {
     throw UnsupportedOperationException("Region.unregisterAllKeys()");
   }
 
-  /**
-   * Registers a regular expression to match with keys to get updates from the
-   * server.
-   * Valid only for a Native Client region when client notification
-   * ( {@link AttributesFactory::setClientNotification} ) is true.
-   *
-   * @param regex The regular expression string.
-   * @param isDurable flag to indicate whether this is a durable registration
-   * @param resultKeys If non-nullptr then the keys that match the regular
-   *   expression on the server are returned. The vector is cleared at the
-   *   start to discard any existing keys in the vector.
-   * @param getInitialValues true to populate the cache with values of the keys
-   *   that were registered on the server
-   * @param receiveValues whether to act like notify-by-subscription is set
-   *
-   * @throws IllegalArgumentException If regex is empty.
-   * @throws IllegalStateException If already registered interest for all keys.
-   * @throws EntryNotFoundException If an exception occurs while obtaining
-   *   values from server after register interest is complete. The actual cause
-   *   of the exception can be obtained using <code>Exception::getCause</code>.
-   *   If an application wants to undo the registration on server, or take
-   *   some other steps for the incomplete cache population then this is
-   *   the exception that should be caught.
-   * @throws UnsupportedOperationException If the region is not a Native Client
-   * region or
-   * {@link AttributesFactory::setClientNotification} is false.
-   * @throws CacheServerException If an exception is received from the Java
-   * cache server.
-   * @throws NotConnectedException if it is not connected to the cache because
-   * the client
-   *         cannot establish usable connections to any of the servers given to
-   * it
-   * @throws MessageExcepton If the message received from server could not be
-   *         handled. This will be the case when an unregistered typeId is
-   *         received in the reply or reply is not well formed.
-   *         More information can be found in the log.
-   * @throws RegionDestroyedException If region destroy is pending.
-   * @throws UnknownException For other exceptions.
-   * @throws TimeoutException if operation timed out
-   */
   virtual void registerRegex(const char* regex, bool isDurable = false,
                              bool getInitialValues = false,
-                             bool receiveValues = true) {
+                             bool receiveValues = true) override {
     throw UnsupportedOperationException("Region.registerRegex()");
   }
 
-  /**
-   * Unregisters a regular expression to stop getting updates for keys from the
-   * server.
-   * Valid only for a Native Client region when client notification
-   * ( {@link AttributesFactory::setClientNotification} ) is true.
-   *
-   * @param regex The regular expression string.
-   *
-   * @throws IllegalArgumentException If regex is empty.
-   * @throws IllegalStateException If not previously registered this regular
-   * expression string.
-   * @throws UnsupportedOperationException If the region is not a Native Client
-   * region or
-   * {@link AttributesFactory::setClientNotification} is false.
-   * @throws CacheServerException If an exception is received from the Java
-   * cache server.
-   * @throws NotConnectedException if it is not connected to the cache because
-   * the client
-   *         cannot establish usable connections to any of the servers given to
-   * it
-   * @throws RegionDestroyedException If region destroy is pending.
-   * @throws UnknownException For other exceptions.
-   * @throws TimeoutException if operation timed out
-   */
-  virtual void unregisterRegex(const char* regex) {
+  virtual void unregisterRegex(const char* regex) override {
     throw UnsupportedOperationException("Region.unregisterRegex()");
   }
 
-  /**
-   * Gets values for an array of keys from the local cache or server.
-   * If value for a key is not present locally then it is requested from the
-   * java server. The value returned is not copied, so multi-threaded
-   * applications should not modify the value directly,
-   * but should use the update methods.
-   *<p>
-   * Updates the {@link CacheStatistics::getLastAccessedTime},
-   * {@link CacheStatistics::getHitCount} and {@link
-   *CacheStatistics::getMissCount}
-   * for this region and the entry.
-   *
-   * @param keys the array of keys
-   * @param values Output parameter that provides the map of keys to
-   *   respective values. It is ignored if nullptr, and when nullptr then at
-   *least
-   *   the <code>addToLocalCache</code> parameter should be true and caching
-   *   should be enabled for the region to get values into the region
-   *   otherwise an <code>IllegalArgumentException</code> is thrown.
-   * @param exceptions Output parameter that provides the map of keys
-   *   to any exceptions while obtaining the key. It is ignored if nullptr.
-   * @param addToLocalCache true if the obtained values have also to be added
-   *   to the local cache
-   * @since 8.1
-   * @param aCallbackArgument an argument that is passed to the callback
-   *functions.
-   * It may be nullptr. Must be serializable if this operation is distributed.
-   * @throws IllegalArgumentException If the array of keys is empty. Other
-   *   invalid case is when the <code>values</code> parameter is nullptr, and
-   *   either <code>addToLocalCache</code> is false or caching is disabled
-   *   for this region.
-   * @throws CacheServerException If an exception is received from the Java
-   *   cache server while processing the request.
-   * @throws NotConnectedException if it is not connected to the cache because
-   *   the client cannot establish usable connections to any of the given
-   *servers
-   * @throws RegionDestroyedException If region destroy is pending.
-   * @throws TimeoutException if operation timed out.
-   * @throws UnknownException For other exceptions.
-   *
-   * @see get
-   */
   virtual HashMapOfCacheable getAll(
       const VectorOfCacheableKey& keys,
-      const SerializablePtr& aCallbackArgument = nullptr) {
+      const SerializablePtr& aCallbackArgument = nullptr) override {
     GuardUserAttribures gua(m_proxyCache);
     return m_realRegion->getAll_internal(keys, aCallbackArgument, false);
   }
 
-  /**
-   * Executes the query on the server based on the predicate.
-   * Valid only for a Native Client region.
-   *
-   * @param predicate The query predicate (just the WHERE clause) or the entire
-   * query to execute.
-   * @param timeout The time (in seconds) to wait for the query response,
-   * optional.
-   *        This should be less than or equal to 2^31/1000 i.e. 2147483.
-   *
-   * @throws IllegalArgumentException If predicate is empty or timeout
-   *         parameter is greater than 2^31/1000.
-   * @throws QueryException if some query error occurred at the server.
-   * @throws CacheServerException If an exception is received from the Java
-   * cache server.
-   * @throws NotConnectedException if a server connection error occurs.
-   * @throws MessageExcepton If the message received from server could not be
-   *         handled. This will be the case when an unregistered typeId is
-   *         received in the reply or reply is not well formed.
-   *         More information can be found in the log.
-   * @throws TimeoutException if operation timed out
-   * @throws CacheClosedException if the cache has been closed
-   *
-   * @returns A smart pointer to the SelectResults which can either be a
-   * ResultSet or a StructSet.
-   */
-  virtual SelectResultsPtr query(
-      const char* predicate,
-      uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) {
+  virtual SelectResultsPtr query(const char* predicate,
+                                 std::chrono::milliseconds timeout =
+                                     DEFAULT_QUERY_RESPONSE_TIMEOUT) override {
     GuardUserAttribures gua(m_proxyCache);
     return m_realRegion->query(predicate, timeout);
   }
 
-  /**
-   * Executes the query on the server based on the predicate and returns whether
-   * any result exists.
-   * Valid only for a Native Client region.
-   * @param predicate The query predicate (just the WHERE clause) or the entire
-   * query to execute.
-   * @param timeout The time (in seconds) to wait for the response, optional.
-   *        This should be less than or equal to 2^31/1000 i.e. 2147483.
-   * @throws IllegalArgumentException If predicate is empty or timeout
-   *         parameter is greater than 2^31/1000.
-   * @throws QueryException if some query error occurred at the server.
-   * @throws NotConnectedException if a server connection error occurs.
-   * @throws MessageExcepton If the message received from server could not be
-   *         handled. This will be the case when the reply is not well formed.
-   *         More information can be found in the log.
-   * @throws TimeoutException if operation timed out
-   * @throws CacheClosedException if the cache has been closed
-   * @returns true if the result size is non-zero, false otherwise.
-   */
   virtual bool existsValue(const char* predicate,
-                           uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) {
+                           std::chrono::milliseconds timeout =
+                               DEFAULT_QUERY_RESPONSE_TIMEOUT) override {
     GuardUserAttribures gua(m_proxyCache);
     return m_realRegion->existsValue(predicate, timeout);
   }
 
-  /**
-   * Executes the query on the server based on the predicate and returns a
-   * single result value. Valid only for a Native Client region.
-   * @param predicate The query predicate (just the WHERE clause) or the entire
-   * query to execute.
-   * @param timeout The time (in seconds) to wait for the response, optional.
-   *        This should be less than or equal to 2^31/1000 i.e. 2147483.
-   * @throws IllegalArgumentException If predicate is empty or timeout
-   *         parameter is greater than 2^31/1000.
-   * @throws QueryException if some query error occurred at the server, or more
-   * than one result items are available.
-   * @throws NotConnectedException if a server connection error occurs.
-   * @throws MessageExcepton If the message received from server could not be
-   *         handled. This will be the case when an unregistered typeId is
-   *         received in the reply or reply is not well formed.
-   *         More information can be found in the log.
-   * @throws TimeoutException if operation timed out
-   * @throws CacheClosedException if the cache has been closed
-   * @returns A smart pointer to the single ResultSet or StructSet item, or
-   * nullptr of no results are available.
-   */
   virtual SerializablePtr selectValue(
       const char* predicate,
-      uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT) {
+      std::chrono::milliseconds timeout =
+          DEFAULT_QUERY_RESPONSE_TIMEOUT) override {
     GuardUserAttribures gua(m_proxyCache);
     return m_realRegion->selectValue(predicate, timeout);
   }
 
-  /**
-   * Removes all of the entries for the specified keys from this region.
-   * The effect of this call is equivalent to that of calling {@link #destroy}
-   * on this region once for each key in the specified collection. If an entry
-   * does not exist that key is skipped; EntryNotFoundException is not thrown.
-   * <p>Updates the {@link CacheStatistics::getLastAccessedTime} and
-   * {@link CacheStatistics::getLastModifiedTime} for this region and
-   * the entries.
-   * @since 8.1
-   * @param keys the keys to remove from this region.
-   * @param aCallbackArgument an argument that is passed to the callback
-   * functions.
-   *  It is ignored if nullptr. It must be serializable if this operation is
-   * distributed.
-   * @throws IllegalArgumentException If the array of keys is empty.
-   * @throws CacheServerException If an exception is received from the Java
-   *   cache server while processing the request.
-   * @throws NotConnectedException if it is not connected to the cache because
-   *   the client cannot establish usable connections to any of the given
-   * servers For pools configured with locators, if no locators are available,
-   * the cause of NotConnectedException is set to
-   * NoAvailableLocatorsException.
-   * @throws RegionDestroyedException If region destroy is pending.
-   * @throws TimeoutException if operation timed out.
-   * @throws UnknownException For other exceptions.
-   * @see destroy
-   */
-  virtual void removeAll(const VectorOfCacheableKey& keys,
-                         const SerializablePtr& aCallbackArgument = nullptr) {
+  virtual void removeAll(
+      const VectorOfCacheableKey& keys,
+      const SerializablePtr& aCallbackArgument = nullptr) override {
     GuardUserAttribures gua(m_proxyCache);
     m_realRegion->removeAll(keys, aCallbackArgument);
   }
 
-  /**
-   * Get the size of region. For native client regions, this will give the
-   * number of entries in the local cache and not on the servers.
-   */
-  virtual uint32_t size() { return m_realRegion->size(); }
+  virtual uint32_t size() override { return m_realRegion->size(); }
 
-  virtual const PoolPtr& getPool() { return m_realRegion->getPool(); }
+  virtual const PoolPtr& getPool() override { return m_realRegion->getPool(); }
 
   ProxyRegion(const ProxyCachePtr& proxyCache,
               const std::shared_ptr<RegionInternal>& realRegion)
@@ -1516,6 +586,7 @@ class CPPCACHE_EXPORT ProxyRegion : public Region {
 };
 
 typedef std::shared_ptr<ProxyRegion> ProxyRegionPtr;
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/src/RegionAttributes.cpp b/cppcache/src/RegionAttributes.cpp
index 26e91844..040e2b55 100644
--- a/cppcache/src/RegionAttributes.cpp
+++ b/cppcache/src/RegionAttributes.cpp
@@ -383,27 +383,35 @@ PropertiesPtr RegionAttributes::getPersistenceProperties() {
   return m_persistenceProperties;
 }
 
-int RegionAttributes::getRegionTimeToLive() { return m_regionTimeToLive; }
+std::chrono::seconds RegionAttributes::getRegionTimeToLive() const {
+  return m_regionTimeToLive;
+}
 
-ExpirationAction::Action RegionAttributes::getRegionTimeToLiveAction() {
+ExpirationAction::Action RegionAttributes::getRegionTimeToLiveAction() const {
   return m_regionTimeToLiveExpirationAction;
 }
 
-int RegionAttributes::getRegionIdleTimeout() { return m_regionIdleTimeout; }
+std::chrono::seconds RegionAttributes::getRegionIdleTimeout() const {
+  return m_regionIdleTimeout;
+}
 
-ExpirationAction::Action RegionAttributes::getRegionIdleTimeoutAction() {
+ExpirationAction::Action RegionAttributes::getRegionIdleTimeoutAction() const {
   return m_regionIdleTimeoutExpirationAction;
 }
 
-int RegionAttributes::getEntryTimeToLive() { return m_entryTimeToLive; }
+std::chrono::seconds RegionAttributes::getEntryTimeToLive() const {
+  return m_entryTimeToLive;
+}
 
-ExpirationAction::Action RegionAttributes::getEntryTimeToLiveAction() {
+ExpirationAction::Action RegionAttributes::getEntryTimeToLiveAction() const {
   return m_entryTimeToLiveExpirationAction;
 }
 
-int RegionAttributes::getEntryIdleTimeout() { return m_entryIdleTimeout; }
+std::chrono::seconds RegionAttributes::getEntryIdleTimeout() const {
+  return m_entryIdleTimeout;
+}
 
-ExpirationAction::Action RegionAttributes::getEntryIdleTimeoutAction() {
+ExpirationAction::Action RegionAttributes::getEntryIdleTimeoutAction() const {
   return m_entryIdleTimeoutExpirationAction;
 }
 
@@ -473,13 +481,13 @@ void readCharStar(DataInput& in, char** field) {
 }  // namespace apache
 
 void RegionAttributes::toData(DataOutput& out) const {
-  out.writeInt(static_cast<int32_t>(m_regionTimeToLive));
+  out.writeInt(static_cast<int32_t>(m_regionTimeToLive.count()));
   out.writeInt(static_cast<int32_t>(m_regionTimeToLiveExpirationAction));
-  out.writeInt(static_cast<int32_t>(m_regionIdleTimeout));
+  out.writeInt(static_cast<int32_t>(m_regionIdleTimeout.count()));
   out.writeInt(static_cast<int32_t>(m_regionIdleTimeoutExpirationAction));
-  out.writeInt(static_cast<int32_t>(m_entryTimeToLive));
+  out.writeInt(static_cast<int32_t>(m_entryTimeToLive.count()));
   out.writeInt(static_cast<int32_t>(m_entryTimeToLiveExpirationAction));
-  out.writeInt(static_cast<int32_t>(m_entryIdleTimeout));
+  out.writeInt(static_cast<int32_t>(m_entryIdleTimeout.count()));
   out.writeInt(static_cast<int32_t>(m_entryIdleTimeoutExpirationAction));
   out.writeInt(static_cast<int32_t>(m_initialCapacity));
   out.writeFloat(m_loadFactor);
@@ -509,16 +517,16 @@ void RegionAttributes::toData(DataOutput& out) const {
 }
 
 void RegionAttributes::fromData(DataInput& in) {
-  m_regionTimeToLive = in.readInt32();
+  m_regionTimeToLive = std::chrono::seconds(in.readInt32());
   m_regionTimeToLiveExpirationAction =
       static_cast<ExpirationAction::Action>(in.readInt32());
-  m_regionIdleTimeout = in.readInt32();
+  m_regionIdleTimeout = std::chrono::seconds(in.readInt32());
   m_regionIdleTimeoutExpirationAction =
       static_cast<ExpirationAction::Action>(in.readInt32());
-  m_entryTimeToLive = in.readInt32();
+  m_entryTimeToLive = std::chrono::seconds(in.readInt32());
   m_entryTimeToLiveExpirationAction =
       static_cast<ExpirationAction::Action>(in.readInt32());
-  m_entryIdleTimeout = in.readInt32();
+  m_entryIdleTimeout = std::chrono::seconds(in.readInt32());
   m_entryIdleTimeoutExpirationAction =
       static_cast<ExpirationAction::Action>(in.readInt32());
   m_initialCapacity = in.readInt32();
diff --git a/cppcache/src/RegionExpiryHandler.cpp b/cppcache/src/RegionExpiryHandler.cpp
index ba97f161..61a100e3 100644
--- a/cppcache/src/RegionExpiryHandler.cpp
+++ b/cppcache/src/RegionExpiryHandler.cpp
@@ -47,7 +47,7 @@ int RegionExpiryHandler::handle_timeout(const ACE_Time_Value& current_time,
   try {
     CacheStatisticsPtr ptr = m_regionPtr->getStatistics();
     uint32_t lastTimeForExp = ptr->getLastAccessedTime();
-    if (m_regionPtr->getAttributes()->getRegionTimeToLive() > 0) {
+    if (m_regionPtr->getAttributes()->getRegionTimeToLive().count() > 0) {
       lastTimeForExp = ptr->getLastModifiedTime();
     }
 
diff --git a/cppcache/src/RegionFactory.cpp b/cppcache/src/RegionFactory.cpp
index 90f41116..b7686959 100644
--- a/cppcache/src/RegionFactory.cpp
+++ b/cppcache/src/RegionFactory.cpp
@@ -127,24 +127,25 @@ RegionFactory& RegionFactory::setPartitionResolver(const char* lib,
 }
 
 RegionFactory& RegionFactory::setEntryIdleTimeout(
-    ExpirationAction::Action action, int idleTimeout) {
+    ExpirationAction::Action action, std::chrono::seconds idleTimeout) {
   m_attributeFactory->setEntryIdleTimeout(action, idleTimeout);
   return *this;
 }
 
 RegionFactory& RegionFactory::setEntryTimeToLive(
-    ExpirationAction::Action action, int timeToLive) {
+    ExpirationAction::Action action, std::chrono::seconds timeToLive) {
   m_attributeFactory->setEntryTimeToLive(action, timeToLive);
   return *this;
 }
 
 RegionFactory& RegionFactory::setRegionIdleTimeout(
-    ExpirationAction::Action action, int idleTimeout) {
+    ExpirationAction::Action action, std::chrono::seconds idleTimeout) {
   m_attributeFactory->setRegionIdleTimeout(action, idleTimeout);
   return *this;
 }
+
 RegionFactory& RegionFactory::setRegionTimeToLive(
-    ExpirationAction::Action action, int timeToLive) {
+    ExpirationAction::Action action, std::chrono::seconds timeToLive) {
   m_attributeFactory->setRegionTimeToLive(action, timeToLive);
   return *this;
 }
diff --git a/cppcache/src/RegionInternal.cpp b/cppcache/src/RegionInternal.cpp
index 4551c736..5f8c569d 100644
--- a/cppcache/src/RegionInternal.cpp
+++ b/cppcache/src/RegionInternal.cpp
@@ -14,6 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 #include "RegionInternal.hpp"
 #include <geode/RegionEntry.hpp>
 #include "TombstoneList.hpp"
@@ -81,18 +82,19 @@ void RegionInternal::unregisterRegex(const char* regex) {
 }
 
 SelectResultsPtr RegionInternal::query(const char* predicate,
-                                       uint32_t timeout) {
+                                       std::chrono::milliseconds timeout) {
   throw UnsupportedOperationException(
       "query only supported by Thin Client Region.");
 }
 
-bool RegionInternal::existsValue(const char* predicate, uint32_t timeout) {
+bool RegionInternal::existsValue(const char* predicate,
+                                 std::chrono::milliseconds timeout) {
   throw UnsupportedOperationException(
       "existsValue only supported by Thin Client Region.");
 }
 
 SerializablePtr RegionInternal::selectValue(const char* predicate,
-                                            uint32_t timeout) {
+                                            std::chrono::milliseconds timeout) {
   throw UnsupportedOperationException(
       "selectValue only supported by Thin Client Region.");
 }
@@ -141,25 +143,26 @@ void RegionInternal::setEntryIdleTimeoutExpirationAction(
   }
 }
 
-void RegionInternal::setRegionTimeToLive(int32_t duration) {
+void RegionInternal::setRegionTimeToLive(const std::chrono::seconds& duration) {
   if (m_regionAttributes != nullptr) {
     m_regionAttributes->m_regionTimeToLive = duration;
   }
 }
 
-void RegionInternal::setRegionIdleTimeout(int32_t duration) {
+void RegionInternal::setRegionIdleTimeout(
+    const std::chrono::seconds& duration) {
   if (m_regionAttributes != nullptr) {
     m_regionAttributes->m_regionIdleTimeout = duration;
   }
 }
 
-void RegionInternal::setEntryTimeToLive(int32_t duration) {
+void RegionInternal::setEntryTimeToLive(const std::chrono::seconds& duration) {
   if (m_regionAttributes != nullptr) {
     m_regionAttributes->m_entryTimeToLive = duration;
   }
 }
 
-void RegionInternal::setEntryIdleTimeout(int32_t duration) {
+void RegionInternal::setEntryIdleTimeout(const std::chrono::seconds& duration) {
   if (m_regionAttributes != nullptr) {
     m_regionAttributes->m_entryIdleTimeout = duration;
   }
diff --git a/cppcache/src/RegionInternal.hpp b/cppcache/src/RegionInternal.hpp
index d77cadc6..3fe63137 100644
--- a/cppcache/src/RegionInternal.hpp
+++ b/cppcache/src/RegionInternal.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_REGIONINTERNAL_H_
-#define GEODE_REGIONINTERNAL_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,10 +15,18 @@
  * limitations under the License.
  */
 
-#include <geode/Region.hpp>
-#include "RegionStats.hpp"
+#pragma once
+
+#ifndef GEODE_REGIONINTERNAL_H_
+#define GEODE_REGIONINTERNAL_H_
+
 #include <string>
 #include <map>
+#include <chrono>
+
+#include <geode/Region.hpp>
+
+#include "RegionStats.hpp"
 #include "EventId.hpp"
 
 namespace apache {
@@ -146,24 +149,30 @@ class RegionInternal : public Region {
   virtual void registerKeys(const VectorOfCacheableKey& keys,
                             bool isDurable = false,
                             bool getInitialValues = false,
-                            bool receiveValues = true);
-  virtual void unregisterKeys(const VectorOfCacheableKey& keys);
+                            bool receiveValues = true) override;
+  virtual void unregisterKeys(const VectorOfCacheableKey& keys) override;
   virtual void registerAllKeys(bool isDurable = false,
                                bool getInitialValues = false,
-                               bool receiveValues = true);
-  virtual void unregisterAllKeys();
+                               bool receiveValues = true) override;
+  virtual void unregisterAllKeys() override;
 
   virtual void registerRegex(const char* regex, bool isDurable = false,
                              bool getInitialValues = false,
-                             bool receiveValues = true);
-  virtual void unregisterRegex(const char* regex);
+                             bool receiveValues = true) override;
+  virtual void unregisterRegex(const char* regex) override;
+
+  virtual SelectResultsPtr query(const char* predicate,
+                                 std::chrono::milliseconds timeout =
+                                     DEFAULT_QUERY_RESPONSE_TIMEOUT) override;
 
-  virtual SelectResultsPtr query(
-      const char* predicate, uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
   virtual bool existsValue(const char* predicate,
-                           uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
+                           std::chrono::milliseconds timeout =
+                               DEFAULT_QUERY_RESPONSE_TIMEOUT) override;
+
   virtual SerializablePtr selectValue(
-      const char* predicate, uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
+      const char* predicate,
+      std::chrono::milliseconds timeout =
+          DEFAULT_QUERY_RESPONSE_TIMEOUT) override;
 
   /** @brief Public Methods
    */
@@ -215,9 +224,9 @@ class RegionInternal : public Region {
   virtual GfErrType invalidateRegionNoThrow(
       const SerializablePtr& aCallbackArgument,
       const CacheEventFlags eventFlags) = 0;
-  virtual GfErrType destroyRegionNoThrow(const SerializablePtr& aCallbackArgument,
-                                         bool removeFromParent,
-                                         const CacheEventFlags eventFlags) = 0;
+  virtual GfErrType destroyRegionNoThrow(
+      const SerializablePtr& aCallbackArgument, bool removeFromParent,
+      const CacheEventFlags eventFlags) = 0;
 
   virtual void setRegionExpiryTask() = 0;
   virtual void acquireReadLock() = 0;
@@ -228,8 +237,10 @@ class RegionInternal : public Region {
       ExpirationAction::Action action) = 0;
   virtual ExpirationAction::Action adjustEntryExpiryAction(
       ExpirationAction::Action action) = 0;
-  virtual int32_t adjustRegionExpiryDuration(int32_t duration) = 0;
-  virtual int32_t adjustEntryExpiryDuration(int32_t duration) = 0;
+  virtual std::chrono::seconds adjustRegionExpiryDuration(
+      const std::chrono::seconds& duration) = 0;
+  virtual std::chrono::seconds adjustEntryExpiryDuration(
+      const std::chrono::seconds& duration) = 0;
   virtual void adjustCacheListener(const CacheListenerPtr& aListener) = 0;
   virtual void adjustCacheListener(const char* libpath,
                                    const char* factoryFuncName) = 0;
@@ -242,7 +253,7 @@ class RegionInternal : public Region {
 
   virtual RegionStats* getRegionStats() = 0;
   virtual bool cacheEnabled() = 0;
-  virtual bool isDestroyed() const = 0;
+  virtual bool isDestroyed() const override = 0;
   virtual void evict(int32_t percentage) = 0;
   virtual CacheImpl* getCacheImpl() const = 0;
   virtual TombstoneListPtr getTombstoneList();
@@ -265,7 +276,7 @@ class RegionInternal : public Region {
   inline bool isConcurrencyCheckEnabled() const {
     return m_regionAttributes->getConcurrencyChecksEnabled();
   }
-  virtual const PoolPtr& getPool() = 0;
+  virtual const PoolPtr& getPool() override = 0;
 
  protected:
   /**
@@ -278,10 +289,10 @@ class RegionInternal : public Region {
   void setRegionIdleTimeoutExpirationAction(ExpirationAction::Action action);
   void setEntryTimeToLiveExpirationAction(ExpirationAction::Action action);
   void setEntryIdleTimeoutExpirationAction(ExpirationAction::Action action);
-  void setRegionTimeToLive(int32_t duration);
-  void setRegionIdleTimeout(int32_t duration);
-  void setEntryTimeToLive(int32_t duration);
-  void setEntryIdleTimeout(int32_t duration);
+  void setRegionTimeToLive(const std::chrono::seconds& duration);
+  void setRegionIdleTimeout(const std::chrono::seconds& duration);
+  void setEntryTimeToLive(const std::chrono::seconds& duration);
+  void setEntryIdleTimeout(const std::chrono::seconds& duration);
   void setCacheListener(const CacheListenerPtr& aListener);
   void setCacheListener(const char* libpath, const char* factoryFuncName);
   void setPartitionResolver(const PartitionResolverPtr& aListener);
diff --git a/cppcache/src/RemoteQuery.cpp b/cppcache/src/RemoteQuery.cpp
index b8450f57..d7ed0b0c 100644
--- a/cppcache/src/RemoteQuery.cpp
+++ b/cppcache/src/RemoteQuery.cpp
@@ -14,16 +14,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
+#include <geode/GeodeTypeIds.hpp>
+
 #include "RemoteQuery.hpp"
 #include "TcrMessage.hpp"
 #include "ResultSetImpl.hpp"
 #include "StructSetImpl.hpp"
-#include <geode/GeodeTypeIds.hpp>
 #include "ReadWriteLock.hpp"
 #include "ThinClientRegion.hpp"
 #include "UserAttributes.hpp"
 #include "EventId.hpp"
 #include "ThinClientPoolDM.hpp"
+#include "util/bounds.hpp"
 
 using namespace apache::geode::client;
 
@@ -37,7 +40,8 @@ RemoteQuery::RemoteQuery(const char* querystr,
   LOGFINEST("RemoteQuery: created a new query: %s", querystr);
 }
 
-SelectResultsPtr RemoteQuery::execute(uint32_t timeout) {
+SelectResultsPtr RemoteQuery::execute(std::chrono::milliseconds timeout) {
+  util::PROTOCOL_OPERATION_TIMEOUT_BOUNDS(timeout);
   GuardUserAttribures gua;
   if (m_proxyCache != nullptr) {
     gua.setProxyCache(m_proxyCache);
@@ -46,7 +50,8 @@ SelectResultsPtr RemoteQuery::execute(uint32_t timeout) {
 }
 
 SelectResultsPtr RemoteQuery::execute(CacheableVectorPtr paramList,
-                                      uint32_t timeout) {
+                                      std::chrono::milliseconds timeout) {
+  util::PROTOCOL_OPERATION_TIMEOUT_BOUNDS(timeout);
   GuardUserAttribures gua;
   if (m_proxyCache != nullptr) {
     gua.setProxyCache(m_proxyCache);
@@ -54,17 +59,9 @@ SelectResultsPtr RemoteQuery::execute(CacheableVectorPtr paramList,
   return execute(timeout, "Query::execute", m_tccdm, paramList);
 }
 
-SelectResultsPtr RemoteQuery::execute(uint32_t timeout, const char* func,
-                                      ThinClientBaseDM* tcdm,
+SelectResultsPtr RemoteQuery::execute(std::chrono::milliseconds timeout,
+                                      const char* func, ThinClientBaseDM* tcdm,
                                       CacheableVectorPtr paramList) {
-  if ((timeout * 1000) >= 0x7fffffff) {
-    char exMsg[1024];
-    ACE_OS::snprintf(exMsg, 1023,
-                     "%s: timeout parameter "
-                     "greater than maximum allowed (2^31/1000 i.e 2147483)",
-                     func);
-    throw IllegalArgumentException(exMsg);
-  }
   ThinClientPoolDM* pool = dynamic_cast<ThinClientPoolDM*>(tcdm);
   if (pool != nullptr) {
     pool->getStats().incQueryExecutionId();
@@ -120,8 +117,9 @@ SelectResultsPtr RemoteQuery::execute(uint32_t timeout, const char* func,
   return sr;
 }
 
-GfErrType RemoteQuery::executeNoThrow(uint32_t timeout, TcrMessageReply& reply,
-                                      const char* func, ThinClientBaseDM* tcdm,
+GfErrType RemoteQuery::executeNoThrow(std::chrono::milliseconds timeout,
+                                      TcrMessageReply& reply, const char* func,
+                                      ThinClientBaseDM* tcdm,
                                       CacheableVectorPtr paramList) {
   LOGFINEST("%s: executing query: %s", func, m_queryString.c_str());
 
@@ -134,13 +132,12 @@ GfErrType RemoteQuery::executeNoThrow(uint32_t timeout, TcrMessageReply& reply,
            m_queryString.c_str());
   if (paramList != nullptr) {
     // QUERY_WITH_PARAMETERS
-    TcrMessageQueryWithParameters msg(
-        m_tccdm->getConnectionManager()
-            .getCacheImpl()
-            ->getCache()
-            ->createDataOutput(),
-        m_queryString, nullptr, paramList,
-        static_cast<int>(timeout * 1000) /* in milli second */, tcdm);
+    TcrMessageQueryWithParameters msg(m_tccdm->getConnectionManager()
+                                          .getCacheImpl()
+                                          ->getCache()
+                                          ->createDataOutput(),
+                                      m_queryString, nullptr, paramList,
+                                      timeout, tcdm);
     msg.setTimeout(timeout);
     reply.setTimeout(timeout);
 
@@ -165,9 +162,7 @@ GfErrType RemoteQuery::executeNoThrow(uint32_t timeout, TcrMessageReply& reply,
                             .getCacheImpl()
                             ->getCache()
                             ->createDataOutput(),
-                        m_queryString,
-                        static_cast<int>(timeout * 1000) /* in milli second */,
-                        tcdm);
+                        m_queryString, timeout, tcdm);
     msg.setTimeout(timeout);
     reply.setTimeout(timeout);
 
diff --git a/cppcache/src/RemoteQuery.hpp b/cppcache/src/RemoteQuery.hpp
index 3140163c..e61e5fb9 100644
--- a/cppcache/src/RemoteQuery.hpp
+++ b/cppcache/src/RemoteQuery.hpp
@@ -55,29 +55,32 @@ class CPPCACHE_EXPORT RemoteQuery : public Query {
 
   //@TODO check the return type, is it ok. second option could be to pass
   // SelectResults by reference as a parameter.
-  SelectResultsPtr execute(uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
+  SelectResultsPtr execute(std::chrono::milliseconds timeout =
+                               DEFAULT_QUERY_RESPONSE_TIMEOUT) override;
 
   //@TODO check the return type, is it ok. second option could be to pass
   // SelectResults by reference as a parameter.
   SelectResultsPtr execute(CacheableVectorPtr paramList = nullptr,
-                           uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
+                           std::chrono::milliseconds timeout =
+                               DEFAULT_QUERY_RESPONSE_TIMEOUT) override;
 
   // executes a query using a given distribution manager
   // used by Region.query() and Region.getAll()
-  SelectResultsPtr execute(uint32_t timeout, const char* func,
+  SelectResultsPtr execute(std::chrono::milliseconds timeout, const char* func,
                            ThinClientBaseDM* tcdm,
                            CacheableVectorPtr paramList);
 
   // nothrow version of execute()
-  GfErrType executeNoThrow(uint32_t timeout, TcrMessageReply& reply,
-                           const char* func, ThinClientBaseDM* tcdm,
+  GfErrType executeNoThrow(std::chrono::milliseconds timeout,
+                           TcrMessageReply& reply, const char* func,
+                           ThinClientBaseDM* tcdm,
                            CacheableVectorPtr paramList);
 
-  const char* getQueryString() const;
+  const char* getQueryString() const override;
 
-  void compile();
+  void compile() override;
 
-  bool isCompiled();
+  bool isCompiled() override;
 };
 
 typedef std::shared_ptr<RemoteQuery> RemoteQueryPtr;
diff --git a/cppcache/src/ResultCollector.cpp b/cppcache/src/ResultCollector.cpp
deleted file mode 100644
index 84814d2c..00000000
--- a/cppcache/src/ResultCollector.cpp
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <geode/ResultCollector.hpp>
-#include <geode/ExceptionTypes.hpp>
-#include <TimeoutTimer.hpp>
-
-using namespace apache::geode::client;
-ResultCollector::ResultCollector()
-    : m_resultList(CacheableVector::create()), m_isResultReady(false) {}
-ResultCollector::~ResultCollector() {}
-CacheableVectorPtr ResultCollector::getResult(uint32_t timeout) {
-  if (m_isResultReady == true) {
-    return m_resultList;
-  } else {
-    TimeoutTimer ttimer;
-    for (uint32_t i = 0; i < timeout; i++) {
-      ttimer.untilTimeout(1);
-      if (m_isResultReady == true) return m_resultList;
-    }
-    throw FunctionExecutionException(
-        "Result is not ready, endResults callback is called before invoking "
-        "getResult() method");
-  }
-}
-void ResultCollector::addResult(const CacheablePtr& result) {
-  m_resultList->push_back(result);
-}
-void ResultCollector::endResults() { m_isResultReady = true; }
-
-void ResultCollector::clearResults() { m_resultList->clear(); }
diff --git a/cppcache/src/SerializationRegistry.cpp b/cppcache/src/SerializationRegistry.cpp
index d1ddc856..80f8c84e 100644
--- a/cppcache/src/SerializationRegistry.cpp
+++ b/cppcache/src/SerializationRegistry.cpp
@@ -259,8 +259,8 @@ PdxSerializablePtr SerializationRegistry::getPdxType(char* className) {
   return pdxObj;
 }
 
-void SerializationRegistry::setPdxSerializer(PdxSerializerPtr pdxSerializer) {
-  this->pdxSerializer = pdxSerializer;
+void SerializationRegistry::setPdxSerializer(PdxSerializerPtr serializer) {
+  this->pdxSerializer = serializer;
 }
 
 PdxSerializerPtr SerializationRegistry::getPdxSerializer() {
diff --git a/cppcache/src/SerializationRegistry.hpp b/cppcache/src/SerializationRegistry.hpp
index 691e7f73..3324a2d9 100644
--- a/cppcache/src/SerializationRegistry.hpp
+++ b/cppcache/src/SerializationRegistry.hpp
@@ -216,8 +216,8 @@ class CPPCACHE_EXPORT SerializationRegistry {
 
   typedef std::function<std::shared_ptr<Serializable>(DataInput&)>
       PdxTypeHandler;
-  void setPdxTypeHandler(const PdxTypeHandler& pdxTypeHandler) {
-    this->pdxTypeHandler = pdxTypeHandler;
+  void setPdxTypeHandler(const PdxTypeHandler& handler) {
+    this->pdxTypeHandler = handler;
   }
 
  private:
diff --git a/cppcache/src/SuspendedTxExpiryHandler.cpp b/cppcache/src/SuspendedTxExpiryHandler.cpp
index 3a42f6d0..5fb4b24a 100644
--- a/cppcache/src/SuspendedTxExpiryHandler.cpp
+++ b/cppcache/src/SuspendedTxExpiryHandler.cpp
@@ -29,7 +29,7 @@ using namespace apache::geode::client;
 
 SuspendedTxExpiryHandler::SuspendedTxExpiryHandler(
     CacheTransactionManagerImpl* cacheTxMgr, TransactionIdPtr tid,
-    uint32_t duration)
+    std::chrono::seconds duration)
     :  // UNUSED m_duration(duration),
       m_cacheTxMgr(cacheTxMgr),
       m_txid(tid) {}
diff --git a/cppcache/src/SuspendedTxExpiryHandler.hpp b/cppcache/src/SuspendedTxExpiryHandler.hpp
index d69330d5..c9e51c9d 100644
--- a/cppcache/src/SuspendedTxExpiryHandler.hpp
+++ b/cppcache/src/SuspendedTxExpiryHandler.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_SUSPENDEDTXEXPIRYHANDLER_H_
-#define GEODE_SUSPENDEDTXEXPIRYHANDLER_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,8 +15,14 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_SUSPENDEDTXEXPIRYHANDLER_H_
+#define GEODE_SUSPENDEDTXEXPIRYHANDLER_H_
+
 #include <geode/geode_globals.hpp>
 #include <geode/Cache.hpp>
+
 #include "CacheTransactionManagerImpl.hpp"
 
 /**
@@ -31,7 +32,9 @@
 namespace apache {
 namespace geode {
 namespace client {
+
 class CacheTransactionManagerImpl;
+
 /**
  * @class SuspendedTxExpiryHandler
  *
@@ -45,12 +48,14 @@ class CPPCACHE_EXPORT SuspendedTxExpiryHandler : public ACE_Event_Handler {
    * Constructor
    */
   SuspendedTxExpiryHandler(CacheTransactionManagerImpl* cacheTxMgr,
-                           TransactionIdPtr txid, uint32_t duration);
+                           TransactionIdPtr txid,
+                           std::chrono::seconds duration);
 
   /** This task object will be registered with the Timer Queue.
    *  When the timer expires the handle_timeout is invoked.
    */
   int handle_timeout(const ACE_Time_Value& current_time, const void* arg);
+
   /**
    * This is called when the task object needs to be cleaned up..
    */
diff --git a/cppcache/src/SystemProperties.cpp b/cppcache/src/SystemProperties.cpp
index 7b16e0c0..e593a7e3 100644
--- a/cppcache/src/SystemProperties.cpp
+++ b/cppcache/src/SystemProperties.cpp
@@ -15,48 +15,27 @@
  * limitations under the License.
  */
 
-#include <geode/geode_globals.hpp>
-
 #include <string>
 #include <cstdlib>
 #include <string>
 
-#include <geode/SystemProperties.hpp>
-#include <CppCacheLibrary.hpp>
-#include "util/Log.hpp"
-#include <geode/ExceptionTypes.hpp>
 #include <ace/OS.h>
 #include <ace/DLL.h>
 
+#include <geode/geode_globals.hpp>
+#include <geode/util/chrono/duration.hpp>
+#include <geode/SystemProperties.hpp>
+#include <geode/ExceptionTypes.hpp>
+
+#include "CppCacheLibrary.hpp"
+#include "util/Log.hpp"
+
 #if defined(_WIN32)
 #include <windows.h>
 #else
 #include <dlfcn.h>
 #endif
 
-using namespace apache::geode::client;
-namespace apache {
-namespace geode {
-namespace client {
-namespace impl {
-
-void* getFactoryFunc(const char* lib, const char* funcName);
-
-}  // namespace impl
-}  // namespace client
-}  // namespace geode
-}  // namespace apache
-
-using namespace apache::geode::client::impl;
-
-/******************************************************************************/
-
-/**
- * The implementation of the SystemProperties class
- *
- *
- *
- */
 
 namespace {
 
@@ -111,23 +90,23 @@ const char OnClientDisconnectClearPdxTypeIds[] =
     "on-client-disconnect-clear-pdxType-Ids";
 const char TombstoneTimeoutInMSec[] = "tombstone-timeout";
 const char DefaultConflateEvents[] = "server";
-const char ReadTimeoutUnitInMillis[] = "read-timeout-unit-in-millis";
 
 const char DefaultDurableClientId[] = "";
-const uint32_t DefaultDurableTimeout = 300;
+constexpr auto DefaultDurableTimeout = std::chrono::seconds(300);
 
-const uint32_t DefaultConnectTimeout = 59;
-const uint32_t DefaultConnectWaitTimeout = 0;
-const uint32_t DefaultBucketWaitTimeout = 0;
+constexpr auto DefaultConnectTimeout = std::chrono::seconds(59);
+constexpr auto DefaultConnectWaitTimeout = std::chrono::seconds(0);
+constexpr auto DefaultBucketWaitTimeout = std::chrono::seconds(0);
 
-const int DefaultSamplingInterval = 1;
+constexpr auto DefaultSamplingInterval = std::chrono::seconds(1);
 const bool DefaultSamplingEnabled = true;
 const bool DefaultAppDomainEnabled = false;
 
 const char DefaultStatArchive[] = "statArchive.gfs";
 const char DefaultLogFilename[] = "";  // stdout...
 
-const Log::LogLevel DefaultLogLevel = Log::Config;
+const apache::geode::client::Log::LogLevel DefaultLogLevel =
+    apache::geode::client::Log::Config;
 
 const int DefaultJavaConnectionPoolSize = 5;
 const bool DefaultDebugStackTraceEnabled = false;  // or true
@@ -155,22 +134,31 @@ const uint32_t DefaultHeapLRULimit = 0;  // = unlimited, disabled when it is 0
 const int32_t DefaultHeapLRUDelta = 10;  // = unlimited, disabled when it is 0
 
 const int32_t DefaultMaxSocketBufferSize = 65 * 1024;
-const int32_t DefaultPingInterval = 10;
-const int32_t DefaultRedundancyMonitorInterval = 10;
-const int32_t DefaultNotifyAckInterval = 1;
-const int32_t DefaultNotifyDupCheckLife = 300;
+constexpr auto DefaultPingInterval = std::chrono::seconds(10);
+constexpr auto DefaultRedundancyMonitorInterval = std::chrono::seconds(10);
+constexpr auto DefaultNotifyAckInterval = std::chrono::seconds(1);
+constexpr auto DefaultNotifyDupCheckLife = std::chrono::seconds(300);
 const char DefaultSecurityPrefix[] = "security-";
 const char DefaultSecurityClientDhAlgo[] ATTR_UNUSED = "";
 const char DefaultSecurityClientKsPath[] ATTR_UNUSED = "";
 const uint32_t DefaultThreadPoolSize = ACE_OS::num_processors() * 2;
-const uint32_t DefaultSuspendedTxTimeout = 30;
-const uint32_t DefaultTombstoneTimeout = 480000;
+constexpr auto DefaultSuspendedTxTimeout = std::chrono::seconds(30);
+constexpr auto DefaultTombstoneTimeout = std::chrono::seconds(480);
 // not disable; all region api will use chunk handler thread
 const bool DefaultDisableChunkHandlerThread = false;
-const bool DefaultReadTimeoutUnitInMillis = false;
 const bool DefaultOnClientDisconnectClearPdxTypeIds = false;
+
 }  // namespace
 
+namespace apache {
+namespace geode {
+namespace client {
+
+namespace impl {
+
+void* getFactoryFunc(const char* lib, const char* funcName);
+
+}  // namespace impl
 
 SystemProperties::SystemProperties(const PropertiesPtr& propertiesPtr,
                                    const char* configFile)
@@ -216,9 +204,8 @@ SystemProperties::SystemProperties(const PropertiesPtr& propertiesPtr,
       m_conflateEvents(nullptr),
       m_threadPoolSize(DefaultThreadPoolSize),
       m_suspendedTxTimeout(DefaultSuspendedTxTimeout),
-      m_tombstoneTimeoutInMSec(DefaultTombstoneTimeout),
+      m_tombstoneTimeout(DefaultTombstoneTimeout),
       m_disableChunkHandlerThread(DefaultDisableChunkHandlerThread),
-      m_readTimeoutUnitInMillis(DefaultReadTimeoutUnitInMillis),
       m_onClientDisconnectClearPdxTypeIds(
           DefaultOnClientDisconnectClearPdxTypeIds) {
   processProperty(ConflateEvents, DefaultConflateEvents);
@@ -304,6 +291,19 @@ void SystemProperties::throwError(const char* msg) {
   throw GeodeConfigException(msg);
 }
 
+template <class _Rep, class _Period>
+void SystemProperties::parseDurationProperty(
+    const std::string& property, const std::string& value,
+    std::chrono::duration<_Rep, _Period>& duration) {
+  try {
+    duration = util::chrono::duration::from_string<
+        std::chrono::duration<_Rep, _Period>>(value);
+  } catch (std::invalid_argument& e) {
+    throwError(
+        ("SystemProperties: non-duration " + property + "=" + value).c_str());
+  }
+}
+
 void SystemProperties::processProperty(const char* property,
                                        const char* value) {
   std::string prop = property;
@@ -327,98 +327,44 @@ void SystemProperties::processProperty(const char* property,
     }
 
   } else if (prop == PingInterval) {
-    char* end;
-    long si = strtol(value, &end, 10);
-    if (!*end) {
-      m_pingInterval = si;
-    } else {
+    try {
+      m_pingInterval =
+          util::chrono::duration::from_string<decltype(m_pingInterval)>(
+              std::string(value));
+    } catch (std::invalid_argument& e) {
       throwError(
-          ("SystemProperties: non-integer " + prop + "=" + value).c_str());
+          ("SystemProperties: non-duration " + prop + "=" + value).c_str());
     }
-
   } else if (prop == RedundancyMonitorInterval) {
-    char* end;
-    long si = strtol(value, &end, 10);
-    if (!*end) {
-      m_redundancyMonitorInterval = si;
-    } else {
+    try {
+      m_redundancyMonitorInterval =
+          util::chrono::duration::from_string<decltype(
+              m_redundancyMonitorInterval)>(std::string(value));
+    } catch (std::invalid_argument& e) {
       throwError(
-          ("SystemProperties: non-integer " + prop + "=" + value).c_str());
+          ("SystemProperties: non-duration " + prop + "=" + value).c_str());
     }
-
   } else if (prop == NotifyAckInterval) {
-    char* end;
-    long si = strtol(value, &end, 10);
-    if (!*end) {
-      m_notifyAckInterval = si;
-    } else {
+    try {
+      m_notifyAckInterval =
+          util::chrono::duration::from_string<decltype(m_notifyAckInterval)>(
+              std::string(value));
+    } catch (std::invalid_argument& e) {
       throwError(
-          ("SystemProperties: non-integer " + prop + "=" + value).c_str());
+          ("SystemProperties: non-duration " + prop + "=" + value).c_str());
     }
   } else if (prop == NotifyDupCheckLife) {
-    char* end;
-    long si = strtol(value, &end, 10);
-    if (!*end) {
-      m_notifyDupCheckLife = si;
-    } else {
-      throwError(
-          ("SystemProperties: non-integer " + prop + "=" + value).c_str());
-    }
-
+    parseDurationProperty(prop, std::string(value), m_notifyDupCheckLife);
   } else if (prop == StatisticsSampleInterval) {
-    char* end;
-    long si = strtol(value, &end, 10);
-    if (!*end) {
-      m_statisticsSampleInterval = si;
-
-    } else {
-      throwError(
-          ("SystemProperties: non-integer " + prop + "=" + value).c_str());
-    }
+    parseDurationProperty(prop, std::string(value), m_statisticsSampleInterval);
   } else if (prop == DurableTimeout) {
-    char* end;
-    uint32_t si = strtoul(value, &end, 10);
-    if (!*end) {
-      m_durableTimeout = si;
-
-    } else {
-      throwError(
-          ("SystemProperties: non-integer " + prop + "=" + value).c_str());
-    }
-
+    parseDurationProperty(prop, std::string(value), m_durableTimeout);
   } else if (prop == ConnectTimeout) {
-    char* end;
-    uint32_t si = strtoul(value, &end, 10);
-    if (!*end) {
-      m_connectTimeout = si;
-
-    } else {
-      throwError(
-          ("SystemProperties: non-integer " + prop + "=" + value).c_str());
-    }
-
+    parseDurationProperty(prop, std::string(value), m_connectTimeout);
   } else if (prop == ConnectWaitTimeout) {
-    char* end;
-    uint32_t si = strtoul(value, &end, 10);
-    if (!*end) {
-      m_connectWaitTimeout = si;
-
-    } else {
-      throwError(
-          ("SystemProperties: non-integer " + prop + "=" + value).c_str());
-    }
-
+    parseDurationProperty(prop, std::string(value), m_connectWaitTimeout);
   } else if (prop == BucketWaitTimeout) {
-    char* end;
-    uint32_t si = strtoul(value, &end, 10);
-    if (!*end) {
-      m_bucketWaitTimeout = si;
-
-    } else {
-      throwError(
-          ("SystemProperties: non-integer " + prop + "=" + value).c_str());
-    }
-
+    parseDurationProperty(prop, std::string(value), m_bucketWaitTimeout);
   } else if (prop == DisableShufflingEndpoint) {
     std::string val = value;
     if (val == "false") {
@@ -673,26 +619,9 @@ void SystemProperties::processProperty(const char* property,
           ("SystemProperties: non-integer " + prop + "=" + value).c_str());
     }
   } else if (prop == SuspendedTxTimeout) {
-    char* end;
-    uint32_t si = strtoul(value, &end, 10);
-    if (!*end) {
-      m_suspendedTxTimeout = si;
-
-    } else {
-      throwError(
-          ("SystemProperties: non-integer " + prop + "=" + value).c_str());
-    }
-
-  } else if (prop == TombstoneTimeoutInMSec) {  // Added system properties for
-                                                // TombStone-Timeout.
-    char* end;
-    uint32_t si = strtoul(value, &end, 10);
-    if (!*end) {
-      m_tombstoneTimeoutInMSec = si;
-    } else {
-      throwError(
-          ("SystemProperties: non-integer " + prop + "=" + value).c_str());
-    }
+    parseDurationProperty(prop, std::string(value), m_suspendedTxTimeout);
+  } else if (prop == TombstoneTimeoutInMSec) {
+    parseDurationProperty(prop, std::string(value), m_tombstoneTimeout);
   } else if (strncmp(property, DefaultSecurityPrefix,
                      sizeof(DefaultSecurityPrefix) - 1) == 0) {
     m_securityPropertiesPtr->insert(property, value);
@@ -714,15 +643,6 @@ void SystemProperties::processProperty(const char* property,
     } else {
       throwError(("SystemProperties: non-boolean " + prop + "=" + val).c_str());
     }
-  } else if (prop == ReadTimeoutUnitInMillis) {
-    std::string val = value;
-    if (val == "false") {
-      m_readTimeoutUnitInMillis = false;
-    } else if (val == "true") {
-      m_readTimeoutUnitInMillis = true;
-    } else {
-      throwError(("SystemProperties: non-boolean " + prop + "=" + val).c_str());
-    }
   } else {
     char msg[1000];
     ACE_OS::snprintf(msg, 1000, "SystemProperties: unknown property: %s = %s",
@@ -736,25 +656,20 @@ void SystemProperties::logSettings() {
 
   std::string settings = "Geode Native Client System Properties:";
 
-  char buf[2048];
-
   settings += "\n  appdomain-enabled = ";
   settings += isAppDomainEnabled() ? "true" : "false";
 
-  ACE_OS::snprintf(buf, 2048, "%" PRIu32, statsDiskSpaceLimit());
   settings += "\n  archive-disk-space-limit = ";
-  settings += buf;
+  settings += std::to_string(statsDiskSpaceLimit());
 
-  ACE_OS::snprintf(buf, 2048, "%" PRIu32, statsFileSizeLimit());
   settings += "\n  archive-file-size-limit = ";
-  settings += buf;
+  settings += std::to_string(statsFileSizeLimit());
 
   settings += "\n  auto-ready-for-events = ";
   settings += autoReadyForEvents() ? "true" : "false";
 
-  ACE_OS::snprintf(buf, 2048, "%" PRIu32, bucketWaitTimeout());
   settings += "\n  bucket-wait-timeout = ";
-  settings += buf;
+  settings += util::chrono::duration::to_string(bucketWaitTimeout());
 
   settings += "\n  cache-xml-file = ";
   settings += cacheXMLFile();
@@ -762,17 +677,14 @@ void SystemProperties::logSettings() {
   settings += "\n  conflate-events = ";
   settings += conflateEvents();
 
-  ACE_OS::snprintf(buf, 2048, "%" PRIu32, connectTimeout());
   settings += "\n  connect-timeout = ";
-  settings += buf;
+  settings += util::chrono::duration::to_string(connectTimeout());
 
-  ACE_OS::snprintf(buf, 2048, "%" PRIu32, javaConnectionPoolSize());
   settings += "\n  connection-pool-size = ";
-  settings += buf;
+  settings += std::to_string(javaConnectionPoolSize());
 
-  ACE_OS::snprintf(buf, 2048, "%" PRIu32, connectWaitTimeout());
   settings += "\n  connect-wait-timeout = ";
-  settings += buf;
+  settings += util::chrono::duration::to_string(connectWaitTimeout());
 
   settings += "\n  crash-dump-enabled = ";
   settings += crashDumpEnabled() ? "true" : "false";
@@ -786,9 +698,8 @@ void SystemProperties::logSettings() {
   settings += "\n  durable-client-id = ";
   settings += durableClientId();
 
-  ACE_OS::snprintf(buf, 2048, "%" PRIu32, durableTimeout());
   settings += "\n  durable-timeout = ";
-  settings += buf;
+  settings += util::chrono::duration::to_string(durableTimeout());
 
   // *** PLEASE ADD IN ALPHABETICAL ORDER - USER VISIBLE ***
 
@@ -798,15 +709,13 @@ void SystemProperties::logSettings() {
   settings += "\n  grid-client = ";
   settings += isGridClient() ? "true" : "false";
 
-  ACE_OS::snprintf(buf, 2048, "%" PRIu32, heapLRUDelta());
   settings += "\n  heap-lru-delta = ";
-  settings += buf;
+  settings += std::to_string(heapLRUDelta());
   /* adongre  - Coverity II
    * CID 29195: Printf arg type mismatch (PW.PRINTF_ARG_MISMATCH)
    */
-  ACE_OS::snprintf(buf, 2048, "%" PRIu32, static_cast<int>(heapLRULimit()));
   settings += "\n  heap-lru-limit = ";
-  settings += buf;
+  settings += std::to_string(heapLRULimit());
 
   // settings += "\n  license-file = ";
   // settings += licenseFilename();
@@ -814,51 +723,40 @@ void SystemProperties::logSettings() {
   // settings += "\n  license-type = ";
   // settings += licenseType();
 
-  ACE_OS::snprintf(buf, 2048, "%" PRIu32, logDiskSpaceLimit());
   settings += "\n  log-disk-space-limit = ";
-  settings += buf;
+  settings += std::to_string(logDiskSpaceLimit());
 
   settings += "\n  log-file = ";
   settings += logFilename();
 
-  ACE_OS::snprintf(buf, 2048, "%" PRIu32, logFileSizeLimit());
   settings += "\n  log-file-size-limit = ";
-  settings += buf;
+  settings += std::to_string(logFileSizeLimit());
 
   settings += "\n  log-level = ";
   settings += Log::levelToChars(logLevel());
 
-  ACE_OS::snprintf(buf, 2048, "%" PRIu32, threadPoolSize());
   settings += "\n  max-fe-threads = ";
-  settings += buf;
+  settings += std::to_string(threadPoolSize());
 
-  ACE_OS::snprintf(buf, 2048, "%" PRIu32, maxSocketBufferSize());
   settings += "\n  max-socket-buffer-size = ";
-  settings += buf;
+  settings += std::to_string(maxSocketBufferSize());
 
-  ACE_OS::snprintf(buf, 2048, "%" PRIi32, notifyAckInterval());
   settings += "\n  notify-ack-interval = ";
-  settings += buf;
+  settings += util::chrono::duration::to_string(notifyAckInterval());
 
-  ACE_OS::snprintf(buf, 2048, "%" PRIi32, notifyDupCheckLife());
   settings += "\n  notify-dupcheck-life = ";
-  settings += buf;
+  settings += util::chrono::duration::to_string(notifyDupCheckLife());
 
   settings += "\n  on-client-disconnect-clear-pdxType-Ids = ";
   settings += onClientDisconnectClearPdxTypeIds() ? "true" : "false";
 
   // *** PLEASE ADD IN ALPHABETICAL ORDER - USER VISIBLE ***
 
-  ACE_OS::snprintf(buf, 2048, "%" PRIi32, pingInterval());
   settings += "\n  ping-interval = ";
-  settings += buf;
+  settings += util::chrono::duration::to_string(pingInterval());
 
-  settings += "\n  read-timeout-unit-in-millis = ";
-  settings += readTimeoutUnitInMillis() ? "true" : "false";
-
-  ACE_OS::snprintf(buf, 2048, "%" PRIi32, redundancyMonitorInterval());
   settings += "\n  redundancy-monitor-interval = ";
-  settings += buf;
+  settings += util::chrono::duration::to_string(redundancyMonitorInterval());
 
   settings += "\n  security-client-dhalgo = ";
   settings += securityClientDhAlgo();
@@ -887,21 +785,20 @@ void SystemProperties::logSettings() {
   settings += "\n  statistic-sampling-enabled = ";
   settings += statisticsEnabled() ? "true" : "false";
 
-  ACE_OS::snprintf(buf, 2048, "%" PRIu32, statisticsSampleInterval());
   settings += "\n  statistic-sample-rate = ";
-  settings += buf;
+  settings += util::chrono::duration::to_string(statisticsSampleInterval());
 
-  ACE_OS::snprintf(buf, 2048, "%" PRIu32, suspendedTxTimeout());
   settings += "\n  suspended-tx-timeout = ";
-  settings += buf;
+  settings += util::chrono::duration::to_string(suspendedTxTimeout());
 
-  // tombstone-timeout
-  ACE_OS::snprintf(buf, 2048, "%" PRIu32, tombstoneTimeoutInMSec());
   settings += "\n  tombstone-timeout = ";
-  settings += buf;
+  settings += util::chrono::duration::to_string(tombstoneTimeout());
 
   // *** PLEASE ADD IN ALPHABETICAL ORDER - USER VISIBLE ***
 
   LOGCONFIG(settings.c_str());
 }
 
+}  // namespace client
+}  // namespace geode
+}  // namespace apache
diff --git a/cppcache/src/TcpConn.cpp b/cppcache/src/TcpConn.cpp
index 4f0479dc..7e683c38 100644
--- a/cppcache/src/TcpConn.cpp
+++ b/cppcache/src/TcpConn.cpp
@@ -15,11 +15,6 @@
  * limitations under the License.
  */
 
-#include "TcpConn.hpp"
-#include <geode/DistributedSystem.hpp>
-#include <geode/SystemProperties.hpp>
-#include "util/Log.hpp"
-
 #include <memory.h>
 
 #include <ace/INET_Addr.h>
@@ -27,8 +22,18 @@
 #include <ace/SOCK_Connector.h>
 #include <ace/SOCK_Acceptor.h>
 #include <ace/OS.h>
+
+#include <geode/DistributedSystem.hpp>
+#include <geode/SystemProperties.hpp>
+#include <geode/util/chrono/duration.hpp>
+
+#include "TcpConn.hpp"
 #include "CacheImpl.hpp"
-using namespace apache::geode::client;
+#include "util/Log.hpp"
+
+namespace apache {
+namespace geode {
+namespace client {
 
 void TcpConn::clearNagle(ACE_SOCKET sock) {
   int32_t val = 1;
@@ -127,38 +132,41 @@ void TcpConn::init() {
   connect();
 }
 
-TcpConn::TcpConn(const char *ipaddr, uint32_t waitSeconds,
+TcpConn::TcpConn(const char *ipaddr, std::chrono::microseconds waitSeconds,
                  int32_t maxBuffSizePool)
     : m_io(nullptr),
       m_addr(ipaddr),
-      m_waitMilliSeconds(waitSeconds * 1000),
+      m_waitMilliSeconds(waitSeconds),
       m_maxBuffSizePool(maxBuffSizePool),
       m_chunkSize(getDefaultChunkSize()) {}
 
-TcpConn::TcpConn(const char *hostname, int32_t port, uint32_t waitSeconds,
-                 int32_t maxBuffSizePool)
+TcpConn::TcpConn(const char *hostname, int32_t port,
+                 std::chrono::microseconds waitSeconds, int32_t maxBuffSizePool)
     : m_io(nullptr),
       m_addr(port, hostname),
-      m_waitMilliSeconds(waitSeconds * 1000),
+      m_waitMilliSeconds(waitSeconds),
       m_maxBuffSizePool(maxBuffSizePool),
       m_chunkSize(getDefaultChunkSize()) {}
 
-void TcpConn::listen(const char *hostname, int32_t port, uint32_t waitSeconds) {
+void TcpConn::listen(const char *hostname, int32_t port,
+                     std::chrono::microseconds waitSeconds) {
   ACE_INET_Addr addr(port, hostname);
   listen(addr, waitSeconds);
 }
 
-void TcpConn::listen(const char *ipaddr, uint32_t waitSeconds) {
+void TcpConn::listen(const char *ipaddr,
+                     std::chrono::microseconds waitSeconds) {
   ACE_INET_Addr addr(ipaddr);
   listen(addr, waitSeconds);
 }
 
-void TcpConn::listen(ACE_INET_Addr addr, uint32_t waitSeconds) {
+void TcpConn::listen(ACE_INET_Addr addr,
+                     std::chrono::microseconds waitSeconds) {
   GF_DEV_ASSERT(m_io != nullptr);
 
   ACE_SOCK_Acceptor listener(addr, 1);
   int32_t retVal = 0;
-  if (waitSeconds > 0) {
+  if (waitSeconds > std::chrono::microseconds::zero()) {
     ACE_Time_Value wtime(waitSeconds);
     retVal = listener.accept(*m_io, 0, &wtime);
   } else {
@@ -168,22 +176,9 @@ void TcpConn::listen(ACE_INET_Addr addr, uint32_t waitSeconds) {
     char msg[256];
     int32_t lastError = ACE_OS::last_error();
     if (lastError == ETIME || lastError == ETIMEDOUT) {
-      /* adongre
-       * Coverity - II
-       * CID 29270: Calling risky function (SECURE_CODING)[VERY RISKY]. Using
-       * "sprintf" can cause a
-       * buffer overflow when done incorrectly. Because sprintf() assumes an
-       * arbitrarily long string,
-       * callers must be careful not to overflow the actual space of the
-       * destination.
-       * Use snprintf() instead, or correct precision specifiers.
-       * Fix : using ACE_OS::snprintf
-       */
-      ACE_OS::snprintf(
-          msg, 256,
-          "TcpConn::listen Attempt to listen timed out after %d seconds.",
-          waitSeconds);
-      throw TimeoutException(msg);
+      throw TimeoutException(
+          "TcpConn::listen Attempt to listen timed out after " +
+          util::chrono::duration::to_string(waitSeconds) + ".");
     }
     ACE_OS::snprintf(msg, 256, "TcpConn::listen failed with errno: %d: %s",
                      lastError, ACE_OS::strerror(lastError));
@@ -192,14 +187,15 @@ void TcpConn::listen(ACE_INET_Addr addr, uint32_t waitSeconds) {
 }
 
 void TcpConn::connect(const char *hostname, int32_t port,
-                      uint32_t waitSeconds) {
+                      std::chrono::microseconds waitSeconds) {
   ACE_INET_Addr addr(port, hostname);
   m_addr = addr;
   m_waitMilliSeconds = waitSeconds;
   connect();
 }
 
-void TcpConn::connect(const char *ipaddr, uint32_t waitSeconds) {
+void TcpConn::connect(const char *ipaddr,
+                      std::chrono::microseconds waitSeconds) {
   ACE_INET_Addr addr(ipaddr);
   m_addr = addr;
   m_waitMilliSeconds = waitSeconds;
@@ -210,18 +206,18 @@ void TcpConn::connect() {
   GF_DEV_ASSERT(m_io != nullptr);
 
   ACE_INET_Addr ipaddr = m_addr;
-  uint32_t waitMicroSeconds = m_waitMilliSeconds * 1000;
+  std::chrono::microseconds waitMicroSeconds = m_waitMilliSeconds;
 
   ACE_OS::signal(SIGPIPE, SIG_IGN);  // Ignore broken pipe
 
   LOGFINER("Connecting plain socket stream to %s:%d waiting %d micro sec",
-           ipaddr.get_host_name(), ipaddr.get_port_number(), waitMicroSeconds);
+           ipaddr.get_host_name(), ipaddr.get_port_number(), waitMicroSeconds.count());
 
   ACE_SOCK_Connector conn;
   int32_t retVal = 0;
-  if (waitMicroSeconds > 0) {
+  if (waitMicroSeconds > std::chrono::microseconds::zero()) {
     // passing waittime as microseconds
-    ACE_Time_Value wtime(0, waitMicroSeconds);
+    ACE_Time_Value wtime(waitMicroSeconds);
     retVal = conn.connect(*m_io, ipaddr, &wtime);
   } else {
     retVal = conn.connect(*m_io, ipaddr);
@@ -230,13 +226,11 @@ void TcpConn::connect() {
     char msg[256];
     int32_t lastError = ACE_OS::last_error();
     if (lastError == ETIME || lastError == ETIMEDOUT) {
-      ACE_OS::snprintf(msg, 256,
-                       "TcpConn::connect Attempt to connect timed out after %d "
-                       "microseconds.",
-                       waitMicroSeconds);
       //  this is only called by constructor, so we must delete m_io
       GF_SAFE_DELETE(m_io);
-      throw TimeoutException(msg);
+      throw TimeoutException(
+          "TcpConn::connect Attempt to connect timed out after" +
+          util::chrono::duration::to_string(waitMicroSeconds) + ".");
     }
     ACE_OS::snprintf(msg, 256, "TcpConn::connect failed with errno: %d: %s",
                      lastError, ACE_OS::strerror(lastError));
@@ -262,18 +256,18 @@ void TcpConn::close() {
   }
 }
 
-int32_t TcpConn::receive(char *buff, int32_t len, uint32_t waitSeconds,
-                         uint32_t waitMicroSeconds) {
+int32_t TcpConn::receive(char *buff, int32_t len,
+                         std::chrono::microseconds waitSeconds) {
   return socketOp(SOCK_READ, buff, len, waitSeconds);
 }
 
-int32_t TcpConn::send(const char *buff, int32_t len, uint32_t waitSeconds,
-                      uint32_t waitMicroSeconds) {
+int32_t TcpConn::send(const char *buff, int32_t len,
+                      std::chrono::microseconds waitSeconds) {
   return socketOp(SOCK_WRITE, const_cast<char *>(buff), len, waitSeconds);
 }
 
 int32_t TcpConn::socketOp(TcpConn::SockOp op, char *buff, int32_t len,
-                          uint32_t waitSeconds) {
+                          std::chrono::microseconds waitSeconds) {
   {
     /*{
       ACE_HANDLE handle = m_io->get_handle();
@@ -302,8 +296,9 @@ int32_t TcpConn::socketOp(TcpConn::SockOp op, char *buff, int32_t len,
     }
 #endif
 
-    ACE_Time_Value waitTime(0, waitSeconds /*now its in microSeconds*/);
-    ACE_Time_Value endTime(ACE_OS::gettimeofday() + waitTime);
+    ACE_Time_Value waitTime(waitSeconds);
+    ACE_Time_Value endTime(ACE_OS::gettimeofday());
+    endTime += waitTime;
     ACE_Time_Value sleepTime(0, 100);
     size_t readLen = 0;
     ssize_t retVal;
@@ -367,3 +362,7 @@ uint16_t TcpConn::getPort() {
   m_io->get_local_addr(*(ACE_Addr *)&localAddr);
   return localAddr.get_port_number();
 }
+
+}  // namespace client
+}  // namespace geode
+}  // namespace apache
diff --git a/cppcache/src/TcpConn.hpp b/cppcache/src/TcpConn.hpp
index 41b51991..a2cd9bf3 100644
--- a/cppcache/src/TcpConn.hpp
+++ b/cppcache/src/TcpConn.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_TCPCONN_H_
-#define GEODE_TCPCONN_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,6 +15,11 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_TCPCONN_H_
+#define GEODE_TCPCONN_H_
+
 #include <geode/geode_globals.hpp>
 #include "util/Log.hpp"
 #include "Connector.hpp"
@@ -50,7 +50,7 @@ class CPPCACHE_EXPORT TcpConn : public Connector {
 
  protected:
   ACE_INET_Addr m_addr;
-  uint32_t m_waitMilliSeconds;
+  std::chrono::microseconds m_waitMilliSeconds;
 
   int32_t m_maxBuffSizePool;
 
@@ -60,7 +60,7 @@ class CPPCACHE_EXPORT TcpConn : public Connector {
   int32_t maxSize(ACE_SOCKET sock, int32_t flag, int32_t size);
 
   virtual int32_t socketOp(SockOp op, char* buff, int32_t len,
-                           uint32_t waitSeconds);
+                           std::chrono::microseconds waitSeconds);
 
   virtual void createSocket(ACE_SOCKET sock);
 
@@ -80,38 +80,41 @@ class CPPCACHE_EXPORT TcpConn : public Connector {
     return 16000000;
   }
 
-  TcpConn(const char* hostname, int32_t port, uint32_t waitSeconds,
+  TcpConn(const char* hostname, int32_t port,
+          std::chrono::microseconds waitSeconds, int32_t maxBuffSizePool);
+  TcpConn(const char* ipaddr, std::chrono::microseconds waitSeconds,
           int32_t maxBuffSizePool);
-  TcpConn(const char* ipaddr, uint32_t waitSeconds, int32_t maxBuffSizePool);
 
   virtual ~TcpConn() { close(); }
 
   // Close this tcp connection
-  virtual void close();
+  virtual void close() override;
 
-  void init();
+  void init() override;
 
   // Listen
-  void listen(const char* hostname, int32_t port,
-              uint32_t waitSeconds = DEFAULT_READ_TIMEOUT_SECS);
-  void listen(const char* ipaddr,
-              uint32_t waitSeconds = DEFAULT_READ_TIMEOUT_SECS);
+  void listen(
+      const char* hostname, int32_t port,
+      std::chrono::microseconds waitSeconds = DEFAULT_READ_TIMEOUT_SECS);
+  void listen(const char* ipaddr, std::chrono::microseconds waitSeconds =
+                                      DEFAULT_READ_TIMEOUT_SECS);
 
-  virtual void listen(ACE_INET_Addr addr,
-                      uint32_t waitSeconds = DEFAULT_READ_TIMEOUT_SECS);
+  virtual void listen(
+      ACE_INET_Addr addr,
+      std::chrono::microseconds waitSeconds = DEFAULT_READ_TIMEOUT_SECS);
 
   // connect
   void connect(const char* hostname, int32_t port,
-               uint32_t waitSeconds = DEFAULT_CONNECT_TIMEOUT);
+               std::chrono::microseconds waitSeconds = DEFAULT_CONNECT_TIMEOUT);
   void connect(const char* ipaddr,
-               uint32_t waitSeconds = DEFAULT_CONNECT_TIMEOUT);
+               std::chrono::microseconds waitSeconds = DEFAULT_CONNECT_TIMEOUT);
 
   virtual void connect();
 
-  int32_t receive(char* buff, int32_t len, uint32_t waitSeconds,
-                  uint32_t waitMicroSeconds);
-  int32_t send(const char* buff, int32_t len, uint32_t waitSeconds,
-               uint32_t waitMicroSeconds);
+  int32_t receive(char* buff, int32_t len,
+                  std::chrono::microseconds waitSeconds) override;
+  int32_t send(const char* buff, int32_t len,
+               std::chrono::microseconds waitSeconds) override;
 
   virtual void setOption(int32_t level, int32_t option, void* val,
                          int32_t len) {
@@ -132,7 +135,7 @@ class CPPCACHE_EXPORT TcpConn : public Connector {
     setOption(level, option, (void*)&val, sizeof(bool));
   }
 
-  virtual uint16_t getPort();
+  virtual uint16_t getPort() override;
 };
 }  // namespace client
 }  // namespace geode
diff --git a/cppcache/src/TcpSslConn.cpp b/cppcache/src/TcpSslConn.cpp
index 74b999d1..e8dc56c3 100644
--- a/cppcache/src/TcpSslConn.cpp
+++ b/cppcache/src/TcpSslConn.cpp
@@ -18,9 +18,11 @@
 
 #include <geode/SystemProperties.hpp>
 #include <geode/DistributedSystem.hpp>
-#include "../../cryptoimpl/Ssl.hpp"
 #include "CacheImpl.hpp"
-using namespace apache::geode::client;
+
+namespace apache {
+namespace geode {
+namespace client {
 
 Ssl* TcpSslConn::getSSLImpl(ACE_SOCKET sock, const char* pubkeyfile,
                             const char* privkeyfile) {
@@ -51,7 +53,8 @@ void TcpSslConn::createSocket(ACE_SOCKET sock) {
   m_ssl = getSSLImpl(sock, m_pubkeyfile, m_privkeyfile);
 }
 
-void TcpSslConn::listen(ACE_INET_Addr addr, uint32_t waitSeconds) {
+void TcpSslConn::listen(ACE_INET_Addr addr,
+                        std::chrono::microseconds waitSeconds) {
   GF_DEV_ASSERT(m_ssl != nullptr);
 
   int32_t retVal = m_ssl->listen(addr, waitSeconds);
@@ -60,24 +63,9 @@ void TcpSslConn::listen(ACE_INET_Addr addr, uint32_t waitSeconds) {
     char msg[256];
     int32_t lastError = ACE_OS::last_error();
     if (lastError == ETIME || lastError == ETIMEDOUT) {
-      /* adongre
-       * Coverity - II
-       * CID 29271: Calling risky function (SECURE_CODING)[VERY RISKY]. Using
-       * "sprintf" can cause a
-       * buffer overflow when done incorrectly. Because sprintf() assumes an
-       * arbitrarily long string,
-       * callers must be careful not to overflow the actual space of the
-       * destination.
-       * Use snprintf() instead, or correct precision specifiers.
-       * Fix : using ACE_OS::snprintf
-       */
-      // sprintf( msg, "TcpSslConn::listen Attempt to listen timed out after %d
-      // seconds.", waitSeconds );
-      ACE_OS::snprintf(
-          msg, 256,
-          "TcpSslConn::listen Attempt to listen timed out after %d seconds.",
-          waitSeconds);
-      throw TimeoutException(msg);
+      throw TimeoutException(
+          "TcpSslConn::listen Attempt to listen timed out after" +
+          util::chrono::duration::to_string(waitSeconds) + ".");
     }
     // sprintf( msg, "TcpSslConn::listen failed with errno: %d: %s", lastError,
     // ACE_OS::strerror(lastError) );
@@ -94,10 +82,10 @@ void TcpSslConn::connect() {
 
   // m_ssl->init();
 
-  uint32_t waitMicroSeconds = m_waitMilliSeconds * 1000;
+  std::chrono::microseconds waitMicroSeconds = m_waitMilliSeconds;
 
   LOGDEBUG("Connecting SSL socket stream to %s:%d waiting %d micro sec",
-           m_addr.get_host_name(), m_addr.get_port_number(), waitMicroSeconds);
+           m_addr.get_host_name(), m_addr.get_port_number(), waitMicroSeconds.count());
 
   int32_t retVal = m_ssl->connect(m_addr, waitMicroSeconds);
 
@@ -105,13 +93,11 @@ void TcpSslConn::connect() {
     char msg[256];
     int32_t lastError = ACE_OS::last_error();
     if (lastError == ETIME || lastError == ETIMEDOUT) {
-      ACE_OS::snprintf(msg, 256,
-                       "TcpSslConn::connect Attempt to connect timed out after "
-                       "%d micro-seconds.",
-                       waitMicroSeconds);
       // this is only called by constructor, so we must delete m_ssl
       GF_SAFE_DELETE(m_ssl);
-      throw TimeoutException(msg);
+      throw TimeoutException(
+          "TcpSslConn::connect Attempt to connect timed out after " +
+          util::chrono::duration::to_string(waitMicroSeconds) + ".");
     }
     ACE_OS::snprintf(msg, 256, "TcpSslConn::connect failed with errno: %d: %s",
                      lastError, ACE_OS::strerror(lastError));
@@ -132,7 +118,7 @@ void TcpSslConn::close() {
 }
 
 int32_t TcpSslConn::socketOp(TcpConn::SockOp op, char* buff, int32_t len,
-                             uint32_t waitSeconds) {
+                             std::chrono::microseconds waitSeconds) {
   {
     GF_DEV_ASSERT(m_ssl != nullptr);
     GF_DEV_ASSERT(buff != nullptr);
@@ -147,8 +133,9 @@ int32_t TcpSslConn::socketOp(TcpConn::SockOp op, char* buff, int32_t len,
     }
 #endif
     // passing wait time as micro seconds
-    ACE_Time_Value waitTime(0, waitSeconds);
-    ACE_Time_Value endTime(ACE_OS::gettimeofday() + waitTime);
+    ACE_Time_Value waitTime(waitSeconds);
+    ACE_Time_Value endTime(ACE_OS::gettimeofday());
+    endTime += waitTime;
     ACE_Time_Value sleepTime(0, 100);
     size_t readLen = 0;
     ssize_t retVal;
@@ -211,3 +198,7 @@ uint16_t TcpSslConn::getPort() {
   m_ssl->getLocalAddr(*(ACE_Addr*)&localAddr);
   return localAddr.get_port_number();
 }
+
+}  // namespace client
+}  // namespace geode
+}  // namespace apache
diff --git a/cppcache/src/TcpSslConn.hpp b/cppcache/src/TcpSslConn.hpp
index 1ebf3db7..050471ac 100644
--- a/cppcache/src/TcpSslConn.hpp
+++ b/cppcache/src/TcpSslConn.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_TCPSSLCONN_H_
-#define GEODE_TCPSSLCONN_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,8 +15,14 @@
  * limitations under the License.
  */
 
-#include "TcpConn.hpp"
+#pragma once
+
+#ifndef GEODE_TCPSSLCONN_H_
+#define GEODE_TCPSSLCONN_H_
+
 #include <ace/DLL.h>
+
+#include "TcpConn.hpp"
 #include "../../cryptoimpl/Ssl.hpp"
 
 namespace apache {
@@ -45,23 +46,25 @@ class TcpSslConn : public TcpConn {
                   const char* privkeyfile);
 
  protected:
-  int32_t socketOp(SockOp op, char* buff, int32_t len, uint32_t waitSeconds);
+  int32_t socketOp(SockOp op, char* buff, int32_t len,
+                   std::chrono::microseconds waitSeconds) override;
 
-  void createSocket(ACE_SOCKET sock);
+  void createSocket(ACE_SOCKET sock) override;
 
  public:
-  TcpSslConn(const char* hostname, int32_t port, uint32_t waitSeconds,
-             int32_t maxBuffSizePool, const char* pubkeyfile,
-             const char* privkeyfile, const char* pemPassword)
+  TcpSslConn(const char* hostname, int32_t port,
+             std::chrono::microseconds waitSeconds, int32_t maxBuffSizePool,
+             const char* pubkeyfile, const char* privkeyfile,
+             const char* pemPassword)
       : TcpConn(hostname, port, waitSeconds, maxBuffSizePool),
         m_ssl(nullptr),
         m_pubkeyfile(pubkeyfile),
         m_privkeyfile(privkeyfile),
         m_pemPassword(pemPassword){};
 
-  TcpSslConn(const char* ipaddr, uint32_t waitSeconds, int32_t maxBuffSizePool,
-             const char* pubkeyfile, const char* privkeyfile,
-             const char* pemPassword)
+  TcpSslConn(const char* ipaddr, std::chrono::microseconds waitSeconds,
+             int32_t maxBuffSizePool, const char* pubkeyfile,
+             const char* privkeyfile, const char* pemPassword)
       : TcpConn(ipaddr, waitSeconds, maxBuffSizePool),
         m_ssl(nullptr),
         m_pubkeyfile(pubkeyfile),
@@ -73,16 +76,17 @@ class TcpSslConn : public TcpConn {
   virtual ~TcpSslConn() {}
 
   // Close this tcp connection
-  void close();
+  void close() override;
 
   // Listen
-  void listen(ACE_INET_Addr addr,
-              uint32_t waitSeconds = DEFAULT_READ_TIMEOUT_SECS);
+  void listen(ACE_INET_Addr addr, std::chrono::microseconds waitSeconds =
+                                      DEFAULT_READ_TIMEOUT_SECS) override;
 
   // connect
-  void connect();
+  void connect() override;
 
-  void setOption(int32_t level, int32_t option, void* val, int32_t len) {
+  void setOption(int32_t level, int32_t option, void* val,
+                 int32_t len) override {
     GF_DEV_ASSERT(m_ssl != nullptr);
 
     if (m_ssl->setOption(level, option, val, len) == -1) {
@@ -92,7 +96,7 @@ class TcpSslConn : public TcpConn {
     }
   }
 
-  uint16_t getPort();
+  uint16_t getPort() override;
 };
 }  // namespace client
 }  // namespace geode
diff --git a/cppcache/src/TcrConnection.cpp b/cppcache/src/TcrConnection.cpp
index 3f2ad543..43272b0b 100644
--- a/cppcache/src/TcrConnection.cpp
+++ b/cppcache/src/TcrConnection.cpp
@@ -53,7 +53,8 @@ const int64_t INITIAL_CONNECTION_ID = 26739;
   }
 bool TcrConnection::InitTcrConnection(
     TcrEndpoint* endpointObj, const char* endpoint, Set<uint16_t>& ports,
-    bool isClientNotification, bool isSecondary, uint32_t connectTimeout) {
+    bool isClientNotification, bool isSecondary,
+    std::chrono::microseconds connectTimeout) {
   m_conn = nullptr;
   m_endpointObj = endpointObj;
   m_poolDM = dynamic_cast<ThinClientPoolDM*>(m_endpointObj->getPoolHADM());
@@ -167,7 +168,7 @@ bool TcrConnection::InitTcrConnection(
     // Add 3 durable Subcription properties to ClientProxyMembershipID
 
     const char* durableId = sysProp.durableClientId();
-    const uint32_t durableTimeOut = sysProp.durableTimeout();
+    const auto durableTimeOut = sysProp.durableTimeout();
 
     // Write ClientProxyMembershipID serialized object.
     uint32_t memIdBufferLength;
@@ -560,9 +561,9 @@ bool TcrConnection::InitTcrConnection(
   return false;
 }
 
-Connector* TcrConnection::createConnection(const char* endpoint,
-                                           uint32_t connectTimeout,
-                                           int32_t maxBuffSizePool) {
+Connector* TcrConnection::createConnection(
+    const char* endpoint, std::chrono::microseconds connectTimeout,
+    int32_t maxBuffSizePool) {
   Connector* socket = nullptr;
   auto& systemProperties = m_connectionManager->getCacheImpl()
                                ->getDistributedSystem()
@@ -592,56 +593,26 @@ Connector* TcrConnection::createConnection(const char* endpoint,
  *           that is used instead
  *   Body: default timeout
  */
-inline ConnErrType TcrConnection::receiveData(char* buffer, int32_t length,
-                                              uint32_t receiveTimeoutSec,
-                                              bool checkConnected,
-                                              bool isNotificationMessage,
-                                              int32_t notPublicApiWithTimeout) {
+inline ConnErrType TcrConnection::receiveData(
+    char* buffer, int32_t length, std::chrono::microseconds receiveTimeoutSec,
+    bool checkConnected, bool isNotificationMessage) {
   GF_DEV_ASSERT(buffer != nullptr);
   GF_DEV_ASSERT(m_conn != nullptr);
 
-  // if gfcpp property unit set then sendTimeoutSec will be in millisecond
-  // otherwise it will be in second
-  if (m_poolDM->getConnectionManager()
-          .getCacheImpl()
-          ->getDistributedSystem()
-          .getSystemProperties()
-          .readTimeoutUnitInMillis()) {
-    LOGFINER("recieveData %d %d ", receiveTimeoutSec, notPublicApiWithTimeout);
-    if (notPublicApiWithTimeout == TcrMessage::QUERY ||
-        notPublicApiWithTimeout == TcrMessage::QUERY_WITH_PARAMETERS ||
-        notPublicApiWithTimeout == TcrMessage::EXECUTECQ_WITH_IR_MSG_TYPE ||
-        /*notPublicApiWithTimeout == TcrMessage::GETDURABLECQS_MSG_TYPE || this
-           is not public yet*/
-        notPublicApiWithTimeout == TcrMessage::EXECUTE_FUNCTION ||
-        notPublicApiWithTimeout == TcrMessage::EXECUTE_REGION_FUNCTION ||
-        notPublicApiWithTimeout ==
-            TcrMessage::EXECUTE_REGION_FUNCTION_SINGLE_HOP) {
-      // then app has set timeout in millis, change it to microSeconds
-      receiveTimeoutSec = receiveTimeoutSec * 1000;
-      LOGDEBUG("recieveData2 %d ", receiveTimeoutSec);
-    } else {
-      receiveTimeoutSec = receiveTimeoutSec * 1000 * 1000;
-    }
-  } else {  // it is set as seconds and change it to microsecond
-    receiveTimeoutSec = receiveTimeoutSec * 1000 * 1000;
-  }
-
-  uint32_t defaultWaitSecs =
-      isNotificationMessage ? 1 * 1000 * 1000 : 2 * 1000 * 1000;
-  // uint32_t defaultMicroSecs = (sendTimeoutSec % (1000*1000))
+  std::chrono::microseconds defaultWaitSecs =
+      isNotificationMessage ? std::chrono::seconds(1) : std::chrono::seconds(2);
   if (defaultWaitSecs > receiveTimeoutSec) defaultWaitSecs = receiveTimeoutSec;
 
   int32_t startLen = length;
 
-  while (length > 0 && receiveTimeoutSec > 0) {
+  while (length > 0 && receiveTimeoutSec > std::chrono::microseconds::zero()) {
     if (checkConnected && !m_connected) {
       return CONN_IOERR;
     }
     if (receiveTimeoutSec < defaultWaitSecs) {
       defaultWaitSecs = receiveTimeoutSec;
     }
-    int32_t readBytes = m_conn->receive(buffer, length, defaultWaitSecs, 0);
+    int32_t readBytes = m_conn->receive(buffer, length, defaultWaitSecs);
     int32_t lastError = ACE_OS::last_error();
     length -= readBytes;
     if (length > 0 && lastError != ETIME && lastError != ETIMEDOUT) {
@@ -655,7 +626,7 @@ inline ConnErrType TcrConnection::receiveData(char* buffer, int32_t length,
       readHandshakeString, all call TcrConnection::receiveData.
     */
     LOGDEBUG("TcrConnection::receiveData length = %d defaultWaitSecs = %d",
-             length, defaultWaitSecs);
+             length, defaultWaitSecs.count());
     if (m_poolDM != nullptr) {
       LOGDEBUG("TcrConnection::receiveData readBytes = %d", readBytes);
       m_poolDM->getStats().incReceivedBytes(static_cast<int64_t>(readBytes));
@@ -672,65 +643,33 @@ inline ConnErrType TcrConnection::receiveData(char* buffer, int32_t length,
                       : (length == startLen ? CONN_NODATA : CONN_TIMEOUT));
 }
 
-inline ConnErrType TcrConnection::sendData(const char* buffer, int32_t length,
-                                           uint32_t sendTimeoutSec,
-                                           bool checkConnected) {
-  uint32_t dummy = 0;
-  return sendData(dummy, buffer, length, sendTimeoutSec, checkConnected);
+inline ConnErrType TcrConnection::sendData(
+    const char* buffer, int32_t length, std::chrono::microseconds sendTimeout,
+    bool checkConnected) {
+  std::chrono::microseconds dummy{0};
+  return sendData(dummy, buffer, length, sendTimeout, checkConnected);
 }
 
-inline ConnErrType TcrConnection::sendData(uint32_t& timeSpent,
-                                           const char* buffer, int32_t length,
-                                           uint32_t sendTimeoutSec,
-                                           bool checkConnected,
-                                           int32_t notPublicApiWithTimeout) {
+inline ConnErrType TcrConnection::sendData(
+    std::chrono::microseconds& timeSpent, const char* buffer, int32_t length,
+    std::chrono::microseconds sendTimeout, bool checkConnected) {
   GF_DEV_ASSERT(buffer != nullptr);
   GF_DEV_ASSERT(m_conn != nullptr);
-  bool isPublicApiTimeout = false;
-  // if gfcpp property unit set then sendTimeoutSec will be in millisecond
-  // otherwise it will be in second
-  if (m_poolDM->getConnectionManager()
-          .getCacheImpl()
-          ->getDistributedSystem()
-          .getSystemProperties()
-          .readTimeoutUnitInMillis()) {
-    LOGFINER("sendData %d  %d", sendTimeoutSec, notPublicApiWithTimeout);
-    if (notPublicApiWithTimeout == TcrMessage::QUERY ||
-        notPublicApiWithTimeout == TcrMessage::QUERY_WITH_PARAMETERS ||
-        notPublicApiWithTimeout == TcrMessage::EXECUTECQ_WITH_IR_MSG_TYPE ||
-        /*notPublicApiWithTimeout == TcrMessage::GETDURABLECQS_MSG_TYPE || this
-           is not public yet*/
-        notPublicApiWithTimeout == TcrMessage::EXECUTE_FUNCTION ||
-        notPublicApiWithTimeout == TcrMessage::EXECUTE_REGION_FUNCTION ||
-        notPublicApiWithTimeout ==
-            TcrMessage::EXECUTE_REGION_FUNCTION_SINGLE_HOP) {
-      // then app has set timeout in millis, change it to microSeconds
-      sendTimeoutSec = sendTimeoutSec * 1000;
-      isPublicApiTimeout = true;
-      LOGDEBUG("sendData2 %d ", sendTimeoutSec);
-    } else {
-      sendTimeoutSec = sendTimeoutSec * 1000;
-    }
-  } else {  // it is set as seconds and change it to microsecond
-    sendTimeoutSec = sendTimeoutSec * 1000 * 1000;
-  }
 
-  uint32_t defaultWaitSecs = 2 * 1000 * 1000;  // 2 second
-  // uint32_t defaultMicroSecs = (sendTimeoutSec % (1000*1000))
-  if (defaultWaitSecs > sendTimeoutSec) defaultWaitSecs = sendTimeoutSec;
+  std::chrono::microseconds defaultWaitSecs = std::chrono::seconds(2);
+  if (defaultWaitSecs > sendTimeout) defaultWaitSecs = sendTimeout;
   LOGDEBUG(
       "before send len %d sendTimeoutSec = %d checkConnected = %d m_connected "
       "%d",
-      length, sendTimeoutSec, checkConnected, m_connected);
-  while (length > 0 && sendTimeoutSec > 0) {
+      length, sendTimeout.count(), checkConnected, m_connected);
+  while (length > 0 && sendTimeout > std::chrono::microseconds::zero()) {
     if (checkConnected && !m_connected) {
       return CONN_IOERR;
     }
-    LOGDEBUG("before send ");
-    if (sendTimeoutSec < defaultWaitSecs) {
-      defaultWaitSecs = sendTimeoutSec;
+    if (sendTimeout < defaultWaitSecs) {
+      defaultWaitSecs = sendTimeout;
     }
-    int32_t sentBytes = m_conn->send(buffer, length, defaultWaitSecs, 0);
+    int32_t sentBytes = m_conn->send(buffer, length, defaultWaitSecs);
 
     length -= sentBytes;
     buffer += sentBytes;
@@ -744,21 +683,19 @@ inline ConnErrType TcrConnection::sendData(uint32_t& timeSpent,
     }
 
     timeSpent += defaultWaitSecs;
-    sendTimeoutSec -= defaultWaitSecs;
-  }
-  if (isPublicApiTimeout) {  // it should go in millis
-    timeSpent = timeSpent / 1000;
-  } else {  // it should go in seconds
-    timeSpent = timeSpent / (1000 * 1000);
+    sendTimeout -= defaultWaitSecs;
   }
+
   return (length == 0 ? CONN_NOERR : CONN_TIMEOUT);
 }
 
 char* TcrConnection::sendRequest(const char* buffer, int32_t len,
-                                 size_t* recvLen, uint32_t sendTimeoutSec,
-                                 uint32_t receiveTimeoutSec, int32_t request) {
+                                 size_t* recvLen,
+                                 std::chrono::microseconds sendTimeoutSec,
+                                 std::chrono::microseconds receiveTimeoutSec,
+                                 int32_t request) {
   LOGDEBUG("TcrConnection::sendRequest");
-  uint32_t timeSpent = 0;
+  std::chrono::microseconds timeSpent{0};
 
   send(timeSpent, buffer, len, sendTimeoutSec);
 
@@ -771,11 +708,10 @@ char* TcrConnection::sendRequest(const char* buffer, int32_t len,
   return readMessage(recvLen, receiveTimeoutSec, true, &opErr, false, request);
 }
 
-void TcrConnection::sendRequestForChunkedResponse(const TcrMessage& request,
-                                                  int32_t len,
-                                                  TcrMessageReply& reply,
-                                                  uint32_t sendTimeoutSec,
-                                                  uint32_t receiveTimeoutSec) {
+void TcrConnection::sendRequestForChunkedResponse(
+    const TcrMessage& request, int32_t len, TcrMessageReply& reply,
+    std::chrono::microseconds sendTimeoutSec,
+    std::chrono::microseconds receiveTimeoutSec) {
   int32_t msgType = request.getMessageType();
   // ACE_OS::memcpy(&msgType, buffer, 4);
   // msgType = ntohl(msgType);
@@ -826,8 +762,8 @@ void TcrConnection::sendRequestForChunkedResponse(const TcrMessage& request,
   }*/
 
   // send(buffer, len, sendTimeoutSec);
-  uint32_t timeSpent = 0;
-  send(timeSpent, request.getMsgData(), len, sendTimeoutSec, true, msgType);
+  std::chrono::microseconds timeSpent{0};
+  send(timeSpent, request.getMsgData(), len, sendTimeoutSec, true);
 
   if (timeSpent >= receiveTimeoutSec)
     throwException(
@@ -852,15 +788,17 @@ void TcrConnection::sendRequestForChunkedResponse(const TcrMessage& request,
   readMessageChunked(reply, receiveTimeoutSec, true);
 }
 
-void TcrConnection::send(const char* buffer, int len, uint32_t sendTimeoutSec,
+void TcrConnection::send(const char* buffer, int len,
+                         std::chrono::microseconds sendTimeoutSec,
                          bool checkConnected) {
-  uint32_t dummy = 0;
+  std::chrono::microseconds dummy;
   send(dummy, buffer, len, sendTimeoutSec, checkConnected);
 }
 
-void TcrConnection::send(uint32_t& timeSpent, const char* buffer, int len,
-                         uint32_t sendTimeoutSec, bool checkConnected,
-                         int32_t notPublicApiWithTimeout) {
+void TcrConnection::send(std::chrono::microseconds& timeSpent,
+                         const char* buffer, int len,
+                         std::chrono::microseconds sendTimeoutSec,
+                         bool checkConnected) {
   GF_DEV_ASSERT(m_conn != nullptr);
 
   // LOGINFO("TcrConnection::send: [%p] sending request to endpoint %s;",
@@ -870,8 +808,7 @@ void TcrConnection::send(uint32_t& timeSpent, const char* buffer, int len,
       "TcrConnection::send: [%p] sending request to endpoint %s; bytes: %s",
       this, m_endpoint, Utils::convertBytesToString(buffer, len)->asChar());
 
-  ConnErrType error = sendData(timeSpent, buffer, len, sendTimeoutSec,
-                               checkConnected, notPublicApiWithTimeout);
+  ConnErrType error = sendData(timeSpent, buffer, len, sendTimeoutSec);
 
   LOGFINER(
       "TcrConnection::send: completed send request to endpoint %s "
@@ -890,13 +827,14 @@ void TcrConnection::send(uint32_t& timeSpent, const char* buffer, int len,
 }
 
 char* TcrConnection::receive(size_t* recvLen, ConnErrType* opErr,
-                             uint32_t receiveTimeoutSec) {
+                             std::chrono::microseconds receiveTimeoutSec) {
   GF_DEV_ASSERT(m_conn != nullptr);
 
   return readMessage(recvLen, receiveTimeoutSec, false, opErr, true);
 }
 
-char* TcrConnection::readMessage(size_t* recvLen, uint32_t receiveTimeoutSec,
+char* TcrConnection::readMessage(size_t* recvLen,
+                                 std::chrono::microseconds receiveTimeoutSec,
                                  bool doHeaderTimeoutRetries,
                                  ConnErrType* opErr, bool isNotificationMessage,
                                  int32_t request) {
@@ -904,7 +842,7 @@ char* TcrConnection::readMessage(size_t* recvLen, uint32_t receiveTimeoutSec,
   int32_t msgType, msgLen;
   ConnErrType error;
 
-  uint32_t headerTimeout = receiveTimeoutSec;
+  std::chrono::microseconds headerTimeout = receiveTimeoutSec;
   if (doHeaderTimeoutRetries &&
       receiveTimeoutSec == DEFAULT_READ_TIMEOUT_SECS) {
     headerTimeout = DEFAULT_READ_TIMEOUT_SECS * DEFAULT_TIMEOUT_RETRIES;
@@ -970,7 +908,7 @@ char* TcrConnection::readMessage(size_t* recvLen, uint32_t receiveTimeoutSec,
   GF_NEW(fullMessage, char[HEADER_LENGTH + msgLen]);
   ACE_OS::memcpy(fullMessage, msg_header, HEADER_LENGTH);
 
-  uint32_t mesgBodyTimeout = receiveTimeoutSec;
+  std::chrono::microseconds mesgBodyTimeout = receiveTimeoutSec;
   if (isNotificationMessage) {
     mesgBodyTimeout = receiveTimeoutSec * DEFAULT_TIMEOUT_RETRIES;
   }
@@ -1019,15 +957,15 @@ char* TcrConnection::readMessage(size_t* recvLen, uint32_t receiveTimeoutSec,
   return fullMessage;
 }
 
-void TcrConnection::readMessageChunked(TcrMessageReply& reply,
-                                       uint32_t receiveTimeoutSec,
-                                       bool doHeaderTimeoutRetries) {
+void TcrConnection::readMessageChunked(
+    TcrMessageReply& reply, std::chrono::microseconds receiveTimeoutSec,
+    bool doHeaderTimeoutRetries) {
   const int HDR_LEN = 5;
   const int HDR_LEN_12 = 12;
   uint8_t msg_header[HDR_LEN_12 + HDR_LEN];
   ConnErrType error;
 
-  uint32_t headerTimeout = receiveTimeoutSec;
+  std::chrono::microseconds headerTimeout = receiveTimeoutSec;
   if (doHeaderTimeoutRetries &&
       receiveTimeoutSec == DEFAULT_READ_TIMEOUT_SECS) {
     headerTimeout = DEFAULT_READ_TIMEOUT_SECS * DEFAULT_TIMEOUT_RETRIES;
@@ -1038,9 +976,8 @@ void TcrConnection::readMessageChunked(TcrMessageReply& reply,
       "endpoint %s",
       m_endpoint);
 
-  error =
-      receiveData(reinterpret_cast<char*>(msg_header), HDR_LEN_12 + HDR_LEN,
-                  headerTimeout, true, false, reply.getMessageTypeRequest());
+  error = receiveData(reinterpret_cast<char*>(msg_header), HDR_LEN_12 + HDR_LEN,
+                      headerTimeout, true, false);
   if (error != CONN_NOERR) {
     if (error & CONN_TIMEOUT) {
       throwException(TimeoutException(
@@ -1099,8 +1036,7 @@ void TcrConnection::readMessageChunked(TcrMessageReply& reply,
     // uint8_t chunk_header[HDR_LEN];
     if (!first) {
       error = receiveData(reinterpret_cast<char*>(msg_header + HDR_LEN_12),
-                          HDR_LEN, headerTimeout, true, false,
-                          reply.getMessageTypeRequest());
+                          HDR_LEN, headerTimeout, true, false);
       if (error != CONN_NOERR) {
         if (error & CONN_TIMEOUT) {
           throwException(TimeoutException(
@@ -1136,8 +1072,7 @@ void TcrConnection::readMessageChunked(TcrMessageReply& reply,
     uint8_t* chunk_body;
     GF_NEW(chunk_body, uint8_t[chunkLen]);
     error = receiveData(reinterpret_cast<char*>(chunk_body), chunkLen,
-                        receiveTimeoutSec, true, false,
-                        reply.getMessageTypeRequest());
+                        receiveTimeoutSec, true, false);
     if (error != CONN_NOERR) {
       delete[] chunk_body;
       if (error & CONN_TIMEOUT) {
@@ -1185,7 +1120,8 @@ void TcrConnection::close() {
   try {
     if (!TcrConnectionManager::TEST_DURABLE_CLIENT_CRASH &&
         !m_connectionManager->isNetDown()) {
-      send(closeMsg->getMsgData(), closeMsg->getMsgLength(), 2, false);
+      send(closeMsg->getMsgData(), closeMsg->getMsgLength(),
+           std::chrono::seconds(2), false);
     }
   } catch (Exception& e) {
     LOGINFO("Close connection message failed with msg: %s", e.getMessage());
@@ -1202,8 +1138,8 @@ void TcrConnection::close() {
  */
 // CacheableBytesPtr TcrConnection::readHandshakeData(uint32_t msgLength,
 // uint32_t connectTimeout )
-CacheableBytesPtr TcrConnection::readHandshakeData(int32_t msgLength,
-                                                   uint32_t connectTimeout) {
+CacheableBytesPtr TcrConnection::readHandshakeData(
+    int32_t msgLength, std::chrono::microseconds connectTimeout) {
   ConnErrType error = CONN_NOERR;
   if (msgLength < 0) {
     msgLength = 0;
@@ -1243,8 +1179,8 @@ CacheableBytesPtr TcrConnection::readHandshakeData(int32_t msgLength,
  * change the input parameter from unint32_t to int32_t
  * as the comparasion case is valid
  */
-CacheableBytesPtr TcrConnection::readHandshakeRawData(int32_t msgLength,
-                                                      uint32_t connectTimeout) {
+CacheableBytesPtr TcrConnection::readHandshakeRawData(
+    int32_t msgLength, std::chrono::microseconds connectTimeout) {
   ConnErrType error = CONN_NOERR;
   if (msgLength < 0) {
     msgLength = 0;
@@ -1279,13 +1215,14 @@ CacheableBytesPtr TcrConnection::readHandshakeRawData(int32_t msgLength,
 
 // read a byte array
 CacheableBytesPtr TcrConnection::readHandshakeByteArray(
-    uint32_t connectTimeout) {
+    std::chrono::microseconds connectTimeout) {
   uint32_t arraySize = readHandshakeArraySize(connectTimeout);
   return readHandshakeRawData(arraySize, connectTimeout);
 }
 
 // read a byte array
-uint32_t TcrConnection::readHandshakeArraySize(uint32_t connectTimeout) {
+uint32_t TcrConnection::readHandshakeArraySize(
+    std::chrono::microseconds connectTimeout) {
   CacheableBytesPtr codeBytes = readHandshakeData(1, connectTimeout);
   auto codeDI =
       m_connectionManager->getCacheImpl()->getCache()->createDataInput(
@@ -1322,7 +1259,8 @@ uint32_t TcrConnection::readHandshakeArraySize(uint32_t connectTimeout) {
   return arraySize;
 }
 
-void TcrConnection::readHandshakeInstantiatorMsg(uint32_t connectTimeout) {
+void TcrConnection::readHandshakeInstantiatorMsg(
+    std::chrono::microseconds connectTimeout) {
   int hashMapSize = readHandshakeArraySize(connectTimeout);
   for (int i = 0; i < hashMapSize; i++) {
     readHandShakeBytes(6, connectTimeout);  // reading integer and arraylist
@@ -1350,8 +1288,8 @@ void TcrConnection::readHandshakeInstantiatorMsg(uint32_t connectTimeout) {
     }
   }
 }
-void TcrConnection::readHandShakeBytes(int numberOfBytes,
-                                       uint32_t connectTimeout) {
+void TcrConnection::readHandShakeBytes(
+    int numberOfBytes, std::chrono::microseconds connectTimeout) {
   ConnErrType error = CONN_NOERR;
   uint8_t* recvMessage;
   GF_NEW(recvMessage, uint8_t[numberOfBytes]);
@@ -1376,7 +1314,8 @@ void TcrConnection::readHandShakeBytes(int numberOfBytes,
   GF_SAFE_DELETE_ARRAY(recvMessage);
 }
 
-int32_t TcrConnection::readHandShakeInt(uint32_t connectTimeout) {
+int32_t TcrConnection::readHandShakeInt(
+    std::chrono::microseconds connectTimeout) {
   ConnErrType error = CONN_NOERR;
   uint8_t* recvMessage;
   GF_NEW(recvMessage, uint8_t[4]);
@@ -1406,7 +1345,8 @@ int32_t TcrConnection::readHandShakeInt(uint32_t connectTimeout) {
 
   return val;
 }
-CacheableStringPtr TcrConnection::readHandshakeString(uint32_t connectTimeout) {
+CacheableStringPtr TcrConnection::readHandshakeString(
+    std::chrono::microseconds connectTimeout) {
   ConnErrType error = CONN_NOERR;
 
   char cstypeid;
@@ -1486,12 +1426,12 @@ CacheableStringPtr TcrConnection::readHandshakeString(uint32_t connectTimeout) {
     return retval;
   }
 }
-bool TcrConnection::hasExpired(int expiryTime) {
-  if (expiryTime == -1) {
+bool TcrConnection::hasExpired(const std::chrono::milliseconds& expiryTime) {
+  if (expiryTime.count() < 0) {
     return false;
   }
 
-  ACE_Time_Value _expiryTime(expiryTime / 1000, (expiryTime % 1000) * 1000);
+  ACE_Time_Value _expiryTime(expiryTime);
 
   if (ACE_OS::gettimeofday() - m_creationTime > _expiryTime) {
     return true;
@@ -1500,12 +1440,12 @@ bool TcrConnection::hasExpired(int expiryTime) {
   }
 }
 
-bool TcrConnection::isIdle(int idleTime) {
-  if (idleTime == -1) {
+bool TcrConnection::isIdle(const std::chrono::milliseconds& idleTime) {
+  if (idleTime.count() < 0) {
     return false;
   }
 
-  ACE_Time_Value _idleTime(idleTime / 1000, (idleTime % 1000) * 1000);
+  ACE_Time_Value _idleTime(idleTime);
 
   if (ACE_OS::gettimeofday() - m_lastAccessed > _idleTime) {
     return true;
diff --git a/cppcache/src/TcrConnection.hpp b/cppcache/src/TcrConnection.hpp
index fc8f54f8..f6722545 100644
--- a/cppcache/src/TcrConnection.hpp
+++ b/cppcache/src/TcrConnection.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_TCRCONNECTION_H_
-#define GEODE_TCRCONNECTION_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,14 +15,23 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_TCRCONNECTION_H_
+#define GEODE_TCRCONNECTION_H_
+
 #include <atomic>
+#include <chrono>
+
 #include <ace/Semaphore.h>
+
 #include <geode/geode_globals.hpp>
 #include <geode/ExceptionTypes.hpp>
+#include <geode/CacheableBuiltins.hpp>
+
 #include "Connector.hpp"
 #include "Set.hpp"
 #include "TcrMessage.hpp"
-#include <geode/CacheableBuiltins.hpp>
 #include "DiffieHellman.hpp"
 
 #define DEFAULT_TIMEOUT_RETRIES 12
@@ -106,11 +110,10 @@ class CPPCACHE_EXPORT TcrConnection {
    * @param     ports     List of local ports for connections to endpoint
    * @param     numPorts  Size of ports list
    */
-  bool InitTcrConnection(TcrEndpoint* endpointObj, const char* endpoint,
-                         Set<uint16_t>& ports,
-                         bool isClientNotification = false,
-                         bool isSecondary = false,
-                         uint32_t connectTimeout = DEFAULT_CONNECT_TIMEOUT);
+  bool InitTcrConnection(
+      TcrEndpoint* endpointObj, const char* endpoint, Set<uint16_t>& ports,
+      bool isClientNotification = false, bool isSecondary = false,
+      std::chrono::microseconds connectTimeout = DEFAULT_CONNECT_TIMEOUT);
 
   TcrConnection(const TcrConnectionManager& connectionManager,
                 volatile const bool& isConnected)
@@ -160,10 +163,11 @@ class CPPCACHE_EXPORT TcrConnection {
    * @exception  TimeoutException  if timeout happens at any of the 3 socket
    * operation: 1 write, 2 read
    */
-  char* sendRequest(const char* buffer, int32_t len, size_t* recvLen,
-                    uint32_t sendTimeoutSec = DEFAULT_WRITE_TIMEOUT,
-                    uint32_t receiveTimeoutSec = DEFAULT_READ_TIMEOUT_SECS,
-                    int32_t request = -1);
+  char* sendRequest(
+      const char* buffer, int32_t len, size_t* recvLen,
+      std::chrono::microseconds sendTimeoutSec = DEFAULT_WRITE_TIMEOUT,
+      std::chrono::microseconds receiveTimeoutSec = DEFAULT_READ_TIMEOUT_SECS,
+      int32_t request = -1);
 
   /**
    * send a synchronized request to server for REGISTER_INTEREST_LIST.
@@ -179,8 +183,8 @@ class CPPCACHE_EXPORT TcrConnection {
    */
   void sendRequestForChunkedResponse(
       const TcrMessage& request, int32_t len, TcrMessageReply& message,
-      uint32_t sendTimeoutSec = DEFAULT_WRITE_TIMEOUT,
-      uint32_t receiveTimeoutSec = DEFAULT_READ_TIMEOUT_SECS);
+      std::chrono::microseconds sendTimeoutSec = DEFAULT_WRITE_TIMEOUT,
+      std::chrono::microseconds receiveTimeoutSec = DEFAULT_READ_TIMEOUT_SECS);
 
   /**
    * send an asynchronized request to server. No response is expected.
@@ -195,14 +199,12 @@ class CPPCACHE_EXPORT TcrConnection {
    * operation: 1 write, 2 read
    */
   void send(const char* buffer, int len,
-            uint32_t sendTimeoutSec = DEFAULT_WRITE_TIMEOUT,
+            std::chrono::microseconds sendTimeoutSec = DEFAULT_WRITE_TIMEOUT,
             bool checkConnected = true);
 
-  void send(
-      uint32_t& timeSpent, const char* buffer, int len,
-      uint32_t sendTimeoutSec = DEFAULT_WRITE_TIMEOUT,
-      bool checkConnected = true,
-      int32_t notPublicApiWithTimeout = -2 /*NOT_PUBLIC_API_WITH_TIMEOUT*/);
+  void send(std::chrono::microseconds& timeSpent, const char* buffer, int len,
+            std::chrono::microseconds sendTimeoutSec = DEFAULT_WRITE_TIMEOUT,
+            bool checkConnected = true);
 
   /**
    * This method is for receiving client notification. It will read 2 times as
@@ -215,8 +217,9 @@ class CPPCACHE_EXPORT TcrConnection {
    * @exception  TimeoutException  if timeout happens at any of the 3 socket
    * operation: 1 write, 2 read
    */
-  char* receive(size_t* recvLen, ConnErrType* opErr,
-                uint32_t receiveTimeoutSec = DEFAULT_READ_TIMEOUT_SECS);
+  char* receive(
+      size_t* recvLen, ConnErrType* opErr,
+      std::chrono::microseconds receiveTimeoutSec = DEFAULT_READ_TIMEOUT_SECS);
 
   //  readMessage is now public
   /**
@@ -229,7 +232,8 @@ class CPPCACHE_EXPORT TcrConnection {
    * @exception  GeodeIOException  if an I/O error occurs (socket failure).
    * @exception  TimeoutException  if timeout happens during read
    */
-  char* readMessage(size_t* recvLen, uint32_t receiveTimeoutSec,
+  char* readMessage(size_t* recvLen,
+                    std::chrono::microseconds receiveTimeoutSec,
                     bool doHeaderTimeoutRetries, ConnErrType* opErr,
                     bool isNotificationMessage = false, int32_t request = -1);
 
@@ -243,7 +247,8 @@ class CPPCACHE_EXPORT TcrConnection {
    * @exception  GeodeIOException  if an I/O error occurs (socket failure).
    * @exception  TimeoutException  if timeout happens during read
    */
-  void readMessageChunked(TcrMessageReply& reply, uint32_t receiveTimeoutSec,
+  void readMessageChunked(TcrMessageReply& reply,
+                          std::chrono::microseconds receiveTimeoutSec,
                           bool doHeaderTimeoutRetries);
 
   /**
@@ -267,8 +272,8 @@ class CPPCACHE_EXPORT TcrConnection {
 
   // helpers for pool connection manager
   void touch();
-  bool hasExpired(int expiryTime);
-  bool isIdle(int idleTime);
+  bool hasExpired(const std::chrono::milliseconds& expiryTime);
+  bool isIdle(const std::chrono::milliseconds& idleTime);
   ACE_Time_Value getLastAccessed();
   void updateCreationTime();
 
@@ -310,7 +315,7 @@ class CPPCACHE_EXPORT TcrConnection {
    * To read Intantiator message(which meant for java client), here we are
    * ignoring it
    */
-  void readHandshakeInstantiatorMsg(uint32_t connectTimeout);
+  void readHandshakeInstantiatorMsg(std::chrono::microseconds connectTimeout);
 
   /**
    * Packs the override settings bits into bytes - currently a single byte for
@@ -321,77 +326,69 @@ class CPPCACHE_EXPORT TcrConnection {
   /**
    * To read the from stream
    */
-  int32_t readHandShakeInt(uint32_t connectTimeout);
+  int32_t readHandShakeInt(std::chrono::microseconds connectTimeout);
 
   /*
    * To read the arraysize
    */
-  uint32_t readHandshakeArraySize(uint32_t connectTimeout);
+  uint32_t readHandshakeArraySize(std::chrono::microseconds connectTimeout);
 
   /*
    * This function reads "numberOfBytes" and ignores it.
    */
-  void readHandShakeBytes(int numberOfBytes, uint32_t connectTimeout);
+  void readHandShakeBytes(int numberOfBytes,
+                          std::chrono::microseconds connectTimeout);
 
   /** Create a normal or SSL connection */
-  Connector* createConnection(const char* ipaddr,
-                              uint32_t waitSeconds = DEFAULT_CONNECT_TIMEOUT,
-                              int32_t maxBuffSizePool = 0);
+  Connector* createConnection(
+      const char* ipaddr,
+      std::chrono::microseconds waitSeconds = DEFAULT_CONNECT_TIMEOUT,
+      int32_t maxBuffSizePool = 0);
 
   /**
    * Reads bytes from socket and handles error conditions in case of Handshake.
    */
-  /* adongre
-   * CID 28738: Unsigned compared against 0 (NO_EFFECT)
-   * This less-than-zero comparison of an unsigned value is never true.
-   * "msgLength < 0U".
-   */
   CacheableBytesPtr readHandshakeData(int32_t msgLength,
-                                      uint32_t connectTimeout);
+                                      std::chrono::microseconds connectTimeout);
 
   /**
    * Reads raw bytes (without appending nullptr terminator) from socket and
    * handles error conditions in case of Handshake.
    */
-  /* adongre
-   * CID 28739: Unsigned compared against 0 (NO_EFFECT)
-   * change the input parameter from unint32_t to int32_t
-   * as the comparasion case is valid
-   */
-  // CacheableBytesPtr readHandshakeRawData( uint32_t msgLength, uint32_t
-  // connectTimeout );
-  CacheableBytesPtr readHandshakeRawData(int32_t msgLength,
-                                         uint32_t connectTimeout);
+  CacheableBytesPtr readHandshakeRawData(
+      int32_t msgLength, std::chrono::microseconds connectTimeout);
   /**
    * Reads a string from socket and handles error conditions in case of
    * Handshake.
    */
-  CacheableStringPtr readHandshakeString(uint32_t connectTimeout);
+  CacheableStringPtr readHandshakeString(
+      std::chrono::microseconds connectTimeout);
 
   /**
    * Reads a byte array (using initial length) from socket and handles error
    * conditions in case of Handshake.
    */
-  CacheableBytesPtr readHandshakeByteArray(uint32_t connectTimeout);
+  CacheableBytesPtr readHandshakeByteArray(
+      std::chrono::microseconds connectTimeout);
 
   /**
-   * Send data to the connection till sendTimeoutSec
+   * Send data to the connection till sendTimeout
    */
   ConnErrType sendData(const char* buffer, int32_t length,
-                       uint32_t sendTimeoutSec, bool checkConnected = true);
+                       std::chrono::microseconds sendTimeout,
+                       bool checkConnected = true);
 
-  ConnErrType sendData(
-      uint32_t& timeSpent, const char* buffer, int32_t length,
-      uint32_t sendTimeoutSec, bool checkConnected = true,
-      int32_t notPublicApiWithTimeout = -2 /*NOT_PUBLIC_API_WITH_TIMEOUT*/);
+  ConnErrType sendData(std::chrono::microseconds& timeSpent, const char* buffer,
+                       int32_t length, std::chrono::microseconds sendTimeout,
+                       bool checkConnected = true);
 
   /**
    * Read data from the connection till receiveTimeoutSec
    */
-  ConnErrType receiveData(
-      char* buffer, int32_t length, uint32_t receiveTimeoutSec,
-      bool checkConnected = true, bool isNotificationMessage = false,
-      int32_t notPublicApiWithTimeout = -2 /*NOT_PUBLIC_API_WITH_TIMEOUT*/);
+  ConnErrType receiveData(char* buffer, int32_t length,
+                          std::chrono::microseconds receiveTimeoutSec,
+                          bool checkConnected = true,
+                          bool isNotificationMessage = false);
 
   const char* m_endpoint;
   TcrEndpoint* m_endpointObj;
diff --git a/cppcache/src/TcrConnectionManager.cpp b/cppcache/src/TcrConnectionManager.cpp
index 714f4799..94a70ce5 100644
--- a/cppcache/src/TcrConnectionManager.cpp
+++ b/cppcache/src/TcrConnectionManager.cpp
@@ -72,17 +72,17 @@ void TcrConnectionManager::init(bool isPool) {
   }
   auto &props = m_cache->getDistributedSystem().getSystemProperties();
   m_isDurable = strlen(props.durableClientId()) > 0;
-  int32_t pingInterval = (props.pingInterval() / 2);
+  auto pingInterval = (props.pingInterval() / 2);
   if (!props.isGridClient() && !isPool) {
     ACE_Event_Handler *connectionChecker =
         new ExpiryHandler_T<TcrConnectionManager>(
             this, &TcrConnectionManager::checkConnection);
     m_pingTaskId = m_cache->getExpiryTaskManager().scheduleExpiryTask(
-        connectionChecker, 10, pingInterval, false);
+        connectionChecker, std::chrono::seconds(10), pingInterval, false);
     LOGFINE(
         "TcrConnectionManager::TcrConnectionManager Registered ping "
         "task with id = %ld, interval = %ld",
-        m_pingTaskId, pingInterval);
+        m_pingTaskId, pingInterval.count());
   }
 
   CacheAttributesPtr cacheAttributes = m_cache->getAttributes();
@@ -105,14 +105,15 @@ void TcrConnectionManager::init(bool isPool) {
     ACE_Event_Handler *redundancyChecker =
         new ExpiryHandler_T<TcrConnectionManager>(
             this, &TcrConnectionManager::checkRedundancy);
-    int32_t redundancyMonitorInterval = props.redundancyMonitorInterval();
+    const auto redundancyMonitorInterval = props.redundancyMonitorInterval();
 
     m_servermonitorTaskId = m_cache->getExpiryTaskManager().scheduleExpiryTask(
-        redundancyChecker, 1, redundancyMonitorInterval, false);
+        redundancyChecker, std::chrono::seconds(1), redundancyMonitorInterval,
+        false);
     LOGFINE(
         "TcrConnectionManager::TcrConnectionManager Registered server "
         "monitor task with id = %ld, interval = %ld",
-        m_servermonitorTaskId, redundancyMonitorInterval);
+        m_servermonitorTaskId, redundancyMonitorInterval.count());
 
     if (ThinClientBaseDM::isFatalError(err)) {
       GfErrTypeToException("TcrConnectionManager::init", err);
diff --git a/cppcache/src/TcrConnectionManager.hpp b/cppcache/src/TcrConnectionManager.hpp
index bb9afbc3..2fec248a 100644
--- a/cppcache/src/TcrConnectionManager.hpp
+++ b/cppcache/src/TcrConnectionManager.hpp
@@ -32,7 +32,6 @@
 #include "ace/config-lite.h"
 #include "ace/Versioned_Namespace.h"
 #include "Queue.hpp"
-#include "EventIdMap.hpp"
 #include "ThinClientRedundancyManager.hpp"
 
 ACE_BEGIN_VERSIONED_NAMESPACE_DECL
diff --git a/cppcache/src/TcrEndpoint.cpp b/cppcache/src/TcrEndpoint.cpp
index 6a1d05f5..3c8a100b 100644
--- a/cppcache/src/TcrEndpoint.cpp
+++ b/cppcache/src/TcrEndpoint.cpp
@@ -122,7 +122,7 @@ inline bool TcrEndpoint::needtoTakeConnectLock() {
 #ifdef __linux
   if (m_cacheImpl->getDistributedSystem()
           .getSystemProperties()
-          .connectWaitTimeout() > 0) {
+          .connectWaitTimeout() > std::chrono::seconds::zero()) {
     return m_needToConnectInLock;  // once pipe or other socket error will take
                                    // lock to connect.
   }
@@ -132,16 +132,14 @@ inline bool TcrEndpoint::needtoTakeConnectLock() {
 #endif
 }
 
-GfErrType TcrEndpoint::createNewConnectionWL(TcrConnection*& newConn,
-                                             bool isClientNotification,
-                                             bool isSecondary,
-                                             uint32_t connectTimeout) {
+GfErrType TcrEndpoint::createNewConnectionWL(
+    TcrConnection*& newConn, bool isClientNotification, bool isSecondary,
+    std::chrono::microseconds connectTimeout) {
   LOGFINE("TcrEndpoint::createNewConnectionWL");
-  uint32_t connectWaitTimeout = m_cacheImpl->getDistributedSystem()
-                                    .getSystemProperties()
-                                    .connectWaitTimeout() *
-                                1000;  // need to change
-  ACE_Time_Value interval(0, connectWaitTimeout);
+  auto connectWaitTimeout = m_cacheImpl->getDistributedSystem()
+                                .getSystemProperties()
+                                .connectWaitTimeout();
+  ACE_Time_Value interval(connectWaitTimeout);
   ACE_Time_Value stopAt(ACE_OS::gettimeofday());
   stopAt += interval;
   bool connCreated = false;
@@ -201,12 +199,12 @@ GfErrType TcrEndpoint::createNewConnectionWL(TcrConnection*& newConn,
 
 GfErrType TcrEndpoint::createNewConnection(
     TcrConnection*& newConn, bool isClientNotification, bool isSecondary,
-    uint32_t connectTimeout, int32_t timeoutRetries,
+    std::chrono::microseconds connectTimeout, int32_t timeoutRetries,
     bool sendUpdateNotification, bool appThreadRequest) {
   LOGFINE(
       "TcrEndpoint::createNewConnection: connectTimeout =%d "
       "m_needToConnectInLock=%d appThreadRequest =%d",
-      connectTimeout, m_needToConnectInLock, appThreadRequest);
+      connectTimeout.count(), m_needToConnectInLock, appThreadRequest);
   GfErrType err = GF_NOERR;
   newConn = nullptr;
   while (timeoutRetries-- >= 0) {
@@ -604,7 +602,8 @@ int TcrEndpoint::receiveNotification(volatile bool& isRunning) {
     try {
       size_t dataLen;
       ConnErrType opErr = CONN_NOERR;
-      auto data = m_notifyConnection->receive(&dataLen, &opErr, 5);
+      auto data = m_notifyConnection->receive(&dataLen, &opErr,
+                                              std::chrono::seconds(5));
 
       if (opErr == CONN_IOERR) {
         // Endpoint is disconnected, this exception is expected
@@ -908,7 +907,8 @@ bool TcrEndpoint::isMultiUserMode() {
 GfErrType TcrEndpoint::sendRequestWithRetry(
     const TcrMessage& request, TcrMessageReply& reply, TcrConnection*& conn,
     bool& epFailure, std::string& failReason, int maxSendRetries,
-    bool useEPPool, int64_t requestedTimeout, bool isBgThread) {
+    bool useEPPool, std::chrono::microseconds requestedTimeout,
+    bool isBgThread) {
   GfErrType error = GF_NOTCON;
   bool createNewConn = false;
   // int32_t type = request.getMessageType();
@@ -926,7 +926,7 @@ GfErrType TcrEndpoint::sendRequestWithRetry(
       (const_cast<TcrMessage&>(request)).updateHeaderForRetry();
     }
 
-    int64_t timeout = requestedTimeout;
+    auto timeout = requestedTimeout;
     epFailure = false;
     if (useEPPool) {
       if (m_maxConnections == 0) {
@@ -966,9 +966,9 @@ GfErrType TcrEndpoint::sendRequestWithRetry(
       LOGFINER(
           "sendRequestWithRetry:: looking for connection in queue timeout = "
           "%d ",
-          timeout);
-      conn = m_opConnections.getUntil(
-          timeout);  // max wait time to get a connection
+          timeout.count());
+      // max wait time to get a connection
+      conn = m_opConnections.getUntil(timeout);
     }
     if (!m_connected) {
       return GF_NOTCON;
@@ -1088,18 +1088,18 @@ GfErrType TcrEndpoint::sendRequestWithRetry(
       if (useEPPool) {
         epFailure = true;
         failReason = "server connection could not be obtained";
-        if (timeout <= 0) {
+        if (timeout <= std::chrono::microseconds::zero()) {
           error = GF_TIMOUT;
           LOGWARN(
               "No connection available for %ld seconds "
               "for endpoint %s.",
-              requestedTimeout, m_name.c_str());
+              requestedTimeout.count(), m_name.c_str());
         } else {
           error = GF_NOTCON;
           LOGFINE(
               "Returning without connection with %d seconds remaining "
               "for endpoint %s.",
-              timeout, m_name.c_str());
+              timeout.count(), m_name.c_str());
         }
       } else {
         LOGERROR("Unexpected failure while sending request to server.");
@@ -1111,9 +1111,7 @@ GfErrType TcrEndpoint::sendRequestWithRetry(
   return error;
 }
 
-void TcrEndpoint::setRetryAndTimeout(const TcrMessage& request,
-                                     int& maxSendRetries,
-                                     uint32_t& requestedTimeout) {
+void TcrEndpoint::setRetry(const TcrMessage& request, int& maxSendRetries) {
   int32_t type = request.getMessageType();
   if (type == TcrMessage::QUERY || type == TcrMessage::QUERY_WITH_PARAMETERS ||
       type == TcrMessage::PUTALL || type == TcrMessage::PUT_ALL_WITH_CALLBACK ||
@@ -1127,17 +1125,16 @@ void TcrEndpoint::setRetryAndTimeout(const TcrMessage& request,
 
 GfErrType TcrEndpoint::send(const TcrMessage& request, TcrMessageReply& reply) {
   GfErrType error = GF_NOTCON;
-  int maxSendRetries = 1;
 
-  uint32_t requestedTimeout = reply.getTimeout();
-  setRetryAndTimeout(request, maxSendRetries, requestedTimeout);
+  int maxSendRetries = 1;
+  setRetry(request, maxSendRetries);
 
   TcrConnection* conn = nullptr;
   bool epFailure;
   std::string failReason;
   //  TODO: remove sendRetryCount as parameter.
   error = sendRequestWithRetry(request, reply, conn, epFailure, failReason,
-                               maxSendRetries, true, requestedTimeout);
+                               maxSendRetries, true, reply.getTimeout());
 
   if (error == GF_NOERR) {
     m_msgSent = true;
@@ -1168,10 +1165,9 @@ GfErrType TcrEndpoint::sendRequestConnWithRetry(const TcrMessage& request,
                                                 TcrConnection*& conn,
                                                 bool isBgThread) {
   GfErrType error = GF_NOTCON;
-  int maxSendRetries = 1;
 
-  uint32_t requestedTimeout = reply.getTimeout();
-  setRetryAndTimeout(request, maxSendRetries, requestedTimeout);
+  int maxSendRetries = 1;
+  setRetry(request, maxSendRetries);
 
   //  Retry on the following send errors:
   // Timeout: 1 retry
@@ -1181,9 +1177,9 @@ GfErrType TcrEndpoint::sendRequestConnWithRetry(const TcrMessage& request,
   bool epFailure;
   std::string failReason;
   LOGFINE("sendRequestConnWithRetry:: maxSendRetries = %d ", maxSendRetries);
-  error =
-      sendRequestWithRetry(request, reply, conn, epFailure, failReason,
-                           maxSendRetries, false, requestedTimeout, isBgThread);
+  error = sendRequestWithRetry(request, reply, conn, epFailure, failReason,
+                               maxSendRetries, false, reply.getTimeout(),
+                               isBgThread);
   if (error == GF_NOERR) {
     m_msgSent = true;
   }
diff --git a/cppcache/src/TcrEndpoint.hpp b/cppcache/src/TcrEndpoint.hpp
index e259d409..4837059b 100644
--- a/cppcache/src/TcrEndpoint.hpp
+++ b/cppcache/src/TcrEndpoint.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_TCRENDPOINT_H_
-#define GEODE_TCRENDPOINT_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,13 +15,21 @@
  * limitations under the License.
  */
 
-#include <geode/geode_globals.hpp>
+#pragma once
+
+#ifndef GEODE_TCRENDPOINT_H_
+#define GEODE_TCRENDPOINT_H_
+
 #include <string>
 #include <list>
 #include <atomic>
+
 #include <ace/Recursive_Thread_Mutex.h>
 #include <ace/Semaphore.h>
+
+#include <geode/geode_globals.hpp>
 #include <geode/geode_base.hpp>
+
 #include "FairQueue.hpp"
 #include "Set.hpp"
 #include "TcrConnection.hpp"
@@ -35,12 +38,14 @@
 namespace apache {
 namespace geode {
 namespace client {
+
 class ThinClientRegion;
 class TcrMessage;
 class ThinClientBaseDM;
 class CacheImpl;
 class ThinClientPoolHADM;
 class ThinClientPoolDM;
+
 class CPPCACHE_EXPORT TcrEndpoint {
  public:
   TcrEndpoint(
@@ -74,7 +79,7 @@ class CPPCACHE_EXPORT TcrEndpoint {
                                  TcrMessageReply& reply, TcrConnection*& conn,
                                  bool& epFailure, std::string& failReason,
                                  int maxSendRetries, bool useEPPool,
-                                 int64_t requestedTimeout,
+                                 std::chrono::microseconds requestedTimeout,
                                  bool isBgThread = false);
   GfErrType sendRequestConnWithRetry(const TcrMessage& request,
                                      TcrMessageReply& reply,
@@ -144,7 +149,7 @@ class CPPCACHE_EXPORT TcrEndpoint {
   GfErrType createNewConnection(
       TcrConnection*& newConn, bool isClientNotification = false,
       bool isSecondary = false,
-      uint32_t connectTimeout = DEFAULT_CONNECT_TIMEOUT,
+      std::chrono::microseconds connectTimeout = DEFAULT_CONNECT_TIMEOUT,
       int32_t timeoutRetries = 1, bool sendUpdateNotification = true,
       bool appThreadRequest = false);
 
@@ -155,7 +160,7 @@ class CPPCACHE_EXPORT TcrEndpoint {
 
   GfErrType createNewConnectionWL(TcrConnection*& newConn,
                                   bool isClientNotification, bool isSecondary,
-                                  uint32_t connectTimeout);
+                                  std::chrono::microseconds connectTimeout);
 
   void setConnected(volatile bool connected = true) { m_connected = connected; }
   virtual ThinClientPoolDM* getPoolHADM() { return nullptr; }
@@ -220,8 +225,7 @@ class CPPCACHE_EXPORT TcrEndpoint {
   bool compareTransactionIds(int32_t reqTransId, int32_t replyTransId,
                              std::string& failReason, TcrConnection* conn);
   void closeConnections();
-  void setRetryAndTimeout(const TcrMessage& request, int& maxSendRetries,
-                          uint32_t& requestedTimeout);
+  void setRetry(const TcrMessage& request, int& maxSendRetries);
 
   std::string m_name;
   ACE_Recursive_Thread_Mutex m_connectionLock;
diff --git a/cppcache/src/TcrMessage.cpp b/cppcache/src/TcrMessage.cpp
index 845ae3a5..7e4c6230 100644
--- a/cppcache/src/TcrMessage.cpp
+++ b/cppcache/src/TcrMessage.cpp
@@ -90,11 +90,16 @@ void TcrMessage::writeBytePart(uint8_t byteValue) {
   m_request->write(byteValue);
 }
 
-void TcrMessage::writeByteAndTimeOutPart(uint8_t byteValue, int32_t timeout) {
+void TcrMessage::writeByteAndTimeOutPart(uint8_t byteValue,
+                                         std::chrono::milliseconds timeout) {
   m_request->writeInt((int32_t)5);  // 1 (byte) + 4 (timeout)
   m_request->write(static_cast<int8_t>(0));
   m_request->write(byteValue);
-  m_request->writeInt(timeout);
+  m_request->writeInt(static_cast<int32_t>(timeout.count()));
+}
+
+void TcrMessage::writeMillisecondsPart(std::chrono::milliseconds millis) {
+  writeIntPart(static_cast<int32_t>(millis.count()));
 }
 
 void TcrMessage::readBooleanPartAsObject(DataInput& input, bool* boolVal) {
@@ -1408,7 +1413,8 @@ void TcrMessage::handleByteArrayResponse(
 
 TcrMessageDestroyRegion::TcrMessageDestroyRegion(
     std::unique_ptr<DataOutput> dataOutput, const Region* region,
-    const SerializablePtr& aCallbackArgument, int messageResponsetimeout,
+    const SerializablePtr& aCallbackArgument,
+    std::chrono::milliseconds messageResponsetimeout,
     ThinClientBaseDM* connectionDM) {
   m_request = std::move(dataOutput);
   m_msgType = TcrMessage::DESTROY_REGION;
@@ -1426,15 +1432,16 @@ TcrMessageDestroyRegion::TcrMessageDestroyRegion(
 
   numOfParts++;
 
-  if (m_messageResponseTimeout != -1) numOfParts++;
+  if (m_messageResponseTimeout >= std::chrono::milliseconds::zero())
+    numOfParts++;
   writeHeader(m_msgType, numOfParts);
   writeRegionPart(m_regionName);
   writeEventIdPart();
   if (aCallbackArgument != nullptr) {
     writeObjectPart(aCallbackArgument);
   }
-  if (m_messageResponseTimeout != -1) {
-    writeIntPart(m_messageResponseTimeout);
+  if (m_messageResponseTimeout >= std::chrono::milliseconds::zero()) {
+    writeMillisecondsPart(m_messageResponseTimeout);
   }
 
   writeMessageLength();
@@ -1442,7 +1449,8 @@ TcrMessageDestroyRegion::TcrMessageDestroyRegion(
 
 TcrMessageClearRegion::TcrMessageClearRegion(
     std::unique_ptr<DataOutput> dataOutput, const Region* region,
-    const SerializablePtr& aCallbackArgument, int messageResponsetimeout,
+    const SerializablePtr& aCallbackArgument,
+    std::chrono::milliseconds messageResponsetimeout,
     ThinClientBaseDM* connectionDM) {
   m_request = std::move(dataOutput);
   m_msgType = TcrMessage::CLEAR_REGION;
@@ -1463,24 +1471,25 @@ TcrMessageClearRegion::TcrMessageClearRegion(
 
   numOfParts++;
 
-  if (m_messageResponseTimeout != -1) numOfParts++;
+  if (m_messageResponseTimeout >= std::chrono::milliseconds::zero())
+    numOfParts++;
   writeHeader(m_msgType, numOfParts);
   writeRegionPart(m_regionName);
   writeEventIdPart();
   if (aCallbackArgument != nullptr) {
     writeObjectPart(aCallbackArgument);
   }
-  if (m_messageResponseTimeout != -1) {
-    writeIntPart(m_messageResponseTimeout);
+  if (m_messageResponseTimeout >= std::chrono::milliseconds::zero()) {
+    writeMillisecondsPart(m_messageResponseTimeout);
   }
 
   writeMessageLength();
 }
 
-TcrMessageQuery::TcrMessageQuery(std::unique_ptr<DataOutput> dataOutput,
-                                 const std::string& regionName,
-                                 int messageResponsetimeout,
-                                 ThinClientBaseDM* connectionDM) {
+TcrMessageQuery::TcrMessageQuery(
+    std::unique_ptr<DataOutput> dataOutput, const std::string& regionName,
+    std::chrono::milliseconds messageResponsetimeout,
+    ThinClientBaseDM* connectionDM) {
   m_request = std::move(dataOutput);
   m_msgType = TcrMessage::QUERY;
   m_tcdm = connectionDM;
@@ -1492,20 +1501,21 @@ TcrMessageQuery::TcrMessageQuery(std::unique_ptr<DataOutput> dataOutput,
 
   numOfParts++;
 
-  if (m_messageResponseTimeout != -1) numOfParts++;
+  if (m_messageResponseTimeout >= std::chrono::milliseconds::zero())
+    numOfParts++;
   writeHeader(m_msgType, numOfParts);
   writeRegionPart(m_regionName);
   writeEventIdPart();
-  if (m_messageResponseTimeout != -1) {
-    writeIntPart(m_messageResponseTimeout);
+  if (m_messageResponseTimeout >= std::chrono::milliseconds::zero()) {
+    writeMillisecondsPart(m_messageResponseTimeout);
   }
   writeMessageLength();
 }
 
-TcrMessageStopCQ::TcrMessageStopCQ(std::unique_ptr<DataOutput> dataOutput,
-                                   const std::string& regionName,
-                                   int messageResponsetimeout,
-                                   ThinClientBaseDM* connectionDM) {
+TcrMessageStopCQ::TcrMessageStopCQ(
+    std::unique_ptr<DataOutput> dataOutput, const std::string& regionName,
+    std::chrono::milliseconds messageResponsetimeout,
+    ThinClientBaseDM* connectionDM) {
   m_request = std::move(dataOutput);
   m_msgType = TcrMessage::STOPCQ_MSG_TYPE;
   m_tcdm = connectionDM;
@@ -1520,20 +1530,23 @@ TcrMessageStopCQ::TcrMessageStopCQ(std::unique_ptr<DataOutput> dataOutput,
 
   numOfParts++;
 
-  if (m_messageResponseTimeout != -1) numOfParts++;
+  if (m_messageResponseTimeout >= std::chrono::milliseconds::zero()) {
+    numOfParts++;
+  }
+
   writeHeader(m_msgType, numOfParts);
   writeRegionPart(m_regionName);
   writeEventIdPart();
-  if (m_messageResponseTimeout != -1) {
-    writeIntPart(m_messageResponseTimeout);
+  if (m_messageResponseTimeout >= std::chrono::milliseconds::zero()) {
+    writeMillisecondsPart(m_messageResponseTimeout);
   }
   writeMessageLength();
 }
 
-TcrMessageCloseCQ::TcrMessageCloseCQ(std::unique_ptr<DataOutput> dataOutput,
-                                     const std::string& regionName,
-                                     int messageResponsetimeout,
-                                     ThinClientBaseDM* connectionDM) {
+TcrMessageCloseCQ::TcrMessageCloseCQ(
+    std::unique_ptr<DataOutput> dataOutput, const std::string& regionName,
+    std::chrono::milliseconds messageResponsetimeout,
+    ThinClientBaseDM* connectionDM) {
   m_request = std::move(dataOutput);
   m_msgType = TcrMessage::CLOSECQ_MSG_TYPE;
   m_tcdm = connectionDM;
@@ -1545,12 +1558,14 @@ TcrMessageCloseCQ::TcrMessageCloseCQ(std::unique_ptr<DataOutput> dataOutput,
 
   numOfParts++;
 
-  if (m_messageResponseTimeout != -1) numOfParts++;
+  if (m_messageResponseTimeout >= std::chrono::milliseconds::zero()) {
+    numOfParts++;
+  }
   writeHeader(m_msgType, numOfParts);
   writeRegionPart(m_regionName);
   writeEventIdPart();
-  if (m_messageResponseTimeout != -1) {
-    writeIntPart(m_messageResponseTimeout);
+  if (m_messageResponseTimeout >= std::chrono::milliseconds::zero()) {
+    writeMillisecondsPart(m_messageResponseTimeout);
   }
   writeMessageLength();
 }
@@ -1558,7 +1573,8 @@ TcrMessageCloseCQ::TcrMessageCloseCQ(std::unique_ptr<DataOutput> dataOutput,
 TcrMessageQueryWithParameters::TcrMessageQueryWithParameters(
     std::unique_ptr<DataOutput> dataOutput, const std::string& regionName,
     const SerializablePtr& aCallbackArgument, CacheableVectorPtr paramList,
-    int messageResponsetimeout, ThinClientBaseDM* connectionDM) {
+    std::chrono::milliseconds messageResponsetimeout,
+    ThinClientBaseDM* connectionDM) {
   m_request = std::move(dataOutput);
   m_msgType = TcrMessage::QUERY_WITH_PARAMETERS;
   m_tcdm = connectionDM;
@@ -1580,8 +1596,8 @@ TcrMessageQueryWithParameters::TcrMessageQueryWithParameters(
   writeIntPart(15);
 
   // Part-4: Request specific timeout
-  if (m_messageResponseTimeout != -1) {
-    writeIntPart(m_messageResponseTimeout);
+  if (m_messageResponseTimeout >= std::chrono::milliseconds::zero()) {
+    writeMillisecondsPart(m_messageResponseTimeout);
   }
   // Part-5: Parameters
   if (paramList != nullptr) {
@@ -2135,12 +2151,11 @@ TcrMessagePeriodicAck::TcrMessagePeriodicAck(
   writeMessageLength();
 }
 
-TcrMessagePutAll::TcrMessagePutAll(std::unique_ptr<DataOutput> dataOutput,
-                                   const Region* region,
-                                   const HashMapOfCacheable& map,
-                                   int messageResponsetimeout,
-                                   ThinClientBaseDM* connectionDM,
-                                   const SerializablePtr& aCallbackArgument) {
+TcrMessagePutAll::TcrMessagePutAll(
+    std::unique_ptr<DataOutput> dataOutput, const Region* region,
+    const HashMapOfCacheable& map,
+    std::chrono::milliseconds messageResponsetimeout,
+    ThinClientBaseDM* connectionDM, const SerializablePtr& aCallbackArgument) {
   m_tcdm = connectionDM;
   m_regionName = region->getFullPath();
   m_region = region;
@@ -2164,7 +2179,8 @@ TcrMessagePutAll::TcrMessagePutAll(std::unique_ptr<DataOutput> dataOutput,
 
   // numOfParts++;
 
-  if (m_messageResponseTimeout != -1) numOfParts++;
+  if (m_messageResponseTimeout >= std::chrono::milliseconds::zero())
+    numOfParts++;
 
   writeHeader(m_msgType, numOfParts);
   writeRegionPart(m_regionName);
@@ -2198,8 +2214,8 @@ TcrMessagePutAll::TcrMessagePutAll(std::unique_ptr<DataOutput> dataOutput,
     writeObjectPart(iter.second);
   }
 
-  if (m_messageResponseTimeout != -1) {
-    writeIntPart(m_messageResponseTimeout);
+  if (m_messageResponseTimeout >= std::chrono::milliseconds::zero()) {
+    writeMillisecondsPart(m_messageResponseTimeout);
   }
   writeMessageLength();
 }
@@ -2219,7 +2235,8 @@ TcrMessageRemoveAll::TcrMessageRemoveAll(std::unique_ptr<DataOutput> dataOutput,
   // value can be nullptr also.
   uint32_t numOfParts = 5 + static_cast<uint32_t>(keys.size());
 
-  if (m_messageResponseTimeout != -1) numOfParts++;
+  if (m_messageResponseTimeout >= std::chrono::milliseconds::zero())
+    numOfParts++;
   writeHeader(m_msgType, numOfParts);
   writeRegionPart(m_regionName);
   writeEventIdPart(static_cast<int>(keys.size() - 1));
@@ -2370,7 +2387,7 @@ TcrMessageExecuteCqWithIr::TcrMessageExecuteCqWithIr(
 TcrMessageExecuteFunction::TcrMessageExecuteFunction(
     std::unique_ptr<DataOutput> dataOutput, const std::string& funcName,
     const CacheablePtr& args, uint8_t getResult, ThinClientBaseDM* connectionDM,
-    int32_t timeout) {
+    std::chrono::milliseconds timeout) {
   m_request = std::move(dataOutput);
 
   m_msgType = TcrMessage::EXECUTE_FUNCTION;
@@ -2389,7 +2406,7 @@ TcrMessageExecuteRegionFunction::TcrMessageExecuteRegionFunction(
     std::unique_ptr<DataOutput> dataOutput, const std::string& funcName,
     const Region* region, const CacheablePtr& args,
     CacheableVectorPtr routingObj, uint8_t getResult,
-    CacheableHashSetPtr failedNodes, int32_t timeout,
+    CacheableHashSetPtr failedNodes, std::chrono::milliseconds timeout,
     ThinClientBaseDM* connectionDM, int8_t reExecute) {
   m_request = std::move(dataOutput);
 
@@ -2442,8 +2459,8 @@ TcrMessageExecuteRegionFunctionSingleHop::
         std::unique_ptr<DataOutput> dataOutput, const std::string& funcName,
         const Region* region, const CacheablePtr& args,
         CacheableHashSetPtr routingObj, uint8_t getResult,
-        CacheableHashSetPtr failedNodes, bool allBuckets, int32_t timeout,
-        ThinClientBaseDM* connectionDM) {
+        CacheableHashSetPtr failedNodes, bool allBuckets,
+        std::chrono::milliseconds timeout, ThinClientBaseDM* connectionDM) {
   m_request = std::move(dataOutput);
 
   m_msgType = TcrMessage::EXECUTE_REGION_FUNCTION_SINGLE_HOP;
@@ -2874,9 +2891,11 @@ int32_t TcrMessage::getTransId() const { return m_txId; }
 
 void TcrMessage::setTransId(int32_t txId) { m_txId = txId; }
 
-uint32_t TcrMessage::getTimeout() const { return m_timeout; }
+std::chrono::milliseconds TcrMessage::getTimeout() const { return m_timeout; }
 
-void TcrMessage::setTimeout(uint32_t timeout) { m_timeout = timeout; }
+void TcrMessage::setTimeout(std::chrono::milliseconds timeout) {
+  m_timeout = timeout;
+}
 
 void TcrMessage::skipParts(DataInput& input, int32_t numParts) {
   while (numParts > 0) {
diff --git a/cppcache/src/TcrMessage.hpp b/cppcache/src/TcrMessage.hpp
index 80953569..2a8e01be 100644
--- a/cppcache/src/TcrMessage.hpp
+++ b/cppcache/src/TcrMessage.hpp
@@ -20,31 +20,33 @@
 #ifndef GEODE_TCRMESSAGE_H_
 #define GEODE_TCRMESSAGE_H_
 
+#include <atomic>
+#include <string>
+#include <map>
+#include <vector>
+
 #include <ace/OS.h>
 
 #include <geode/geode_globals.hpp>
-#include <atomic>
 #include <geode/Cacheable.hpp>
 #include <geode/CacheableKey.hpp>
 #include <geode/CacheableString.hpp>
 #include <geode/DataOutput.hpp>
 #include <geode/DataInput.hpp>
 #include <geode/ExceptionTypes.hpp>
+#include <geode/VectorT.hpp>
+#include <geode/CacheableBuiltins.hpp>
+
 #include "InterestResultPolicy.hpp"
 #include "EventId.hpp"
 #include "EventIdMap.hpp"
-#include <geode/CacheableBuiltins.hpp>
 #include "TcrChunkedContext.hpp"
-#include <geode/VectorT.hpp>
 #include "GeodeTypeIdsImpl.hpp"
 #include "BucketServerLocation.hpp"
 #include "FixedPartitionAttributesImpl.hpp"
 #include "VersionTag.hpp"
 #include "VersionedCacheableObjectPartList.hpp"
 #include "SerializationRegistry.hpp"
-#include <string>
-#include <map>
-#include <vector>
 
 namespace apache {
 namespace geode {
@@ -334,8 +336,8 @@ class CPPCACHE_EXPORT TcrMessage {
   int32_t getTransId() const;
   void setTransId(int32_t txId);
 
-  uint32_t getTimeout() const;
-  void setTimeout(uint32_t timeout);
+  std::chrono::milliseconds getTimeout() const;
+  void setTimeout(std::chrono::milliseconds timeout);
 
   /* we need a static method to generate ping */
   /* The caller should not delete the message since it is global. */
@@ -564,7 +566,9 @@ class CPPCACHE_EXPORT TcrMessage {
   void writeInterestResultPolicyPart(InterestResultPolicy policy);
   void writeIntPart(int32_t intValue);
   void writeBytePart(uint8_t byteValue);
-  void writeByteAndTimeOutPart(uint8_t byteValue, int32_t timeout);
+  void writeMillisecondsPart(std::chrono::milliseconds millis);
+  void writeByteAndTimeOutPart(uint8_t byteValue,
+                               std::chrono::milliseconds timeout);
   void chunkSecurityHeader(int skipParts, const uint8_t* bytes, int32_t len,
                            uint8_t isLastChunkAndSecurityHeader);
 
@@ -605,7 +609,7 @@ class CPPCACHE_EXPORT TcrMessage {
   const Region* m_region;
   std::string m_regex;
   char m_interestPolicy;
-  uint32_t m_timeout;
+  std::chrono::milliseconds m_timeout;
   bool m_isDurable;
   bool m_receiveValues;
   bool m_hasCqsPart;
@@ -622,7 +626,7 @@ class CPPCACHE_EXPORT TcrMessage {
   uint32_t m_numCqPart;
   uint32_t m_msgTypeForCq;  // new part since 7.0 for cq event message type.
   std::map<std::string, int>* m_cqs;
-  int32_t m_messageResponseTimeout;
+  std::chrono::milliseconds m_messageResponseTimeout;
   bool m_boolValue;
   std::unique_ptr<DataInput> m_delta;
   uint8_t* m_deltaBytes;
@@ -646,7 +650,7 @@ class TcrMessageDestroyRegion : public TcrMessage {
   TcrMessageDestroyRegion(std::unique_ptr<DataOutput> dataOutput,
                           const Region* region,
                           const SerializablePtr& aCallbackArgument,
-                          int messageResponsetimeout,
+                          std::chrono::milliseconds messageResponsetimeout,
                           ThinClientBaseDM* connectionDM);
 
   virtual ~TcrMessageDestroyRegion() {}
@@ -659,7 +663,7 @@ class TcrMessageClearRegion : public TcrMessage {
   TcrMessageClearRegion(std::unique_ptr<DataOutput> dataOutput,
                         const Region* region,
                         const SerializablePtr& aCallbackArgument,
-                        int messageResponsetimeout,
+                        std::chrono::milliseconds messageResponsetimeout,
                         ThinClientBaseDM* connectionDM);
 
   virtual ~TcrMessageClearRegion() {}
@@ -670,7 +674,8 @@ class TcrMessageClearRegion : public TcrMessage {
 class TcrMessageQuery : public TcrMessage {
  public:
   TcrMessageQuery(std::unique_ptr<DataOutput> dataOutput,
-                  const std::string& regionName, int messageResponsetimeout,
+                  const std::string& regionName,
+                  std::chrono::milliseconds messageResponsetimeout,
                   ThinClientBaseDM* connectionDM);
 
   virtual ~TcrMessageQuery() {}
@@ -681,7 +686,8 @@ class TcrMessageQuery : public TcrMessage {
 class TcrMessageStopCQ : public TcrMessage {
  public:
   TcrMessageStopCQ(std::unique_ptr<DataOutput> dataOutput,
-                   const std::string& regionName, int messageResponsetimeout,
+                   const std::string& regionName,
+                   std::chrono::milliseconds messageResponsetimeout,
                    ThinClientBaseDM* connectionDM);
 
   virtual ~TcrMessageStopCQ() {}
@@ -692,7 +698,8 @@ class TcrMessageStopCQ : public TcrMessage {
 class TcrMessageCloseCQ : public TcrMessage {
  public:
   TcrMessageCloseCQ(std::unique_ptr<DataOutput> dataOutput,
-                    const std::string& regionName, int messageResponsetimeout,
+                    const std::string& regionName,
+                    std::chrono::milliseconds messageResponsetimeout,
                     ThinClientBaseDM* connectionDM);
 
   virtual ~TcrMessageCloseCQ() {}
@@ -702,12 +709,11 @@ class TcrMessageCloseCQ : public TcrMessage {
 
 class TcrMessageQueryWithParameters : public TcrMessage {
  public:
-  TcrMessageQueryWithParameters(std::unique_ptr<DataOutput> dataOutput,
-                                const std::string& regionName,
-                                const SerializablePtr& aCallbackArgument,
-                                CacheableVectorPtr paramList,
-                                int messageResponsetimeout,
-                                ThinClientBaseDM* connectionDM);
+  TcrMessageQueryWithParameters(
+      std::unique_ptr<DataOutput> dataOutput, const std::string& regionName,
+      const SerializablePtr& aCallbackArgument, CacheableVectorPtr paramList,
+      std::chrono::milliseconds messageResponsetimeout,
+      ThinClientBaseDM* connectionDM);
 
   virtual ~TcrMessageQueryWithParameters() {}
 
@@ -912,7 +918,8 @@ class TcrMessageMakePrimary : public TcrMessage {
 class TcrMessagePutAll : public TcrMessage {
  public:
   TcrMessagePutAll(std::unique_ptr<DataOutput> dataOutput, const Region* region,
-                   const HashMapOfCacheable& map, int messageResponsetimeout,
+                   const HashMapOfCacheable& map,
+                   std::chrono::milliseconds messageResponsetimeout,
                    ThinClientBaseDM* connectionDM,
                    const SerializablePtr& aCallbackArgument);
 
@@ -963,7 +970,7 @@ class TcrMessageExecuteRegionFunction : public TcrMessage {
       std::unique_ptr<DataOutput> dataOutput, const std::string& funcName,
       const Region* region, const CacheablePtr& args,
       CacheableVectorPtr routingObj, uint8_t getResult,
-      CacheableHashSetPtr failedNodes, int32_t timeout,
+      CacheableHashSetPtr failedNodes, std::chrono::milliseconds timeout,
       ThinClientBaseDM* connectionDM = nullptr, int8_t reExecute = 0);
 
   virtual ~TcrMessageExecuteRegionFunction() {}
@@ -977,8 +984,8 @@ class TcrMessageExecuteRegionFunctionSingleHop : public TcrMessage {
       std::unique_ptr<DataOutput> dataOutput, const std::string& funcName,
       const Region* region, const CacheablePtr& args,
       CacheableHashSetPtr routingObj, uint8_t getResult,
-      CacheableHashSetPtr failedNodes, bool allBuckets, int32_t timeout,
-      ThinClientBaseDM* connectionDM);
+      CacheableHashSetPtr failedNodes, bool allBuckets,
+      std::chrono::milliseconds timeout, ThinClientBaseDM* connectionDM);
 
   virtual ~TcrMessageExecuteRegionFunctionSingleHop() {}
 
@@ -1171,7 +1178,8 @@ class TcrMessageExecuteFunction : public TcrMessage {
   TcrMessageExecuteFunction(std::unique_ptr<DataOutput> dataOutput,
                             const std::string& funcName,
                             const CacheablePtr& args, uint8_t getResult,
-                            ThinClientBaseDM* connectionDM, int32_t timeout);
+                            ThinClientBaseDM* connectionDM,
+                            std::chrono::milliseconds timeout);
 
   virtual ~TcrMessageExecuteFunction() {}
 
diff --git a/cppcache/src/ThinClientLocatorHelper.cpp b/cppcache/src/ThinClientLocatorHelper.cpp
index 367bd270..2147b8f0 100644
--- a/cppcache/src/ThinClientLocatorHelper.cpp
+++ b/cppcache/src/ThinClientLocatorHelper.cpp
@@ -59,11 +59,9 @@ ThinClientLocatorHelper::ThinClientLocatorHelper(
   }
 }
 
-Connector* ThinClientLocatorHelper::createConnection(Connector*& conn,
-                                                     const char* hostname,
-                                                     int32_t port,
-                                                     uint32_t waitSeconds,
-                                                     int32_t maxBuffSizePool) {
+Connector* ThinClientLocatorHelper::createConnection(
+    Connector*& conn, const char* hostname, int32_t port,
+    std::chrono::microseconds waitSeconds, int32_t maxBuffSizePool) {
   Connector* socket = nullptr;
   auto& systemProperties = m_poolDM->getConnectionManager()
                                .getCacheImpl()
@@ -109,9 +107,7 @@ GfErrType ThinClientLocatorHelper::getAllServers(
       data->writeObject(&request);
       int sentLength = conn->send(
           (char*)(data->getBuffer()), data->getBufferLength(),
-          m_poolDM ? (m_poolDM->getReadTimeout() / 1000) * 1000 * 1000
-                   : 10 * 1000 * 1000,
-          0);
+          m_poolDM ? m_poolDM->getReadTimeout() : std::chrono::seconds(10));
       if (sentLength <= 0) {
         // conn->close(); delete conn; conn = nullptr;
         continue;
@@ -119,9 +115,7 @@ GfErrType ThinClientLocatorHelper::getAllServers(
       char buff[BUFF_SIZE];
       int receivedLength = conn->receive(
           buff, BUFF_SIZE,
-          m_poolDM ? (m_poolDM->getReadTimeout() / 1000) * 1000 * 1000
-                   : 10 * 1000 * 1000,
-          0);
+          m_poolDM ? m_poolDM->getReadTimeout() : std::chrono::seconds(10));
       // conn->close();
       // delete conn; conn = nullptr;
       if (receivedLength <= 0) {
@@ -205,9 +199,7 @@ GfErrType ThinClientLocatorHelper::getEndpointForNewCallBackConn(
       data->writeObject(&request);
       int sentLength = conn->send(
           (char*)(data->getBuffer()), data->getBufferLength(),
-          m_poolDM ? (m_poolDM->getReadTimeout() / 1000) * 1000 * 1000
-                   : sysProps.connectTimeout() * 1000 * 1000,
-          0);
+          m_poolDM ? m_poolDM->getReadTimeout() : sysProps.connectTimeout());
       if (sentLength <= 0) {
         // conn->close(); delete conn; conn = nullptr;
         continue;
@@ -215,9 +207,7 @@ GfErrType ThinClientLocatorHelper::getEndpointForNewCallBackConn(
       char buff[BUFF_SIZE];
       int receivedLength = conn->receive(
           buff, BUFF_SIZE,
-          m_poolDM ? (m_poolDM->getReadTimeout() / 1000) * 1000 * 1000
-                   : sysProps.connectTimeout() * 1000 * 1000,
-          0);
+          m_poolDM ? m_poolDM->getReadTimeout() : sysProps.connectTimeout());
       // conn->close();
       // delete conn; conn = nullptr;
       if (receivedLength <= 0) {
@@ -292,7 +282,10 @@ GfErrType ThinClientLocatorHelper::getEndpointForNewFwdConn(
       ConnectionWrapper cw(conn);
       createConnection(conn, serLoc.getServerName().c_str(), serLoc.getPort(),
                        sysProps.connectTimeout(), buffSize);
-      auto data = m_poolDM->getConnectionManager().getCacheImpl()->getCache()->createDataOutput();
+      auto data = m_poolDM->getConnectionManager()
+                      .getCacheImpl()
+                      ->getCache()
+                      ->createDataOutput();
       data->writeInt(1001);  // GOSSIPVERSION
       if (currentServer == nullptr) {
         LOGDEBUG("Creating ClientConnectionRequest");
@@ -307,9 +300,7 @@ GfErrType ThinClientLocatorHelper::getEndpointForNewFwdConn(
       }
       int sentLength = conn->send(
           (char*)(data->getBuffer()), data->getBufferLength(),
-          m_poolDM ? (m_poolDM->getReadTimeout() / 1000) * 1000 * 1000
-                   : sysProps.connectTimeout() * 1000 * 1000,
-          0);
+          m_poolDM ? m_poolDM->getReadTimeout() : sysProps.connectTimeout());
       if (sentLength <= 0) {
         // conn->close();
         // delete conn;
@@ -318,9 +309,7 @@ GfErrType ThinClientLocatorHelper::getEndpointForNewFwdConn(
       char buff[BUFF_SIZE];
       int receivedLength = conn->receive(
           buff, BUFF_SIZE,
-          m_poolDM ? (m_poolDM->getReadTimeout() / 1000) * 1000 * 1000
-                   : sysProps.connectTimeout() * 1000 * 1000,
-          0);
+          m_poolDM ? m_poolDM->getReadTimeout() : sysProps.connectTimeout());
       // conn->close();
       // delete conn;
       if (receivedLength <= 0) {
@@ -392,14 +381,15 @@ GfErrType ThinClientLocatorHelper::updateLocators(
       createConnection(conn, serLoc.getServerName().c_str(), serLoc.getPort(),
                        sysProps.connectTimeout(), buffSize);
       LocatorListRequest request(serverGrp);
-      auto data = m_poolDM->getConnectionManager().getCacheImpl()->getCache()->createDataOutput();
+      auto data = m_poolDM->getConnectionManager()
+                      .getCacheImpl()
+                      ->getCache()
+                      ->createDataOutput();
       data->writeInt((int32_t)1001);  // GOSSIPVERSION
       data->writeObject(&request);
       int sentLength = conn->send(
           (char*)(data->getBuffer()), data->getBufferLength(),
-          m_poolDM ? (m_poolDM->getReadTimeout() / 1000) * 1000 * 1000
-                   : sysProps.connectTimeout() * 1000 * 1000,
-          0);
+          m_poolDM ? m_poolDM->getReadTimeout() : sysProps.connectTimeout());
       if (sentLength <= 0) {
         //  conn->close();
         // delete conn;
@@ -409,9 +399,7 @@ GfErrType ThinClientLocatorHelper::updateLocators(
       char buff[BUFF_SIZE];
       int receivedLength = conn->receive(
           buff, BUFF_SIZE,
-          m_poolDM ? (m_poolDM->getReadTimeout() / 1000) * 1000 * 1000
-                   : sysProps.connectTimeout() * 1000 * 1000,
-          0);
+          m_poolDM ? m_poolDM->getReadTimeout() : sysProps.connectTimeout());
       // conn->close();
       // delete conn; conn = nullptr;
       if (receivedLength <= 0) {
diff --git a/cppcache/src/ThinClientLocatorHelper.hpp b/cppcache/src/ThinClientLocatorHelper.hpp
index 8ae1466c..36cf2dd9 100644
--- a/cppcache/src/ThinClientLocatorHelper.hpp
+++ b/cppcache/src/ThinClientLocatorHelper.hpp
@@ -59,7 +59,8 @@ class ThinClientLocatorHelper {
 
  private:
   Connector* createConnection(Connector*& conn, const char* hostname,
-                              int32_t port, uint32_t waitSeconds,
+                              int32_t port,
+                              std::chrono::microseconds waitSeconds,
                               int32_t maxBuffSizePool = 0);
   ACE_Thread_Mutex m_locatorLock;
   std::vector<ServerLocation> m_locHostPort;
diff --git a/cppcache/src/ThinClientPoolDM.cpp b/cppcache/src/ThinClientPoolDM.cpp
index 98d520e4..1045bf99 100644
--- a/cppcache/src/ThinClientPoolDM.cpp
+++ b/cppcache/src/ThinClientPoolDM.cpp
@@ -183,7 +183,7 @@ ThinClientPoolDM::ThinClientPoolDM(const char* name,
                              ? (poolSeparator + m_poolName)
                              : "");
 
-  const uint32_t durableTimeOut = sysProp.durableTimeout();
+  const auto durableTimeOut = sysProp.durableTimeout();
   m_memId = cacheImpl->getClientProxyMembershipIDFactory().create(
       hostName, hostAddr, hostPort, clientDurableId.c_str(), durableTimeOut);
 
@@ -281,7 +281,7 @@ void ThinClientPoolDM::startBackgroundThreads() {
   ACE_Event_Handler* pingHandler =
       new ExpiryHandler_T<ThinClientPoolDM>(this, &ThinClientPoolDM::doPing);
 
-  long pingInterval = getPingInterval() / (1000 * 2);
+  long pingInterval = getPingInterval().count() / (1000 * 2);
   if (pingInterval > 0) {
     LOGDEBUG(
         "ThinClientPoolDM::startBackgroundThreads: Scheduling ping task at %ld",
@@ -293,10 +293,10 @@ void ThinClientPoolDM::startBackgroundThreads() {
     LOGDEBUG(
         "ThinClientPoolDM::startBackgroundThreads: Not Scheduling ping task as "
         "ping interval %ld",
-        getPingInterval());
+        getPingInterval().count());
   }
 
-  long updateLocatorListInterval = getUpdateLocatorListInterval();
+  long updateLocatorListInterval = getUpdateLocatorListInterval().count();
 
   if (updateLocatorListInterval > 0) {
     m_updateLocatorListTask =
@@ -328,16 +328,17 @@ void ThinClientPoolDM::startBackgroundThreads() {
       this, &ThinClientPoolDM::manageConnections, NC_MC_Thread);
   m_connManageTask->start();
 
-  int idle = getIdleTimeout();
-  int load = getLoadConditioningInterval();
+  auto idle = getIdleTimeout();
+  auto load = getLoadConditioningInterval();
 
-  if (load != -1) {
-    if (load < idle || idle == -1) {
+  // TODO GEODE-3136 - consider using 0 rather than -1.
+  if (load.count() >= 0) {
+    if (load < idle || idle.count() < 0) {
       idle = load;
     }
   }
 
-  if (idle != -1) {
+  if (idle.count() != -1) {
     LOGDEBUG(
         "ThinClientPoolDM::startBackgroundThreads: Starting manageConnections "
         "task");
@@ -349,7 +350,7 @@ void ThinClientPoolDM::startBackgroundThreads() {
         "manageConnections task");
     m_connManageTaskId =
         m_connManager.getCacheImpl()->getExpiryTaskManager().scheduleExpiryTask(
-            connHandler, 1, idle / 1000 + 1, false);
+            connHandler, std::chrono::seconds(1), idle, false);
   }
 
   LOGDEBUG(
@@ -362,10 +363,10 @@ void ThinClientPoolDM::startBackgroundThreads() {
 
   LOGDEBUG(
       "ThinClientPoolDM::startBackgroundThreads: Starting pool stat sampler");
-  if (m_PoolStatsSampler == nullptr && getStatisticInterval() > -1 &&
+  if (m_PoolStatsSampler == nullptr && getStatisticInterval().count() > -1 &&
       props.statisticsEnabled()) {
     m_PoolStatsSampler = new PoolStatsSampler(
-        getStatisticInterval() / 1000 + 1, m_connManager.getCacheImpl(), this);
+        getStatisticInterval().count() / 1000 + 1, m_connManager.getCacheImpl(), this);
     m_PoolStatsSampler->start();
   }
 
@@ -399,9 +400,7 @@ void ThinClientPoolDM::cleanStaleConnections(volatile bool& isRunning) {
 
   LOGDEBUG("Cleaning stale connections");
 
-  int idle = getIdleTimeout();
-
-  ACE_Time_Value _idle(idle / 1000, (idle % 1000) * 1000);
+  ACE_Time_Value _idle(getIdleTimeout());
   ACE_Time_Value _nextIdle = _idle;
   {
     TcrConnection* conn = nullptr;
@@ -561,10 +560,11 @@ std::string ThinClientPoolDM::selectEndpoint(
     // Update Locator Request Stats
     getStats().incLoctorRequests();
 
-    if (GF_NOERR != ((ThinClientLocatorHelper*)m_locHelper)
-                        ->getEndpointForNewFwdConn(
-                            outEndpoint, additionalLoc, excludeServers,
-                            m_attrs->m_serverGrp, currentServer)) {
+    if (GF_NOERR !=
+        ((ThinClientLocatorHelper*)m_locHelper)
+            ->getEndpointForNewFwdConn(outEndpoint, additionalLoc,
+                                       excludeServers, m_attrs->m_serverGrp,
+                                       currentServer)) {
       throw IllegalStateException("Locator query failed");
     }
     // Update Locator stats
@@ -613,8 +613,9 @@ void ThinClientPoolDM::addConnection(TcrConnection* conn) {
   ++m_poolSize;
 }
 GfErrType ThinClientPoolDM::sendRequestToAllServers(
-    const char* func, uint8_t getResult, uint32_t timeout, CacheablePtr args,
-    ResultCollectorPtr& rs, CacheableStringPtr& exceptionPtr) {
+    const char* func, uint8_t getResult, std::chrono::milliseconds timeout,
+    CacheablePtr args, ResultCollectorPtr& rs,
+    CacheableStringPtr& exceptionPtr) {
   GfErrType err = GF_NOERR;
 
   getStats().setCurClientOps(++m_clientOps);
@@ -1367,8 +1368,8 @@ GfErrType ThinClientPoolDM::sendSyncRequest(
         type == TcrMessage::EXECUTE_REGION_FUNCTION_SINGLE_HOP ||
         type == TcrMessage::EXECUTECQ_WITH_IR_MSG_TYPE)) {
     // set only when message is not query, putall and executeCQ
-    reply.setTimeout(this->getReadTimeout() / 1000);
-    request.setTimeout(this->getReadTimeout() / 1000);
+    reply.setTimeout(this->getReadTimeout());
+    request.setTimeout(this->getReadTimeout());
   }
 
   bool retryAllEPsOnce = false;
@@ -1388,8 +1389,7 @@ GfErrType ThinClientPoolDM::sendSyncRequest(
     isAuthRequireExcep = false;
     if (!firstTry) request.updateHeaderForRetry();
     // if it's a query or putall and we had a timeout, just return with the
-    // newly
-    // selected endpoint without failover-retry
+    // newly selected endpoint without failover-retry
     if ((type == TcrMessage::QUERY ||
          type == TcrMessage::QUERY_WITH_PARAMETERS ||
          type == TcrMessage::PUTALL ||
@@ -1892,8 +1892,7 @@ GfErrType ThinClientPoolDM::createPoolConnection(
 TcrConnection* ThinClientPoolDM::getConnectionFromQueue(
     bool timeout, GfErrType* error, std::set<ServerLocation>& excludeServers,
     bool& maxConnLimit) {
-  int64_t timeoutTime = m_attrs->getFreeConnectionTimeout() /
-                        1000;  // in millisec so divide by 1000
+  std::chrono::microseconds timeoutTime = m_attrs->getFreeConnectionTimeout();
 
   getStats().setCurWaitingConnections(waiters());
   getStats().incWaitingConnections();
@@ -1903,10 +1902,8 @@ TcrConnection* ThinClientPoolDM::getConnectionFromQueue(
                                   ->getDistributedSystem()
                                   .getSystemProperties()
                                   .getEnableTimeStatistics();
-  int64_t sampleStartNanos =
-      enableTimeStatistics ? Utils::startStatOpTime() : 0;
-  TcrConnection* mp =
-      getUntil(timeoutTime, error, excludeServers, maxConnLimit);
+  auto sampleStartNanos = enableTimeStatistics ? Utils::startStatOpTime() : 0;
+  auto mp = getUntil(timeoutTime, error, excludeServers, maxConnLimit);
   /*Update the time stat for clientOpsTime */
   if (enableTimeStatistics) {
     Utils::updateStatOpTime(getStats().getStats(),
@@ -1979,7 +1976,7 @@ GfErrType ThinClientPoolDM::sendRequestToEP(const TcrMessage& request,
           type == TcrMessage::EXECUTE_REGION_FUNCTION ||
           type == TcrMessage::EXECUTE_REGION_FUNCTION_SINGLE_HOP ||
           type == TcrMessage::EXECUTECQ_WITH_IR_MSG_TYPE)) {
-      reply.setTimeout(this->getReadTimeout() / 1000);
+      reply.setTimeout(this->getReadTimeout());
     }
 
     reply.setDM(this);
@@ -2198,25 +2195,18 @@ void ThinClientPoolDM::setThreadLocalConnection(TcrConnection* conn) {
 }
 
 bool ThinClientPoolDM::hasExpired(TcrConnection* conn) {
-  int load = getLoadConditioningInterval();
-  int idle = getIdleTimeout();
-
-  if (load != -1) {
-    if (load < idle || idle == -1) {
-      idle = load;
-    }
-  }
-
+  const auto& load = getLoadConditioningInterval();
   return conn->hasExpired(load);
 }
 
 bool ThinClientPoolDM::canItBeDeleted(TcrConnection* conn) {
-  int load = getLoadConditioningInterval();
-  int idle = getIdleTimeout();
+  const auto& load = getLoadConditioningInterval();
+  auto idle = getIdleTimeout();
   int min = getMinConnections();
 
-  if (load != -1) {
-    if (load < idle || idle == -1) {
+  // TODO GEODE-3136 reconsider use of -1
+  if (load.count() >= 0) {
+    if (load < idle || idle.count() < 0) {
       idle = load;
     }
   }
diff --git a/cppcache/src/ThinClientPoolDM.hpp b/cppcache/src/ThinClientPoolDM.hpp
index 1da32d89..cbc1ef8e 100644
--- a/cppcache/src/ThinClientPoolDM.hpp
+++ b/cppcache/src/ThinClientPoolDM.hpp
@@ -101,8 +101,8 @@ class ThinClientPoolDM
   virtual QueryServicePtr getQueryServiceWithoutCheck();
   virtual bool isEndpointAttached(TcrEndpoint* ep);
   GfErrType sendRequestToAllServers(const char* func, uint8_t getResult,
-                                    uint32_t timeout, CacheablePtr args,
-                                    ResultCollectorPtr& rs,
+                                    std::chrono::milliseconds timeout,
+                                    CacheablePtr args, ResultCollectorPtr& rs,
                                     CacheableStringPtr& exceptionPtr);
 
   GfErrType sendRequestToEP(const TcrMessage& request, TcrMessageReply& reply,
@@ -361,7 +361,7 @@ class ThinClientPoolDM
   bool m_isSecurityOn;
   bool m_isMultiUserMode;
 
-  TcrConnection* getUntil(int64_t& sec, GfErrType* error,
+  TcrConnection* getUntil(std::chrono::microseconds& sec, GfErrType* error,
                           std::set<ServerLocation>& excludeServers,
                           bool& maxConnLimit) {
     bool isClosed;
@@ -436,7 +436,7 @@ class FunctionExecution : public PooledWork<GfErrType> {
   TcrEndpoint* m_ep;
   const char* m_func;
   uint8_t m_getResult;
-  uint32_t m_timeout;
+  std::chrono::milliseconds m_timeout;
   CacheablePtr m_args;
   GfErrType m_error;
   ResultCollectorPtr* m_rc;
@@ -450,7 +450,6 @@ class FunctionExecution : public PooledWork<GfErrType> {
     m_ep = nullptr;
     m_func = nullptr;
     m_getResult = 0;
-    m_timeout = 0;
     m_error = GF_NOERR;
     m_rc = nullptr;
     m_resultCollectorLock = nullptr;
@@ -461,9 +460,9 @@ class FunctionExecution : public PooledWork<GfErrType> {
 
   CacheableStringPtr getException() { return exceptionPtr; }
 
-  void setParameters(const char* func, uint8_t getResult, uint32_t timeout,
-                     CacheablePtr args, TcrEndpoint* ep,
-                     ThinClientPoolDM* poolDM,
+  void setParameters(const char* func, uint8_t getResult,
+                     std::chrono::milliseconds timeout, CacheablePtr args,
+                     TcrEndpoint* ep, ThinClientPoolDM* poolDM,
                      const std::shared_ptr<ACE_Recursive_Thread_Mutex>& rCL,
                      ResultCollectorPtr* rs, UserAttributesPtr userAttr) {
     exceptionPtr = nullptr;
@@ -550,7 +549,7 @@ class OnRegionFunctionExecution : public PooledWork<GfErrType> {
   ThinClientPoolDM* m_poolDM;
   const char* m_func;
   uint8_t m_getResult;
-  uint32_t m_timeout;
+  std::chrono::milliseconds m_timeout;
   CacheablePtr m_args;
   CacheableHashSetPtr m_routingObj;
   ResultCollectorPtr m_rc;
@@ -563,8 +562,8 @@ class OnRegionFunctionExecution : public PooledWork<GfErrType> {
  public:
   OnRegionFunctionExecution(
       const char* func, const Region* region, CacheablePtr args,
-      CacheableHashSetPtr routingObj, uint8_t getResult, uint32_t timeout,
-      ThinClientPoolDM* poolDM,
+      CacheableHashSetPtr routingObj, uint8_t getResult,
+      std::chrono::milliseconds timeout, ThinClientPoolDM* poolDM,
       const std::shared_ptr<ACE_Recursive_Thread_Mutex>& rCL,
       ResultCollectorPtr rs, UserAttributesPtr userAttr, bool isBGThread,
       const BucketServerLocationPtr& serverLocation, bool allBuckets)
diff --git a/cppcache/src/ThinClientPoolHADM.cpp b/cppcache/src/ThinClientPoolHADM.cpp
index 6c442964..86cdff32 100644
--- a/cppcache/src/ThinClientPoolHADM.cpp
+++ b/cppcache/src/ThinClientPoolHADM.cpp
@@ -57,15 +57,16 @@ void ThinClientPoolHADM::startBackgroundThreads() {
   ACE_Event_Handler* redundancyChecker =
       new ExpiryHandler_T<ThinClientPoolHADM>(
           this, &ThinClientPoolHADM::checkRedundancy);
-  int32_t redundancyMonitorInterval = props.redundancyMonitorInterval();
+  const auto redundancyMonitorInterval = props.redundancyMonitorInterval();
 
   m_servermonitorTaskId =
       m_connManager.getCacheImpl()->getExpiryTaskManager().scheduleExpiryTask(
-          redundancyChecker, 1, redundancyMonitorInterval, false);
+          redundancyChecker, std::chrono::seconds(1), redundancyMonitorInterval,
+          false);
   LOGFINE(
       "ThinClientPoolHADM::ThinClientPoolHADM Registered server "
       "monitor task with id = %ld, interval = %ld",
-      m_servermonitorTaskId, redundancyMonitorInterval);
+      m_servermonitorTaskId, redundancyMonitorInterval.count());
 
   if (ThinClientBaseDM::isFatalClientError(err)) {
     if (err == GF_CACHE_LOCATOR_EXCEPTION) {
diff --git a/cppcache/src/ThinClientRedundancyManager.cpp b/cppcache/src/ThinClientRedundancyManager.cpp
index 6ab32485..19f93d02 100644
--- a/cppcache/src/ThinClientRedundancyManager.cpp
+++ b/cppcache/src/ThinClientRedundancyManager.cpp
@@ -650,23 +650,20 @@ void ThinClientRedundancyManager::initialize(int redundancyLevel) {
   } else {
     m_eventidmap.init(sysProp.notifyDupCheckLife());
   }
-  int millis = 100;
+
   if (m_HAenabled) {
+    std::chrono::milliseconds interval;
     if (m_poolHADM) {
       //  Set periodic ack interval in seconds.
-      millis = m_poolHADM->getSubscriptionAckInterval();
+      interval = m_poolHADM->getSubscriptionAckInterval();
 
     } else {
-      millis = sysProp.notifyAckInterval();
+      interval = sysProp.notifyAckInterval();
     }
-    if (millis < 100) millis = 100;
-    {
-      time_t secs = millis / 1000;
-      suseconds_t usecs = (millis % 1000) * 1000;
-      ACE_Time_Value duration(secs, usecs);
-      m_nextAckInc = duration;
+    if (interval < std::chrono::milliseconds(100)) {
+      interval = std::chrono::milliseconds(100);
     }
-
+    m_nextAckInc = ACE_Time_Value(interval);
     m_nextAck = ACE_OS::gettimeofday();
     m_nextAck += m_nextAckInc;
   }
@@ -675,13 +672,10 @@ void ThinClientRedundancyManager::initialize(int redundancyLevel) {
     m_locators = m_poolHADM->getLocators();
     if (m_locators->length() == 0) m_servers = m_poolHADM->getServers();
     if (m_locators->length() > 0) {
-      std::vector<std::string> locators;
       for (int item = 0; item < m_locators->length(); item++) {
         LOGDEBUG("ThinClientRedundancyManager::initialize: adding locator %s",
                  (*m_locators)[item]->asChar());
-        locators.push_back((*m_locators)[item]->asChar());
       }
-
     } else if (m_servers->length() > 0) {
       RandGen randgen;
       m_server = randgen(m_servers->length());
@@ -854,7 +848,7 @@ GfErrType ThinClientRedundancyManager::sendSyncRequestCq(
       if (request.getMessageType() == TcrMessage::EXECUTECQ_WITH_IR_MSG_TYPE) {
         // Timeout for this message type is set like so...
         reply.setTimeout(
-            dynamic_cast<ThinClientPoolDM*>(theHADM)->getReadTimeout() / 1000);
+            dynamic_cast<ThinClientPoolDM*>(theHADM)->getReadTimeout());
         opErr = theHADM->sendRequestToEP(request, reply, *iter);
       } else {
         opErr = theHADM->sendRequestToEP(request, reply, *iter);
@@ -1267,10 +1261,10 @@ void ThinClientRedundancyManager::startPeriodicAck() {
       "periodic ack task with id = %ld, notify-ack-interval = %ld, "
       "notify-dupcheck-life = %ld, periodic ack is %sabled",
       m_processEventIdMapTaskId,
-      m_poolHADM ? m_poolHADM->getSubscriptionAckInterval()
-                 : props.notifyAckInterval(),
-      m_poolHADM ? m_poolHADM->getSubscriptionMessageTrackingTimeout()
-                 : props.notifyDupCheckLife(),
+      (m_poolHADM ? m_poolHADM->getSubscriptionAckInterval()
+                 : props.notifyAckInterval()).count(),
+      (m_poolHADM ? m_poolHADM->getSubscriptionMessageTrackingTimeout()
+                 : props.notifyDupCheckLife()).count(),
       m_HAenabled ? "en" : "dis");
 }
 
diff --git a/cppcache/src/ThinClientRedundancyManager.hpp b/cppcache/src/ThinClientRedundancyManager.hpp
index eedaeac1..3cad1e45 100644
--- a/cppcache/src/ThinClientRedundancyManager.hpp
+++ b/cppcache/src/ThinClientRedundancyManager.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_THINCLIENTREDUNDANCYMANAGER_H_
-#define GEODE_THINCLIENTREDUNDANCYMANAGER_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -19,21 +14,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-/*
- * ThinClientRedundancyManager.hpp
- *
- *  Created on: Dec 1, 2008
- *      Author: abhaware
- */
 
-#include "TcrMessage.hpp"
-#include "TcrEndpoint.hpp"
-#include "ServerLocation.hpp"
+#pragma once
+
+#ifndef GEODE_THINCLIENTREDUNDANCYMANAGER_H_
+#define GEODE_THINCLIENTREDUNDANCYMANAGER_H_
 
 #include <set>
 #include <list>
 #include <string>
 
+#include "TcrMessage.hpp"
+#include "TcrEndpoint.hpp"
+#include "ServerLocation.hpp"
+#include "EventIdMap.hpp"
+
 namespace apache {
 namespace geode {
 namespace client {
diff --git a/cppcache/src/ThinClientRegion.cpp b/cppcache/src/ThinClientRegion.cpp
index fe068fe3..3064cf7f 100644
--- a/cppcache/src/ThinClientRegion.cpp
+++ b/cppcache/src/ThinClientRegion.cpp
@@ -16,11 +16,13 @@
  */
 
 #include <algorithm>
+#include <limits>
 
 #include <geode/SelectResultsIterator.hpp>
 #include <geode/SystemProperties.hpp>
 #include <geode/PoolManager.hpp>
 #include <geode/UserFunctionExecutionException.hpp>
+#include <geode/Struct.hpp>
 
 #include "Utils.hpp"
 #include "CacheRegionHelper.hpp"
@@ -33,23 +35,18 @@
 #include "RegionGlobalLocks.hpp"
 #include "ReadWriteLock.hpp"
 #include "RemoteQuery.hpp"
-#include <geode/Struct.hpp>
 #include "GeodeTypeIdsImpl.hpp"
 #include "AutoDelete.hpp"
 #include "UserAttributes.hpp"
 #include "PutAllPartialResultServerException.hpp"
 #include "VersionedCacheableObjectPartList.hpp"
-//#include "PutAllPartialResult.hpp"
-
-using namespace apache::geode::client;
+#include "util/bounds.hpp"
 
 namespace apache {
 namespace geode {
 namespace client {
+
 void setTSSExceptionMessage(const char* exMsg);
-}  // namespace client
-}  // namespace geode
-}  // namespace apache
 
 class PutAllWork : public PooledWork<GfErrType>,
                    private NonCopyable,
@@ -66,7 +63,7 @@ class PutAllWork : public PooledWork<GfErrType>,
   VectorOfCacheableKeyPtr m_keys;
   HashMapOfCacheablePtr m_map;
   VersionedCacheableObjectPartListPtr m_verObjPartListPtr;
-  uint32_t m_timeout;
+  std::chrono::milliseconds m_timeout;
   PutAllPartialResultServerExceptionPtr m_papException;
   bool m_isPapeReceived;
   ChunkedPutAllResponse* m_resultCollector;
@@ -77,7 +74,8 @@ class PutAllWork : public PooledWork<GfErrType>,
              const BucketServerLocationPtr& serverLocation,
              const RegionPtr& region, bool attemptFailover, bool isBGThread,
              const HashMapOfCacheablePtr map,
-             const VectorOfCacheableKeyPtr keys, uint32_t timeout,
+             const VectorOfCacheableKeyPtr keys,
+             std::chrono::milliseconds timeout,
              const SerializablePtr& aCallbackArgument)
       : m_poolDM(poolDM),
         m_serverLocation(serverLocation),
@@ -92,9 +90,9 @@ class PutAllWork : public PooledWork<GfErrType>,
         m_isPapeReceived(false)
   // UNUSED , m_aCallbackArgument(aCallbackArgument)
   {
-    m_request = new TcrMessagePutAll(
-        m_region->getCache()->createDataOutput(), m_region.get(), *m_map.get(),
-        static_cast<int>(m_timeout * 1000), m_poolDM, aCallbackArgument);
+    m_request = new TcrMessagePutAll(m_region->getCache()->createDataOutput(),
+                                     m_region.get(), *m_map.get(), m_timeout,
+                                     m_poolDM, aCallbackArgument);
     m_reply = new TcrMessageReply(true, m_poolDM);
 
     // create new instanceof VCOPL
@@ -611,7 +609,9 @@ void ThinClientRegion::unregisterAllKeys() {
 }
 
 SelectResultsPtr ThinClientRegion::query(const char* predicate,
-                                         uint32_t timeout) {
+                                         std::chrono::milliseconds timeout) {
+  util::PROTOCOL_OPERATION_TIMEOUT_BOUNDS(timeout);
+
   CHECK_DESTROY_PENDING(TryReadGuard, Region::query);
 
   if (predicate == nullptr || predicate[0] == '\0') {
@@ -675,7 +675,10 @@ SelectResultsPtr ThinClientRegion::query(const char* predicate,
   return queryPtr->execute(timeout, "Region::query", m_tcrdm, nullptr);
 }
 
-bool ThinClientRegion::existsValue(const char* predicate, uint32_t timeout) {
+bool ThinClientRegion::existsValue(const char* predicate,
+                                   std::chrono::milliseconds timeout) {
+  util::PROTOCOL_OPERATION_TIMEOUT_BOUNDS(timeout);
+
   SelectResultsPtr results = query(predicate, timeout);
 
   if (results == nullptr) {
@@ -736,8 +739,8 @@ GfErrType ThinClientRegion::unregisterKeysBeforeDestroyRegion() {
   return err;
 }
 
-SerializablePtr ThinClientRegion::selectValue(const char* predicate,
-                                              uint32_t timeout) {
+SerializablePtr ThinClientRegion::selectValue(
+    const char* predicate, std::chrono::milliseconds timeout) {
   SelectResultsPtr results = query(predicate, timeout);
 
   if (results == nullptr || results->size() == 0) {
@@ -915,7 +918,8 @@ void ThinClientRegion::clear(const SerializablePtr& aCallbackArgument) {
   /** @brief Create message and send to bridge server */
 
   TcrMessageClearRegion request(m_cache->createDataOutput(), this,
-                                aCallbackArgument, -1, m_tcrdm);
+                                aCallbackArgument,
+                                std::chrono::milliseconds(-1), m_tcrdm);
   TcrMessageReply reply(true, m_tcrdm);
   err = m_tcrdm->sendSyncRequest(request, reply);
   if (err != GF_NOERR) GfErrTypeToException("Region::clear", err);
@@ -1309,20 +1313,21 @@ GfErrType ThinClientRegion::getAllNoThrow_remote(
 
 GfErrType ThinClientRegion::singleHopPutAllNoThrow_remote(
     ThinClientPoolDM* tcrdm, const HashMapOfCacheable& map,
-    VersionedCacheableObjectPartListPtr& versionedObjPartList, uint32_t timeout,
+    VersionedCacheableObjectPartListPtr& versionedObjPartList,
+    std::chrono::milliseconds timeout,
     const SerializablePtr& aCallbackArgument) {
   LOGDEBUG(" ThinClientRegion::singleHopPutAllNoThrow_remote map size = %d",
            map.size());
-  RegionPtr region = shared_from_this();
+  auto region = shared_from_this();
 
-  GfErrType error = GF_NOERR;
+  auto error = GF_NOERR;
   /*Step-1::
    * populate the keys vector from the user Map and pass it to the
    * getServerToFilterMap to generate locationMap
    * If locationMap is nullptr try the old, existing putAll impl that may take
    * multiple n/w hops
    */
-  VectorOfCacheableKey userKeys = VectorOfCacheableKey();
+  auto userKeys = VectorOfCacheableKey();
   for (const auto& iter : map) {
     userKeys.push_back(iter.first);
   }
@@ -1357,7 +1362,7 @@ GfErrType ThinClientRegion::singleHopPutAllNoThrow_remote(
    *  e. insert the worker into the vector.
    */
   std::vector<PutAllWork*> putAllWorkers;
-  auto* threadPool =
+  auto threadPool =
       CacheRegionHelper::getCacheImpl(getCache().get())->getThreadPool();
   int locationMapIndex = 0;
   for (const auto& locationIter : *locationMap) {
@@ -1378,21 +1383,9 @@ GfErrType ThinClientRegion::singleHopPutAllNoThrow_remote(
       }
     }
 
-    // TEST-CODE :: PRINT each sub-Map entries
-    /*
-    LOGDEBUG("Printing map at %d locationMapindex ", locationMapIndex);
-    for (const auto& filteredMapIter : *filteredMap){
-      auto kPtr =
-    std::dynamic_pointer_cast<CacheableInt32>(filteredMapIter.first()) ;
-      auto vPtr =
-    std::dynamic_pointer_cast<CacheableInt32>(filteredMapIter.second());
-      LOGDEBUG("Key = %d  Value = %d ", kPtr->value(), vPtr->value() );
-    }
-    */
-
-    PutAllWork* worker = new PutAllWork(
-        tcrdm, serverLocation, region, true /*attemptFailover*/,
-        false /*isBGThread*/, filteredMap, keys, timeout, aCallbackArgument);
+    auto worker = new PutAllWork(tcrdm, serverLocation, region,
+                                 true /*attemptFailover*/, false /*isBGThread*/,
+                                 filteredMap, keys, timeout, aCallbackArgument);
     threadPool->perform(worker);
     putAllWorkers.push_back(worker);
     locationMapIndex++;
@@ -1620,16 +1613,16 @@ GfErrType ThinClientRegion::singleHopPutAllNoThrow_remote(
 
 GfErrType ThinClientRegion::multiHopPutAllNoThrow_remote(
     const HashMapOfCacheable& map,
-    VersionedCacheableObjectPartListPtr& versionedObjPartList, uint32_t timeout,
+    VersionedCacheableObjectPartListPtr& versionedObjPartList,
+    std::chrono::milliseconds timeout,
     const SerializablePtr& aCallbackArgument) {
   // Multiple hop implementation
   LOGDEBUG("ThinClientRegion::multiHopPutAllNoThrow_remote ");
-  GfErrType err = GF_NOERR;
+  auto err = GF_NOERR;
 
   // Construct request/reply for putAll
-  TcrMessagePutAll request(m_cache->createDataOutput(), this, map,
-                           static_cast<int>(timeout * 1000), m_tcrdm,
-                           aCallbackArgument);
+  TcrMessagePutAll request(m_cache->createDataOutput(), this, map, timeout,
+                           m_tcrdm, aCallbackArgument);
   TcrMessageReply reply(true, m_tcrdm);
   request.setTimeout(timeout);
   reply.setTimeout(timeout);
@@ -1685,12 +1678,13 @@ GfErrType ThinClientRegion::multiHopPutAllNoThrow_remote(
 
 GfErrType ThinClientRegion::putAllNoThrow_remote(
     const HashMapOfCacheable& map,
-    VersionedCacheableObjectPartListPtr& versionedObjPartList, uint32_t timeout,
+    VersionedCacheableObjectPartListPtr& versionedObjPartList,
+    std::chrono::milliseconds timeout,
     const SerializablePtr& aCallbackArgument) {
   LOGDEBUG("ThinClientRegion::putAllNoThrow_remote");
 
-  ThinClientPoolDM* poolDM = dynamic_cast<ThinClientPoolDM*>(m_tcrdm);
-  TXState* txState = TSSTXStateWrapper::s_geodeTSSTXState->getTXState();
+  auto poolDM = dynamic_cast<ThinClientPoolDM*>(m_tcrdm);
+  auto txState = TSSTXStateWrapper::s_geodeTSSTXState->getTXState();
 
   if (poolDM != nullptr) {
     if (poolDM->getPRSingleHopEnabled() &&
@@ -2243,7 +2237,8 @@ GfErrType ThinClientRegion::destroyRegionNoThrow_remote(
 
   // do TCR destroyRegion
   TcrMessageDestroyRegion request(m_cache->createDataOutput(), this,
-                                  aCallbackArgument, -1, m_tcrdm);
+                                  aCallbackArgument,
+                                  std::chrono::milliseconds(-1), m_tcrdm);
   TcrMessageReply reply(true, m_tcrdm);
   err = m_tcrdm->sendSyncRequest(request, reply);
   if (err != GF_NOERR) return err;
@@ -2995,7 +2990,7 @@ void ThinClientRegion::executeFunction(const char* func,
                                        CacheableVectorPtr routingObj,
                                        uint8_t getResult, ResultCollectorPtr rc,
                                        int32_t retryAttempts,
-                                       uint32_t timeout) {
+                                       std::chrono::milliseconds timeout) {
   int32_t attempt = 0;
   CacheableHashSetPtr failedNodes = CacheableHashSet::create();
   // if pools retry attempts are not set then retry once on all available
@@ -3068,7 +3063,7 @@ void ThinClientRegion::executeFunction(const char* func,
         LOGINFO(
             "function timeout. Name: %s, timeout: %d, params: %d, "
             "retryAttempts: %d ",
-            funcName.c_str(), timeout, getResult, retryAttempts);
+            funcName.c_str(), timeout.count(), getResult, retryAttempts);
         GfErrTypeToException("ExecuteOnRegion", GF_TIMOUT);
       } else if (err == GF_CLIENT_WAIT_TIMEOUT ||
                  err == GF_CLIENT_WAIT_TIMEOUT_REFRESH_PRMETADATA) {
@@ -3076,7 +3071,7 @@ void ThinClientRegion::executeFunction(const char* func,
             "function timeout, possibly bucket is not available or bucket "
             "blacklisted. Name: %s, timeout: %d, params: %d, retryAttempts: "
             "%d ",
-            funcName.c_str(), timeout, getResult, retryAttempts);
+            funcName.c_str(), timeout.count(), getResult, retryAttempts);
         GfErrTypeToException("ExecuteOnRegion", GF_CLIENT_WAIT_TIMEOUT);
       } else {
         LOGDEBUG("executeFunction err = %d ", err);
@@ -3097,7 +3092,7 @@ void ThinClientRegion::executeFunction(const char* func,
 CacheableVectorPtr ThinClientRegion::reExecuteFunction(
     const char* func, const CacheablePtr& args, CacheableVectorPtr routingObj,
     uint8_t getResult, ResultCollectorPtr rc, int32_t retryAttempts,
-    CacheableHashSetPtr& failedNodes, uint32_t timeout) {
+    CacheableHashSetPtr& failedNodes, std::chrono::milliseconds timeout) {
   int32_t attempt = 0;
   bool reExecute = true;
   // if pools retry attempts are not set then retry once on all available
@@ -3175,7 +3170,8 @@ bool ThinClientRegion::executeFunctionSH(
     const char* func, const CacheablePtr& args, uint8_t getResult,
     ResultCollectorPtr rc,
     const ClientMetadataService::ServerToKeysMapPtr& locationMap,
-    CacheableHashSetPtr& failedNodes, uint32_t timeout, bool allBuckets) {
+    CacheableHashSetPtr& failedNodes, std::chrono::milliseconds timeout,
+    bool allBuckets) {
   bool reExecute = false;
   auto resultCollectorLock = std::make_shared<ACE_Recursive_Thread_Mutex>();
   const auto& userAttr =
@@ -3950,3 +3946,7 @@ void ChunkedDurableCQListResponse::handleChunk(const uint8_t* chunk,
     m_resultList->push_back(input->readObject<CacheableString>());
   }
 }
+
+}  // namespace client
+}  // namespace geode
+}  // namespace apache
diff --git a/cppcache/src/ThinClientRegion.hpp b/cppcache/src/ThinClientRegion.hpp
index 5d2d5b35..7c6ccfa5 100644
--- a/cppcache/src/ThinClientRegion.hpp
+++ b/cppcache/src/ThinClientRegion.hpp
@@ -72,25 +72,32 @@ class CPPCACHE_EXPORT ThinClientRegion : public LocalRegion {
   virtual void registerKeys(const VectorOfCacheableKey& keys,
                             bool isDurable = false,
                             bool getInitialValues = false,
-                            bool receiveValues = true);
-  virtual void unregisterKeys(const VectorOfCacheableKey& keys);
+                            bool receiveValues = true) override;
+  virtual void unregisterKeys(const VectorOfCacheableKey& keys) override;
   virtual void registerAllKeys(bool isDurable = false,
                                bool getInitialValues = false,
-                               bool receiveValues = true);
-  virtual void unregisterAllKeys();
+                               bool receiveValues = true) override;
+  virtual void unregisterAllKeys() override;
   virtual void registerRegex(const char* regex, bool isDurable = false,
                              bool getInitialValues = false,
-                             bool receiveValues = true);
-  virtual void unregisterRegex(const char* regex);
-  virtual VectorOfCacheableKey serverKeys();
-  virtual void clear(const SerializablePtr& aCallbackArgument = nullptr);
+                             bool receiveValues = true) override;
+  virtual void unregisterRegex(const char* regex) override;
+  virtual VectorOfCacheableKey serverKeys() override;
+  virtual void clear(
+      const SerializablePtr& aCallbackArgument = nullptr) override;
+
+  virtual SelectResultsPtr query(const char* predicate,
+                                 std::chrono::milliseconds timeout =
+                                     DEFAULT_QUERY_RESPONSE_TIMEOUT) override;
 
-  virtual SelectResultsPtr query(
-      const char* predicate, uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
   virtual bool existsValue(const char* predicate,
-                           uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
+                           std::chrono::milliseconds timeout =
+                               DEFAULT_QUERY_RESPONSE_TIMEOUT) override;
+
   virtual SerializablePtr selectValue(
-      const char* predicate, uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
+      const char* predicate,
+      std::chrono::milliseconds timeout =
+          DEFAULT_QUERY_RESPONSE_TIMEOUT) override;
 
   /** @brief Public Methods from RegionInternal
    *  These are all virtual methods
@@ -98,12 +105,12 @@ class CPPCACHE_EXPORT ThinClientRegion : public LocalRegion {
   GfErrType putAllNoThrow_remote(
       const HashMapOfCacheable& map,
       VersionedCacheableObjectPartListPtr& versionedObjPartList,
-      uint32_t timeout = DEFAULT_RESPONSE_TIMEOUT,
-      const SerializablePtr& aCallbackArgument = nullptr);
+      std::chrono::milliseconds timeout = DEFAULT_RESPONSE_TIMEOUT,
+      const SerializablePtr& aCallbackArgument = nullptr) override;
   GfErrType removeAllNoThrow_remote(
       const VectorOfCacheableKey& keys,
       VersionedCacheableObjectPartListPtr& versionedObjPartList,
-      const SerializablePtr& aCallbackArgument = nullptr);
+      const SerializablePtr& aCallbackArgument = nullptr) override;
   GfErrType registerKeys(TcrEndpoint* endpoint = nullptr,
                          const TcrMessage* request = nullptr,
                          TcrMessageReply* reply = nullptr);
@@ -115,10 +122,10 @@ class CPPCACHE_EXPORT ThinClientRegion : public LocalRegion {
   GfErrType findRegex(const std::string& regex);
   void clearRegex(const std::string& regex);
 
-  bool containsKeyOnServer(const CacheableKeyPtr& keyPtr) const;
-  virtual bool containsValueForKey_remote(const CacheableKeyPtr& keyPtr) const;
-  virtual VectorOfCacheableKey getInterestList() const;
-  virtual VectorOfCacheableString getInterestListRegex() const;
+  bool containsKeyOnServer(const CacheableKeyPtr& keyPtr) const override;
+  virtual bool containsValueForKey_remote(const CacheableKeyPtr& keyPtr) const override;
+  virtual VectorOfCacheableKey getInterestList() const override;
+  virtual VectorOfCacheableString getInterestListRegex() const override;
 
   /** @brief Public Methods from RegionInternal
    *  These are all virtual methods
@@ -129,8 +136,8 @@ class CPPCACHE_EXPORT ThinClientRegion : public LocalRegion {
   static GfErrType handleServerException(const char* func,
                                          const char* exceptionMsg);
 
-  virtual void acquireGlobals(bool failover);
-  virtual void releaseGlobals(bool failover);
+  virtual void acquireGlobals(bool failover)override;
+  virtual void releaseGlobals(bool failover)override;
 
   void localInvalidateFailover();
 
@@ -140,18 +147,21 @@ class CPPCACHE_EXPORT ThinClientRegion : public LocalRegion {
       const char* func, const CacheablePtr& args, CacheableVectorPtr routingObj,
       uint8_t getResult, ResultCollectorPtr rc, int32_t retryAttempts,
       CacheableHashSetPtr& failedNodes,
-      uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
+      std::chrono::milliseconds timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
+
   bool executeFunctionSH(
       const char* func, const CacheablePtr& args, uint8_t getResult,
       ResultCollectorPtr rc,
       const ClientMetadataService::ServerToKeysMapPtr& locationMap,
       CacheableHashSetPtr& failedNodes,
-      uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT,
+      std::chrono::milliseconds timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT,
       bool allBuckets = false);
-  void executeFunction(const char* func, const CacheablePtr& args,
-                       CacheableVectorPtr routingObj, uint8_t getResult,
-                       ResultCollectorPtr rc, int32_t retryAttempts,
-                       uint32_t timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
+
+  void executeFunction(
+      const char* func, const CacheablePtr& args, CacheableVectorPtr routingObj,
+      uint8_t getResult, ResultCollectorPtr rc, int32_t retryAttempts,
+      std::chrono::milliseconds timeout = DEFAULT_QUERY_RESPONSE_TIMEOUT);
+
   GfErrType getFuncAttributes(const char* func, std::vector<int8_t>** attr);
 
   ACE_RW_Thread_Mutex& getMataDataMutex() { return m_RegionMutex; }
@@ -162,15 +172,17 @@ class CPPCACHE_EXPORT ThinClientRegion : public LocalRegion {
     m_isMetaDataRefreshed = aMetaDataRefreshed;
   }
 
-  uint32_t size_remote();
+  uint32_t size_remote() override;
 
   virtual void txDestroy(const CacheableKeyPtr& key,
-                         const SerializablePtr& callBack, VersionTagPtr versionTag);
+                         const SerializablePtr& callBack,
+                         VersionTagPtr versionTag) override;
   virtual void txInvalidate(const CacheableKeyPtr& key,
                             const SerializablePtr& callBack,
-                            VersionTagPtr versionTag);
+                            VersionTagPtr versionTag) override;
   virtual void txPut(const CacheableKeyPtr& key, const CacheablePtr& value,
-                     const SerializablePtr& callBack, VersionTagPtr versionTag);
+                     const SerializablePtr& callBack,
+                     VersionTagPtr versionTag) override;
 
  protected:
   /** @brief the methods need to be overloaded in TCR
@@ -178,36 +190,36 @@ class CPPCACHE_EXPORT ThinClientRegion : public LocalRegion {
   GfErrType getNoThrow_remote(const CacheableKeyPtr& keyPtr,
                               CacheablePtr& valPtr,
                               const SerializablePtr& aCallbackArgument,
-                              VersionTagPtr& versionTag);
+                              VersionTagPtr& versionTag) override;
   GfErrType putNoThrow_remote(const CacheableKeyPtr& keyPtr,
                               const CacheablePtr& cvalue,
                               const SerializablePtr& aCallbackArgument,
                               VersionTagPtr& versionTag,
-                              bool checkDelta = true);
+                              bool checkDelta = true) override;
   GfErrType createNoThrow_remote(const CacheableKeyPtr& keyPtr,
                                  const CacheablePtr& cvalue,
                                  const SerializablePtr& aCallbackArgument,
-                                 VersionTagPtr& versionTag);
+                                 VersionTagPtr& versionTag) override;
   GfErrType destroyNoThrow_remote(const CacheableKeyPtr& keyPtr,
                                   const SerializablePtr& aCallbackArgument,
-                                  VersionTagPtr& versionTag);
+                                  VersionTagPtr& versionTag) override;
   GfErrType removeNoThrow_remote(const CacheableKeyPtr& keyPtr,
                                  const CacheablePtr& cvalue,
                                  const SerializablePtr& aCallbackArgument,
-                                 VersionTagPtr& versionTag);
+                                 VersionTagPtr& versionTag) override;
   GfErrType removeNoThrowEX_remote(const CacheableKeyPtr& keyPtr,
                                    const SerializablePtr& aCallbackArgument,
-                                   VersionTagPtr& versionTag);
+                                   VersionTagPtr& versionTag) override;
   GfErrType invalidateNoThrow_remote(const CacheableKeyPtr& keyPtr,
                                      const SerializablePtr& aCallbackArgument,
-                                     VersionTagPtr& versionTag);
-  GfErrType getAllNoThrow_remote(const VectorOfCacheableKey* keys,
-                                 const HashMapOfCacheablePtr& values,
-                                 const HashMapOfExceptionPtr& exceptions,
-                                 const VectorOfCacheableKeyPtr& resultKeys,
-                                 bool addToLocalCache,
-                                 const SerializablePtr& aCallbackArgument);
-  GfErrType destroyRegionNoThrow_remote(const SerializablePtr& aCallbackArgument);
+                                     VersionTagPtr& versionTag) override;
+  GfErrType getAllNoThrow_remote(
+      const VectorOfCacheableKey* keys, const HashMapOfCacheablePtr& values,
+      const HashMapOfExceptionPtr& exceptions,
+      const VectorOfCacheableKeyPtr& resultKeys, bool addToLocalCache,
+      const SerializablePtr& aCallbackArgument) override;
+  GfErrType destroyRegionNoThrow_remote(
+      const SerializablePtr& aCallbackArgument) override;
   GfErrType registerKeysNoThrow(
       const VectorOfCacheableKey& keys, bool attemptFailover = true,
       TcrEndpoint* endpoint = nullptr, bool isDurable = false,
@@ -238,9 +250,9 @@ class CPPCACHE_EXPORT ThinClientRegion : public LocalRegion {
       VectorOfCacheableKey& keysVector,
       std::unordered_map<CacheableKeyPtr, InterestResultPolicy>& interestList)
       const;
-  virtual void release(bool invokeCallbacks = true);
+  virtual void release(bool invokeCallbacks = true) override;
 
-  GfErrType unregisterKeysBeforeDestroyRegion();
+  GfErrType unregisterKeysBeforeDestroyRegion() override;
 
   bool isDurableClient() { return m_isDurableClnt; }
   /** @brief Protected fields. */
@@ -294,7 +306,7 @@ class CPPCACHE_EXPORT ThinClientRegion : public LocalRegion {
                                  const VectorOfCacheableKey* keys,
                                  const VectorOfCacheableKeyPtr& resultKeys);
   GfErrType getNoThrow_FullObject(EventIdPtr eventId, CacheablePtr& fullObject,
-                                  VersionTagPtr& versionTag);
+                                  VersionTagPtr& versionTag) override;
 
   // Disallow copy constructor and assignment operator.
   ThinClientRegion(const ThinClientRegion&);
@@ -302,12 +314,12 @@ class CPPCACHE_EXPORT ThinClientRegion : public LocalRegion {
   GfErrType singleHopPutAllNoThrow_remote(
       ThinClientPoolDM* tcrdm, const HashMapOfCacheable& map,
       VersionedCacheableObjectPartListPtr& versionedObjPartList,
-      uint32_t timeout = DEFAULT_RESPONSE_TIMEOUT,
+      std::chrono::milliseconds timeout = DEFAULT_RESPONSE_TIMEOUT,
       const SerializablePtr& aCallbackArgument = nullptr);
   GfErrType multiHopPutAllNoThrow_remote(
       const HashMapOfCacheable& map,
       VersionedCacheableObjectPartListPtr& versionedObjPartList,
-      uint32_t timeout = DEFAULT_RESPONSE_TIMEOUT,
+      std::chrono::milliseconds timeout = DEFAULT_RESPONSE_TIMEOUT,
       const SerializablePtr& aCallbackArgument = nullptr);
 
   GfErrType singleHopRemoveAllNoThrow_remote(
diff --git a/cppcache/src/TombstoneExpiryHandler.cpp b/cppcache/src/TombstoneExpiryHandler.cpp
index 399131ef..15684cdb 100644
--- a/cppcache/src/TombstoneExpiryHandler.cpp
+++ b/cppcache/src/TombstoneExpiryHandler.cpp
@@ -29,10 +29,9 @@
 
 using namespace apache::geode::client;
 
-TombstoneExpiryHandler::TombstoneExpiryHandler(TombstoneEntryPtr entryPtr,
-                                               TombstoneList* tombstoneList,
-                                               uint32_t duration,
-                                               CacheImpl* cacheImpl)
+TombstoneExpiryHandler::TombstoneExpiryHandler(
+    TombstoneEntryPtr entryPtr, TombstoneList* tombstoneList,
+    std::chrono::milliseconds duration, CacheImpl* cacheImpl)
     : m_entryPtr(entryPtr),
       m_duration(duration),
       m_tombstoneList(tombstoneList),
@@ -45,13 +44,13 @@ int TombstoneExpiryHandler::handle_timeout(const ACE_Time_Value& current_time,
   int64_t creationTime = m_entryPtr->getTombstoneCreationTime();
   int64_t curr_time = static_cast<int64_t>(current_time.get_msec());
   int64_t expiryTaskId = m_entryPtr->getExpiryTaskId();
-  int64_t sec = curr_time - creationTime - m_duration * 1000;
+  int64_t sec = curr_time - creationTime - m_duration.count();
   try {
     LOGDEBUG(
         "Entered entry expiry task handler for tombstone of key [%s]: "
         "%lld,%lld,%d,%lld",
         Utils::getCacheableKeyString(key)->asChar(), curr_time, creationTime,
-        m_duration, sec);
+        m_duration.count(), sec);
     if (sec >= 0) {
       DoTheExpirationAction(key);
     } else {
diff --git a/cppcache/src/TombstoneExpiryHandler.hpp b/cppcache/src/TombstoneExpiryHandler.hpp
index e4ef7301..845af17a 100644
--- a/cppcache/src/TombstoneExpiryHandler.hpp
+++ b/cppcache/src/TombstoneExpiryHandler.hpp
@@ -46,7 +46,8 @@ class CPPCACHE_EXPORT TombstoneExpiryHandler : public ACE_Event_Handler {
    * Constructor
    */
   TombstoneExpiryHandler(TombstoneEntryPtr entryPtr,
-                         TombstoneList* tombstoneList, uint32_t duration,
+                         TombstoneList* tombstoneList,
+                         std::chrono::milliseconds duration,
                          CacheImpl* cacheImpl);
 
   /** This task object will be registered with the Timer Queue.
@@ -65,7 +66,7 @@ class CPPCACHE_EXPORT TombstoneExpiryHandler : public ACE_Event_Handler {
   TombstoneEntryPtr m_entryPtr;
   // Duration after which the task should be reset in case of
   // modification.
-  uint32_t m_duration;
+  std::chrono::milliseconds m_duration;
   CacheImpl* m_cacheImpl;
   // perform the actual expiration action
   void DoTheExpirationAction(const CacheableKeyPtr& key);
diff --git a/cppcache/src/TombstoneList.cpp b/cppcache/src/TombstoneList.cpp
index d32243a8..51b3ebda 100644
--- a/cppcache/src/TombstoneList.cpp
+++ b/cppcache/src/TombstoneList.cpp
@@ -38,19 +38,17 @@ using namespace apache::geode::client;
 long TombstoneList::getExpiryTask(TombstoneExpiryHandler** handler) {
   // This function is not guarded as all functions of this class are called from
   // MapSegment
-  // read TombstoneTImeout from systemProperties.
-  uint32_t duration = m_cacheImpl->getDistributedSystem()
-                          .getSystemProperties()
-                          .tombstoneTimeoutInMSec() /
-                      1000;
+  auto duration = m_cacheImpl->getDistributedSystem()
+                      .getSystemProperties()
+                      .tombstoneTimeout();
   ACE_Time_Value currTime(ACE_OS::gettimeofday());
   auto tombstoneEntryPtr = std::make_shared<TombstoneEntry>(
       nullptr, static_cast<int64_t>(currTime.get_msec()));
   *handler = new TombstoneExpiryHandler(tombstoneEntryPtr, this, duration,
                                         m_cacheImpl);
   tombstoneEntryPtr->setHandler(*handler);
-  long id = m_cacheImpl->getExpiryTaskManager().scheduleExpiryTask(*handler,
-                                                                   duration, 0);
+  long id = m_cacheImpl->getExpiryTaskManager().scheduleExpiryTask(
+      *handler, duration, std::chrono::seconds(0));
   return id;
 }
 
diff --git a/cppcache/src/TombstoneList.hpp b/cppcache/src/TombstoneList.hpp
index c535ea06..d549ac76 100644
--- a/cppcache/src/TombstoneList.hpp
+++ b/cppcache/src/TombstoneList.hpp
@@ -42,14 +42,6 @@ class TombstoneEntry {
   TombstoneEntry(const MapEntryImplPtr& entry, int64_t tombstoneCreationTime)
       : m_entry(entry),
         m_tombstoneCreationTime(tombstoneCreationTime),
-        /* adongre
-         * Coverity - II
-         * CID 29289: Uninitialized scalar field (UNINIT_CTOR)
-         * Non-static class member "m_expiryTaskId" is not initialized in this
-         * constructor nor in any functions that it calls.
-         * Fix : Initialize the member
-         * also change the member initialization to initializer list
-         */
         m_expiryTaskId(0),
         m_handler(nullptr) {}
   virtual ~TombstoneEntry() {}
diff --git a/cppcache/src/TransactionalOperation.cpp b/cppcache/src/TransactionalOperation.cpp
index 442c2bd6..3f21c4df 100644
--- a/cppcache/src/TransactionalOperation.cpp
+++ b/cppcache/src/TransactionalOperation.cpp
@@ -76,10 +76,11 @@ CacheablePtr TransactionalOperation::replay(Cache* cache) {
                   std::static_pointer_cast<CacheableVector>(m_arguments->at(1)))
               ->withCollector(std::dynamic_pointer_cast<ResultCollector>(
                   m_arguments->at(2)))
-              ->execute(
-                  m_arguments->at(3)->toString()->asChar(),
-                  std::static_pointer_cast<CacheableInt32>(m_arguments->at(4))
-                      ->value()));
+              ->execute(m_arguments->at(3)->toString()->asChar(),
+                        std::chrono::milliseconds(
+                            std::static_pointer_cast<CacheableInt32>(
+                                m_arguments->at(4))
+                                ->value())));
     } break;
     case GF_GET:
       result = cache->getRegion(m_regionName)->get(m_key, m_arguments->at(0));
@@ -128,10 +129,12 @@ CacheablePtr TransactionalOperation::replay(Cache* cache) {
       break;
     case GF_PUT_ALL:
       cache->getRegion(m_regionName)
-          ->putAll(*std::dynamic_pointer_cast<HashMapOfCacheable>(
-                       m_arguments->at(0)),
-                   std::static_pointer_cast<CacheableInt32>(m_arguments->at(1))
-                       ->value());
+          ->putAll(
+              *std::dynamic_pointer_cast<HashMapOfCacheable>(
+                  m_arguments->at(0)),
+              std::chrono::milliseconds(
+                  std::static_pointer_cast<CacheableInt32>(m_arguments->at(1))
+                      ->value()));
       break;
     default:
       throw UnsupportedOperationException(
diff --git a/cppcache/src/statistics/HostStatSampler.cpp b/cppcache/src/statistics/HostStatSampler.cpp
index 85eed8b9..9e97f621 100644
--- a/cppcache/src/statistics/HostStatSampler.cpp
+++ b/cppcache/src/statistics/HostStatSampler.cpp
@@ -128,10 +128,11 @@ using std::chrono::nanoseconds;
 
 const char* HostStatSampler::NC_HSS_Thread = "NC HSS Thread";
 
-HostStatSampler::HostStatSampler(const char* filePath, int64_t sampleIntervalMs,
+HostStatSampler::HostStatSampler(const char* filePath,
+                                 std::chrono::milliseconds sampleIntervalMs,
                                  StatisticsManager* statMngr, Cache* cache,
                                  const char* durableClientId,
-                                 const uint32_t durableTimeout,
+                                 const std::chrono::seconds durableTimeout,
                                  int64_t statFileLimit,
                                  int64_t statDiskSpaceLimit)
     : m_cache(cache) {
@@ -298,7 +299,9 @@ int64_t HostStatSampler::getArchiveDiskSpaceLimit() {
   return m_archiveDiskSpaceLimit;
 }
 
-int64_t HostStatSampler::getSampleRate() { return m_sampleRate; }
+std::chrono::milliseconds HostStatSampler::getSampleRate() {
+  return m_sampleRate;
+}
 
 bool HostStatSampler::isSamplingEnabled() { return true; }
 
diff --git a/cppcache/src/statistics/HostStatSampler.hpp b/cppcache/src/statistics/HostStatSampler.hpp
index 67d22380..96466209 100644
--- a/cppcache/src/statistics/HostStatSampler.hpp
+++ b/cppcache/src/statistics/HostStatSampler.hpp
@@ -81,9 +81,11 @@ class CPPCACHE_EXPORT HostStatSampler : public ACE_Task_Base,
   /*
    * Constructor:
    */
-  HostStatSampler(const char* filePath, int64_t sampleIntervalMs,
+  HostStatSampler(const char* filePath,
+                  std::chrono::milliseconds sampleIntervalMs,
                   StatisticsManager* statMngr, Cache* cache,
-                  const char* durableClientId, const uint32_t durableTimeout,
+                  const char* durableClientId,
+                  const std::chrono::seconds durableTimeout,
                   int64_t statFileLimit = 0, int64_t statDiskSpaceLimit = 0);
 
   /**
@@ -105,7 +107,7 @@ class CPPCACHE_EXPORT HostStatSampler : public ACE_Task_Base,
   /**
    * Gets the sample rate in milliseconds
    */
-  int64_t getSampleRate();
+  std::chrono::milliseconds getSampleRate();
   /**
    * Returns true if sampling is enabled.
    */
@@ -209,12 +211,12 @@ class CPPCACHE_EXPORT HostStatSampler : public ACE_Task_Base,
   StatArchiveWriter* m_archiver;
   StatSamplerStats* m_samplerStats;
   const char* m_durableClientId;
-  uint32_t m_durableTimeout;
+  std::chrono::seconds m_durableTimeout;
 
   std::string m_archiveFileName;
   int64_t m_archiveFileSizeLimit;
   int64_t m_archiveDiskSpaceLimit;
-  int64_t m_sampleRate;
+  std::chrono::milliseconds m_sampleRate;
   StatisticsManager* m_statMngr;
   Cache* m_cache;
 
diff --git a/cppcache/src/statistics/StatisticsManager.cpp b/cppcache/src/statistics/StatisticsManager.cpp
index 57fbb6a2..2732bcf1 100644
--- a/cppcache/src/statistics/StatisticsManager.cpp
+++ b/cppcache/src/statistics/StatisticsManager.cpp
@@ -37,15 +37,14 @@ using namespace apache::geode::statistics;
  * static member initialization
  */
 
-StatisticsManager::StatisticsManager(const char* filePath,
-                                     int64_t sampleInterval, bool enabled,
-                                     Cache* cache, const char* durableClientId,
-                                     const uint32_t durableTimeout,
-                                     int64_t statFileLimit,
-                                     int64_t statDiskSpaceLimit)
-    : m_sampler(nullptr), m_adminRegion(nullptr) {
-  m_sampleIntervalMs =
-      static_cast<int32_t>(sampleInterval) * 1000; /* convert to millis */
+StatisticsManager::StatisticsManager(
+    const char* filePath, const std::chrono::milliseconds sampleInterval,
+    bool enabled, Cache* cache, const char* durableClientId,
+    const std::chrono::seconds durableTimeout, int64_t statFileLimit,
+    int64_t statDiskSpaceLimit)
+    : m_sampleIntervalMs(sampleInterval),
+      m_sampler(nullptr),
+      m_adminRegion(nullptr) {
   m_newlyAddedStatsList.reserve(16);               // Allocate initial sizes
   m_statisticsFactory =
       std::unique_ptr<GeodeStatisticsFactory>(new GeodeStatisticsFactory(this));
diff --git a/cppcache/src/statistics/StatisticsManager.hpp b/cppcache/src/statistics/StatisticsManager.hpp
index 0d48d0c3..536bea3e 100644
--- a/cppcache/src/statistics/StatisticsManager.hpp
+++ b/cppcache/src/statistics/StatisticsManager.hpp
@@ -45,7 +45,7 @@ class GeodeStatisticsFactory;
 class StatisticsManager {
  private:
   // interval at which the sampler will take a sample of Stats
-  int32_t m_sampleIntervalMs;
+  std::chrono::milliseconds m_sampleIntervalMs;
 
   // Statistics sampler
   HostStatSampler* m_sampler;
@@ -66,10 +66,11 @@ class StatisticsManager {
   void closeSampler();
 
  public:
-  StatisticsManager(const char* filePath, int64_t sampleIntervalMs,
-                    bool enabled, Cache* cache, const char* durableClientId,
-                    const uint32_t durableTimeout, int64_t statFileLimit = 0,
-                    int64_t statDiskSpaceLimit = 0);
+  StatisticsManager(const char* filePath,
+                    std::chrono::milliseconds sampleIntervalMs, bool enabled,
+                    Cache* cache, const char* durableClientId,
+                    const std::chrono::seconds durableTimeout,
+                    int64_t statFileLimit = 0, int64_t statDiskSpaceLimit = 0);
 
   void RegisterAdminRegion(AdminRegionPtr adminRegPtr) {
     m_adminRegion = adminRegPtr;
diff --git a/cppcache/src/util/bounds.hpp b/cppcache/src/util/bounds.hpp
new file mode 100644
index 00000000..d7b6a137
--- /dev/null
+++ b/cppcache/src/util/bounds.hpp
@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#ifndef GEODE_UTIL_BOUNDS_H_
+#define GEODE_UTIL_BOUNDS_H_
+
+#include "chrono/duration_bounds.hpp"
+
+namespace apache {
+namespace geode {
+namespace util {
+
+constexpr auto PROTOCOL_OPERATION_TIMEOUT_BOUNDS =
+    chrono::duration::assert_bounds<int32_t, std::milli, 0>{};
+
+}  // namespace util
+}  // namespace geode
+}  // namespace apache
+
+#endif  // GEODE_UTIL_BOUNDS_H_
diff --git a/cppcache/src/util/chrono/duration.cpp b/cppcache/src/util/chrono/duration.cpp
new file mode 100644
index 00000000..c2424a75
--- /dev/null
+++ b/cppcache/src/util/chrono/duration.cpp
@@ -0,0 +1,37 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <geode/util/chrono/duration.hpp>
+
+namespace apache {
+namespace geode {
+namespace util {
+namespace chrono {
+namespace duration {
+
+constexpr char const* _suffix<std::ratio<3600>>::value;
+constexpr char const* _suffix<std::ratio<60>>::value;
+constexpr char const* _suffix<std::ratio<1>>::value;
+constexpr char const* _suffix<std::milli>::value;
+constexpr char const* _suffix<std::micro>::value;
+constexpr char const* _suffix<std::nano>::value;
+
+}  // namespace duration
+}  // namespace chrono
+}  // namespace util
+}  // namespace geode
+}  // namespace apache
diff --git a/cppcache/src/util/chrono/duration_bounds.hpp b/cppcache/src/util/chrono/duration_bounds.hpp
new file mode 100644
index 00000000..4fa3d512
--- /dev/null
+++ b/cppcache/src/util/chrono/duration_bounds.hpp
@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#ifndef GEODE_UTIL_CHRONO_DURATION_BOUNDS_H_
+#define GEODE_UTIL_CHRONO_DURATION_BOUNDS_H_
+
+#include <chrono>
+#include <algorithm>
+
+#include <geode/ExceptionTypes.hpp>
+
+namespace apache {
+namespace geode {
+namespace util {
+namespace chrono {
+namespace duration {
+
+using namespace apache::geode::client;
+
+template <class LimitRep, class LimitPeriod,
+          LimitRep lower = std::numeric_limits<LimitRep>::lowest(),
+          LimitRep upper = std::numeric_limits<LimitRep>::max()>
+struct assert_bounds {
+  template <class Rep, class Period>
+  inline void operator()(const std::chrono::duration<Rep, Period> value) const {
+    constexpr auto min = std::chrono::duration<LimitRep, LimitPeriod>(lower);
+    constexpr auto max = std::chrono::duration<LimitRep, LimitPeriod>(upper);
+    if (value > max) {
+      throw IllegalArgumentException("Duration exceeds maximum of " +
+                                     to_string(max));
+    } else if (value < min) {
+      throw IllegalArgumentException("Duration exceeds minimum of " +
+                                     to_string(min));
+    }
+  }
+};
+
+}  // namespace duration
+}  // namespace chrono
+}  // namespace util
+}  // namespace geode
+}  // namespace apache
+
+#endif  // GEODE_UTIL_CHRONO_DURATION_BOUNDS_H_
diff --git a/cppcache/test/AttributesFactoryTest.cpp b/cppcache/test/AttributesFactoryTest.cpp
new file mode 100644
index 00000000..1fa375e8
--- /dev/null
+++ b/cppcache/test/AttributesFactoryTest.cpp
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+
+#include <geode/AttributesFactory.hpp>
+
+using namespace apache::geode::client;
+
+TEST(AttributesFactoryTest, setEntryIdleTimeoutSeconds) {
+  AttributesFactory attributesFactory;
+  attributesFactory.setEntryIdleTimeout(ExpirationAction::DESTROY,
+                                        std::chrono::seconds(10));
+  auto regionAttributes = attributesFactory.createRegionAttributes();
+  EXPECT_EQ(std::chrono::seconds(10), regionAttributes->getEntryIdleTimeout());
+}
+
+TEST(AttributesFactoryTest, setEntryTimeToLiveSeconds) {
+  AttributesFactory attributesFactory;
+  attributesFactory.setEntryTimeToLive(ExpirationAction::DESTROY,
+                                       std::chrono::seconds(10));
+  auto regionAttributes = attributesFactory.createRegionAttributes();
+  EXPECT_EQ(std::chrono::seconds(10), regionAttributes->getEntryTimeToLive());
+}
+
+TEST(AttributesFactoryTest, setRegionIdleTimeoutSeconds) {
+  AttributesFactory attributesFactory;
+  attributesFactory.setRegionIdleTimeout(ExpirationAction::DESTROY,
+                                         std::chrono::seconds(10));
+  auto regionAttributes = attributesFactory.createRegionAttributes();
+  EXPECT_EQ(std::chrono::seconds(10), regionAttributes->getRegionIdleTimeout());
+}
+
+TEST(AttributesFactoryTest, setRegionTimeToLiveSeconds) {
+  AttributesFactory attributesFactory;
+  attributesFactory.setRegionTimeToLive(ExpirationAction::DESTROY,
+                                        std::chrono::seconds(10));
+  auto regionAttributes = attributesFactory.createRegionAttributes();
+  EXPECT_EQ(std::chrono::seconds(10), regionAttributes->getRegionTimeToLive());
+}
diff --git a/cppcache/test/CacheXmlParserTest.cpp b/cppcache/test/CacheXmlParserTest.cpp
index b0d44045..ab3f7fd0 100644
--- a/cppcache/test/CacheXmlParserTest.cpp
+++ b/cppcache/test/CacheXmlParserTest.cpp
@@ -25,8 +25,8 @@ std::string xsd_prefix = R"(<?xml version='1.0' encoding='UTF-8'?>
 <client-cache
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns="http://schema.pivotal.io/gemfire/gfcpp-cache"
-  xsi:schemaLocation="http://schema.pivotal.io/gemfire/gfcpp-cache"
-  version='9.0'
+  xsi:schemaLocation="http://schema.pivotal.io/gemfire/gfcpp-cache-10.0.xsd"
+  version='10.0'
 >)";
 
 std::string valid_cache_config_body = R"(<root-region name = 'Root1' >
@@ -37,16 +37,16 @@ std::string valid_cache_config_body = R"(<root-region name = 'Root1' >
                            concurrency-level='10'
                            lru-entries-limit = '35'>
             <region-idle-time>
-                <expiration-attributes timeout='20' action='destroy'/> 
+                <expiration-attributes timeout='20s' action='destroy'/>
             </region-idle-time>
             <entry-idle-time>
-                <expiration-attributes timeout='10' action='invalidate'/>
+                <expiration-attributes timeout='10s' action='invalidate'/>
             </entry-idle-time>
             <region-time-to-live>
-                <expiration-attributes timeout='0' action='local-destroy'/>
+                <expiration-attributes timeout='0s' action='local-destroy'/>
             </region-time-to-live>
             <entry-time-to-live>
-                <expiration-attributes timeout='0' action='local-invalidate'/>
+                <expiration-attributes timeout='0s' action='local-invalidate'/>
             </entry-time-to-live>
         </region-attributes>
         <region name='SubRegion1'>
@@ -65,16 +65,16 @@ std::string valid_cache_config_body = R"(<root-region name = 'Root1' >
                            load-factor='0.75'
                            concurrency-level='16'>
             <region-time-to-live>
-                <expiration-attributes timeout='0' action='destroy'/>
+                <expiration-attributes timeout='0s' action='destroy'/>
             </region-time-to-live>
             <region-idle-time>
-                <expiration-attributes timeout='0' action='invalidate'/>
+                <expiration-attributes timeout='0s' action='invalidate'/>
             </region-idle-time>
             <entry-time-to-live>
-                <expiration-attributes timeout='0' action='destroy'/>
+                <expiration-attributes timeout='0s' action='destroy'/>
             </entry-time-to-live>
             <entry-idle-time>
-                <expiration-attributes timeout='0' action='invalidate'/>
+                <expiration-attributes timeout='0s' action='invalidate'/>
             </entry-idle-time>
         </region-attributes>
         <region name='SubRegion21'>
@@ -84,10 +84,10 @@ std::string valid_cache_config_body = R"(<root-region name = 'Root1' >
                                load-factor='0.75'
                                concurrency-level='16'>
                 <region-idle-time>
-                    <expiration-attributes timeout='20' action='destroy'/>
+                    <expiration-attributes timeout='20s' action='destroy'/>
                 </region-idle-time>
                 <entry-idle-time>
-                    <expiration-attributes timeout='10' action='invalidate'/>
+                    <expiration-attributes timeout='10s' action='invalidate'/>
                 </entry-idle-time>
             </region-attributes>
         </region>
@@ -98,20 +98,8 @@ std::string valid_cache_config_body = R"(<root-region name = 'Root1' >
     </root-region>
 </client-cache>)";
 
-std::string dtd_prefix = R"(<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE cache PUBLIC
-    "-//GemStone Systems, Inc.//Geode Declarative Caching 3.6//EN"
-    "http://www.gemstone.com/dtd/gfcpp-cache3600.dtd">
-<client-cache>)";
-
 TEST(CacheXmlParser, CanParseRegionConfigFromAValidXsdCacheConfig) {
   CacheXmlParser parser(nullptr);
   std::string xml = xsd_prefix + valid_cache_config_body;
   parser.parseMemory(xml.c_str(), static_cast<int>(xml.length()));
 }
-
-TEST(CacheXmlParser, CanParseRegionConfigFromAValidDtdCacheConfig) {
-  CacheXmlParser parser(nullptr);
-  std::string xml = dtd_prefix + valid_cache_config_body;
-  parser.parseMemory(xml.c_str(), static_cast<int>(xml.length()));
-}
diff --git a/cppcache/test/ClientProxyMembershipIDFactoryTest.cpp b/cppcache/test/ClientProxyMembershipIDFactoryTest.cpp
index d5938121..f8a72e72 100644
--- a/cppcache/test/ClientProxyMembershipIDFactoryTest.cpp
+++ b/cppcache/test/ClientProxyMembershipIDFactoryTest.cpp
@@ -27,7 +27,8 @@ TEST(ClientProxyMembershipIDFactoryTest, testCreate) {
   ClientProxyMembershipIDFactory factory("myDs");
 
   auto hostAddr = htonl(1);
-  auto id = factory.create("myHost", hostAddr, 2, "myClientID", 3);
+  auto id = factory.create("myHost", hostAddr, 2, "myClientID",
+                           std::chrono::seconds(3));
   ASSERT_NE(nullptr, id);
 
   EXPECT_EQ("myDs", id->getDSName());
diff --git a/cppcache/test/TcrMessage_unittest.cpp b/cppcache/test/TcrMessage_unittest.cpp
index 2fb04175..33fe861d 100644
--- a/cppcache/test/TcrMessage_unittest.cpp
+++ b/cppcache/test/TcrMessage_unittest.cpp
@@ -66,7 +66,7 @@ TEST_F(TcrMessageTest, intializeDefaultConstructor) {
 TEST_F(TcrMessageTest, testConstructor1MessageDataContentWithDESTROY_REGION) {
   const Region *region = nullptr;
   const SerializablePtr aCallbackArgument = nullptr;
-  int messageResponseTimeout = 1000;
+  std::chrono::milliseconds messageResponseTimeout{1000};
   ThinClientBaseDM *connectionDM = nullptr;
 
   TcrMessageDestroyRegion message(
@@ -85,7 +85,7 @@ TEST_F(TcrMessageTest, testConstructor1MessageDataContentWithDESTROY_REGION) {
 TEST_F(TcrMessageTest, testConstructor1MessageDataContentWithCLEAR_REGION) {
   const Region *region = nullptr;
   const SerializablePtr aCallbackArgument = nullptr;
-  int messageResponseTimeout = 1000;
+  std::chrono::milliseconds messageResponseTimeout{1000};
   ThinClientBaseDM *connectionDM = nullptr;
 
   TcrMessageClearRegion message(
@@ -100,7 +100,7 @@ TEST_F(TcrMessageTest, testConstructor1MessageDataContentWithCLEAR_REGION) {
 }
 
 TEST_F(TcrMessageTest, testQueryConstructorMessageDataCotent) {
-  int messageResponseTimeout = 1000;
+  std::chrono::milliseconds messageResponseTimeout{1000};
   ThinClientBaseDM *connectionDM = nullptr;
 
   TcrMessageCloseCQ message(
@@ -116,7 +116,7 @@ TEST_F(TcrMessageTest, testQueryConstructorMessageDataCotent) {
 }
 
 TEST_F(TcrMessageTest, testQueryConstructorWithQUERY) {
-  int messageResponseTimeout = 1000;
+  std::chrono::milliseconds messageResponseTimeout{1000};
   ThinClientBaseDM *connectionDM = nullptr;
 
   TcrMessageQuery message(
@@ -132,7 +132,7 @@ TEST_F(TcrMessageTest, testQueryConstructorWithQUERY) {
 }
 
 TEST_F(TcrMessageTest, testQueryConstructorWithSTOPCQ_MSG_TYPE) {
-  int messageResponseTimeout = 1000;
+  std::chrono::milliseconds messageResponseTimeout{1000};
   ThinClientBaseDM *connectionDM = nullptr;
 
   TcrMessageStopCQ message(
@@ -148,7 +148,7 @@ TEST_F(TcrMessageTest, testQueryConstructorWithSTOPCQ_MSG_TYPE) {
 }
 
 TEST_F(TcrMessageTest, testQueryConstructorWithCLOSECQ_MSG_TYPE) {
-  int messageResponseTimeout = 1000;
+  std::chrono::milliseconds messageResponseTimeout{1000};
   ThinClientBaseDM *connectionDM = nullptr;
 
   TcrMessageCloseCQ message(
@@ -165,7 +165,7 @@ TEST_F(TcrMessageTest, testQueryConstructorWithCLOSECQ_MSG_TYPE) {
 
 TEST_F(TcrMessageTest,
        testParameterizedQueryConstructorWithQUERY_WITH_PARAMETERS) {
-  int messageResponseTimeout = 1000;
+  std::chrono::milliseconds messageResponseTimeout{1000};
   ThinClientBaseDM *connectionDM = nullptr;
   const SerializablePtr aCallbackArgument = nullptr;
   CacheableVectorPtr paramList = CacheableVector::create();
@@ -578,7 +578,7 @@ TEST_F(TcrMessageTest, testConstructorEXECUTE_REGION_FUNCTION_SINGLE_HOP) {
       std::unique_ptr<DataOutputUnderTest>(new DataOutputUnderTest()),
       "myFuncName", region, myPtr, myHashCachePtr, 2, myHashCachePtr,
       false,  // allBuckets
-      1, static_cast<ThinClientBaseDM *>(nullptr));
+      std::chrono::milliseconds{1}, static_cast<ThinClientBaseDM *>(nullptr));
 
   EXPECT_EQ(TcrMessage::EXECUTE_REGION_FUNCTION_SINGLE_HOP,
             message.getMessageType());
@@ -602,8 +602,9 @@ TEST_F(TcrMessageTest, testConstructorEXECUTE_REGION_FUNCTION) {
 
   TcrMessageExecuteRegionFunction testMessage(
       std::unique_ptr<DataOutputUnderTest>(new DataOutputUnderTest()),
-      "ExecuteRegion", region, myCacheablePtr, myVectPtr, 2, myHashCachePtr, 10,
-      static_cast<ThinClientBaseDM *>(nullptr), 10);
+      "ExecuteRegion", region, myCacheablePtr, myVectPtr, 2, myHashCachePtr,
+      std::chrono::milliseconds{10}, static_cast<ThinClientBaseDM *>(nullptr),
+      10);
 
   EXPECT_EQ(TcrMessage::EXECUTE_REGION_FUNCTION, testMessage.getMessageType());
   // this message is currently blank so this should change it if the impl
@@ -625,7 +626,7 @@ TEST_F(TcrMessageTest, DISABLED_testConstructorEXECUTE_FUNCTION) {
   TcrMessageExecuteFunction testMessage(
       std::unique_ptr<DataOutputUnderTest>(new DataOutputUnderTest()),
       "ExecuteFunction", myCacheablePtr, 1,
-      static_cast<ThinClientBaseDM *>(nullptr), 10);
+      static_cast<ThinClientBaseDM *>(nullptr), std::chrono::milliseconds{10});
 
   EXPECT_EQ(TcrMessage::EXECUTE_FUNCTION, testMessage.getMessageType());
 
diff --git a/cppcache/test/util/chrono/durationTest.cpp b/cppcache/test/util/chrono/durationTest.cpp
new file mode 100644
index 00000000..25e7773e
--- /dev/null
+++ b/cppcache/test/util/chrono/durationTest.cpp
@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <chrono>
+#include <algorithm>
+
+#include <gtest/gtest.h>
+
+#include <geode/util/chrono/duration.hpp>
+
+#include "util/chrono/duration_bounds.hpp"
+
+using namespace apache::geode::util::chrono::duration;
+
+TEST(util_chrono_durationTest, ceil) {
+  EXPECT_EQ(std::chrono::seconds(1),
+            _ceil<std::chrono::seconds>(std::chrono::milliseconds(1)));
+  EXPECT_EQ(std::chrono::milliseconds(1),
+            _ceil<std::chrono::milliseconds>(std::chrono::milliseconds(1)));
+  EXPECT_EQ(std::chrono::microseconds(1000),
+            _ceil<std::chrono::milliseconds>(std::chrono::milliseconds(1)));
+}
+
+TEST(util_chrono_durationTest, to_string) {
+  EXPECT_EQ("42h", to_string(std::chrono::hours(42)));
+  EXPECT_EQ("42min", to_string(std::chrono::minutes(42)));
+  EXPECT_EQ("42s", to_string(std::chrono::seconds(42)));
+  EXPECT_EQ("42ms", to_string(std::chrono::milliseconds(42)));
+  EXPECT_EQ("42us", to_string(std::chrono::microseconds(42)));
+  EXPECT_EQ("42ns", to_string(std::chrono::nanoseconds(42)));
+  EXPECT_EQ("0ns", to_string(std::chrono::nanoseconds(0)));
+  EXPECT_EQ("-42ns", to_string(std::chrono::nanoseconds(-42)));
+}
+
+TEST(util_chrono_durationTest, from_string) {
+  EXPECT_EQ(std::chrono::hours(42), from_string("42h"));
+  EXPECT_EQ(std::chrono::minutes(42), from_string("42min"));
+  EXPECT_EQ(std::chrono::seconds(42), from_string("42s"));
+  EXPECT_EQ(std::chrono::milliseconds(42), from_string("42ms"));
+  EXPECT_EQ(std::chrono::microseconds(42), from_string("42us"));
+  EXPECT_EQ(std::chrono::nanoseconds(42), from_string("42ns"));
+  EXPECT_EQ(std::chrono::nanoseconds(0), from_string("0ns"));
+  EXPECT_EQ(std::chrono::nanoseconds(-42), from_string("-42ns"));
+}
+
+TEST(util_chrono_durationTest, from_stringWithCeil) {
+  EXPECT_EQ(std::chrono::hours(42), from_string<std::chrono::hours>("42h"));
+  EXPECT_EQ(std::chrono::hours(1), from_string<std::chrono::hours>("42min"));
+  EXPECT_EQ(std::chrono::minutes(1), from_string<std::chrono::minutes>("42s"));
+  EXPECT_EQ(std::chrono::seconds(1), from_string<std::chrono::seconds>("42ms"));
+  EXPECT_EQ(std::chrono::milliseconds(1),
+            from_string<std::chrono::milliseconds>("42us"));
+  EXPECT_EQ(std::chrono::microseconds(1),
+            from_string<std::chrono::microseconds>("42ns"));
+  EXPECT_EQ(std::chrono::seconds(2),
+            from_string<std::chrono::seconds>("2000ms"));
+}
+
+TEST(util_chrono_durationTest, from_stringException) {
+  ASSERT_THROW(from_string("42"), std::invalid_argument);
+}
+
+TEST(util_chrono_durationTest, assert_bounds) {
+  auto protocolTimeoutLimit = assert_bounds<int32_t, std::milli, 0>{};
+
+  ASSERT_NO_THROW(protocolTimeoutLimit(std::chrono::milliseconds(2147483647)));
+
+  ASSERT_THROW(protocolTimeoutLimit(std::chrono::milliseconds(2147483648)),
+               std::invalid_argument);
+
+  ASSERT_THROW(protocolTimeoutLimit(std::chrono::hours(2400)),
+               std::invalid_argument);
+
+  ASSERT_NO_THROW(protocolTimeoutLimit(std::chrono::milliseconds(0)));
+
+  ASSERT_THROW(protocolTimeoutLimit(std::chrono::milliseconds(-2)),
+               std::invalid_argument);
+
+  ASSERT_THROW(protocolTimeoutLimit(std::chrono::hours(-2400)),
+               std::invalid_argument);
+}
diff --git a/cryptoimpl/SSLImpl.cpp b/cryptoimpl/SSLImpl.cpp
index 775c2c71..3e838048 100644
--- a/cryptoimpl/SSLImpl.cpp
+++ b/cryptoimpl/SSLImpl.cpp
@@ -14,6 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 #include "SSLImpl.hpp"
 
 #include <ace/INET_Addr.h>
@@ -24,6 +25,10 @@
 #include <ace/OS.h>
 #include <cstdint>
 
+namespace apache {
+namespace geode {
+namespace client {
+
 ACE_Recursive_Thread_Mutex SSLImpl::s_mutex;
 volatile bool SSLImpl::s_initialized = false;
 
@@ -92,29 +97,25 @@ int SSLImpl::setOption(int level, int option, void *optval, int optlen) {
   return m_io->set_option(level, option, optval, optlen);
 }
 
-int SSLImpl::listen(ACE_INET_Addr addr, unsigned waitSeconds) {
+int SSLImpl::listen(ACE_INET_Addr addr, std::chrono::microseconds waitSeconds) {
   ACE_SSL_SOCK_Acceptor listener(addr, 1);
-  int32_t retVal = 0;
-  if (waitSeconds > 0) {
+  if (waitSeconds > std::chrono::microseconds::zero()) {
     ACE_Time_Value wtime(waitSeconds);
-    retVal = listener.accept(*m_io, 0, &wtime);
+    return listener.accept(*m_io, 0, &wtime);
   } else {
-    retVal = listener.accept(*m_io, 0);
+    return listener.accept(*m_io, 0);
   }
-  return retVal;
 }
 
-int SSLImpl::connect(ACE_INET_Addr ipaddr, unsigned waitSeconds) {
+int SSLImpl::connect(ACE_INET_Addr ipaddr,
+                     std::chrono::microseconds waitSeconds) {
   ACE_SSL_SOCK_Connector conn;
-  int32_t retVal = 0;
-  if (waitSeconds > 0) {
-    // passing wait time as microseconds
-    ACE_Time_Value wtime(0, waitSeconds);
-    retVal = conn.connect(*m_io, ipaddr, &wtime);
+  if (waitSeconds > std::chrono::microseconds::zero()) {
+    ACE_Time_Value wtime(waitSeconds);
+    return conn.connect(*m_io, ipaddr, &wtime);
   } else {
-    retVal = conn.connect(*m_io, ipaddr);
+    return conn.connect(*m_io, ipaddr);
   }
-  return retVal;
 }
 
 ssize_t SSLImpl::recv(void *buf, size_t len, const ACE_Time_Value *timeout,
@@ -129,3 +130,7 @@ ssize_t SSLImpl::send(const void *buf, size_t len,
 }
 
 int SSLImpl::getLocalAddr(ACE_Addr &addr) { return m_io->get_local_addr(addr); }
+
+}  // namespace client
+}  // namespace geode
+}  // namespace apache
diff --git a/cryptoimpl/SSLImpl.hpp b/cryptoimpl/SSLImpl.hpp
index ca692471..f37356ed 100644
--- a/cryptoimpl/SSLImpl.hpp
+++ b/cryptoimpl/SSLImpl.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_CRYPTOIMPL_SSLIMPL_H_
-#define GEODE_CRYPTOIMPL_SSLIMPL_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,18 +15,29 @@
  * limitations under the License.
  */
 
-#include <geode/geode_base.hpp>
-#include "ace/ACE.h"
-#include "ace/OS.h"
+#pragma once
+
+#ifndef GEODE_CRYPTOIMPL_SSLIMPL_H_
+#define GEODE_CRYPTOIMPL_SSLIMPL_H_
+
+#include <ace/ACE.h>
+#include <ace/OS.h>
 #include <ace/INET_Addr.h>
 #include <ace/SOCK_IO.h>
 #include <ace/SSL/SSL_SOCK_Connector.h>
 #include <ace/SSL/SSL_SOCK_Acceptor.h>
 #include <ace/OS.h>
 #include <ace/Recursive_Thread_Mutex.h>
-#include "ace/Time_Value.h"
+#include <ace/Time_Value.h>
+
+#include <geode/geode_base.hpp>
+
 #include "Ssl.hpp"
 
+namespace apache {
+namespace geode {
+namespace client {
+
 class SSLImpl : public apache::geode::client::Ssl {
  private:
   ACE_SSL_SOCK_Stream* m_io;
@@ -43,13 +49,13 @@ class SSLImpl : public apache::geode::client::Ssl {
           const char* password);
   virtual ~SSLImpl();
 
-  int setOption(int, int, void*, int);
-  int listen(ACE_INET_Addr, unsigned);
-  int connect(ACE_INET_Addr, unsigned);
-  ssize_t recv(void*, size_t, const ACE_Time_Value*, size_t*);
-  ssize_t send(const void*, size_t, const ACE_Time_Value*, size_t*);
-  int getLocalAddr(ACE_Addr&);
-  void close();
+  int setOption(int, int, void*, int) override;
+  int listen(ACE_INET_Addr, std::chrono::microseconds) override;
+  int connect(ACE_INET_Addr, std::chrono::microseconds) override;
+  ssize_t recv(void*, size_t, const ACE_Time_Value*, size_t*) override;
+  ssize_t send(const void*, size_t, const ACE_Time_Value*, size_t*) override;
+  int getLocalAddr(ACE_Addr&) override;
+  void close() override;
 };
 
 extern "C" {
@@ -59,4 +65,8 @@ CPPCACHE_EXPORT void* gf_create_SslImpl(ACE_SOCKET sock, const char* pubkeyfile,
 CPPCACHE_EXPORT void gf_destroy_SslImpl(void* impl);
 }
 
+}  // namespace client
+}  // namespace geode
+}  // namespace apache
+
 #endif  // GEODE_CRYPTOIMPL_SSLIMPL_H_
diff --git a/cryptoimpl/Ssl.hpp b/cryptoimpl/Ssl.hpp
index 4bd08545..8e5e1ff2 100644
--- a/cryptoimpl/Ssl.hpp
+++ b/cryptoimpl/Ssl.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_CRYPTOIMPL_SSL_H_
-#define GEODE_CRYPTOIMPL_SSL_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -19,12 +14,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-/*
- * Ssl.hpp
- *
- *  Created on: 28-Apr-2010
- *      Author: ankurs
- */
+
+#pragma once
+
+#ifndef GEODE_CRYPTOIMPL_SSL_H_
+#define GEODE_CRYPTOIMPL_SSL_H_
+
+#include <chrono>
 
 #include <ace/INET_Addr.h>
 #include <ace/OS.h>
@@ -36,8 +32,8 @@ class Ssl {
  public:
   virtual ~Ssl(){};
   virtual int setOption(int, int, void*, int) = 0;
-  virtual int listen(ACE_INET_Addr, unsigned) = 0;
-  virtual int connect(ACE_INET_Addr, unsigned) = 0;
+  virtual int listen(ACE_INET_Addr, std::chrono::microseconds) = 0;
+  virtual int connect(ACE_INET_Addr, std::chrono::microseconds) = 0;
   virtual ssize_t recv(void*, size_t, const ACE_Time_Value*, size_t*) = 0;
   virtual ssize_t send(const void*, size_t, const ACE_Time_Value*, size_t*) = 0;
   virtual int getLocalAddr(ACE_Addr&) = 0;
diff --git a/dependencies/ACE/config.h.in b/dependencies/ACE/config.h.in
index ddd936cc..931400c8 100755
--- a/dependencies/ACE/config.h.in
+++ b/dependencies/ACE/config.h.in
@@ -14,11 +14,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+ 
 #define ACE_LACKS_IOSTREAM_TOTALLY 1
 #define ACE_HAS_VERSIONED_NAMESPACE 1
 
-#if defined __SUNPRO_CC && __cplusplus >= 201103L
+#if __cplusplus >= 201103L
+
+#if defined(__clang__)
+#define ACE_HAS_CPP11 1
+#endif
+
+#if defined(__SUNPRO_CC)
+#define ACE_HAS_CPP11 1
 #define _RWSTD_ALLOCATOR 1
 #endif
 
+#endif // __cplusplus >= 201103L
+
 #include "ace/config-@ACE_CONFIG@.h"
+
diff --git a/docs/geode-native-docs/preserving-data/configuring-durable-nc.html.md.erb b/docs/geode-native-docs/preserving-data/configuring-durable-nc.html.md.erb
index d60d2b50..3eb1a370 100644
--- a/docs/geode-native-docs/preserving-data/configuring-durable-nc.html.md.erb
+++ b/docs/geode-native-docs/preserving-data/configuring-durable-nc.html.md.erb
@@ -48,6 +48,6 @@ This programmatic example creates a durable client using the `CacheFactory::set(
 // Create durable client's properties using the C++ api
 PropertiesPtr pp = Properties::create();
 pp->insert("durable-client-id", "DurableClientId");
-pp->insert("durable-timeout", 200);
+pp->insert("durable-timeout", std::chrono::seconds(200));
 cacheFactoryPtr = CacheFactory::createCacheFactory(pp);
 ```
diff --git a/quickstart/cpp/DurableClient.cpp b/quickstart/cpp/DurableClient.cpp
index 3d82abbe..f509bad8 100644
--- a/quickstart/cpp/DurableClient.cpp
+++ b/quickstart/cpp/DurableClient.cpp
@@ -44,7 +44,7 @@ void RunDurableClient() {
   // Create durable client's properties using api.
   PropertiesPtr pp = Properties::create();
   pp->insert("durable-client-id", "DurableClientId");
-  pp->insert("durable-timeout", 300);
+  pp->insert("durable-timeout", std::chrono::seconds(300));
 
   // Create a Geode Cache Programmatically.
   CacheFactoryPtr cacheFactory = CacheFactory::createCacheFactory(pp);
diff --git a/quickstart/csharp/DurableClient.cs b/quickstart/csharp/DurableClient.cs
index e61fd474..1b86eb16 100644
--- a/quickstart/csharp/DurableClient.cs
+++ b/quickstart/csharp/DurableClient.cs
@@ -45,7 +45,7 @@ public void RunDurableClient()
         // Create durable client's properties using api.
       Properties<string, string> durableProp = Properties<string, string>.Create<string, string>();
         durableProp.Insert("durable-client-id", "DurableClientId");
-        durableProp.Insert("durable-timeout", "300");
+        durableProp.Insert("durable-timeout", "300s");
 
         // Create a Geode Cache programmatically.
         CacheFactory cacheFactory = CacheFactory.CreateCacheFactory(durableProp);
diff --git a/tests/cli/FwkUtil/FwkData.cs b/tests/cli/FwkUtil/FwkData.cs
index c5f6c40b..f8bbcad2 100644
--- a/tests/cli/FwkUtil/FwkData.cs
+++ b/tests/cli/FwkUtil/FwkData.cs
@@ -265,7 +265,7 @@ public static void SetThisAttribute(string name, XmlNode node, Apache.Geode.Clie
             XmlAttributeCollection exAttrColl = nlrttl.Attributes;
             Apache.Geode.Client.ExpirationAction action = StrToExpirationAction(exAttrColl["action"].Value);
             string rttl = exAttrColl["timeout"].Value;
-            af.SetRegionTimeToLive(action, uint.Parse(rttl));
+            af.SetRegionTimeToLive(action, TimeSpan.FromSeconds(uint.Parse(rttl)));
           }
           else
           {
@@ -280,7 +280,7 @@ public static void SetThisAttribute(string name, XmlNode node, Apache.Geode.Clie
             XmlAttributeCollection exAttrColl = nlrit.Attributes;
             Apache.Geode.Client.ExpirationAction action = StrToExpirationAction(exAttrColl["action"].Value);
             string rit = exAttrColl["timeout"].Value;
-            af.SetRegionIdleTimeout(action, uint.Parse(rit));
+            af.SetRegionIdleTimeout(action, TimeSpan.FromSeconds(uint.Parse(rit)));
           }
           else
           {
@@ -295,7 +295,7 @@ public static void SetThisAttribute(string name, XmlNode node, Apache.Geode.Clie
             XmlAttributeCollection exAttrColl = nlettl.Attributes;
             Apache.Geode.Client.ExpirationAction action = StrToExpirationAction(exAttrColl["action"].Value);
             string ettl = exAttrColl["timeout"].Value;
-            af.SetEntryTimeToLive(action, uint.Parse(ettl));
+            af.SetEntryTimeToLive(action, TimeSpan.FromSeconds(uint.Parse(ettl)));
           }
           else
           {
@@ -310,7 +310,7 @@ public static void SetThisAttribute(string name, XmlNode node, Apache.Geode.Clie
             XmlAttributeCollection exAttrColl = nleit.Attributes;
             Apache.Geode.Client.ExpirationAction action = StrToExpirationAction(exAttrColl["action"].Value);
             string eit = exAttrColl["timeout"].Value;
-            af.SetEntryIdleTimeout(action, uint.Parse(eit));
+            af.SetEntryIdleTimeout(action, TimeSpan.FromSeconds(uint.Parse(eit)));
           }
           else
           {
diff --git a/tests/cli/NewFwkLib/CacheHelper.cs b/tests/cli/NewFwkLib/CacheHelper.cs
index f3c47537..ffdff1a3 100644
--- a/tests/cli/NewFwkLib/CacheHelper.cs
+++ b/tests/cli/NewFwkLib/CacheHelper.cs
@@ -276,7 +276,7 @@ public static void InitConfigForPoolDurable(string durableClientId, int durableT
     {
       Properties<string,string> config = new Properties<string,string>();
       config.Insert("durable-client-id", durableClientId);
-      config.Insert("durable-timeout", durableTimeout.ToString());
+      config.Insert("durable-timeout", durableTimeout.ToString() + "s");
       if (conflateEvents != null && conflateEvents.Length > 0)
       {
         config.Insert("conflate-events", conflateEvents);
diff --git a/tests/cli/NewFwkLib/CacheServer.cs b/tests/cli/NewFwkLib/CacheServer.cs
index dddcbdf1..ccb11825 100644
--- a/tests/cli/NewFwkLib/CacheServer.cs
+++ b/tests/cli/NewFwkLib/CacheServer.cs
@@ -856,7 +856,7 @@ public class CacheServer<TKey, TVal> : FwkTest<TKey, TVal>
   {
     #region Private constants and statics
 
-    private const UInt32 QueryResponseTimeout = 600;
+    private static TimeSpan QueryResponseTimeout = TimeSpan.FromSeconds(600);
     private const string RegionName = "regionName";
     private const string ValueSizes = "valueSizes";
     private const string OpsSecond = "opsSecond";
@@ -1100,11 +1100,11 @@ private TVal GetUserObject(string objType)
           startTime = DateTime.Now;
           if (isparam)
           {
-            results = qry.Execute(paramList,600);
+            results = qry.Execute(paramList, TimeSpan.FromSeconds(600));
           }
           else
           {
-            results = qry.Execute(600);
+            results = qry.Execute(TimeSpan.FromSeconds(600));
           }
           endTime = DateTime.Now;
           elapsedTime = endTime - startTime;
@@ -1250,7 +1250,7 @@ private void PutAllOps()
           map.Add(key, value);
         }
       }
-      region.PutAll(map,60);
+      region.PutAll(map, TimeSpan.FromSeconds(60));
     }
 
     private void GetAllOps()
@@ -1896,7 +1896,7 @@ protected void putAll(IRegion<TKey, TVal> r)
 
    // do the putAll
    FwkInfo("putAll: calling putAll with map of " + mapToPut.Count + " entries");
-   r.PutAll(mapToPut,60);
+   r.PutAll(mapToPut, TimeSpan.FromSeconds(60));
 
    FwkInfo("putAll: done calling putAll with map of " + mapToPut.Count + " entries");
 
@@ -2820,7 +2820,7 @@ public void DoEntryOperationsForSecurity()
             {
               QueryService<TKey, object> qs = CheckQueryService();
               Query<object> qry = qs.NewQuery("select distinct * from /Portfolios where FALSE");
-              ISelectResults<object> result = qry.Execute(600);
+              ISelectResults<object> result = qry.Execute(TimeSpan.FromSeconds(600));
               query++;
             }
             else if (opCode == "cq")
@@ -4691,7 +4691,7 @@ public void DoEntryOperationsForMU()
             {
               QueryService<TKey, object> qs = authCache.GetQueryService<TKey, object>();
               Query<object> qry = qs.NewQuery("select distinct * from /Portfolios where FALSE");
-              ISelectResults<object> result = qry.Execute(600);
+              ISelectResults<object> result = qry.Execute(TimeSpan.FromSeconds(600));
             }
             else if (opCode == "cq")
             {
@@ -4725,7 +4725,7 @@ public void DoEntryOperationsForMU()
                 args.Add("addKey"); 
                 funcName = "RegionOperationsFunction";
                 exc = Client.FunctionService<object>.OnRegion(region);
-                executeFunctionResult = exc.WithArgs(args).WithFilter(filterObj).Execute(funcName, 15).GetResult();
+                executeFunctionResult = exc.WithArgs(args).WithFilter(filterObj).Execute(funcName, TimeSpan.FromSeconds(15)).GetResult();
               }
               else if (num == 1)
               {
@@ -4733,7 +4733,7 @@ public void DoEntryOperationsForMU()
                 funcName = "ServerOperationsFunction";
                 //exc = region.Cache.GetFunctionService().OnServer();
                 exc = Client.FunctionService<object>.OnServer(authCache);
-                executeFunctionResult = exc.WithArgs(args).Execute(funcName, 15).GetResult();
+                executeFunctionResult = exc.WithArgs(args).Execute(funcName, TimeSpan.FromSeconds(15)).GetResult();
               }
               else
               {
@@ -4743,7 +4743,7 @@ public void DoEntryOperationsForMU()
                   funcName = "ServerOperationsFunction";
                   //exc = region.Cache.GetFunctionService().OnServers();
                   exc = Client.FunctionService<object>.OnServers(authCache);
-                  executeFunctionResult = exc.WithArgs(args).Execute(funcName, 15).GetResult();
+                  executeFunctionResult = exc.WithArgs(args).Execute(funcName, TimeSpan.FromSeconds(15)).GetResult();
                 }
                 catch (FunctionExecutionException)
                 {
diff --git a/tests/cli/NewFwkLib/FunctionExecution/FunctionExecution.cs b/tests/cli/NewFwkLib/FunctionExecution/FunctionExecution.cs
index 9195aa64..b84d1bf2 100644
--- a/tests/cli/NewFwkLib/FunctionExecution/FunctionExecution.cs
+++ b/tests/cli/NewFwkLib/FunctionExecution/FunctionExecution.cs
@@ -760,28 +760,28 @@ private void ExecuteFunction(Object[] filterObj, string ops)
         if(!isReplicate){
           if(getresult == true){
             if(executionMode == "onRegion"){
-              executeFunctionResult = exc.WithArgs<string>(ops).WithFilter<object>(filterObj).Execute(funcName, 15).GetResult();
+              executeFunctionResult = exc.WithArgs<string>(ops).WithFilter<object>(filterObj).Execute(funcName, TimeSpan.FromSeconds(15)).GetResult();
             }else{
               args.Add(ops);
-              executeFunctionResult = exc.WithArgs<ArrayList>(args).Execute(funcName, 15).GetResult();
+              executeFunctionResult = exc.WithArgs<ArrayList>(args).Execute(funcName, TimeSpan.FromSeconds(15)).GetResult();
             }
           }else {
             if(executionMode == "onRegion"){
-              exc.WithArgs<string>(ops).WithFilter<object>(filterObj).Execute(funcName, 15);
+              exc.WithArgs<string>(ops).WithFilter<object>(filterObj).Execute(funcName, TimeSpan.FromSeconds(15));
             } else {
               args.Add(ops);
-              exc.WithArgs<ArrayList>(args).Execute(funcName, 15);
+              exc.WithArgs<ArrayList>(args).Execute(funcName, TimeSpan.FromSeconds(15));
             }
           }
         } else {
           args.Add(ops);
           if (getresult)
           {
-            executeFunctionResult = exc.WithArgs<ArrayList>(args).Execute(funcName, 15).GetResult();
+            executeFunctionResult = exc.WithArgs<ArrayList>(args).Execute(funcName, TimeSpan.FromSeconds(15)).GetResult();
           }
           else
           {
-            executeFunctionResult = exc.WithArgs<ArrayList>(args).Execute(funcName, 15).GetResult();
+            executeFunctionResult = exc.WithArgs<ArrayList>(args).Execute(funcName, TimeSpan.FromSeconds(15)).GetResult();
           }       
         }
         Thread.Sleep(30000);
@@ -1061,7 +1061,7 @@ public void DoParitionedRegionFunctionExecution()
            exc = exc.WithFilter(filterObj).WithCollector(myRC);
          }
          // execute function
-         Client.IResultCollector<object> rc = exc.Execute("ExceptionHandlingFunction", 30);
+         Client.IResultCollector<object> rc = exc.Execute("ExceptionHandlingFunction", TimeSpan.FromSeconds(30));
 
       }
       catch (Apache.Geode.Client.FunctionExecutionException)
@@ -1085,7 +1085,7 @@ public void DoReplicatedRegionFunctionExecution()
         MyResultCollector<object> myRC = new MyResultCollector<object>();
         exc = exc.WithCollector(myRC);
         // execute function
-        Client.IResultCollector<object> rc = exc.Execute("ExceptionHandlingFunction", 30);
+        Client.IResultCollector<object> rc = exc.Execute("ExceptionHandlingFunction", TimeSpan.FromSeconds(30));
       }
       catch (Apache.Geode.Client.FunctionExecutionException)
       {
@@ -1117,7 +1117,7 @@ public void DoFireAndForgetFunctionExecution()
         MyResultCollector<object> myRC = new MyResultCollector<object>();
         Apache.Geode.Client.Execution<object> exc = Client.FunctionService<object>.OnRegion<TKey, TVal>(region).WithCollector(myRC);
         // execute function
-        Client.IResultCollector<object> rc = exc.Execute("FireNForget", 30);
+        Client.IResultCollector<object> rc = exc.Execute("FireNForget", TimeSpan.FromSeconds(30));
       }
       catch (Apache.Geode.Client.FunctionExecutionException)
       {
@@ -1141,7 +1141,7 @@ public void DoOnServersFunctionExcecution()
         MyResultCollector<object> myRC = new MyResultCollector<object>();
         exc = Client.FunctionService<object>.OnServers(pptr).WithCollector(myRC);
         // execute function
-        Client.IResultCollector<object> rc = exc.Execute("ExceptionHandlingFunction", 30);
+        Client.IResultCollector<object> rc = exc.Execute("ExceptionHandlingFunction", TimeSpan.FromSeconds(30));
       }
       catch (Apache.Geode.Client.FunctionExecutionException)
       {
@@ -1166,7 +1166,7 @@ public void DoExecuteFunctionsHA()
       Apache.Geode.Client.Execution<object> exc = Client.FunctionService<object>.OnRegion<TKey, TVal>(region);
       MyResultCollectorHA<object> myRC = new MyResultCollectorHA<object>();
       exc = exc.WithCollector(myRC);
-      Client.IResultCollector<object>  rc = exc.Execute(funcName, 120);
+      Client.IResultCollector<object>  rc = exc.Execute(funcName, TimeSpan.FromSeconds(120));
       executeFunctionResult = myRC.GetResult();
       if (executeFunctionResult != null)
       {
@@ -1176,7 +1176,7 @@ public void DoExecuteFunctionsHA()
         //Boolean lastResult = (Boolean)executeFunctionResult[0];
        // if (lastResult!= true) 
        //   FwkException("FunctionExecution::DoExecuteFunctionHA failed, last result is not true");
-        ICollection<object> resultListColl = myRC.GetResult(60);
+        ICollection<object> resultListColl = myRC.GetResult(TimeSpan.FromSeconds(60));
         string[] resultList = new string[resultListColl.Count];
         resultList.CopyTo(resultList, 0);
         //FwkInfo("FunctionExecution::DoExecuteFunctionHA GetClearResultCount {0} GetGetResultCount {1} GetAddResultCount {2}", myRC.GetClearResultCount(), myRC.GetGetResultCount(), myRC.GetAddResultCount());
diff --git a/tests/cli/NewFwkLib/FunctionExecution/MyResultCollector.cs b/tests/cli/NewFwkLib/FunctionExecution/MyResultCollector.cs
index 13ec85eb..f886f41d 100644
--- a/tests/cli/NewFwkLib/FunctionExecution/MyResultCollector.cs
+++ b/tests/cli/NewFwkLib/FunctionExecution/MyResultCollector.cs
@@ -26,7 +26,7 @@ namespace Apache.Geode.Client.FwkLib
   public class MyResultCollector<TResult> : Client.IResultCollector<TResult>
   {
     #region Private members
-    private bool m_resultReady = false;
+    private Boolean m_resultReady = false;
     //private CacheableVector m_results = null;
     ICollection<TResult> m_results = null;
     private int m_addResultCount = 0;
@@ -52,48 +52,47 @@ public MyResultCollector()
     public void AddResult(TResult result)
     {
       m_addResultCount++;
-      //CacheableArrayList rs = result as CacheableArrayList;
-      //List<Object> rs = result as List<Object>;
-      //for (int i = 0; i < rs.Count; i++)
-      //{
-      //  m_results.Add(rs[i]);
-      //}
       m_results.Add(result);
     }
     public ICollection<TResult> GetResult()
     {
-      return GetResult(50);
+      return GetResult(TimeSpan.FromSeconds(50));
     }
-    public ICollection<TResult> GetResult(UInt32 timeout)
+    public ICollection<TResult> GetResult(TimeSpan timeout)
     {
       m_getResultCount++;
-      if (m_resultReady == true)
-      {
-        return m_results;
-      }
-      else
+
+      lock(this)
       {
-        for (int i = 0; i < timeout; i++)
+        if (!m_resultReady)
         {
-          Thread.Sleep(1000);
-          if (m_resultReady == true)
-          {
-            return m_results;
+          if (timeout > TimeSpan.Zero) {
+            if (!Monitor.Wait(this, timeout)) {
+              throw new FunctionExecutionException("Timeout waiting for result.");
+            }
+          } else {
+            throw new FunctionExecutionException("Results not ready.");
           }
         }
-        throw new FunctionExecutionException(
-                   "Result is not ready, endResults callback is called before invoking getResult() method");
-
       }
+
+      return m_results;
     }
+
     public void EndResults()
     {
       m_endResultCount++;
-      m_resultReady = true;
+
+      lock (this) {
+        m_resultReady = true;
+        Monitor.Pulse(this);
+      }
     }
+
     public void ClearResults(/*bool unused*/)
     {
       m_results.Clear();
+      m_resultReady = false;
     }
 
   }
@@ -137,39 +136,39 @@ public void AddResult(TResult result)
     }
     public ICollection<TResult> GetResult()
     {
-      return GetResult(50);
+      return GetResult(TimeSpan.FromSeconds(50));
     }
-    public ICollection<TResult> GetResult(UInt32 timeout)
+    public ICollection<TResult> GetResult(TimeSpan timeout)
     {
       m_getResultCount++;
-      if (m_resultReady == true)
-      {
-        return m_results;
-      }
-      else
-      {
-        for (int i = 0; i < timeout; i++)
-        {
-          Thread.Sleep(1000);
-          if (m_resultReady == true)
-          {
-            return m_results;
+
+      lock (this) {
+        if (!m_resultReady) {
+          if (timeout > TimeSpan.Zero) {
+            if (!Monitor.Wait(this, timeout)) {
+              throw new FunctionExecutionException("Timeout waiting for result.");
+            }
+          } else {
+            throw new FunctionExecutionException("Results not ready.");
           }
         }
-        throw new FunctionExecutionException(
-                   "Result is not ready, endResults callback is called before invoking getResult() method");
-
       }
+
+      return m_results;
     }
     public void ClearResults(/*bool unused*/)
     {
       m_clearResultCount++;
       m_results.Clear();
+      m_resultReady = false;
     }
     public void EndResults()
     {
       m_endResultCount++;
-      m_resultReady = true;
+      lock (this) {
+        m_resultReady = true;
+        Monitor.Pulse(this);
+      }
     }
 
   }
diff --git a/tests/cli/NewFwkLib/FwkTest.cs b/tests/cli/NewFwkLib/FwkTest.cs
index da7e5a8b..a85fd98b 100644
--- a/tests/cli/NewFwkLib/FwkTest.cs
+++ b/tests/cli/NewFwkLib/FwkTest.cs
@@ -631,15 +631,15 @@ private void SetThisPoolAttributes(PoolFactory pf,string key, string value)
       {
         case "free-connection-timeout":
           int fct = int.Parse(value);
-           pf.SetFreeConnectionTimeout(fct);
+           pf.SetFreeConnectionTimeout(TimeSpan.FromSeconds(fct));
            break;
         case "idle-timeout":
           int it = int.Parse(value);
-            pf.SetIdleTimeout(it);
+            pf.SetIdleTimeout(TimeSpan.FromSeconds(it));
             break;
         case "load-conditioning-interval":
           int lci = int.Parse(value);
-            pf.SetLoadConditioningInterval(lci);
+            pf.SetLoadConditioningInterval(TimeSpan.FromSeconds(lci));
           break;
         case "max-connections":
           int mxc = int.Parse(value);
@@ -651,11 +651,11 @@ private void SetThisPoolAttributes(PoolFactory pf,string key, string value)
            break;
         case "ping-interval":
           int pi = int.Parse(value);
-            pf.SetPingInterval(pi);
+            pf.SetPingInterval(TimeSpan.FromSeconds(pi));
             break;
         case "read-timeout":
           int rt = int.Parse(value);
-           pf.SetReadTimeout(rt);
+           pf.SetReadTimeout(TimeSpan.FromSeconds(rt));
            break;
         case "retry-attempts":
           int ra = int.Parse(value);
@@ -670,7 +670,7 @@ private void SetThisPoolAttributes(PoolFactory pf,string key, string value)
           break;
         case "subscription-ack-interval":
            int acki = int.Parse(value);
-            pf.SetSubscriptionAckInterval(acki);
+            pf.SetSubscriptionAckInterval(TimeSpan.FromSeconds(acki));
             break;
         case "subscription-enabled":
            if (value == "true")
@@ -694,7 +694,7 @@ private void SetThisPoolAttributes(PoolFactory pf,string key, string value)
           break;
         case "subscription-message-tracking-timeout":
             int smtt = int.Parse(value);
-            pf.SetSubscriptionMessageTrackingTimeout(smtt);
+            pf.SetSubscriptionMessageTrackingTimeout(TimeSpan.FromSeconds(smtt));
             break;
         case "subscription-redundancy":
             int sr = int.Parse(value);
@@ -878,7 +878,7 @@ public static void SetThisAttribute(string name, XmlNode node, RegionFactory af,
             XmlAttributeCollection exAttrColl = nlrttl.Attributes;
             ExpirationAction action = StrToExpirationAction(exAttrColl["action"].Value);
             string rttl = exAttrColl["timeout"].Value;
-            af.SetRegionTimeToLive(action, uint.Parse(rttl));
+            af.SetRegionTimeToLive(action, TimeSpan.FromSeconds(uint.Parse(rttl)));
           }
           else
           {
@@ -893,7 +893,7 @@ public static void SetThisAttribute(string name, XmlNode node, RegionFactory af,
             XmlAttributeCollection exAttrColl = nlrit.Attributes;
             ExpirationAction action = StrToExpirationAction(exAttrColl["action"].Value);
             string rit = exAttrColl["timeout"].Value;
-            af.SetRegionIdleTimeout(action, uint.Parse(rit));
+            af.SetRegionIdleTimeout(action, TimeSpan.FromSeconds(uint.Parse(rit)));
           }
           else
           {
@@ -908,7 +908,7 @@ public static void SetThisAttribute(string name, XmlNode node, RegionFactory af,
             XmlAttributeCollection exAttrColl = nlettl.Attributes;
             ExpirationAction action = StrToExpirationAction(exAttrColl["action"].Value);
             string ettl = exAttrColl["timeout"].Value;
-            af.SetEntryTimeToLive(action, uint.Parse(ettl));
+            af.SetEntryTimeToLive(action, TimeSpan.FromSeconds(uint.Parse(ettl)));
           }
           else
           {
@@ -923,7 +923,7 @@ public static void SetThisAttribute(string name, XmlNode node, RegionFactory af,
             XmlAttributeCollection exAttrColl = nleit.Attributes;
             ExpirationAction action = StrToExpirationAction(exAttrColl["action"].Value);
             string eit = exAttrColl["timeout"].Value;
-            af.SetEntryIdleTimeout(action, uint.Parse(eit));
+            af.SetEntryIdleTimeout(action, TimeSpan.FromSeconds(uint.Parse(eit)));
           }
           else
           {
@@ -1381,8 +1381,8 @@ private void ParseEndPoints(string ep, bool isServer, int redundancyLevel)
         pf.SetMultiuserAuthentication(false);
         FwkInfo("MultiUser Mode is set to false");
       }
-      pf.SetFreeConnectionTimeout(180000);
-      pf.SetReadTimeout(180000);
+      pf.SetFreeConnectionTimeout(TimeSpan.FromMilliseconds(180000));
+      pf.SetReadTimeout(TimeSpan.FromMilliseconds(180000));
       pf.SetMinConnections(20);
       pf.SetMaxConnections(30);
 
diff --git a/tests/cli/NewFwkLib/PdxTest/PdxTests.cs b/tests/cli/NewFwkLib/PdxTest/PdxTests.cs
index f15d6e67..72199d74 100644
--- a/tests/cli/NewFwkLib/PdxTest/PdxTests.cs
+++ b/tests/cli/NewFwkLib/PdxTest/PdxTests.cs
@@ -784,7 +784,7 @@ protected void putAll(IRegion<TKey, TVal> r, int index)
    
             // do the putAll
             FwkTest<TKey, TVal>.CurrentTest.FwkInfo("putAll: calling putAll with map of " + mapToPut.Count + " entries");
-            r.PutAll(mapToPut, 60);
+            r.PutAll(mapToPut, TimeSpan.FromSeconds(60));
 
             FwkTest<TKey, TVal>.CurrentTest.FwkInfo("putAll: done calling putAll with map of " + mapToPut.Count + " entries");
 
@@ -1149,11 +1149,11 @@ private TVal GetUserObject(string objType)
                 startTime = DateTime.Now;
                 if (isparam)
                 {
-                    results = qry.Execute(paramList, 600);
+                    results = qry.Execute(paramList, TimeSpan.FromSeconds(600));
                 }
                 else
                 {
-                    results = qry.Execute(600);
+                    results = qry.Execute(TimeSpan.FromSeconds(600));
                 }
                 endTime = DateTime.Now;
                 elapsedTime = endTime - startTime;
@@ -1275,7 +1275,7 @@ private void PutAllOps()
                     map.Add(key, value);
                 }
             }
-            region.PutAll(map, 60);
+            region.PutAll(map, TimeSpan.FromSeconds(60));
         }
 
         private void GetAllOps()
@@ -3541,7 +3541,7 @@ public void DoEntryOperationsForSecurity()
                         {
                             QueryService<TKey, object> qs = CheckQueryService();
                             Query<object> qry = qs.NewQuery("select distinct * from /Portfolios where FALSE");
-                            ISelectResults<object> result = qry.Execute(600);
+                            ISelectResults<object> result = qry.Execute(TimeSpan.FromSeconds(600));
                         }
                         else if (opCode == "cq")
                         {
diff --git a/tests/cli/NewFwkLib/PerfTest/PerfTests.cs b/tests/cli/NewFwkLib/PerfTest/PerfTests.cs
index 755bcb03..a540f19c 100644
--- a/tests/cli/NewFwkLib/PerfTest/PerfTests.cs
+++ b/tests/cli/NewFwkLib/PerfTest/PerfTests.cs
@@ -945,7 +945,7 @@ public void DoPutAll()
         DateTime endTime;
         TimeSpan elapsedTime;
         startTime = DateTime.Now;
-        region.PutAll(map,60);
+        region.PutAll(map, TimeSpan.FromSeconds(60));
         endTime = DateTime.Now;
         elapsedTime = endTime - startTime;
         FwkInfo("PerfTests.DoPutAll: Time Taken to execute" +
diff --git a/tests/cli/NewFwkLib/QueryTest/QueryTests.cs b/tests/cli/NewFwkLib/QueryTest/QueryTests.cs
index e6f5dd6b..787db672 100644
--- a/tests/cli/NewFwkLib/QueryTest/QueryTests.cs
+++ b/tests/cli/NewFwkLib/QueryTest/QueryTests.cs
@@ -115,7 +115,7 @@ public QueryTests()
 
     #region Private constants
 
-    private const UInt32 QueryResponseTimeout = 600;
+    private static TimeSpan QueryResponseTimeout = TimeSpan.FromSeconds(600);
     
     private const string QueryBB = "QueryBB";
     private const string DistinctKeys = "distinctKeys";
diff --git a/tests/cli/NewFwkLib/ResumableTx/ResumableTx.cs b/tests/cli/NewFwkLib/ResumableTx/ResumableTx.cs
index 6ef069a4..8ac30ca8 100644
--- a/tests/cli/NewFwkLib/ResumableTx/ResumableTx.cs
+++ b/tests/cli/NewFwkLib/ResumableTx/ResumableTx.cs
@@ -122,7 +122,7 @@ public bool commit(TxInfo txInfo)
       bool commited = false;
       CacheTransactionManager txManager = null;
       txManager = CacheHelper<TKey, TVal>.DCache.CacheTransactionManager;
-      if (txManager.TryResume(id, 30000))
+      if (txManager.TryResume(id, TimeSpan.FromMilliseconds(30000)))
       {
         try
         {
@@ -156,7 +156,7 @@ public void rollback(TxInfo txInfo)
       CacheTransactionManager txManager = null;
       bool isRollBack = false;
       txManager = CacheHelper<TKey, TVal>.DCache.CacheTransactionManager;
-      if (txManager.TryResume(id, 30000))
+      if (txManager.TryResume(id, TimeSpan.FromMilliseconds(30000)))
       {
          txManager.Rollback();
          isRollBack = true;
@@ -175,7 +175,7 @@ public void executeTxOps(TxInfo txInfo)
       txManager = CacheHelper<TKey, TVal>.DCache.CacheTransactionManager;
       bool executedOps = false;
       int numOfOpsToDo = 5;
-      if (txManager.TryResume(id, 30000))
+      if (txManager.TryResume(id, TimeSpan.FromMilliseconds(30000)))
       {
         try
         {
diff --git a/tests/cpp/fwklib/FrameworkTest.cpp b/tests/cpp/fwklib/FrameworkTest.cpp
index 73cb357b..636386af 100644
--- a/tests/cpp/fwklib/FrameworkTest.cpp
+++ b/tests/cpp/fwklib/FrameworkTest.cpp
@@ -15,12 +15,14 @@
  * limitations under the License.
  */
 
+#include <geode/AttributesFactory.hpp>
+#include <geode/PoolFactory.hpp>
+#include <geode/util/chrono/duration.hpp>
+
 #include "fwklib/FrameworkTest.hpp"
 #include "fwklib/TestClient.hpp"
 #include "fwklib/FwkLog.hpp"
-#include <geode/AttributesFactory.hpp>
-//#include <geode/RegionAttributes.hpp>
-#include <geode/PoolFactory.hpp>
+
 #include "PoolAttributes.hpp"
 
 #include <util/concurrent/spinlock_mutex.hpp>
@@ -391,8 +393,8 @@ void FrameworkTest::parseEndPoints(int32_t ep, std::string label,
   pfPtr->setMinConnections(20);
   pfPtr->setMaxConnections(30);
   pfPtr->setSubscriptionEnabled(true);
-  pfPtr->setReadTimeout(180000);
-  pfPtr->setFreeConnectionTimeout(180000);
+  pfPtr->setReadTimeout(std::chrono::seconds(180));
+  pfPtr->setFreeConnectionTimeout(std::chrono::seconds(180));
   int32_t redundancyLevel = getIntValue("redundancyLevel");
   if (redundancyLevel > 0) pfPtr->setSubscriptionRedundancy(redundancyLevel);
   // create tag specific pools
@@ -478,23 +480,25 @@ void FrameworkTest::setTestScheme() {
 }
 
 std::string FrameworkTest::poolAttributesToString(PoolPtr& pool) {
+  using namespace apache::geode::util::chrono::duration;
+
   std::string sString;
   sString += "\npoolName: ";
   sString += FwkStrCvt(pool->getName()).toString();
   sString += "\nFreeConnectionTimeout: ";
-  sString += FwkStrCvt(pool->getFreeConnectionTimeout()).toString();
+  sString += to_string(pool->getFreeConnectionTimeout());
   sString += "\nLoadConditioningInterval: ";
-  sString += FwkStrCvt(pool->getLoadConditioningInterval()).toString();
+  sString += to_string(pool->getLoadConditioningInterval());
   sString += "\nSocketBufferSize: ";
   sString += FwkStrCvt(pool->getSocketBufferSize()).toString();
   sString += "\nReadTimeout: ";
-  sString += FwkStrCvt(pool->getReadTimeout()).toString();
+  sString += to_string(pool->getReadTimeout());
   sString += "\nMinConnections: ";
   sString += FwkStrCvt(pool->getMinConnections()).toString();
   sString += "\nMaxConnections: ";
   sString += FwkStrCvt(pool->getMaxConnections()).toString();
   sString += "\nStatisticInterval: ";
-  sString += FwkStrCvt(pool->getStatisticInterval()).toString();
+  sString += to_string(pool->getStatisticInterval());
   sString += "\nRetryAttempts: ";
   sString += FwkStrCvt(pool->getRetryAttempts()).toString();
   sString += "\nSubscriptionEnabled: ";
@@ -502,17 +506,15 @@ std::string FrameworkTest::poolAttributesToString(PoolPtr& pool) {
   sString += "\nSubscriptionRedundancy: ";
   sString += FwkStrCvt(pool->getSubscriptionRedundancy()).toString();
   sString += "\nSubscriptionMessageTrackingTimeout: ";
-  sString +=
-      FwkStrCvt(pool->getSubscriptionMessageTrackingTimeout()).toString();
+  sString += to_string(pool->getSubscriptionMessageTrackingTimeout());
   sString += "\nSubscriptionAckInterval: ";
-  sString += FwkStrCvt(pool->getSubscriptionAckInterval()).toString();
+  sString += to_string(pool->getSubscriptionAckInterval());
   sString += "\nServerGroup: ";
   sString += pool->getServerGroup();
   sString += "\nIdleTimeout: ";
-  sString += FwkStrCvt(static_cast<int64_t>(pool->getIdleTimeout())).toString();
+  sString += util::chrono::duration::to_string(pool->getIdleTimeout());
   sString += "\nPingInterval: ";
-  sString +=
-      FwkStrCvt(static_cast<int64_t>(pool->getPingInterval())).toString();
+  sString += to_string(pool->getPingInterval());
   sString += "\nThreadLocalConnections: ";
   sString += pool->getThreadLocalConnections() ? "true" : "false";
   sString += "\nMultiuserAuthentication: ";
diff --git a/tests/cpp/fwklib/FwkObjects.hpp b/tests/cpp/fwklib/FwkObjects.hpp
index b8a37937..18800954 100644
--- a/tests/cpp/fwklib/FwkObjects.hpp
+++ b/tests/cpp/fwklib/FwkObjects.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_FWKLIB_FWKOBJECTS_H_
-#define GEODE_FWKLIB_FWKOBJECTS_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,14 +15,19 @@
  * limitations under the License.
  */
 
-/**
- * @file    FwkObjects.hpp
- * @since   1.0
- * @version 1.0
- * @see
- */
+#pragma once
 
-// ----------------------------------------------------------------------------
+#ifndef GEODE_FWKLIB_FWKOBJECTS_H_
+#define GEODE_FWKLIB_FWKOBJECTS_H_
+
+#include <chrono>
+#include <vector>
+#include <list>
+#include <map>
+
+#include <errno.h>
+
+#include <ace/OS.h>
 
 #include <geode/Cache.hpp>
 #include <geode/Properties.hpp>
@@ -35,18 +35,13 @@
 #include <geode/RegionAttributes.hpp>
 #include <geode/AttributesFactory.hpp>
 #include <geode/PoolManager.hpp>
+#include <geode/util/chrono/duration.hpp>
 
 #include "fwklib/FwkStrCvt.hpp"
 #include "fwklib/FwkLog.hpp"
 
 #include "fwklib/GsRandom.hpp"
 
-#include <vector>
-#include <list>
-#include <map>
-#include <ace/OS.h>
-#include <errno.h>
-
 #include <xercesc/dom/DOM.hpp>
 
 XERCES_CPP_NAMESPACE_USE
@@ -317,10 +312,13 @@ class ActionPair {
 // ----------------------------------------------------------------------------
 
 class ExpiryAttributes {
-  int32_t m_timeout;
+  std::chrono::seconds m_timeout;
   ExpirationAction::Action m_action;
 
-  void setTimeout(std::string str) { m_timeout = FwkStrCvt::toInt32(str); }
+  // TODO GEODE-3136: Consider parser
+  void setTimeout(std::string str) {
+    m_timeout = std::chrono::seconds(FwkStrCvt::toInt32(str));
+  }
 
   void setAction(std::string action) {
     if (action == "invalidate") {
@@ -338,7 +336,7 @@ class ExpiryAttributes {
   ExpiryAttributes(const DOMNode* node);
 
   ExpirationAction::Action getAction() { return m_action; }
-  int32_t getTimeout() { return m_timeout; }
+  std::chrono::seconds getTimeout() { return m_timeout; }
 };
 
 // ----------------------------------------------------------------------------
@@ -503,11 +501,13 @@ class FwkPool {
   void setAttributesToFactory(const DOMNode* node);
 
   void setFreeConnectionTimeout(std::string val) {
-    m_poolFactory->setFreeConnectionTimeout(FwkStrCvt::toInt32(val));
+    m_poolFactory->setFreeConnectionTimeout(
+        util::chrono::duration::from_string<std::chrono::milliseconds>(val));
   }
 
   void setLoadConditioningInterval(std::string val) {
-    m_poolFactory->setLoadConditioningInterval(FwkStrCvt::toInt32(val));
+    m_poolFactory->setLoadConditioningInterval(
+        util::chrono::duration::from_string<std::chrono::milliseconds>(val));
   }
 
   void setSocketBufferSize(std::string val) {
@@ -515,7 +515,8 @@ class FwkPool {
   }
 
   void setReadTimeout(std::string val) {
-    m_poolFactory->setReadTimeout(FwkStrCvt::toInt32(val));
+    m_poolFactory->setReadTimeout(
+        util::chrono::duration::from_string<std::chrono::milliseconds>(val));
   }
 
   void setMinConnections(std::string val) {
@@ -527,7 +528,8 @@ class FwkPool {
   }
 
   void setIdleTimeout(std::string val) {
-    m_poolFactory->setIdleTimeout(FwkStrCvt(val).toLong());
+    m_poolFactory->setIdleTimeout(
+        util::chrono::duration::from_string<std::chrono::milliseconds>(val));
   }
 
   void setRetryAttempts(std::string val) {
@@ -535,11 +537,13 @@ class FwkPool {
   }
 
   void setPingInterval(std::string val) {
-    m_poolFactory->setPingInterval(FwkStrCvt(val).toLong());
+    m_poolFactory->setPingInterval(
+        util::chrono::duration::from_string<std::chrono::milliseconds>(val));
   }
 
   void setStatisticInterval(std::string val) {
-    m_poolFactory->setStatisticInterval(FwkStrCvt::toInt32(val));
+    m_poolFactory->setStatisticInterval(
+        util::chrono::duration::from_string<std::chrono::milliseconds>(val));
   }
 
   void setServerGroup(std::string val) {
@@ -556,11 +560,12 @@ class FwkPool {
 
   void setSubscriptionMessageTrackingTimeout(std::string val) {
     m_poolFactory->setSubscriptionMessageTrackingTimeout(
-        FwkStrCvt::toInt32(val));
+        util::chrono::duration::from_string<std::chrono::milliseconds>(val));
   }
 
   void setSubscriptionAckInterval(std::string val) {
-    m_poolFactory->setSubscriptionAckInterval(FwkStrCvt::toInt32(val));
+    m_poolFactory->setSubscriptionAckInterval(
+        util::chrono::duration::from_string<std::chrono::milliseconds>(val));
   }
 
   void setThreadLocalConnections(std::string val) {
diff --git a/tests/cpp/fwklib/RegionHelper.hpp b/tests/cpp/fwklib/RegionHelper.hpp
index d6358034..77049b51 100644
--- a/tests/cpp/fwklib/RegionHelper.hpp
+++ b/tests/cpp/fwklib/RegionHelper.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_FWKLIB_REGIONHELPER_H_
-#define GEODE_FWKLIB_REGIONHELPER_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,22 +15,30 @@
  * limitations under the License.
  */
 
+#pragma once
+
+#ifndef GEODE_FWKLIB_REGIONHELPER_H_
+#define GEODE_FWKLIB_REGIONHELPER_H_
+
+#include <cstdlib>
+#include <string>
+#include <map>
+
 #include <geode/GeodeCppCache.hpp>
+#include <geode/util/chrono/duration.hpp>
 
 #include "fwklib/FrameworkTest.hpp"
 #include "fwklib/FwkObjects.hpp"
 #include "fwklib/FwkStrCvt.hpp"
 #include "fwklib/FwkLog.hpp"
-#include <cstdlib>
-
-#include <string>
-#include <map>
 
 namespace apache {
 namespace geode {
 namespace client {
 namespace testframework {
 
+using namespace apache::geode::util::chrono::duration;
+
 // ----------------------------------------------------------------------------
 
 /** @class RegionHelper
@@ -107,19 +110,19 @@ class RegionHelper {
     sString += "\nlruEvictionAction: ";
     sString += ExpirationAction::fromOrdinal(attr->getLruEvictionAction());
     sString += "\nentryTimeToLive: ";
-    sString += FwkStrCvt(attr->getEntryTimeToLive()).toString();
+    sString += to_string(attr->getEntryTimeToLive());
     sString += "\nentryTimeToLiveAction: ";
     sString += ExpirationAction::fromOrdinal(attr->getEntryTimeToLiveAction());
     sString += "\nentryIdleTimeout: ";
-    sString += FwkStrCvt(attr->getEntryIdleTimeout()).toString();
+    sString += to_string(attr->getEntryIdleTimeout());
     sString += "\nentryIdleTimeoutAction: ";
     sString += ExpirationAction::fromOrdinal(attr->getEntryIdleTimeoutAction());
     sString += "\nregionTimeToLive: ";
-    sString += FwkStrCvt(attr->getRegionTimeToLive()).toString();
+    sString += to_string(attr->getRegionTimeToLive());
     sString += "\nregionTimeToLiveAction: ";
     sString += ExpirationAction::fromOrdinal(attr->getRegionTimeToLiveAction());
     sString += "\nregionIdleTimeout: ";
-    sString += FwkStrCvt(attr->getRegionIdleTimeout()).toString();
+    sString += to_string(attr->getRegionIdleTimeout());
     sString += "\nregionIdleTimeoutAction: ";
     sString +=
         ExpirationAction::fromOrdinal(attr->getRegionIdleTimeoutAction());
@@ -164,19 +167,19 @@ class RegionHelper {
       regionFac.setCacheWriter(atts->getCacheWriterLibrary(),
                                atts->getCacheWriterFactory());
     }
-    if (atts->getEntryIdleTimeout() != 0) {
+    if (atts->getEntryIdleTimeout().count() != 0) {
       regionFac.setEntryIdleTimeout(atts->getEntryIdleTimeoutAction(),
                                     atts->getEntryIdleTimeout());
     }
-    if (atts->getEntryTimeToLive() != 0) {
+    if (atts->getEntryTimeToLive().count() != 0) {
       regionFac.setEntryTimeToLive(atts->getEntryTimeToLiveAction(),
                                    atts->getEntryTimeToLive());
     }
-    if (atts->getRegionIdleTimeout() != 0) {
+    if (atts->getRegionIdleTimeout().count() != 0) {
       regionFac.setRegionIdleTimeout(atts->getRegionIdleTimeoutAction(),
                                      atts->getRegionIdleTimeout());
     }
-    if (atts->getRegionTimeToLive() != 0) {
+    if (atts->getRegionTimeToLive().count() != 0) {
       regionFac.setRegionTimeToLive(atts->getRegionTimeToLiveAction(),
                                     atts->getRegionTimeToLive());
     }
diff --git a/tests/cpp/security/Security.cpp b/tests/cpp/security/Security.cpp
index 306ae95c..5b93e584 100644
--- a/tests/cpp/security/Security.cpp
+++ b/tests/cpp/security/Security.cpp
@@ -908,7 +908,7 @@ void Security::runQuery(int32_t &queryCnt) {
               << i << "] query : " << resultsetQueries[i].query());
       qry = qs->newQuery(resultsetQueries[i].query());
       startTime = ACE_OS::gettimeofday();
-      results = qry->execute(600);
+      results = qry->execute(std::chrono::seconds{600});
       endTime = ACE_OS::gettimeofday() - startTime;
       FWKINFO(" Time Taken to execute the reselt set query : "
               << resultsetQueries[i].query() << ": is " << endTime.sec() << "."
@@ -924,7 +924,7 @@ void Security::runQuery(int32_t &queryCnt) {
               << i << "] query : " << structsetQueries[i].query());
       qry = qs->newQuery(structsetQueries[i].query());
       startTime = ACE_OS::gettimeofday();
-      results = qry->execute(600);
+      results = qry->execute(std::chrono::seconds{600});
       endTime = ACE_OS::gettimeofday() - startTime;
       FWKINFO(" Time Taken to execute the struct set query : "
               << structsetQueries[i].query() << ": is " << endTime.sec() << "."
diff --git a/tests/javaobject/FunctionExecutionTimeOut.java b/tests/javaobject/FunctionExecutionTimeOut.java
index 367b800a..a2b6fd47 100644
--- a/tests/javaobject/FunctionExecutionTimeOut.java
+++ b/tests/javaobject/FunctionExecutionTimeOut.java
@@ -47,7 +47,7 @@
   public void execute(FunctionContext context) {
     DistributedSystem ds = InternalDistributedSystem.getAnyInstance();
     LogWriter logger = ds.getLogWriter();
-    logger.fine("Executing FunctionExecutionTimeOut ");
+    logger.info("Executing FunctionExecutionTimeOut ");
     int expected = (Integer)context.getArguments();
 	boolean timeoutFound = false;
     GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
@@ -56,7 +56,7 @@ public void execute(FunctionContext context) {
     for (int i = 0; i < scs.length; ++i) {
       ClientHandShake hs = scs[i].getHandshake();
 	  if (hs != null) {
-	    logger.fine("hs.getClientReadTimeout() =  " + hs.getClientReadTimeout());
+	    logger.info("hs.getClientReadTimeout() =  " + hs.getClientReadTimeout());
 	  }
       if (hs != null && expected == hs.getClientReadTimeout()) {
         // success
diff --git a/tests/javaobject/PutAllTimeout.java b/tests/javaobject/PutAllTimeout.java
index c51264fc..466df7c0 100644
--- a/tests/javaobject/PutAllTimeout.java
+++ b/tests/javaobject/PutAllTimeout.java
@@ -15,17 +15,23 @@
  * limitations under the License.
  */
 package javaobject;
+
 import java.util.*;
+
+import org.apache.logging.log4j.*;
+
 import org.apache.geode.cache.CacheListener;
 import org.apache.geode.cache.EntryEvent;
 import org.apache.geode.cache.RegionEvent;
 import org.apache.geode.cache.CacheFactory;
 import org.apache.geode.cache.Declarable;
 import org.apache.geode.internal.cache.tier.sockets.CacheClientProxy;
-import org.apache.geode.LogWriter;
+
 
 public class PutAllTimeout implements Declarable, CacheListener {
 
+  final Logger log = LogManager.getLogger(getClass());
+
   public PutAllTimeout() 
   {
   }
@@ -40,10 +46,10 @@ public void afterCreate(EntryEvent event) {
      if (event.getKey().toString().indexOf("timeout") >= 0) {
         
         int sleepVal = Integer.parseInt( event.getNewValue().toString() );
-        System.out.println("Put all timeout value " + event.getNewValue().toString()); 
-        System.out.println("Put all timeout " + sleepVal);
+        log.info("Put all timeout value " + event.getNewValue().toString());
+        log.info("Put all timeout " + sleepVal);
         Thread.sleep(sleepVal);
-        System.out.println("Put all sleep done");
+        log.info("Put all sleep done");
       }              
     }catch(InterruptedException e)
     {
@@ -60,9 +66,9 @@ public void afterUpdate(EntryEvent event)
      {
        if (event.getKey().toString().indexOf("timeout") >= 0) {
          int sleepVal = Integer.parseInt( event.getNewValue().toString() );
-         System.out.println("Put all timeout " + sleepVal);
+         log.info("Put all timeout " + sleepVal);
          Thread.sleep(sleepVal);
-         System.out.println("Put all sleep done");
+         log.info("Put all sleep done");
        }              
      }catch(InterruptedException e)
      {
@@ -70,7 +76,7 @@ public void afterUpdate(EntryEvent event)
      }
      catch(Exception e)
      {
-       System.out.println("Exception: After update " + e.getMessage());
+       log.info("Exception: After update " + e.getMessage());
      }
    }
   
diff --git a/xsds/gfcpp-cache-9.0.xsd b/xsds/cpp-cache-1.0.xsd
similarity index 83%
rename from xsds/gfcpp-cache-9.0.xsd
rename to xsds/cpp-cache-1.0.xsd
index c84799fa..42dc77dd 100644
--- a/xsds/gfcpp-cache-9.0.xsd
+++ b/xsds/cpp-cache-1.0.xsd
@@ -16,9 +16,13 @@ See the License for the specific language governing permissions and
 limitations under the License.
 -->
 
-<xsd:schema xmlns="http://schema.pivotal.io/gemfire/gfcpp-cache" xmlns:nc="http://schema.pivotal.io/gemfire/gfcpp-cache"
-  elementFormDefault="qualified" attributeFormDefault="unqualified" targetNamespace="http://schema.pivotal.io/gemfire/gfcpp-cache"
-  xmlns:xsd="http://www.w3.org/2001/XMLSchema" version="9.0">
+<xsd:schema 
+    targetNamespace="http://geode.apache.org/schema/cpp-cache"
+    xmlns:nc="http://geode.apache.org/schema/cpp-cache"
+    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
+    elementFormDefault="qualified"
+    attributeFormDefault="unqualified"
+    version="1.0">
   <xsd:annotation>
     <xsd:documentation><![CDATA[
       This is the XML Schema for the GemFire distributed cache declarative
@@ -26,11 +30,11 @@ limitations under the License.
       of the following form:
 
   <client-cache
-      xmlns="http://schema.pivotal.io/gemfire/gfcpp-cache"
+      xmlns="http://geode.apache.org/schema/cpp-cache"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-      xsi:schemaLocation="http://schema.pivotal.io/gemfire/gfcpp-cache
-                          http://schema.pivotal.io/gemfire/gfcpp-cache/gfcpp-cache-9.0.xsd"
-      version="9.0">
+      xsi:schemaLocation="http://geode.apache.org/schema/cpp-cache
+                          http://geode.apache.org/schema/cpp-cache/cpp-cache-1.0.xsd"
+      version="1.0">
 
 The contents of a declarative XML file correspond to APIs found in the
 org.apache.geode.cache and org.apache.geode.cache.client
@@ -60,42 +64,26 @@ declarative caching XML file elements unless indicated otherwise.
               <xsd:element minOccurs="1" maxOccurs="unbounded" name="locator" type="nc:host-port-type" />
               <xsd:element minOccurs="1" maxOccurs="unbounded" name="server" type="nc:host-port-type" />
             </xsd:choice>
-            <xsd:attribute name="free-connection-timeout" type="xsd:string" />
-            <xsd:attribute name="load-conditioning-interval" type="xsd:string" />
+            <xsd:attribute name="name" type="xsd:string" use="required" />
+            <xsd:attribute name="free-connection-timeout" type="nc:duration-type" />
+            <xsd:attribute name="load-conditioning-interval" type="nc:duration-type" />
             <xsd:attribute name="min-connections" type="xsd:string" />
             <xsd:attribute name="max-connections" type="xsd:string" />
             <xsd:attribute name="retry-attempts" type="xsd:string" />
-            <xsd:attribute name="idle-timeout" type="xsd:string" />
-            <xsd:attribute name="ping-interval" type="xsd:string" />
-            <xsd:attribute name="name" type="xsd:string" use="required" />
-            <xsd:attribute name="read-timeout" type="xsd:string" />
+            <xsd:attribute name="idle-timeout" type="nc:duration-type" />
+            <xsd:attribute name="ping-interval" type="nc:duration-type" />
+            <xsd:attribute name="read-timeout" type="nc:duration-type" />
             <xsd:attribute name="server-group" type="xsd:string" />
             <xsd:attribute name="socket-buffer-size" type="xsd:string" />
             <xsd:attribute name="subscription-enabled" type="xsd:boolean" />
             <xsd:attribute name="subscription-message-tracking-timeout" type="xsd:string" />
             <xsd:attribute name="subscription-ack-interval" type="xsd:string" />
             <xsd:attribute name="subscription-redundancy" type="xsd:string" />
-            <xsd:attribute name="statistic-interval" type="xsd:string" />
+            <xsd:attribute name="statistic-interval" type="nc:duration-type" />
             <xsd:attribute name="pr-single-hop-enabled" type="xsd:string" />
             <xsd:attribute name="thread-local-connections" type="xsd:boolean" />
             <xsd:attribute name="multiuser-authentication" type="xsd:boolean" />
-            <xsd:attribute name="update-locator-list-interval">
-              <xsd:simpleType>
-                <xsd:restriction base="xsd:long">
-                  <xsd:minInclusive value="0" />
-                </xsd:restriction>
-              </xsd:simpleType>
-            </xsd:attribute>
-          </xsd:complexType>
-        </xsd:element>
-        <xsd:element minOccurs="0" maxOccurs="unbounded" name="root-region">
-          <xsd:complexType>
-            <xsd:sequence>
-              <xsd:element minOccurs="0" maxOccurs="1" name="region-attributes" type="nc:region-attributes-type" />
-              <xsd:element minOccurs="0" maxOccurs="unbounded" name="region" type="nc:region-type" />
-            </xsd:sequence>
-            <xsd:attribute name="name" type="xsd:string" use="required" />
-          </xsd:complexType>
+            <xsd:attribute name="update-locator-list-interval" type="nc:duration-type" />
         </xsd:element>
         <xsd:element minOccurs="0" maxOccurs="unbounded" name="region" type="nc:region-type" />
         <xsd:element minOccurs="0" maxOccurs="1" name="pdx">
@@ -107,7 +95,7 @@ declarative caching XML file elements unless indicated otherwise.
       </xsd:choice>
       <xsd:attribute name="endpoints" type="xsd:string" />
       <xsd:attribute name="redundancy-level" type="xsd:string" />
-      <xsd:attribute name="version" type="version-type" use="required" fixed="9.0" />
+      <xsd:attribute name="version" type="nc:version-type" use="required" fixed="1.0" />
     </xsd:complexType>
   </xsd:element>
 
@@ -191,7 +179,7 @@ declarative caching XML file elements unless indicated otherwise.
     <xsd:sequence>
       <xsd:element name="expiration-attributes">
         <xsd:complexType>
-          <xsd:attribute name="timeout" type="xsd:string" use="required" />
+          <xsd:attribute name="timeout" type="nc:duration-type" use="required" />
           <xsd:attribute name="action">
             <xsd:simpleType>
               <xsd:restriction base="xsd:NMTOKEN">
@@ -230,6 +218,17 @@ declarative caching XML file elements unless indicated otherwise.
     </xsd:restriction>
   </xsd:simpleType>
 
+  <xsd:simpleType name="duration-type">
+    <xsd:annotation>
+      <xsd:documentation>
+        Time duration in positive integer and unit.
+      </xsd:documentation>
+    </xsd:annotation>
+    <xsd:restriction base="xsd:token">
+      <xsd:pattern value="\d+(h|min|s|ms|us|ns)" />
+    </xsd:restriction>
+  </xsd:simpleType>
+
   <xsd:complexType name="library-type">
     <xsd:attribute name="library-name" type="xsd:string" />
     <xsd:attribute name="library-function-name" type="xsd:string" use="required" />


 

----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 9fe0782f47f0f58ec98f3873b208437df3e93b32 in geode-native's branch refs/heads/develop from Jacob Barrett
[ https://gitbox.apache.org/repos/asf?p=geode-native.git;h=9fe0782 ]

GEODE-3136: Convert time values to std::chrono::duration. (#144)

* GEODE-3136: Convert time values to std::chrono::duration.

- Adds duration utilities.
- XML Schema changes.
- Convert CLI time values to TimeSpan.



Commit 2be9703fb43aed5a16bf49fdaea730351df2c874 in geode-native's branch refs/heads/develop from Jacob Barrett
[ https://gitbox.apache.org/repos/asf?p=geode-native.git;h=2be9703 ]

GEODE-3136: Fixes unit test exception assertion.


Commit 65c96cb2c7c245fdb13c130aeb06984cfcb6621d in geode-native's branch refs/heads/develop from Jacob Barrett
[ https://gitbox.apache.org/repos/asf?p=geode-native.git;h=65c96cb ]

GEODE-3136: Fixes duration comparison bug in VS C++ runtime.


Commit da62705a98f37507d8e61636b78a3b9bc189ecc2 in geode-native's branch refs/heads/develop from Jacob Barrett
[ https://gitbox.apache.org/repos/asf?p=geode-native.git;h=da62705 ]

GEODE-3136: Fixes issues with some tests failing on SPARC.

- Moves test XML files to resource directory.
- Fixes invalid schema file.
- Delete unused XML files.
- Updates schema declaration.


Commit 927af25ca91dc1a31b45977d6594372932d3bdc1 in geode-native's branch refs/heads/develop from [~dkimura]
[ https://gitbox.apache.org/repos/asf?p=geode-native.git;h=927af25 ]

GEODE-3136: Fix flaky test ThinClientFunctionExecutionTestsN


