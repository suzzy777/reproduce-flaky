boglesby commented on pull request #4928:
URL: https://github.com/apache/geode/pull/4928#issuecomment-620307053


   I ran a test with this scenario:
   
   - 2 colocated partitioned regions called customer and order attached to a parallel sender
   - 1 replicated region called customer_creation_time attached to a serial sender
   
   The transaction does:
   
   - put 1 customer into customer region
   - put 10 orders into order region
   - put customer create time into customer_creation_time region
   
   Here are some notes from this test:
   
   GatewaySenderFactoryImpl.configureGatewaySender needs a line like below. Otherwise, the Geode xml case doesn't pass the boolean to the sender.
   ```
   this.attrs.isGroupTransactionEvents = senderCreation.isGroupTransactionEvents()
   ```
   The scenario above is not supported since the transaction is spanning multiple senders. I don't think there is a way to determine that during configuration, but the message that is logged needs additional info:
   ```
   [error 2020/04/27 15:45:57.439 PDT <Pooled Waiting Message Processor 2> tid=0x57] Not all events in transaction go to the same senders that group transactions
   ```
   At least the sender ids should be logged if not which events go to which senders.
   
   I see `TXLastEventInTransactionUtils.checkAllEventsGoToSameGroupingSenders` is throwing the ServiceConfigurationError. Maybe that ServiceConfigurationError's message can contain this info. Then you can log the error. Maybe even the actual stack.
   
   Also, I see that the test above succeeds. The batch is sent with the customer and orders. Other than that warning which the customer could easily miss, there is no evidence that all the events in the transaction were not sent in the same batch. Maybe the commit should fail?
   
   I'll change my test to remove the serial sender and continue to look at this.
   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on pull request #4928:
URL: https://github.com/apache/geode/pull/4928#issuecomment-620529529


   Thanks for your comments.
   Please, see below:
   > I ran a test with this scenario:
   > 
   >     * 2 colocated partitioned regions called customer and order attached to a parallel sender
   > 
   >     * 1 replicated region called customer_creation_time attached to a serial sender
   > 
   I assume that both senders are configured to group transactions.
   > 
   > The transaction does:
   > 
   >     * put 1 customer into customer region
   > 
   >     * put 10 orders into order region
   > 
   >     * put customer create time into customer_creation_time region
   > 
   > 
   > Here are some notes from this test:
   > 
   > GatewaySenderFactoryImpl.configureGatewaySender needs a line like below. Otherwise, the Geode xml case doesn't pass the boolean to the sender.
   > 
   > ```
   > this.attrs.isGroupTransactionEvents = senderCreation.isGroupTransactionEvents()
   > ```
   > 
   Good catch. I have pushed a new commit solving it.
   
   > The scenario above is not supported since the transaction is spanning multiple senders. I don't think there is a way to determine that during configuration, but the message that is logged needs additional info:
   Actually, the reason why the scenario is not supported is not because the transaction is spanning multiple senders. The reason here is that some events go to some senders (the customer and order events go to the parallel sender) and other events go to other senders (the creation time event goes to the serial sender).
   If each event in the transaction went to the same senders, the scenario would be supported.
   You could have another scenario in which you configured two parallel senders for customer and order regions, with transactions containing customer and order instances and the transactions would be grouped in batches because all events would go to the same senders (two in this case).
   > 
   > ```
   > [error 2020/04/27 15:45:57.439 PDT <Pooled Waiting Message Processor 2> tid=0x57] Not all events in transaction go to the same senders that group transactions
   > ```
   > 
   > At least the sender ids should be logged if not which events go to which senders.
   > 
   > I see `TXLastEventInTransactionUtils.checkAllEventsGoToSameGroupingSenders` is throwing the ServiceConfigurationError. Maybe that ServiceConfigurationError's message can contain this info. Then you can log the error. Maybe even the actual stack.
   > 
   The new commit contains an extended logging error including the events and, for each event, to which senders it would be sent to.
   I did not want to add this information initially because I am not sure how meaningful it would be for the one reading it and also because it would add processing time.
   > Also, I see that the test above succeeds. The batch is sent with the customer and orders. Other than that warning which the customer could easily miss, there is no evidence that all the events in the transaction were not sent in the same batch. Maybe the commit should fail?
   > 
   It would not be possible at this point to make the commit fail as the processing is done after the commit. If done before, it could slow down transaction operations.
   Besides, I think it is better to make the operation progress to the other side logging the error which would indicate that there would be a small chance that the events would not be sent in the same batch. This, in turn, could only be a problem when there is a network split.
   > I'll change my test to remove the serial sender and continue to look at this.
   
   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz edited a comment on pull request #4928:
URL: https://github.com/apache/geode/pull/4928#issuecomment-620529529


   Thanks for your comments.
   Please, see below:
   > I ran a test with this scenario:
   > 
   >     * 2 colocated partitioned regions called customer and order attached to a parallel sender
   > 
   >     * 1 replicated region called customer_creation_time attached to a serial sender
   > 
   I assume that both senders are configured to group transactions.
   > 
   > The transaction does:
   > 
   >     * put 1 customer into customer region
   > 
   >     * put 10 orders into order region
   > 
   >     * put customer create time into customer_creation_time region
   > 
   > 
   > Here are some notes from this test:
   > 
   > GatewaySenderFactoryImpl.configureGatewaySender needs a line like below. Otherwise, the Geode xml case doesn't pass the boolean to the sender.
   > 
   > ```
   > this.attrs.isGroupTransactionEvents = senderCreation.isGroupTransactionEvents()
   > ```
   > 
   Good catch. I have pushed a new commit solving it.
   
   > The scenario above is not supported since the transaction is spanning multiple senders. I don't think there is a way to determine that during configuration, but the message that is logged needs additional info:
   > 
   > ```
   > [error 2020/04/27 15:45:57.439 PDT <Pooled Waiting Message Processor 2> tid=0x57] Not all events in transaction go to the same senders that group transactions
   > ```
   Actually, the reason why the scenario is not supported is not because the transaction is spanning multiple senders. The reason here is that some events go to some senders (the customer and order events go to the parallel sender) and other events go to other senders (the creation time event goes to the serial sender).
   If each event in the transaction went to the same senders, the scenario would be supported.
   You could have another scenario in which you configured two parallel senders for customer and order regions, with transactions containing customer and order instances and the transactions would be grouped in batches because all events would go to the same senders (two in this case).
   
   > 
   > At least the sender ids should be logged if not which events go to which senders.
   > 
   > I see `TXLastEventInTransactionUtils.checkAllEventsGoToSameGroupingSenders` is throwing the ServiceConfigurationError. Maybe that ServiceConfigurationError's message can contain this info. Then you can log the error. Maybe even the actual stack.
   > 
   The new commit contains an extended logging error including the events and, for each event, to which senders it would be sent to.
   I did not want to add this information initially because I am not sure how meaningful it would be for the one reading it and also because it would add processing time.
   Here is an example of the error log:
   ```
   [error 2020/04/28 12:00:33.604 CEST <Pooled Waiting Message Processor 2> tid=85] Not all events go to the same senders that group transactions. Event[0]: EntryEventImpl[op=CREATE;region=/SHIPMENT;key=(ShipmentId:1 , (OrderId:0 , (CustId:1));callbackArg=null;originRemote=true;originMember=172.28.0.1(29917)<v1>:41004;version={v1; rv1; ds=1; time=1588068033598};id=EventID[id=18 bytes;threadID=2;sequenceID=0];tailKey=11], senders for Event[0]: [ln]; Event[1]: EntryEventImpl[op=CREATE;region=/SHIPMENT;key=(ShipmentId:1 , (OrderId:1 , (CustId:1));callbackArg=null;originRemote=true;originMember=172.28.0.1(29917)<v1>:41004;version={v1; rv2; ds=1; time=1588068033599};id=EventID[id=18 bytes;threadID=2;sequenceID=1];tailKey=21], senders for Event[1]: [ln]; Event[2]: EntryEventImpl[op=UPDATE;region=/CUSTOMER;key=(CustId:1);callbackArg=null;originRemote=true;originMember=172.28.0.1(29917)<v1>:41004;version={v2; rv2; ds=1; time=1588068033599};id=EventID[id=18 bytes;threadID=2;sequenceID=2];tailKey=31], senders for Event[2]: []; Event[3]: EntryEventImpl[op=CREATE;region=/ORDER;key=(
   ```
   > Also, I see that the test above succeeds. The batch is sent with the customer and orders. Other than that warning which the customer could easily miss, there is no evidence that all the events in the transaction were not sent in the same batch. Maybe the commit should fail?
   > 
   It would not be possible at this point to make the commit fail as the processing is done after the commit. If done before, it could slow down transaction operations.
   Besides, I think it is better to make the operation progress to the other side logging the error which would indicate that there would be a small chance that the events would not be sent in the same batch. This, in turn, could only be a problem when there is a network split.
   > I'll change my test to remove the serial sender and continue to look at this.
   
   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


boglesby commented on pull request #4928:
URL: https://github.com/apache/geode/pull/4928#issuecomment-620812494


   If I do this:
   
   - start site 1 with a sender with batch size = 5
   - do a transaction with 1 customer and 10 orders
   - don't start site 2 immediately
   
   I see behavior like below:
   
   The first call to peek is correct. It returns 11 events.
   
   Since the batch can't be sent, the batch is recreated. This batch only contains 5 events.
   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


boglesby commented on pull request #4928:
URL: https://github.com/apache/geode/pull/4928#issuecomment-620812755


   Here are the details.
   
   The first batch has the 11 events.
   
   5 events are peeked initially:
   ```
   Event Processor for GatewaySender_ny_3: ParallelGatewaySenderQueue.peek peeked a batch of 5 events into batch:
     GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=0;bucketId=48];action=0;operation=CREATE;region=/customer;key=0;value=Customer[id=0; name=name-0];shadowKey=161;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
     GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=1;bucketId=48];action=0;operation=CREATE;region=/order;key=0-0;value=Order[id=0-0; customerId=0];shadowKey=274;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
     GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=2;bucketId=48];action=0;operation=CREATE;region=/order;key=0-1;value=Order[id=0-1; customerId=0];shadowKey=387;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
     GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=3;bucketId=48];action=0;operation=CREATE;region=/order;key=0-2;value=Order[id=0-2; customerId=0];shadowKey=500;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
     GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=4;bucketId=48];action=0;operation=CREATE;region=/order;key=0-3;value=Order[id=0-3; customerId=0];shadowKey=613;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
   ```
   The remaining 6 from the transaction are peeked in peekEventsFromIncompleteTransactions:
   ```
   Event Processor for GatewaySender_ny_3: ParallelGatewaySenderQueue.peekEventsFromIncompleteTransactions areAllTransactionsCompleteInBatch=false
   Event Processor for GatewaySender_ny_3: ParallelGatewaySenderQueue.peekEventsFromIncompleteTransactions getting missing transactions for transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1; bucketId=48
   Event Processor for GatewaySender_ny_3: BucketRegionQueue.getElementsMatching key=726; object=GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=5;bucketId=48];action=0;operation=CREATE;region=/order;key=0-4;value=Order[id=0-4; customerId=0];shadowKey=726;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
   Event Processor for GatewaySender_ny_3: BucketRegionQueue.getElementsMatching key=839; object=GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=6;bucketId=48];action=0;operation=CREATE;region=/order;key=0-5;value=Order[id=0-5; customerId=0];shadowKey=839;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
   Event Processor for GatewaySender_ny_3: BucketRegionQueue.getElementsMatching key=952; object=GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=7;bucketId=48];action=0;operation=CREATE;region=/order;key=0-6;value=Order[id=0-6; customerId=0];shadowKey=952;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
   Event Processor for GatewaySender_ny_3: BucketRegionQueue.getElementsMatching key=1065; object=GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=8;bucketId=48];action=0;operation=CREATE;region=/order;key=0-7;value=Order[id=0-7; customerId=0];shadowKey=1065;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
   Event Processor for GatewaySender_ny_3: BucketRegionQueue.getElementsMatching key=1178; object=GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=9;bucketId=48];action=0;operation=CREATE;region=/order;key=0-8;value=Order[id=0-8; customerId=0];shadowKey=1178;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
   Event Processor for GatewaySender_ny_3: BucketRegionQueue.getElementsMatching key=1291; object=GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=10;bucketId=48];action=0;operation=CREATE;region=/order;key=0-9;value=Order[id=0-9; customerId=0];shadowKey=1291;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=true]
   Event Processor for GatewaySender_ny_3: ParallelGatewaySenderQueue.peekEventsFromIncompleteTransactions peeked 6 events in transaction:
    	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=5;bucketId=48];action=0;operation=CREATE;region=/order;key=0-4;value=Order[id=0-4; customerId=0];shadowKey=726;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
    	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=6;bucketId=48];action=0;operation=CREATE;region=/order;key=0-5;value=Order[id=0-5; customerId=0];shadowKey=839;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
    	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=7;bucketId=48];action=0;operation=CREATE;region=/order;key=0-6;value=Order[id=0-6; customerId=0];shadowKey=952;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
    	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=8;bucketId=48];action=0;operation=CREATE;region=/order;key=0-7;value=Order[id=0-7; customerId=0];shadowKey=1065;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
    	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=9;bucketId=48];action=0;operation=CREATE;region=/order;key=0-8;value=Order[id=0-8; customerId=0];shadowKey=1178;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
    	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=10;bucketId=48];action=0;operation=CREATE;region=/order;key=0-9;value=Order[id=0-9; customerId=0];shadowKey=1291;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=true]
   ```
   The final batch contains 11 events:
   ```
   Event Processor for GatewaySender_ny_3: ParallelGatewaySenderQueue.peek final batch contains 11 events:
    	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=0;bucketId=48];action=0;operation=CREATE;region=/customer;key=0;value=Customer[id=0; name=name-0];shadowKey=161;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
    	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=1;bucketId=48];action=0;operation=CREATE;region=/order;key=0-0;value=Order[id=0-0; customerId=0];shadowKey=274;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
    	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=2;bucketId=48];action=0;operation=CREATE;region=/order;key=0-1;value=Order[id=0-1; customerId=0];shadowKey=387;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
    	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=3;bucketId=48];action=0;operation=CREATE;region=/order;key=0-2;value=Order[id=0-2; customerId=0];shadowKey=500;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
    	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=4;bucketId=48];action=0;operation=CREATE;region=/order;key=0-3;value=Order[id=0-3; customerId=0];shadowKey=613;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
    	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=5;bucketId=48];action=0;operation=CREATE;region=/order;key=0-4;value=Order[id=0-4; customerId=0];shadowKey=726;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
    	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=6;bucketId=48];action=0;operation=CREATE;region=/order;key=0-5;value=Order[id=0-5; customerId=0];shadowKey=839;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
    	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=7;bucketId=48];action=0;operation=CREATE;region=/order;key=0-6;value=Order[id=0-6; customerId=0];shadowKey=952;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
    	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=8;bucketId=48];action=0;operation=CREATE;region=/order;key=0-7;value=Order[id=0-7; customerId=0];shadowKey=1065;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
    	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=9;bucketId=48];action=0;operation=CREATE;region=/order;key=0-8;value=Order[id=0-8; customerId=0];shadowKey=1178;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
    	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=10;bucketId=48];action=0;operation=CREATE;region=/order;key=0-9;value=Order[id=0-9; customerId=0];shadowKey=1291;timeStamp=1588101080898;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=true]
   ```
   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


boglesby commented on pull request #4928:
URL: https://github.com/apache/geode/pull/4928#issuecomment-620812923


   The next peeked batch doesn't contain 11 events. It only contains 5. This is because the previous batch failed to be sent which causes addPeekedEvents to actually do something. In this case, it adds batchSize number of events to the batch since these events have already been peeked. When this method returns, the batch contains batchSize events so the loop is short-circuited, and the incompleteTransactionsInBatch processing doesn't occur.
   
   Here is the behavior:
   
   addPeekedEvents adds 5 previously peeked events to the batch:
   ```
   Event Processor for GatewaySender_ny_3: ParallelGatewaySenderQueue.addPeekedEvents added 5 previously peeked events to the batch:
   	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=0;bucketId=48];action=0;operation=CREATE;region=/customer;key=0;value=Customer[id=0; name=name-0];creationTime=1588101080903;shadowKey=161;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
   	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=1;bucketId=48];action=0;operation=CREATE;region=/order;key=0-0;value=Order[id=0-0; customerId=0];creationTime=1588101080906;shadowKey=274;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
   	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=2;bucketId=48];action=0;operation=CREATE;region=/order;key=0-1;value=Order[id=0-1; customerId=0];creationTime=1588101080906;shadowKey=387;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
   	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=3;bucketId=48];action=0;operation=CREATE;region=/order;key=0-2;value=Order[id=0-2; customerId=0];creationTime=1588101080906;shadowKey=500;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
   	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=4;bucketId=48];action=0;operation=CREATE;region=/order;key=0-3;value=Order[id=0-3; customerId=0];creationTime=1588101080906;shadowKey=613;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
   ```
   peekEventsFromIncompleteTransactions short-circuits because returns because areAllTransactionsCompleteInBatch is true:
   ```
   Event Processor for GatewaySender_ny_3: ParallelGatewaySenderQueue.peekEventsFromIncompleteTransactions areAllTransactionsCompleteInBatch=true
   ```
   The final batch contains 5 events:
   ```
   Event Processor for GatewaySender_ny_3: ParallelGatewaySenderQueue.peek final batch 1156975981 contains 5 events:
   	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=0;bucketId=48];action=0;operation=CREATE;region=/customer;key=0;value=Customer[id=0; name=name-0];creationTime=1588101080903;shadowKey=161;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
   	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=1;bucketId=48];action=0;operation=CREATE;region=/order;key=0-0;value=Order[id=0-0; customerId=0];creationTime=1588101080906;shadowKey=274;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
   	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=2;bucketId=48];action=0;operation=CREATE;region=/order;key=0-1;value=Order[id=0-1; customerId=0];creationTime=1588101080906;shadowKey=387;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
   	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=3;bucketId=48];action=0;operation=CREATE;region=/order;key=0-2;value=Order[id=0-2; customerId=0];creationTime=1588101080906;shadowKey=500;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
   	GatewaySenderEventImpl[id=EventID[id=23 bytes;threadID=0x10030|4;sequenceID=4;bucketId=48];action=0;operation=CREATE;region=/order;key=0-3;value=Order[id=0-3; customerId=0];creationTime=1588101080906;shadowKey=613;timeStamp=1588101080897;transactionId=TXId: 192.168.1.8(ln-client:93385:loner):55648:ae6333c2:ln-client:1;isLastEventInTransaction=false]
   ```
   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


boglesby commented on pull request #4928:
URL: https://github.com/apache/geode/pull/4928#issuecomment-620813007


   When I start site 2, I see 3 batches received:
   ```
   ServerConnection on port 5185 Thread 1: GatewayReceiverCommand.cmdExecute received batch 0 containing 5 events
   ServerConnection on port 5185 Thread 1: GatewayReceiverCommand.cmdExecute received batch 1 containing 5 events
   ServerConnection on port 5185 Thread 1: GatewayReceiverCommand.cmdExecute received batch 2 containing 1 events
   ```


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


boglesby commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r416898601



##########
File path: geode-core/src/main/resources/org/apache/geode/cache/doc-files/cache8_0.dtd
##########
@@ -675,6 +675,7 @@ As of 6.5 roll-oplogs is deprecated. Use disk-store-name instead.
   alert-threshold              CDATA #IMPLIED
   dispatcher-threads           CDATA #IMPLIED
   order-policy                 CDATA #IMPLIED
+  group-transaction-events     (false | true) #IMPLIED

Review comment:
       I'm not sure the cache8_0.dtd should be changed. That implies that this property is supported in earlier versions.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


boglesby commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r416901247



##########
File path: geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java
##########
@@ -1282,22 +1277,90 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac
           Thread.currentThread().interrupt();
           break;
         }
-        continue;
       }
     }
+
+    if (batch.size() > 0) {
+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);
+    }
+
     if (isDebugEnabled) {
       logger.debug("{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}",
           this, batch.size(), size(), localSize());
     }
+
     if (batch.size() == 0) {
       blockProcessorThreadIfRequired();
     }
     return batch;
   }
 
+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {
+    final boolean isDebugEnabled = logger.isDebugEnabled();
+    // If time to wait is -1 (don't wait) or time interval has elapsed
+    if (isDebugEnabled) {
+      logger.debug("{}: Peek current time: {}", this, currentTime);
+    }
+    if (timeToWait == -1 || (end <= currentTime)) {
+      if (isDebugEnabled) {
+        logger.debug("{}: Peek breaking", this);
+      }
+      return true;
+    }
+    return false;
+  }
+
+  protected boolean isGroupTransactionEvents() {
+    return sender.isGroupTransactionEvents();
+  }
+
+  private void peekEventsFromIncompleteTransactions(List<GatewaySenderEventImpl> batch,
+      Map<TransactionId, Integer> incompleteTransactionIdsInBatch, PartitionedRegion prQ) {
+    if (!isGroupTransactionEvents()) {
+      return;
+    }
+
+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {
+      return;
+    }
+
+    int maxRetries = 2;

Review comment:
       Maybe maxRetries should be parameterized.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on pull request #4928:
URL: https://github.com/apache/geode/pull/4928#issuecomment-621255116


   > If I do this:
   > 
   >     * start site 1 with a sender with batch size = 5
   > 
   >     * do a transaction with 1 customer and 10 orders
   > 
   >     * don't start site 2 immediately
   > 
   > 
   > I see behavior like below:
   > 
   > The first call to peek is correct. It returns 11 events.
   > 
   > Since the batch can't be sent, the batch is recreated. This batch only contains 5 events.
   
   I had not thought about this case.
   I have pushed another commit that should solve the issue.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r417369529



##########
File path: geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java
##########
@@ -1282,22 +1277,90 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac
           Thread.currentThread().interrupt();
           break;
         }
-        continue;
       }
     }
+
+    if (batch.size() > 0) {
+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);
+    }
+
     if (isDebugEnabled) {
       logger.debug("{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}",
           this, batch.size(), size(), localSize());
     }
+
     if (batch.size() == 0) {
       blockProcessorThreadIfRequired();
     }
     return batch;
   }
 
+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {
+    final boolean isDebugEnabled = logger.isDebugEnabled();
+    // If time to wait is -1 (don't wait) or time interval has elapsed
+    if (isDebugEnabled) {
+      logger.debug("{}: Peek current time: {}", this, currentTime);
+    }
+    if (timeToWait == -1 || (end <= currentTime)) {
+      if (isDebugEnabled) {
+        logger.debug("{}: Peek breaking", this);
+      }
+      return true;
+    }
+    return false;
+  }
+
+  protected boolean isGroupTransactionEvents() {
+    return sender.isGroupTransactionEvents();
+  }
+
+  private void peekEventsFromIncompleteTransactions(List<GatewaySenderEventImpl> batch,
+      Map<TransactionId, Integer> incompleteTransactionIdsInBatch, PartitionedRegion prQ) {
+    if (!isGroupTransactionEvents()) {
+      return;
+    }
+
+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {
+      return;
+    }
+
+    int maxRetries = 2;

Review comment:
       I agree. The new commit contains a parameter for this.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r417370511



##########
File path: geode-core/src/main/resources/org/apache/geode/cache/doc-files/cache8_0.dtd
##########
@@ -675,6 +675,7 @@ As of 6.5 roll-oplogs is deprecated. Use disk-store-name instead.
   alert-threshold              CDATA #IMPLIED
   dispatcher-threads           CDATA #IMPLIED
   order-policy                 CDATA #IMPLIED
+  group-transaction-events     (false | true) #IMPLIED

Review comment:
       I was not sure of this. I recall seeing some failures in test cases and changed this and the cache7_0.dtd files that had been recently been updated.
   I would appreciate if you can confirm me if these files or any of them should not be updated.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


boglesby commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r417646301



##########
File path: geode-core/src/main/resources/org/apache/geode/cache/doc-files/cache8_0.dtd
##########
@@ -675,6 +675,7 @@ As of 6.5 roll-oplogs is deprecated. Use disk-store-name instead.
   alert-threshold              CDATA #IMPLIED
   dispatcher-threads           CDATA #IMPLIED
   order-policy                 CDATA #IMPLIED
+  group-transaction-events     (false | true) #IMPLIED

Review comment:
       I haven't gotten a definitive answer on this. I guess depending on the exceptions you've seen, I wouldn't update it or the 70 one.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r419179060



##########
File path: geode-core/src/main/resources/org/apache/geode/cache/doc-files/cache8_0.dtd
##########
@@ -675,6 +675,7 @@ As of 6.5 roll-oplogs is deprecated. Use disk-store-name instead.
   alert-threshold              CDATA #IMPLIED
   dispatcher-threads           CDATA #IMPLIED
   order-policy                 CDATA #IMPLIED
+  group-transaction-events     (false | true) #IMPLIED

Review comment:
       I finally figured out that it was not needed to change the dtd files. But I had to change 
   CacheXmlGenerator so that the group-transaction-events attribute was not added to the gateway sender in case the cache.xml version was older than Geode 1.0. Without this change, the following test cases were failing:
   ```
   org.apache.geode.cache.CacheXml80GatewayDUnitTest > testGatewaySenderWithSubstitutionFilter FAILED
       org.apache.geode.cache.CacheXmlException: While reading Cache XML file:/tmp/junit10230339244221650502/XML_8_0/CacheXml80GatewayDUnitTest_testGatewaySenderWithSubstitutionFilter.xml. Error while parsing XML, caused by org.xml.sax.SAXParseException; lineNumber: 4; columnNumber: 458; Attribute "group-transaction-events" must be declared for element type "gateway-sender".
   
   org.apache.geode.cache.CacheXml70GatewayDUnitTest > testParallelGatewaySender FAILED
       org.apache.geode.cache.CacheXmlException: While reading Cache XML file:/tmp/junit5316048290838435700/XML_7_0/CacheXml70GatewayDUnitTest_testParallelGatewaySender.xml. Error while parsing XML, caused by org.xml.sax.SAXParseException; lineNumber: 4; columnNumber: 422; Attribute "group-transaction-events" must be declared for element type "gateway-sender".
   
   org.apache.geode.cache.CacheXml70GatewayDUnitTest > testSerialGatewaySender FAILED
       org.apache.geode.cache.CacheXmlException: While reading Cache XML file:/tmp/junit13002812494872484215/XML_7_0/CacheXml70GatewayDUnitTest_testSerialGatewaySender.xml. Error while parsing XML, caused by org.xml.sax.SAXParseException; lineNumber: 4; columnNumber: 423; Attribute "group-transaction-events" must be declared for element type "gateway-sender".
   ```




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


mivanac commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r421245781



##########
File path: geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderEventImpl.java
##########
@@ -692,6 +704,17 @@ public int getDSFID() {
   @Override
   public void toData(DataOutput out,
       SerializationContext context) throws IOException {
+    toDataPre_GEODE_1_13_0_0(out, context);
+    boolean hasTransaction = this.transactionId != null;
+    DataSerializer.writeBoolean(hasTransaction, out);
+    if (hasTransaction) {
+      DataSerializer.writeBoolean(this.isLastEventInTransaction, out);
+      context.getSerializer().writeObject(this.transactionId, out);
+    }
+  }
+
+  public void toDataPre_GEODE_1_13_0_0(DataOutput out,

Review comment:
       Since creation of 1.13 release is ongoing, I assume that this will go in 1.14 release. Do we need to update this method to toDataPre_GEODE_1_14_0_0

##########
File path: geode-core/src/main/java/org/apache/geode/internal/cache/wan/GatewaySenderEventImpl.java
##########
@@ -725,6 +748,18 @@ protected void serializeKey(DataOutput out,
   @Override
   public void fromData(DataInput in,
       DeserializationContext context) throws IOException, ClassNotFoundException {
+    fromDataPre_GEODE_1_13_0_0(in, context);
+    if (version >= Version.GEODE_1_13_0.ordinal()) {
+      boolean hasTransaction = DataSerializer.readBoolean(in);
+      if (hasTransaction) {
+        this.isLastEventInTransaction = DataSerializer.readBoolean(in);
+        this.transactionId = context.getDeserializer().readObject(in);
+      }
+    }
+  }
+
+  public void fromDataPre_GEODE_1_13_0_0(DataInput in, DeserializationContext context)

Review comment:
       Same comment as above. Do we need to update this method to fromDataPre_GEODE_1_14_0_0?




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


DonalEvans commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r422300082



##########
File path: geode-core/src/main/java/org/apache/geode/cache/wan/GatewaySender.java
##########
@@ -153,6 +155,13 @@
       .getInteger(GeodeGlossary.GEMFIRE_PREFIX + "gateway-connection-retry-interval", 1000)
       .intValue();
 
+  /**
+   * Number of times to retry to get events for a transaction from the gateway sender queue
+   */
+  int GET_TRANSACTION_EVENTS_FROM_QUEUE_RETRIES =
+      Integer.getInteger(GeodeGlossary.GEMFIRE_PREFIX + "get-transaction-events-from-queue-retries",

Review comment:
       gemfire_properties.html.md.erb should be updated to include this new property, as well as any other relevant documentation pages.

##########
File path: geode-core/src/main/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueue.java
##########
@@ -410,6 +442,53 @@ public Object peek() throws CacheException {
     // so no need to worry about off-heap refCount.
   }
 
+  private void peekEventsFromIncompleteTransactions(List<AsyncEvent> batch,
+      Set<TransactionId> incompleteTransactionIdsInBatch, long lastKey) {
+    if (!isGroupTransactionEvents()) {
+      return;
+    }
+
+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {
+      return;
+    }
+
+    for (TransactionId transactionId : incompleteTransactionIdsInBatch) {
+      boolean presentLastEventInTransaction = false;

Review comment:
       A more descriptive name for this variable might be `lastEventIsPresentInTransaction`.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -519,7 +521,9 @@ public static void createReplicatedRegionWithAsyncEventQueue(String regionName,
   }
 
   public static void createReplicatedRegionWithSenderAndAsyncEventQueue(String regionName,
-      String senderIds, String asyncChannelId, Boolean offHeap) {
+      String senderIds,

Review comment:
       Another possibly unnecessary formatting change.

##########
File path: geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java
##########
@@ -1282,22 +1278,89 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac
           Thread.currentThread().interrupt();
           break;
         }
-        continue;
       }
     }
+
+    if (batch.size() > 0) {
+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);
+    }
+
     if (isDebugEnabled) {
       logger.debug("{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}",
           this, batch.size(), size(), localSize());
     }
+
     if (batch.size() == 0) {
       blockProcessorThreadIfRequired();
     }
     return batch;
   }
 
+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {
+    final boolean isDebugEnabled = logger.isDebugEnabled();
+    // If time to wait is -1 (don't wait) or time interval has elapsed
+    if (isDebugEnabled) {
+      logger.debug("{}: Peek current time: {}", this, currentTime);
+    }
+    if (timeToWait == -1 || (end <= currentTime)) {
+      if (isDebugEnabled) {
+        logger.debug("{}: Peek breaking", this);
+      }
+      return true;
+    }
+    return false;
+  }
+
+  protected boolean isGroupTransactionEvents() {
+    return sender.isGroupTransactionEvents();
+  }
+
+  private void peekEventsFromIncompleteTransactions(List<GatewaySenderEventImpl> batch,
+      Map<TransactionId, Integer> incompleteTransactionIdsInBatch, PartitionedRegion prQ) {
+    if (!isGroupTransactionEvents()) {
+      return;
+    }
+
+    if (areAllTransactionsCompleteInBatch(incompleteTransactionIdsInBatch)) {
+      return;
+    }
+
+    for (Map.Entry<TransactionId, Integer> pendingTransaction : incompleteTransactionIdsInBatch
+        .entrySet()) {
+      TransactionId transactionId = pendingTransaction.getKey();
+      int bucketId = pendingTransaction.getValue();
+      boolean presentLastEventInTransaction = false;

Review comment:
       A more descriptive name for this variable might be `lastEventIsPresentInTransaction`.

##########
File path: geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySenderEventProcessor.java
##########
@@ -862,14 +868,14 @@ private void logEvents(String message, List<GatewaySenderEventImpl> events) {
               event.getRawCallbackArgument(), this.sender.getMyDSId(), allRemoteDSIds);
           event.setCallbackArgument(geCallbackArg);
           GatewaySenderEventImpl pdxSenderEvent =
-              new GatewaySenderEventImpl(EnumListenerEvent.AFTER_UPDATE, event, null); // OFFHEAP:
-                                                                                       // event for
-                                                                                       // pdx type
-                                                                                       // meta data
-                                                                                       // so it
-                                                                                       // should
-                                                                                       // never be
-                                                                                       // off-heap
+              new GatewaySenderEventImpl(EnumListenerEvent.AFTER_UPDATE, event, null, false); // OFFHEAP:
+          // event for
+          // pdx type
+          // meta data
+          // so it
+          // should
+          // never be
+          // off-heap

Review comment:
       Could this comment be cleaned up?

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -373,7 +373,8 @@ public static Integer createSecondRemoteLocator(int dsId, int localPort, int rem
   }
 
   public static Integer createSecondRemoteLocatorWithAPI(int dsId, int localPort, int remoteLocPort,
-      String hostnameForClients) throws IOException {
+      String hostnameForClients)

Review comment:
       Is there a reason for the formatting changes to the method signatures in this class? If not, they should be returned to how they were.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -691,7 +700,8 @@ public static void addAsyncEventQueueThroughAttributesMutator(String regionName,
   }
 
   public static void createPartitionedRegionAsAccessor(String regionName, String senderIds,
-      Integer redundantCopies, Integer totalNumBuckets) {
+      Integer redundantCopies,

Review comment:
       Another possibly unnecessary formatting change.

##########
File path: geode-core/src/main/java/org/apache/geode/internal/cache/InternalRegion.java
##########
@@ -307,6 +307,11 @@ void cacheWriteBeforePut(EntryEventImpl event, Set netWriteRecipients, CacheWrit
 
   void invokeTXCallbacks(EnumListenerEvent afterDestroy, EntryEventImpl ee, boolean b);
 
+  default void invokeTXCallbacks(EnumListenerEvent afterDestroy, EntryEventImpl ee, boolean b,

Review comment:
       Per the recent discussion on the dev list regarding the use of default methods in interfaces, does this absolutely need to be `default`?

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -497,7 +498,8 @@ public static void createPersistentReplicatedRegion(String regionName, String se
   }
 
   public static void createReplicatedRegionWithAsyncEventQueue(String regionName,
-      String asyncQueueIds, Boolean offHeap) {
+      String asyncQueueIds,

Review comment:
       Another possibly unnecessary formatting change.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -560,7 +564,8 @@ public static void createReplicatedRegion(String regionName, String senderIds, S
   }
 
   public static void createAsyncEventQueue(String asyncChannelId, boolean isParallel,
-      Integer maxMemory, Integer batchSize, boolean isConflation, boolean isPersistent,
+      Integer maxMemory, Integer batchSize,

Review comment:
       Another possibly unnecessary formatting change.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java
##########
@@ -0,0 +1,192 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.ServiceConfigurationError;
+import java.util.Set;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.wan.GatewaySender;
+
+public class TXLastEventInTransactionUtilsTest {
+
+  public static final String SENDER_1 = "sender1";
+  public static final String SENDER_2 = "sender2";
+  public static final String SENDER_3 = "sender3";
+  public static final String SENDER_4 = "sender4";
+  public static final String SENDER_5 = "sender5";
+
+  Cache cache;
+  InternalRegion region1;
+  InternalRegion region2;
+  InternalRegion region3;
+  InternalRegion region4;
+  InternalRegion region5;
+  InternalRegion region6;
+  InternalRegion region7;
+  InternalRegion region8;
+
+  GatewaySender sender1;
+  GatewaySender sender2;
+  GatewaySender sender3;
+  GatewaySender sender4;
+
+  @Before
+  public void setUp() {
+    sender1 = mock(GatewaySender.class);
+    when(sender1.isGroupTransactionEvents()).thenReturn(false);
+    sender2 = mock(GatewaySender.class);
+    when(sender2.isGroupTransactionEvents()).thenReturn(false);
+    sender3 = mock(GatewaySender.class);
+    when(sender3.isGroupTransactionEvents()).thenReturn(true);
+    sender4 = mock(GatewaySender.class);
+    when(sender4.isGroupTransactionEvents()).thenReturn(true);
+
+    cache = mock(Cache.class);
+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);
+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);
+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);
+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);
+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);
+
+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};
+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};
+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};
+    final String listSenderIdsForRegion7[] = {SENDER_3};
+    final String listSenderIdsForRegion8[] = {SENDER_5};
+
+
+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));
+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));
+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));
+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));
+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));
+
+    region1 = mock(InternalRegion.class);
+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);
+
+    region2 = mock(InternalRegion.class);
+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);
+
+    region3 = mock(InternalRegion.class);
+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);
+
+    region4 = mock(InternalRegion.class);
+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);
+
+    region5 = mock(InternalRegion.class);
+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);
+
+    region6 = mock(InternalRegion.class);
+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);
+
+    region7 = mock(InternalRegion.class);
+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);
+
+    region8 = mock(InternalRegion.class);
+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);
+  }
+
+  @Test
+  public void noSenderGroupingTransactions() throws Exception {
+    List<EntryEventImpl> events = new ArrayList();
+    EntryEventImpl event1 = createMockEntryEventImpl(region1);
+    EntryEventImpl event2 = createMockEntryEventImpl(region2);
+
+    events.add(event1);
+    events.add(event2);
+
+    EntryEventImpl lastTransactionEvent =
+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);
+
+    assertEquals(null, lastTransactionEvent);
+  }
+
+  @Test
+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {
+    List<EntryEventImpl> events = new ArrayList();
+    EntryEventImpl event1 = createMockEntryEventImpl(region3);
+    EntryEventImpl event2 = createMockEntryEventImpl(region4);
+
+    events.add(event1);
+    events.add(event2);
+
+    EntryEventImpl lastTransactionEvent =
+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);
+
+    assertEquals(event2, lastTransactionEvent);
+  }
+
+  @Test
+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {
+    List<EntryEventImpl> events = new ArrayList();
+    EntryEventImpl event1 = createMockEntryEventImpl(region5);
+    EntryEventImpl event2 = createMockEntryEventImpl(region6);
+
+    events.add(event1);
+    events.add(event2);
+
+    EntryEventImpl lastTransactionEvent =
+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);
+
+    assertEquals(event2, lastTransactionEvent);
+  }
+
+  @Test
+  public void notAllEventsToSameGroupingSenders() throws Exception {

Review comment:
       This test name could be more descriptive. Also, an exception is never thrown from this method, so the `throws` can be removed.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -619,7 +625,8 @@ public static void createPartitionedRegion(String regionName, String senderIds,
 
   // TODO:OFFHEAP: add offheap flavor
   public static void createPartitionedRegionWithPersistence(String regionName, String senderIds,
-      Integer redundantCopies, Integer totalNumBuckets) {
+      Integer redundantCopies,

Review comment:
       Another possibly unnecessary formatting change.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -589,7 +594,8 @@ public static void createAsyncEventQueue(String asyncChannelId, boolean isParall
   }
 
   public static void createPartitionedRegion(String regionName, String senderIds,
-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {
+      Integer redundantCopies, Integer totalNumBuckets,

Review comment:
       Another possibly unnecessary formatting change.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -734,7 +747,8 @@ public static void createPartitionedRegionWithSerialParallelSenderIds(String reg
   }
 
   public static void createPersistentPartitionedRegion(String regionName, String senderIds,
-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {
+      Integer redundantCopies,

Review comment:
       Another possibly unnecessary formatting change.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/BucketRegionQueueJUnitTest.java
##########
@@ -120,4 +137,69 @@ public void testBasicDestroyConflationEnabledAndValueNotInRegion() {
     // Invoke basicDestroy
     this.bucketRegionQueue.basicDestroy(event, true, null, false);
   }
+
+  @Test
+  public void testGetElementsMatching() {
+    ParallelGatewaySenderEventProcessor processor =
+        ParallelGatewaySenderHelper.createParallelGatewaySenderEventProcessor(this.sender);
+
+    TransactionId tx1 = new TXId(null, 1);
+    TransactionId tx2 = new TXId(null, 2);
+    TransactionId tx3 = new TXId(null, 3);
+
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEvent(1, tx1, false);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEvent(2, tx2, false);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEvent(3, tx1, true);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEvent(4, tx2, true);
+    GatewaySenderEventImpl event5 = createMockGatewaySenderEvent(5, tx3, false);
+    GatewaySenderEventImpl event6 = createMockGatewaySenderEvent(6, tx3, false);
+    GatewaySenderEventImpl event7 = createMockGatewaySenderEvent(7, tx1, true);
+
+    this.bucketRegionQueue
+        .cleanUpDestroyedTokensAndMarkGIIComplete(InitialImageOperation.GIIStatus.NO_GII);
+
+    try {
+      this.bucketRegionQueue.addToQueue(Long.valueOf(1), event1);
+      this.bucketRegionQueue.addToQueue(Long.valueOf(2), event2);
+      this.bucketRegionQueue.addToQueue(Long.valueOf(3), event3);
+      this.bucketRegionQueue.addToQueue(Long.valueOf(4), event4);
+      this.bucketRegionQueue.addToQueue(Long.valueOf(5), event5);
+      this.bucketRegionQueue.addToQueue(Long.valueOf(6), event6);
+      this.bucketRegionQueue.addToQueue(Long.valueOf(7), event7);
+
+    } catch (ForceReattemptException e) {
+      fail("Exception thrown: " + e);

Review comment:
       This try/catch shouldn't be necessary, I think. The test will automatically fail if an exception is thrown. The exception should instead be added to the test method signature.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java
##########
@@ -0,0 +1,192 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.ServiceConfigurationError;
+import java.util.Set;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.wan.GatewaySender;
+
+public class TXLastEventInTransactionUtilsTest {
+
+  public static final String SENDER_1 = "sender1";
+  public static final String SENDER_2 = "sender2";
+  public static final String SENDER_3 = "sender3";
+  public static final String SENDER_4 = "sender4";
+  public static final String SENDER_5 = "sender5";
+
+  Cache cache;
+  InternalRegion region1;
+  InternalRegion region2;
+  InternalRegion region3;
+  InternalRegion region4;
+  InternalRegion region5;
+  InternalRegion region6;
+  InternalRegion region7;
+  InternalRegion region8;
+
+  GatewaySender sender1;
+  GatewaySender sender2;
+  GatewaySender sender3;
+  GatewaySender sender4;
+
+  @Before
+  public void setUp() {
+    sender1 = mock(GatewaySender.class);
+    when(sender1.isGroupTransactionEvents()).thenReturn(false);
+    sender2 = mock(GatewaySender.class);
+    when(sender2.isGroupTransactionEvents()).thenReturn(false);
+    sender3 = mock(GatewaySender.class);
+    when(sender3.isGroupTransactionEvents()).thenReturn(true);
+    sender4 = mock(GatewaySender.class);
+    when(sender4.isGroupTransactionEvents()).thenReturn(true);
+
+    cache = mock(Cache.class);
+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);
+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);
+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);
+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);
+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);
+
+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};
+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};
+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};
+    final String listSenderIdsForRegion7[] = {SENDER_3};
+    final String listSenderIdsForRegion8[] = {SENDER_5};

Review comment:
       Can these arrays be declared java-style rather than C-style: `String[] listSenderIdsForRegion1_2`

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java
##########
@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {
     assertThat(queue.isDREvent(cache, event)).isFalse();
   }
 
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()
+      throws Exception {
+
+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);
+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);
+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);
+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);
+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);
+
+    Queue backingList = new LinkedList();
+    backingList.add(event1);
+    backingList.add(event2);
+    backingList.add(event3);
+    backingList.add(event4);
+    backingList.add(event5);
+    backingList.add(event6);
+
+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);
+
+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,
+        Collections.emptySet(), 0, 1, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()
+      throws Exception {
+
+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);
+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);
+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);
+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);
+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);
+
+    Queue backingList = new LinkedList();
+    backingList.add(event1);
+    backingList.add(event2);
+    backingList.add(event3);
+    backingList.add(null);
+    backingList.add(event4);
+    backingList.add(event5);
+    backingList.add(event6);
+
+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);
+
+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,
+        Collections.emptySet(), 0, 1, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);
+
+    List peeked = queue.peek(-1, 1);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(-1, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  @Test
+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()
+      throws Exception {
+
+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(2, false);
+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(1, true);
+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(2, true);
+
+    Queue backingList = new LinkedList();
+    backingList.add(event1);
+    backingList.add(event2);
+    backingList.add(event3);
+    backingList.add(event4);
+    backingList.add(event5);
+
+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);
+
+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,
+        Collections.emptySet(), 0, 1, metaRegionFactory);
+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(3, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  private static GatewaySenderEventImpl createGatewaySenderEventImpl(int transactionId,

Review comment:
       This method does not need to be static.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java
##########
@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {
     assertThat(queue.isDREvent(cache, event)).isFalse();
   }
 
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()
+      throws Exception {
+
+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);
+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);
+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);
+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);
+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);
+
+    Queue backingList = new LinkedList();
+    backingList.add(event1);
+    backingList.add(event2);
+    backingList.add(event3);
+    backingList.add(event4);
+    backingList.add(event5);
+    backingList.add(event6);
+
+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);
+
+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,
+        Collections.emptySet(), 0, 1, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()
+      throws Exception {
+
+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);
+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);
+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);
+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);
+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);
+
+    Queue backingList = new LinkedList();
+    backingList.add(event1);
+    backingList.add(event2);
+    backingList.add(event3);
+    backingList.add(null);
+    backingList.add(event4);
+    backingList.add(event5);
+    backingList.add(event6);
+
+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);
+
+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,
+        Collections.emptySet(), 0, 1, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);
+
+    List peeked = queue.peek(-1, 1);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(-1, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  @Test
+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()

Review comment:
       This test name could be more descriptive.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java
##########
@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {
 
   }
 
+  @Test
+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 10000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 2, true, false));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 30000;
+    boolean isGroupTransactionEvents = true;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+
+    // 4 transactions of 3 events each are sent so that the first batch
+    // would initially contain the first 3 transactions complete and the first
+    // event of the next transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // events of the third transaction are added to the batch which makes
+    // that the batch is sent with 12 events.
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 1, true));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0, true));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 30000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 24;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);

Review comment:
       `Thread.sleep()` should be avoided in tests as it can lead to flakiness. `GeodeAwaitility.await()` should be used instead.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java
##########
@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {
     assertThat(queue.isDREvent(cache, event)).isFalse();
   }
 
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()

Review comment:
       This test name could be more descriptive.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/BucketRegionQueueJUnitTest.java
##########
@@ -120,4 +137,69 @@ public void testBasicDestroyConflationEnabledAndValueNotInRegion() {
     // Invoke basicDestroy
     this.bucketRegionQueue.basicDestroy(event, true, null, false);
   }
+
+  @Test
+  public void testGetElementsMatching() {

Review comment:
       Can this test have a more descriptive name? Test names should ideally describe what is being tested, what the conditions are, and what the expected result is.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -764,7 +778,9 @@ public static void createPersistentPartitionedRegion(String regionName, String s
   }
 
   public static void createCustomerOrderShipmentPartitionedRegion(String senderIds,
-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {
+      Integer redundantCopies,

Review comment:
       Another possibly unnecessary formatting change.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -830,7 +846,8 @@ public static void createCustomerOrderShipmentPartitionedRegion(String senderIds
   }
 
   public static void createColocatedPartitionedRegions(String regionName, String senderIds,
-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {
+      Integer redundantCopies,

Review comment:
       Another possibly unnecessary formatting change.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -709,7 +719,10 @@ public static void createPartitionedRegionAsAccessor(String regionName, String s
   }
 
   public static void createPartitionedRegionWithSerialParallelSenderIds(String regionName,
-      String serialSenderIds, String parallelSenderIds, String colocatedWith, Boolean offHeap) {
+      String serialSenderIds,

Review comment:
       Another possibly unnecessary formatting change.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java
##########
@@ -201,18 +306,40 @@ private BucketRegionQueue mockBucketRegionQueue(final Queue backingList) {
     // mocked pr region
     when(mockBucketRegion.getLocalMaxMemory()).thenReturn(100);
     when(mockBucketRegion.size()).thenReturn(backingList.size());
-
     BucketRegionQueue bucketRegionQueue = mock(BucketRegionQueue.class);
     when(bucketRegionQueue.getPartitionedRegion()).thenReturn(mockBucketRegion);
-    when(bucketRegionQueue.peek()).thenAnswer((Answer) invocation -> backingList.poll());
+    when(bucketRegionQueue.peek())
+        .thenAnswer((Answer) invocation -> pollAndWaitIfNull(backingList));
+    when(bucketRegionQueue.getElementsMatching(any(), any()))
+        .thenAnswer((Answer) invocation -> Arrays
+            .asList(new Object[] {getFirstNotNull(backingList)}));
     return bucketRegionQueue;
   }
 
+  private Object pollAndWaitIfNull(Queue queue) {
+    Object object = queue.poll();
+    if (object == null) {
+      try {
+        Thread.sleep(10);
+      } catch (InterruptedException e) {
+        e.printStackTrace();
+      }
+    }

Review comment:
       What is the purpose of waiting here? `Thread.sleep()` should be avoided in tests as it leads to flakiness, so is there something that can be used with `GeodeAwaitility.await()` instead?

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -647,7 +654,9 @@ public static void createPartitionedRegionWithPersistence(String regionName, Str
   }
 
   public static void createColocatedPartitionedRegion(String regionName, String senderIds,
-      Integer redundantCopies, Integer totalNumBuckets, String colocatedWith) {
+      Integer redundantCopies,

Review comment:
       Another possibly unnecessary formatting change.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -858,7 +875,8 @@ public static void createColocatedPartitionedRegions(String regionName, String s
   }
 
   public static void createColocatedPartitionedRegions2(String regionName, String senderIds,
-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {
+      Integer redundantCopies,

Review comment:
       Another possibly unnecessary formatting change.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java
##########
@@ -0,0 +1,192 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.ServiceConfigurationError;
+import java.util.Set;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.wan.GatewaySender;
+
+public class TXLastEventInTransactionUtilsTest {
+
+  public static final String SENDER_1 = "sender1";
+  public static final String SENDER_2 = "sender2";
+  public static final String SENDER_3 = "sender3";
+  public static final String SENDER_4 = "sender4";
+  public static final String SENDER_5 = "sender5";
+
+  Cache cache;
+  InternalRegion region1;
+  InternalRegion region2;
+  InternalRegion region3;
+  InternalRegion region4;
+  InternalRegion region5;
+  InternalRegion region6;
+  InternalRegion region7;
+  InternalRegion region8;
+
+  GatewaySender sender1;
+  GatewaySender sender2;
+  GatewaySender sender3;
+  GatewaySender sender4;
+
+  @Before
+  public void setUp() {
+    sender1 = mock(GatewaySender.class);
+    when(sender1.isGroupTransactionEvents()).thenReturn(false);
+    sender2 = mock(GatewaySender.class);
+    when(sender2.isGroupTransactionEvents()).thenReturn(false);
+    sender3 = mock(GatewaySender.class);
+    when(sender3.isGroupTransactionEvents()).thenReturn(true);
+    sender4 = mock(GatewaySender.class);
+    when(sender4.isGroupTransactionEvents()).thenReturn(true);
+
+    cache = mock(Cache.class);
+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);
+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);
+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);
+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);
+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);
+
+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};
+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};
+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};
+    final String listSenderIdsForRegion7[] = {SENDER_3};
+    final String listSenderIdsForRegion8[] = {SENDER_5};
+
+
+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));
+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));
+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));
+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));
+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));
+
+    region1 = mock(InternalRegion.class);
+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);
+
+    region2 = mock(InternalRegion.class);
+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);
+
+    region3 = mock(InternalRegion.class);
+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);
+
+    region4 = mock(InternalRegion.class);
+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);
+
+    region5 = mock(InternalRegion.class);
+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);
+
+    region6 = mock(InternalRegion.class);
+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);
+
+    region7 = mock(InternalRegion.class);
+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);
+
+    region8 = mock(InternalRegion.class);
+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);
+  }
+
+  @Test
+  public void noSenderGroupingTransactions() throws Exception {

Review comment:
       This test name could be more descriptive. Also, an exception is never thrown from this method, so the `throws` can be removed.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java
##########
@@ -0,0 +1,192 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.ServiceConfigurationError;
+import java.util.Set;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.wan.GatewaySender;
+
+public class TXLastEventInTransactionUtilsTest {
+
+  public static final String SENDER_1 = "sender1";
+  public static final String SENDER_2 = "sender2";
+  public static final String SENDER_3 = "sender3";
+  public static final String SENDER_4 = "sender4";
+  public static final String SENDER_5 = "sender5";
+
+  Cache cache;
+  InternalRegion region1;
+  InternalRegion region2;
+  InternalRegion region3;
+  InternalRegion region4;
+  InternalRegion region5;
+  InternalRegion region6;
+  InternalRegion region7;
+  InternalRegion region8;
+
+  GatewaySender sender1;
+  GatewaySender sender2;
+  GatewaySender sender3;
+  GatewaySender sender4;
+
+  @Before
+  public void setUp() {
+    sender1 = mock(GatewaySender.class);
+    when(sender1.isGroupTransactionEvents()).thenReturn(false);
+    sender2 = mock(GatewaySender.class);
+    when(sender2.isGroupTransactionEvents()).thenReturn(false);
+    sender3 = mock(GatewaySender.class);
+    when(sender3.isGroupTransactionEvents()).thenReturn(true);
+    sender4 = mock(GatewaySender.class);
+    when(sender4.isGroupTransactionEvents()).thenReturn(true);
+
+    cache = mock(Cache.class);
+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);
+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);
+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);
+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);
+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);
+
+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};
+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};
+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};
+    final String listSenderIdsForRegion7[] = {SENDER_3};
+    final String listSenderIdsForRegion8[] = {SENDER_5};
+
+
+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));
+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));
+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));
+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));
+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));
+
+    region1 = mock(InternalRegion.class);
+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);
+
+    region2 = mock(InternalRegion.class);
+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);
+
+    region3 = mock(InternalRegion.class);
+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);
+
+    region4 = mock(InternalRegion.class);
+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);
+
+    region5 = mock(InternalRegion.class);
+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);
+
+    region6 = mock(InternalRegion.class);
+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);
+
+    region7 = mock(InternalRegion.class);
+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);
+
+    region8 = mock(InternalRegion.class);
+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);
+  }
+
+  @Test
+  public void noSenderGroupingTransactions() throws Exception {
+    List<EntryEventImpl> events = new ArrayList();
+    EntryEventImpl event1 = createMockEntryEventImpl(region1);
+    EntryEventImpl event2 = createMockEntryEventImpl(region2);
+
+    events.add(event1);
+    events.add(event2);
+
+    EntryEventImpl lastTransactionEvent =
+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);
+
+    assertEquals(null, lastTransactionEvent);
+  }
+
+  @Test
+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {

Review comment:
       This test name could be more descriptive. Also, an exception is never thrown from this method, so the `throws` can be removed.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java
##########
@@ -292,6 +295,7 @@ public void testCreateDestroyGatewaySenderWithGatewayTransportFilters() {
         + CliStrings.CREATE_GATEWAYSENDER__ALERTTHRESHOLD + "=100" + " --"
         + CliStrings.CREATE_GATEWAYSENDER__DISPATCHERTHREADS + "=2" + " --"
         + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + "=THREAD" + " --"
+        + CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS + "=false" + " --"

Review comment:
       Specifying the default value here is redundant.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java
##########
@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache.wan.serial;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import org.apache.geode.CancelCriterion;
+import org.apache.geode.cache.AttributesFactory;
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.DataPolicy;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionAttributes;
+import org.apache.geode.cache.Scope;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.InternalRegionArguments;
+import org.apache.geode.internal.cache.InternalRegionFactory;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.TXId;
+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;
+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;
+import org.apache.geode.internal.cache.wan.GatewaySenderStats;
+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;
+import org.apache.geode.internal.statistics.StatisticsClock;
+import org.apache.geode.metrics.internal.NoopMeterRegistry;
+
+public class SerialGatewaySenderQueueJUnitTest {
+
+  private static final String TEST_REGION = "testRegion";
+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;
+  private GemFireCacheImpl cache;
+  private AbstractGatewaySender sender;
+  Region region;
+  InternalRegionFactory regionFactory;
+
+  @Before
+  public void setup() {
+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);
+    when(mockInternalDistributedSystem.getStatisticsManager())
+        .thenReturn(new DummyStatisticsRegistry("", 0));
+
+    cache = mock(GemFireCacheImpl.class);
+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);
+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());
+
+    region = createDistributedRegion(TEST_REGION, cache);
+
+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);
+    when(regionFactory.setInternalMetaRegion(any())
+        .setDestroyLockFlag(anyBoolean())
+        .setSnapshotInputStream(any())
+        .setImageTarget(any())
+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())
+        .setInternalRegion(anyBoolean())
+        .setSerialGatewaySender(any())).thenReturn(regionFactory);
+    when(regionFactory.create(TEST_REGION)).thenReturn(region);
+
+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);
+
+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);
+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);
+
+    sender = mock(AbstractGatewaySender.class);
+
+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);
+    when(sender.getCache()).thenReturn(cache);
+    when(sender.getMaximumQueueMemory()).thenReturn(100);
+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());
+    when(sender.getId()).thenReturn("");
+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));
+
+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);
+
+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =
+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);
+
+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()
+      throws Exception {
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);
+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);
+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);
+
+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,
+        TEST_REGION, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+
+    queue.put(event1);
+    queue.put(event2);
+    queue.put(event3);
+    queue.put(event4);
+    queue.put(event5);
+    queue.put(event6);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()
+      throws Exception {
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);
+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =
+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);
+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =
+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);
+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =
+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);
+
+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,
+        TEST_REGION, metaRegionFactory);
+
+    TestableSerialGatewaySenderQueue queue = spy(realQueue);
+    queue.setGroupTransactionEvents(true);
+
+    doAnswer(invocation -> eventPair1)
+        .doAnswer(invocation -> eventPair2)
+        .doAnswer(invocation -> eventPair3)
+        .doAnswer(invocation -> null)
+        .when(queue).peekAhead();
+
+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(
+        Arrays.asList(new Object[] {event4}), 2L))
+            .when(queue).getElementsMatching(any(), any(), anyLong());
+
+    List peeked = queue.peek(-1, 1);
+    assertEquals(4, peeked.size());
+  }
+
+  @Test
+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()
+      throws Exception {
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);
+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);
+
+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,
+        TEST_REGION, metaRegionFactory);
+
+    queue.put(event1);
+    queue.put(event2);
+    queue.put(event3);
+    queue.put(event4);
+    queue.put(event5);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(3, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  private static GatewaySenderEventImpl createMockGatewaySenderEventImpl(int transactionId,

Review comment:
       This method doesn't need to be static.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java
##########
@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {
 
   }
 
+  @Test
+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));

Review comment:
       These casts to `Integer` are redundant.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java
##########
@@ -0,0 +1,192 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.ServiceConfigurationError;
+import java.util.Set;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.wan.GatewaySender;
+
+public class TXLastEventInTransactionUtilsTest {
+
+  public static final String SENDER_1 = "sender1";
+  public static final String SENDER_2 = "sender2";
+  public static final String SENDER_3 = "sender3";
+  public static final String SENDER_4 = "sender4";
+  public static final String SENDER_5 = "sender5";
+
+  Cache cache;
+  InternalRegion region1;
+  InternalRegion region2;
+  InternalRegion region3;
+  InternalRegion region4;
+  InternalRegion region5;
+  InternalRegion region6;
+  InternalRegion region7;
+  InternalRegion region8;
+
+  GatewaySender sender1;
+  GatewaySender sender2;
+  GatewaySender sender3;
+  GatewaySender sender4;
+
+  @Before
+  public void setUp() {
+    sender1 = mock(GatewaySender.class);
+    when(sender1.isGroupTransactionEvents()).thenReturn(false);
+    sender2 = mock(GatewaySender.class);
+    when(sender2.isGroupTransactionEvents()).thenReturn(false);
+    sender3 = mock(GatewaySender.class);
+    when(sender3.isGroupTransactionEvents()).thenReturn(true);
+    sender4 = mock(GatewaySender.class);
+    when(sender4.isGroupTransactionEvents()).thenReturn(true);
+
+    cache = mock(Cache.class);
+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);
+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);
+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);
+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);
+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);
+
+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};
+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};
+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};
+    final String listSenderIdsForRegion7[] = {SENDER_3};
+    final String listSenderIdsForRegion8[] = {SENDER_5};
+
+
+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));
+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));
+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));
+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));
+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));
+
+    region1 = mock(InternalRegion.class);
+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);
+
+    region2 = mock(InternalRegion.class);
+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);
+
+    region3 = mock(InternalRegion.class);
+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);
+
+    region4 = mock(InternalRegion.class);
+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);
+
+    region5 = mock(InternalRegion.class);
+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);
+
+    region6 = mock(InternalRegion.class);
+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);
+
+    region7 = mock(InternalRegion.class);
+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);
+
+    region8 = mock(InternalRegion.class);
+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);
+  }
+
+  @Test
+  public void noSenderGroupingTransactions() throws Exception {
+    List<EntryEventImpl> events = new ArrayList();
+    EntryEventImpl event1 = createMockEntryEventImpl(region1);
+    EntryEventImpl event2 = createMockEntryEventImpl(region2);
+
+    events.add(event1);
+    events.add(event2);
+
+    EntryEventImpl lastTransactionEvent =
+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);
+
+    assertEquals(null, lastTransactionEvent);
+  }
+
+  @Test
+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {
+    List<EntryEventImpl> events = new ArrayList();
+    EntryEventImpl event1 = createMockEntryEventImpl(region3);
+    EntryEventImpl event2 = createMockEntryEventImpl(region4);
+
+    events.add(event1);
+    events.add(event2);
+
+    EntryEventImpl lastTransactionEvent =
+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);
+
+    assertEquals(event2, lastTransactionEvent);
+  }
+
+  @Test
+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {

Review comment:
       This test name could be more descriptive. Also, an exception is never thrown from this method, so the `throws` can be removed.

##########
File path: geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java
##########
@@ -1282,22 +1278,89 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac
           Thread.currentThread().interrupt();
           break;
         }
-        continue;
       }
     }
+
+    if (batch.size() > 0) {
+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);
+    }
+
     if (isDebugEnabled) {
       logger.debug("{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}",
           this, batch.size(), size(), localSize());
     }
+
     if (batch.size() == 0) {
       blockProcessorThreadIfRequired();
     }
     return batch;
   }
 
+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {

Review comment:
       The `currentTime` argument can be removed and replaced with a call to `System.currentTimeMillis()` inside the method.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -159,10 +169,10 @@ public void testQueueSizeInSecondaryBucketRegionQueuesWithMemberRestart() throws
     v7List = (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertEquals(0, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary
-                                                                                        // queue
-                                                                                        // size
+    // queue
+    // size

Review comment:
       More untidy comments.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtilsTest.java
##########
@@ -0,0 +1,192 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.ServiceConfigurationError;
+import java.util.Set;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.wan.GatewaySender;
+
+public class TXLastEventInTransactionUtilsTest {
+
+  public static final String SENDER_1 = "sender1";
+  public static final String SENDER_2 = "sender2";
+  public static final String SENDER_3 = "sender3";
+  public static final String SENDER_4 = "sender4";
+  public static final String SENDER_5 = "sender5";
+
+  Cache cache;
+  InternalRegion region1;
+  InternalRegion region2;
+  InternalRegion region3;
+  InternalRegion region4;
+  InternalRegion region5;
+  InternalRegion region6;
+  InternalRegion region7;
+  InternalRegion region8;
+
+  GatewaySender sender1;
+  GatewaySender sender2;
+  GatewaySender sender3;
+  GatewaySender sender4;
+
+  @Before
+  public void setUp() {
+    sender1 = mock(GatewaySender.class);
+    when(sender1.isGroupTransactionEvents()).thenReturn(false);
+    sender2 = mock(GatewaySender.class);
+    when(sender2.isGroupTransactionEvents()).thenReturn(false);
+    sender3 = mock(GatewaySender.class);
+    when(sender3.isGroupTransactionEvents()).thenReturn(true);
+    sender4 = mock(GatewaySender.class);
+    when(sender4.isGroupTransactionEvents()).thenReturn(true);
+
+    cache = mock(Cache.class);
+    when(cache.getGatewaySender(SENDER_1)).thenReturn(sender1);
+    when(cache.getGatewaySender(SENDER_2)).thenReturn(sender2);
+    when(cache.getGatewaySender(SENDER_3)).thenReturn(sender3);
+    when(cache.getGatewaySender(SENDER_4)).thenReturn(sender4);
+    when(cache.getGatewaySender(SENDER_5)).thenReturn(null);
+
+    final String listSenderIdsForRegion1_2[] = {SENDER_1, SENDER_2};
+    final String listSenderIdsForRegion3_4[] = {SENDER_3, SENDER_4};
+    final String listSenderIdsForRegion5_6[] = {SENDER_1, SENDER_3};
+    final String listSenderIdsForRegion7[] = {SENDER_3};
+    final String listSenderIdsForRegion8[] = {SENDER_5};
+
+
+    Set senderIdsForRegion1_2 = new HashSet(Arrays.asList(listSenderIdsForRegion1_2));
+    Set senderIdsForRegion3_4 = new HashSet(Arrays.asList(listSenderIdsForRegion3_4));
+    Set senderIdsForRegion5_6 = new HashSet(Arrays.asList(listSenderIdsForRegion5_6));
+    Set senderIdsForRegion7 = new HashSet(Arrays.asList(listSenderIdsForRegion7));
+    Set senderIdsForRegion8 = new HashSet(Arrays.asList(listSenderIdsForRegion8));
+
+    region1 = mock(InternalRegion.class);
+    when(region1.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);
+
+    region2 = mock(InternalRegion.class);
+    when(region2.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion1_2);
+
+    region3 = mock(InternalRegion.class);
+    when(region3.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);
+
+    region4 = mock(InternalRegion.class);
+    when(region4.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion3_4);
+
+    region5 = mock(InternalRegion.class);
+    when(region5.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);
+
+    region6 = mock(InternalRegion.class);
+    when(region6.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion5_6);
+
+    region7 = mock(InternalRegion.class);
+    when(region7.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion7);
+
+    region8 = mock(InternalRegion.class);
+    when(region8.getAllGatewaySenderIds()).thenReturn(senderIdsForRegion8);
+  }
+
+  @Test
+  public void noSenderGroupingTransactions() throws Exception {
+    List<EntryEventImpl> events = new ArrayList();
+    EntryEventImpl event1 = createMockEntryEventImpl(region1);
+    EntryEventImpl event2 = createMockEntryEventImpl(region2);
+
+    events.add(event1);
+    events.add(event2);
+
+    EntryEventImpl lastTransactionEvent =
+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);
+
+    assertEquals(null, lastTransactionEvent);
+  }
+
+  @Test
+  public void lastEventFoundAllSendersGroupTransactions() throws Exception {
+    List<EntryEventImpl> events = new ArrayList();
+    EntryEventImpl event1 = createMockEntryEventImpl(region3);
+    EntryEventImpl event2 = createMockEntryEventImpl(region4);
+
+    events.add(event1);
+    events.add(event2);
+
+    EntryEventImpl lastTransactionEvent =
+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);
+
+    assertEquals(event2, lastTransactionEvent);
+  }
+
+  @Test
+  public void lastEventFoundNotAllSendersGroupTransactions() throws Exception {
+    List<EntryEventImpl> events = new ArrayList();
+    EntryEventImpl event1 = createMockEntryEventImpl(region5);
+    EntryEventImpl event2 = createMockEntryEventImpl(region6);
+
+    events.add(event1);
+    events.add(event2);
+
+    EntryEventImpl lastTransactionEvent =
+        TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache);
+
+    assertEquals(event2, lastTransactionEvent);
+  }
+
+  @Test
+  public void notAllEventsToSameGroupingSenders() throws Exception {
+    List<EntryEventImpl> events = new ArrayList();
+    EntryEventImpl event1 = createMockEntryEventImpl(region3);
+    EntryEventImpl event2 = createMockEntryEventImpl(region7);
+
+    events.add(event1);
+    events.add(event2);
+
+    assertThatThrownBy(() -> TXLastEventInTransactionUtils.getLastTransactionEvent(events, cache))
+        .isInstanceOf(ServiceConfigurationError.class)
+        .hasMessageContaining("Not all events go to the same senders that group transactions");
+  }
+
+  @Test
+  public void senderNotFound() throws Exception {

Review comment:
       This test name could be more descriptive. Also, an exception is never thrown from this method, so the `throws` can be removed.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java
##########
@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {
     assertThat(queue.isDREvent(cache, event)).isFalse();
   }
 
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()
+      throws Exception {
+
+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);
+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);
+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);
+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);
+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);
+
+    Queue backingList = new LinkedList();
+    backingList.add(event1);
+    backingList.add(event2);
+    backingList.add(event3);
+    backingList.add(event4);
+    backingList.add(event5);
+    backingList.add(event6);
+
+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);
+
+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,
+        Collections.emptySet(), 0, 1, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);

Review comment:
       Another large, apparently arbitrary timeToWait value.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java
##########
@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache.wan.serial;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import org.apache.geode.CancelCriterion;
+import org.apache.geode.cache.AttributesFactory;
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.DataPolicy;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionAttributes;
+import org.apache.geode.cache.Scope;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.InternalRegionArguments;
+import org.apache.geode.internal.cache.InternalRegionFactory;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.TXId;
+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;
+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;
+import org.apache.geode.internal.cache.wan.GatewaySenderStats;
+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;
+import org.apache.geode.internal.statistics.StatisticsClock;
+import org.apache.geode.metrics.internal.NoopMeterRegistry;
+
+public class SerialGatewaySenderQueueJUnitTest {
+
+  private static final String TEST_REGION = "testRegion";
+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;
+  private GemFireCacheImpl cache;
+  private AbstractGatewaySender sender;
+  Region region;
+  InternalRegionFactory regionFactory;
+
+  @Before
+  public void setup() {
+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);
+    when(mockInternalDistributedSystem.getStatisticsManager())
+        .thenReturn(new DummyStatisticsRegistry("", 0));
+
+    cache = mock(GemFireCacheImpl.class);
+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);
+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());
+
+    region = createDistributedRegion(TEST_REGION, cache);
+
+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);
+    when(regionFactory.setInternalMetaRegion(any())
+        .setDestroyLockFlag(anyBoolean())
+        .setSnapshotInputStream(any())
+        .setImageTarget(any())
+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())
+        .setInternalRegion(anyBoolean())
+        .setSerialGatewaySender(any())).thenReturn(regionFactory);
+    when(regionFactory.create(TEST_REGION)).thenReturn(region);
+
+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);
+
+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);
+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);
+
+    sender = mock(AbstractGatewaySender.class);
+
+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);
+    when(sender.getCache()).thenReturn(cache);
+    when(sender.getMaximumQueueMemory()).thenReturn(100);
+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());
+    when(sender.getId()).thenReturn("");
+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));
+
+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);
+
+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =
+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);
+
+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()
+      throws Exception {
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);
+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);
+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);
+
+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,
+        TEST_REGION, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+
+    queue.put(event1);
+    queue.put(event2);
+    queue.put(event3);
+    queue.put(event4);
+    queue.put(event5);
+    queue.put(event6);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);

Review comment:
       Another large, seemingly arbitrary timeToWait value.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
 
     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));
   }
 
+  @Test
+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, true, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+
+    // 3 transactions of 4 events each are sent so that the batch would
+    // initially contain the first 2 transactions complete and the first
+    // 2 events of the last transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // 2 events of the last transaction are added to the batch which makes
+    // that only one batch of 12 events is sent.
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 6;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertTrue("Batch was not redistributed",
+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, true, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 6;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+
+    // 6 transactions of 4 events each are sent so that the first batch
+    // would initially contain the first 2 transactions complete and the first
+    // 2 events of the next transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // 2 events of the second transaction are added to the batch which makes
+    // that the first batch is sent with 12 events. The same happens with the
+    // second batch which will contain 12 events too.
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);

Review comment:
       Use `GeodeAwaitility.await()` instead.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java
##########
@@ -239,6 +241,7 @@ public void testCreateDestroyGatewaySenderWithGatewayEventFilters() {
         + CliStrings.CREATE_GATEWAYSENDER__ALERTTHRESHOLD + "=100" + " --"
         + CliStrings.CREATE_GATEWAYSENDER__DISPATCHERTHREADS + "=2" + " --"
         + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + "=THREAD" + " --"
+        + CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS + "=false" + " --"

Review comment:
       Specifying the default value here is redundant.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java
##########
@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {
     assertThat(queue.isDREvent(cache, event)).isFalse();
   }
 
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()
+      throws Exception {
+
+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);
+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);
+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);
+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);
+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);
+
+    Queue backingList = new LinkedList();
+    backingList.add(event1);
+    backingList.add(event2);
+    backingList.add(event3);
+    backingList.add(event4);
+    backingList.add(event5);
+    backingList.add(event6);
+
+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);
+
+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,
+        Collections.emptySet(), 0, 1, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);
+
+    List peeked = queue.peek(3, 1000);

Review comment:
       Does the value of timeToWait here need to be so large? Unit tests should typically be expected to complete in milliseconds, so having an entire second timeout seems excessive. Also, is there a reason for this value of 1000 specifically being used? It seems arbitrary.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java
##########
@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {
     assertThat(queue.isDREvent(cache, event)).isFalse();
   }
 
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()
+      throws Exception {
+
+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);
+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);
+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);
+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);
+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);
+
+    Queue backingList = new LinkedList();
+    backingList.add(event1);
+    backingList.add(event2);
+    backingList.add(event3);
+    backingList.add(event4);
+    backingList.add(event5);
+    backingList.add(event6);
+
+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);
+
+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,
+        Collections.emptySet(), 0, 1, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()
+      throws Exception {
+
+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);
+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);
+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);
+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);
+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);
+
+    Queue backingList = new LinkedList();
+    backingList.add(event1);
+    backingList.add(event2);
+    backingList.add(event3);
+    backingList.add(null);
+    backingList.add(event4);
+    backingList.add(event5);
+    backingList.add(event6);
+
+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);
+
+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,
+        Collections.emptySet(), 0, 1, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);
+
+    List peeked = queue.peek(-1, 1);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(-1, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  @Test
+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()
+      throws Exception {
+
+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(2, false);
+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(1, true);
+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(2, true);
+
+    Queue backingList = new LinkedList();
+    backingList.add(event1);
+    backingList.add(event2);
+    backingList.add(event3);
+    backingList.add(event4);
+    backingList.add(event5);
+
+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);
+
+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,
+        Collections.emptySet(), 0, 1, metaRegionFactory);
+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);
+
+    List peeked = queue.peek(3, 1000);

Review comment:
       Another large, apparently arbitrary timeToWait value.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java
##########
@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {
 
   }
 
+  @Test
+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 10000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 2, true, false));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 30000;
+    boolean isGroupTransactionEvents = true;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+
+    // 4 transactions of 3 events each are sent so that the first batch
+    // would initially contain the first 3 transactions complete and the first
+    // event of the next transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // events of the third transaction are added to the batch which makes
+    // that the batch is sent with 12 events.
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 1, true));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0, true));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));

Review comment:
       Redundant cast to `Integer`.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java
##########
@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {
 
   }
 
+  @Test
+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 10000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 2, true, false));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 30000;
+    boolean isGroupTransactionEvents = true;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+
+    // 4 transactions of 3 events each are sent so that the first batch
+    // would initially contain the first 3 transactions complete and the first
+    // event of the next transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // events of the third transaction are added to the batch which makes
+    // that the batch is sent with 12 events.
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 1, true));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0, true));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 30000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 24;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 3, true, true));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()

Review comment:
       This test name could be more descriptive.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java
##########
@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache.wan.serial;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import org.apache.geode.CancelCriterion;
+import org.apache.geode.cache.AttributesFactory;
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.DataPolicy;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionAttributes;
+import org.apache.geode.cache.Scope;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.InternalRegionArguments;
+import org.apache.geode.internal.cache.InternalRegionFactory;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.TXId;
+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;
+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;
+import org.apache.geode.internal.cache.wan.GatewaySenderStats;
+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;
+import org.apache.geode.internal.statistics.StatisticsClock;
+import org.apache.geode.metrics.internal.NoopMeterRegistry;
+
+public class SerialGatewaySenderQueueJUnitTest {
+
+  private static final String TEST_REGION = "testRegion";
+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;
+  private GemFireCacheImpl cache;
+  private AbstractGatewaySender sender;
+  Region region;
+  InternalRegionFactory regionFactory;
+
+  @Before
+  public void setup() {
+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);
+    when(mockInternalDistributedSystem.getStatisticsManager())
+        .thenReturn(new DummyStatisticsRegistry("", 0));
+
+    cache = mock(GemFireCacheImpl.class);
+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);
+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());
+
+    region = createDistributedRegion(TEST_REGION, cache);
+
+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);
+    when(regionFactory.setInternalMetaRegion(any())
+        .setDestroyLockFlag(anyBoolean())
+        .setSnapshotInputStream(any())
+        .setImageTarget(any())
+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())
+        .setInternalRegion(anyBoolean())
+        .setSerialGatewaySender(any())).thenReturn(regionFactory);
+    when(regionFactory.create(TEST_REGION)).thenReturn(region);
+
+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);
+
+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);
+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);
+
+    sender = mock(AbstractGatewaySender.class);
+
+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);
+    when(sender.getCache()).thenReturn(cache);
+    when(sender.getMaximumQueueMemory()).thenReturn(100);
+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());
+    when(sender.getId()).thenReturn("");
+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));
+
+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);
+
+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =
+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);
+
+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()
+      throws Exception {
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);
+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);
+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);
+
+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,
+        TEST_REGION, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+
+    queue.put(event1);
+    queue.put(event2);
+    queue.put(event3);
+    queue.put(event4);
+    queue.put(event5);
+    queue.put(event6);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()
+      throws Exception {
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);
+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =
+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);
+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =
+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);
+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =
+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);
+
+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,
+        TEST_REGION, metaRegionFactory);
+
+    TestableSerialGatewaySenderQueue queue = spy(realQueue);
+    queue.setGroupTransactionEvents(true);
+
+    doAnswer(invocation -> eventPair1)
+        .doAnswer(invocation -> eventPair2)
+        .doAnswer(invocation -> eventPair3)
+        .doAnswer(invocation -> null)
+        .when(queue).peekAhead();
+
+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(
+        Arrays.asList(new Object[] {event4}), 2L))
+            .when(queue).getElementsMatching(any(), any(), anyLong());
+
+    List peeked = queue.peek(-1, 1);
+    assertEquals(4, peeked.size());
+  }
+
+  @Test
+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()
+      throws Exception {
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);
+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);
+
+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,
+        TEST_REGION, metaRegionFactory);
+
+    queue.put(event1);
+    queue.put(event2);
+    queue.put(event3);
+    queue.put(event4);
+    queue.put(event5);
+
+    List peeked = queue.peek(3, 1000);

Review comment:
       Another large, seemingly arbitrary timeToWait value.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java
##########
@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {
     assertThat(queue.isDREvent(cache, event)).isFalse();
   }
 
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()
+      throws Exception {
+
+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);
+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);
+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);
+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);
+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);
+
+    Queue backingList = new LinkedList();
+    backingList.add(event1);
+    backingList.add(event2);
+    backingList.add(event3);
+    backingList.add(event4);
+    backingList.add(event5);
+    backingList.add(event6);
+
+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);
+
+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,
+        Collections.emptySet(), 0, 1, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()
+      throws Exception {
+
+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);
+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);
+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);
+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);
+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);
+
+    Queue backingList = new LinkedList();
+    backingList.add(event1);
+    backingList.add(event2);
+    backingList.add(event3);
+    backingList.add(null);
+    backingList.add(event4);
+    backingList.add(event5);
+    backingList.add(event6);
+
+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);
+
+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,
+        Collections.emptySet(), 0, 1, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);
+
+    List peeked = queue.peek(-1, 1);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(-1, 1000);

Review comment:
       Another large, apparently arbitrary timeToWait value.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java
##########
@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache.wan.serial;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import org.apache.geode.CancelCriterion;
+import org.apache.geode.cache.AttributesFactory;
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.DataPolicy;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionAttributes;
+import org.apache.geode.cache.Scope;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.InternalRegionArguments;
+import org.apache.geode.internal.cache.InternalRegionFactory;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.TXId;
+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;
+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;
+import org.apache.geode.internal.cache.wan.GatewaySenderStats;
+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;
+import org.apache.geode.internal.statistics.StatisticsClock;
+import org.apache.geode.metrics.internal.NoopMeterRegistry;
+
+public class SerialGatewaySenderQueueJUnitTest {
+
+  private static final String TEST_REGION = "testRegion";
+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;
+  private GemFireCacheImpl cache;
+  private AbstractGatewaySender sender;
+  Region region;
+  InternalRegionFactory regionFactory;
+
+  @Before
+  public void setup() {
+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);
+    when(mockInternalDistributedSystem.getStatisticsManager())
+        .thenReturn(new DummyStatisticsRegistry("", 0));
+
+    cache = mock(GemFireCacheImpl.class);
+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);
+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());
+
+    region = createDistributedRegion(TEST_REGION, cache);
+
+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);
+    when(regionFactory.setInternalMetaRegion(any())
+        .setDestroyLockFlag(anyBoolean())
+        .setSnapshotInputStream(any())
+        .setImageTarget(any())
+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())
+        .setInternalRegion(anyBoolean())
+        .setSerialGatewaySender(any())).thenReturn(regionFactory);
+    when(regionFactory.create(TEST_REGION)).thenReturn(region);
+
+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);
+
+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);
+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);
+
+    sender = mock(AbstractGatewaySender.class);
+
+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);
+    when(sender.getCache()).thenReturn(cache);
+    when(sender.getMaximumQueueMemory()).thenReturn(100);
+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());
+    when(sender.getId()).thenReturn("");
+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));
+
+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);
+
+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =
+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);
+
+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()

Review comment:
       This test name could be more descriptive. Also, an exception is never thrown from this method, so the `throws` can be removed.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java
##########
@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache.wan.serial;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import org.apache.geode.CancelCriterion;
+import org.apache.geode.cache.AttributesFactory;
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.DataPolicy;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionAttributes;
+import org.apache.geode.cache.Scope;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.InternalRegionArguments;
+import org.apache.geode.internal.cache.InternalRegionFactory;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.TXId;
+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;
+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;
+import org.apache.geode.internal.cache.wan.GatewaySenderStats;
+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;
+import org.apache.geode.internal.statistics.StatisticsClock;
+import org.apache.geode.metrics.internal.NoopMeterRegistry;
+
+public class SerialGatewaySenderQueueJUnitTest {
+
+  private static final String TEST_REGION = "testRegion";
+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;
+  private GemFireCacheImpl cache;
+  private AbstractGatewaySender sender;
+  Region region;
+  InternalRegionFactory regionFactory;
+
+  @Before
+  public void setup() {
+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);
+    when(mockInternalDistributedSystem.getStatisticsManager())
+        .thenReturn(new DummyStatisticsRegistry("", 0));
+
+    cache = mock(GemFireCacheImpl.class);
+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);
+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());
+
+    region = createDistributedRegion(TEST_REGION, cache);
+
+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);
+    when(regionFactory.setInternalMetaRegion(any())
+        .setDestroyLockFlag(anyBoolean())
+        .setSnapshotInputStream(any())
+        .setImageTarget(any())
+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())
+        .setInternalRegion(anyBoolean())
+        .setSerialGatewaySender(any())).thenReturn(regionFactory);
+    when(regionFactory.create(TEST_REGION)).thenReturn(region);
+
+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);
+
+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);
+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);
+
+    sender = mock(AbstractGatewaySender.class);
+
+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);
+    when(sender.getCache()).thenReturn(cache);
+    when(sender.getMaximumQueueMemory()).thenReturn(100);
+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());
+    when(sender.getId()).thenReturn("");
+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));
+
+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);
+
+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =
+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);
+
+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()
+      throws Exception {
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);
+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);
+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);
+
+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,
+        TEST_REGION, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+
+    queue.put(event1);
+    queue.put(event2);
+    queue.put(event3);
+    queue.put(event4);
+    queue.put(event5);
+    queue.put(event6);
+
+    List peeked = queue.peek(3, 1000);

Review comment:
       Does the value of timeToWait here need to be so large? Unit tests should typically be expected to complete in milliseconds, so having an entire second timeout seems excessive. Also, is there a reason for this value of 1000 specifically being used? It seems arbitrary.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java
##########
@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {
     assertThat(queue.isDREvent(cache, event)).isFalse();
   }
 
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()
+      throws Exception {
+
+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);
+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);
+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);
+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);
+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);
+
+    Queue backingList = new LinkedList();
+    backingList.add(event1);
+    backingList.add(event2);
+    backingList.add(event3);
+    backingList.add(event4);
+    backingList.add(event5);
+    backingList.add(event6);
+
+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);
+
+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,
+        Collections.emptySet(), 0, 1, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()
+      throws Exception {
+
+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);
+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);
+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);
+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);
+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);
+
+    Queue backingList = new LinkedList();
+    backingList.add(event1);
+    backingList.add(event2);
+    backingList.add(event3);
+    backingList.add(null);
+    backingList.add(event4);
+    backingList.add(event5);
+    backingList.add(event6);
+
+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);
+
+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,
+        Collections.emptySet(), 0, 1, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);
+
+    List peeked = queue.peek(-1, 1);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(-1, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  @Test
+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()
+      throws Exception {
+
+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(2, false);
+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(1, true);
+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(2, true);
+
+    Queue backingList = new LinkedList();
+    backingList.add(event1);
+    backingList.add(event2);
+    backingList.add(event3);
+    backingList.add(event4);
+    backingList.add(event5);
+
+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);
+
+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,
+        Collections.emptySet(), 0, 1, metaRegionFactory);
+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(3, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);

Review comment:
       Another large, apparently arbitrary timeToWait value.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
 
     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));
   }
 
+  @Test
+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));

Review comment:
       Redundant case to `Integer`.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java
##########
@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {
 
   }
 
+  @Test
+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 10000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 2, true, false));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));

Review comment:
       Redundant cast to `Integer`.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java
##########
@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache.wan.serial;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import org.apache.geode.CancelCriterion;
+import org.apache.geode.cache.AttributesFactory;
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.DataPolicy;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionAttributes;
+import org.apache.geode.cache.Scope;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.InternalRegionArguments;
+import org.apache.geode.internal.cache.InternalRegionFactory;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.TXId;
+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;
+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;
+import org.apache.geode.internal.cache.wan.GatewaySenderStats;
+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;
+import org.apache.geode.internal.statistics.StatisticsClock;
+import org.apache.geode.metrics.internal.NoopMeterRegistry;
+
+public class SerialGatewaySenderQueueJUnitTest {
+
+  private static final String TEST_REGION = "testRegion";
+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;
+  private GemFireCacheImpl cache;
+  private AbstractGatewaySender sender;
+  Region region;
+  InternalRegionFactory regionFactory;
+
+  @Before
+  public void setup() {
+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);
+    when(mockInternalDistributedSystem.getStatisticsManager())
+        .thenReturn(new DummyStatisticsRegistry("", 0));
+
+    cache = mock(GemFireCacheImpl.class);
+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);
+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());
+
+    region = createDistributedRegion(TEST_REGION, cache);
+
+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);
+    when(regionFactory.setInternalMetaRegion(any())
+        .setDestroyLockFlag(anyBoolean())
+        .setSnapshotInputStream(any())
+        .setImageTarget(any())
+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())
+        .setInternalRegion(anyBoolean())
+        .setSerialGatewaySender(any())).thenReturn(regionFactory);
+    when(regionFactory.create(TEST_REGION)).thenReturn(region);
+
+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);
+
+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);
+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);
+
+    sender = mock(AbstractGatewaySender.class);
+
+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);
+    when(sender.getCache()).thenReturn(cache);
+    when(sender.getMaximumQueueMemory()).thenReturn(100);
+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());
+    when(sender.getId()).thenReturn("");
+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));
+
+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);
+
+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =
+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);
+
+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()
+      throws Exception {
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);
+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);
+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);
+
+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,
+        TEST_REGION, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+
+    queue.put(event1);
+    queue.put(event2);
+    queue.put(event3);
+    queue.put(event4);
+    queue.put(event5);
+    queue.put(event6);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()
+      throws Exception {
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);
+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =
+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);
+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =
+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);
+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =
+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);
+
+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,
+        TEST_REGION, metaRegionFactory);
+
+    TestableSerialGatewaySenderQueue queue = spy(realQueue);
+    queue.setGroupTransactionEvents(true);
+
+    doAnswer(invocation -> eventPair1)
+        .doAnswer(invocation -> eventPair2)
+        .doAnswer(invocation -> eventPair3)
+        .doAnswer(invocation -> null)
+        .when(queue).peekAhead();
+
+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(
+        Arrays.asList(new Object[] {event4}), 2L))
+            .when(queue).getElementsMatching(any(), any(), anyLong());
+
+    List peeked = queue.peek(-1, 1);
+    assertEquals(4, peeked.size());
+  }
+
+  @Test
+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()

Review comment:
       This test name could be more descriptive. Also, an exception is never thrown from this method, so the `throws` can be removed.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java
##########
@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {
 
   }
 
+  @Test
+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 10000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);

Review comment:
       This method is deprecated and so should not be used. `GeodeAwaitility.await()` should be used when tests need to wait for some condition to be met before continuing.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java
##########
@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {
 
   }
 
+  @Test
+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 10000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 2, true, false));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 30000;
+    boolean isGroupTransactionEvents = true;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+
+    // 4 transactions of 3 events each are sent so that the first batch
+    // would initially contain the first 3 transactions complete and the first
+    // event of the next transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // events of the third transaction are added to the batch which makes
+    // that the batch is sent with 12 events.
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 1, true));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0, true));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 30000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 24;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 3, true, true));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 10000;
+    boolean isGroupTransactionEvents = true;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 24;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+
+    // 8 transactions of 3 events each are sent so that the first batch
+    // events would initially contain the first 3 transactions complete and the first
+    // event of the next transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // event of the third transaction is added to the batch which makes
+    // that the first batch is sent with 12 events. The same happens with the
+    // second batch which will contain 12 events too.
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);

Review comment:
       Deprecated method.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java
##########
@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache.wan.serial;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import org.apache.geode.CancelCriterion;
+import org.apache.geode.cache.AttributesFactory;
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.DataPolicy;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionAttributes;
+import org.apache.geode.cache.Scope;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.InternalRegionArguments;
+import org.apache.geode.internal.cache.InternalRegionFactory;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.TXId;
+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;
+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;
+import org.apache.geode.internal.cache.wan.GatewaySenderStats;
+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;
+import org.apache.geode.internal.statistics.StatisticsClock;
+import org.apache.geode.metrics.internal.NoopMeterRegistry;
+
+public class SerialGatewaySenderQueueJUnitTest {
+
+  private static final String TEST_REGION = "testRegion";
+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;
+  private GemFireCacheImpl cache;
+  private AbstractGatewaySender sender;
+  Region region;
+  InternalRegionFactory regionFactory;
+
+  @Before
+  public void setup() {
+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);
+    when(mockInternalDistributedSystem.getStatisticsManager())
+        .thenReturn(new DummyStatisticsRegistry("", 0));
+
+    cache = mock(GemFireCacheImpl.class);
+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);
+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());
+
+    region = createDistributedRegion(TEST_REGION, cache);
+
+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);
+    when(regionFactory.setInternalMetaRegion(any())
+        .setDestroyLockFlag(anyBoolean())
+        .setSnapshotInputStream(any())
+        .setImageTarget(any())
+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())
+        .setInternalRegion(anyBoolean())
+        .setSerialGatewaySender(any())).thenReturn(regionFactory);
+    when(regionFactory.create(TEST_REGION)).thenReturn(region);
+
+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);
+
+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);
+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);
+
+    sender = mock(AbstractGatewaySender.class);
+
+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);
+    when(sender.getCache()).thenReturn(cache);
+    when(sender.getMaximumQueueMemory()).thenReturn(100);
+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());
+    when(sender.getId()).thenReturn("");
+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));
+
+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);
+
+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =
+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);
+
+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()
+      throws Exception {
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);
+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);
+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);
+
+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,
+        TEST_REGION, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+
+    queue.put(event1);
+    queue.put(event2);
+    queue.put(event3);
+    queue.put(event4);
+    queue.put(event5);
+    queue.put(event6);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()
+      throws Exception {
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);
+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =
+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);
+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =
+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);
+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =
+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);
+
+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,
+        TEST_REGION, metaRegionFactory);
+
+    TestableSerialGatewaySenderQueue queue = spy(realQueue);
+    queue.setGroupTransactionEvents(true);
+
+    doAnswer(invocation -> eventPair1)
+        .doAnswer(invocation -> eventPair2)
+        .doAnswer(invocation -> eventPair3)
+        .doAnswer(invocation -> null)
+        .when(queue).peekAhead();
+
+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(
+        Arrays.asList(new Object[] {event4}), 2L))
+            .when(queue).getElementsMatching(any(), any(), anyLong());
+
+    List peeked = queue.peek(-1, 1);
+    assertEquals(4, peeked.size());
+  }
+
+  @Test
+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()
+      throws Exception {
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);
+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);
+
+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,
+        TEST_REGION, metaRegionFactory);
+
+    queue.put(event1);
+    queue.put(event2);
+    queue.put(event3);
+    queue.put(event4);
+    queue.put(event5);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(3, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);

Review comment:
       Another large, seemingly arbitrary timeToWait value.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java
##########
@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache.wan.serial;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import org.apache.geode.CancelCriterion;
+import org.apache.geode.cache.AttributesFactory;
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.DataPolicy;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionAttributes;
+import org.apache.geode.cache.Scope;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.InternalRegionArguments;
+import org.apache.geode.internal.cache.InternalRegionFactory;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.TXId;
+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;
+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;
+import org.apache.geode.internal.cache.wan.GatewaySenderStats;
+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;
+import org.apache.geode.internal.statistics.StatisticsClock;
+import org.apache.geode.metrics.internal.NoopMeterRegistry;
+
+public class SerialGatewaySenderQueueJUnitTest {
+
+  private static final String TEST_REGION = "testRegion";
+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;
+  private GemFireCacheImpl cache;
+  private AbstractGatewaySender sender;
+  Region region;
+  InternalRegionFactory regionFactory;
+
+  @Before
+  public void setup() {
+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);
+    when(mockInternalDistributedSystem.getStatisticsManager())
+        .thenReturn(new DummyStatisticsRegistry("", 0));
+
+    cache = mock(GemFireCacheImpl.class);
+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);
+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());
+
+    region = createDistributedRegion(TEST_REGION, cache);
+
+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);
+    when(regionFactory.setInternalMetaRegion(any())
+        .setDestroyLockFlag(anyBoolean())
+        .setSnapshotInputStream(any())
+        .setImageTarget(any())
+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())
+        .setInternalRegion(anyBoolean())
+        .setSerialGatewaySender(any())).thenReturn(regionFactory);
+    when(regionFactory.create(TEST_REGION)).thenReturn(region);
+
+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);
+
+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);
+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);
+
+    sender = mock(AbstractGatewaySender.class);
+
+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);
+    when(sender.getCache()).thenReturn(cache);
+    when(sender.getMaximumQueueMemory()).thenReturn(100);
+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());
+    when(sender.getId()).thenReturn("");
+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));
+
+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);
+
+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =
+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);
+
+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()
+      throws Exception {
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);
+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);
+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);
+
+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,
+        TEST_REGION, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+
+    queue.put(event1);
+    queue.put(event2);
+    queue.put(event3);
+    queue.put(event4);
+    queue.put(event5);
+    queue.put(event6);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()
+      throws Exception {
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);
+    SerialGatewaySenderQueue.KeyAndEventPair eventPair1 =
+        new SerialGatewaySenderQueue.KeyAndEventPair(0L, event1);
+    SerialGatewaySenderQueue.KeyAndEventPair eventPair2 =
+        new SerialGatewaySenderQueue.KeyAndEventPair(1L, event2);
+    SerialGatewaySenderQueue.KeyAndEventPair eventPair3 =
+        new SerialGatewaySenderQueue.KeyAndEventPair(2L, event3);
+
+    TestableSerialGatewaySenderQueue realQueue = new TestableSerialGatewaySenderQueue(sender,
+        TEST_REGION, metaRegionFactory);
+
+    TestableSerialGatewaySenderQueue queue = spy(realQueue);
+    queue.setGroupTransactionEvents(true);
+
+    doAnswer(invocation -> eventPair1)
+        .doAnswer(invocation -> eventPair2)
+        .doAnswer(invocation -> eventPair3)
+        .doAnswer(invocation -> null)
+        .when(queue).peekAhead();
+
+    doAnswer(invocation -> new SerialGatewaySenderQueue.EventsAndLastKey(
+        Arrays.asList(new Object[] {event4}), 2L))
+            .when(queue).getElementsMatching(any(), any(), anyLong());
+
+    List peeked = queue.peek(-1, 1);
+    assertEquals(4, peeked.size());
+  }
+
+  @Test
+  public void peekedMaxEventsWhenNotIsGroupTransactionEvents()
+      throws Exception {
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(2, false, region);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(1, true, region);
+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(2, true, region);
+
+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,
+        TEST_REGION, metaRegionFactory);
+
+    queue.put(event1);
+    queue.put(event2);
+    queue.put(event3);
+    queue.put(event4);
+    queue.put(event5);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(3, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  private static GatewaySenderEventImpl createMockGatewaySenderEventImpl(int transactionId,
+      boolean isLastEventInTransaction, Region region) {
+    GatewaySenderEventImpl event = mock(GatewaySenderEventImpl.class);
+    when(event.getTransactionId()).thenReturn(new TXId(null, transactionId));
+    when(event.makeHeapCopyIfOffHeap()).thenReturn(event);
+    when(event.isLastEventInTransaction()).thenReturn(isLastEventInTransaction);
+    when(event.getRegion()).thenReturn(region);
+    return event;
+  }
+
+  private Region createDistributedRegion(String regionName, Cache cache) {
+    AttributesFactory factory = new AttributesFactory();
+    factory.setScope(Scope.DISTRIBUTED_ACK);
+    factory.setDataPolicy(DataPolicy.NORMAL);
+    RegionAttributes attrs = factory.create();
+    InternalRegionArguments internalRegionArgs = new InternalRegionArguments();
+    return new TestLocalRegion(regionName, attrs, null, (InternalCache) cache, internalRegionArgs,
+        new TestStatisticsClock());
+  }
+
+  public class TestLocalRegion extends LocalRegion {
+    Map map = new ConcurrentHashMap();
+
+    public TestLocalRegion(String regionName, RegionAttributes attrs,
+        LocalRegion parentRegion, InternalCache cache,
+        InternalRegionArguments internalRegionArgs,
+        StatisticsClock statisticsClock) {
+      super(regionName, attrs, parentRegion, cache, internalRegionArgs, statisticsClock);

Review comment:
       Is there a way to test the new behaviour in `SerialGatewaySenderQueue` without creating an entire `LocalRegion` object here? Huge amounts of code that doesn't belong to `SerialGatewaySenderQueue` are being included in this test due to creating a real `LocalRegion`. If not, then this test should be an integration test rather than a unit test.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java
##########
@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {
 
   }
 
+  @Test
+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 10000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 2, true, false));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 30000;
+    boolean isGroupTransactionEvents = true;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+
+    // 4 transactions of 3 events each are sent so that the first batch
+    // would initially contain the first 3 transactions complete and the first
+    // event of the next transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // events of the third transaction are added to the batch which makes
+    // that the batch is sent with 12 events.
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);

Review comment:
       Deprecated method.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/serial/SerialGatewaySenderQueueJUnitTest.java
##########
@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache.wan.serial;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import org.apache.geode.CancelCriterion;
+import org.apache.geode.cache.AttributesFactory;
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.DataPolicy;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionAttributes;
+import org.apache.geode.cache.Scope;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.InternalRegionArguments;
+import org.apache.geode.internal.cache.InternalRegionFactory;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.TXId;
+import org.apache.geode.internal.cache.wan.AbstractGatewaySender;
+import org.apache.geode.internal.cache.wan.GatewaySenderEventImpl;
+import org.apache.geode.internal.cache.wan.GatewaySenderStats;
+import org.apache.geode.internal.statistics.DummyStatisticsRegistry;
+import org.apache.geode.internal.statistics.StatisticsClock;
+import org.apache.geode.metrics.internal.NoopMeterRegistry;
+
+public class SerialGatewaySenderQueueJUnitTest {
+
+  private static final String TEST_REGION = "testRegion";
+  private SerialGatewaySenderQueue.MetaRegionFactory metaRegionFactory;
+  private GemFireCacheImpl cache;
+  private AbstractGatewaySender sender;
+  Region region;
+  InternalRegionFactory regionFactory;
+
+  @Before
+  public void setup() {
+    InternalDistributedSystem mockInternalDistributedSystem = mock(InternalDistributedSystem.class);
+    when(mockInternalDistributedSystem.getStatisticsManager())
+        .thenReturn(new DummyStatisticsRegistry("", 0));
+
+    cache = mock(GemFireCacheImpl.class);
+    when(cache.getInternalDistributedSystem()).thenReturn(mockInternalDistributedSystem);
+    when(cache.getMeterRegistry()).thenReturn(new NoopMeterRegistry());
+
+    region = createDistributedRegion(TEST_REGION, cache);
+
+    regionFactory = mock(InternalRegionFactory.class, RETURNS_DEEP_STUBS);
+    when(regionFactory.setInternalMetaRegion(any())
+        .setDestroyLockFlag(anyBoolean())
+        .setSnapshotInputStream(any())
+        .setImageTarget(any())
+        .setIsUsedForSerialGatewaySenderQueue(anyBoolean())
+        .setInternalRegion(anyBoolean())
+        .setSerialGatewaySender(any())).thenReturn(regionFactory);
+    when(regionFactory.create(TEST_REGION)).thenReturn(region);
+
+    when(cache.createInternalRegionFactory(any())).thenReturn(regionFactory);
+
+    CancelCriterion cancelCriterion = mock(CancelCriterion.class);
+    when(cache.getCancelCriterion()).thenReturn(cancelCriterion);
+
+    sender = mock(AbstractGatewaySender.class);
+
+    when(sender.getCancelCriterion()).thenReturn(cancelCriterion);
+    when(sender.getCache()).thenReturn(cache);
+    when(sender.getMaximumQueueMemory()).thenReturn(100);
+    when(sender.getLifeCycleLock()).thenReturn(new ReentrantReadWriteLock());
+    when(sender.getId()).thenReturn("");
+    when(sender.getStatistics()).thenReturn(mock(GatewaySenderStats.class));
+
+    metaRegionFactory = mock(SerialGatewaySenderQueue.MetaRegionFactory.class);
+
+    SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion mockMetaRegion =
+        mock(SerialGatewaySenderQueue.SerialGatewaySenderQueueMetaRegion.class);
+
+    when(metaRegionFactory.newMetaRegion(any(), any(), any(), any())).thenReturn(mockMetaRegion);
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()
+      throws Exception {
+    GatewaySenderEventImpl event1 = createMockGatewaySenderEventImpl(1, false, region);
+    GatewaySenderEventImpl event2 = createMockGatewaySenderEventImpl(2, false, region);
+    GatewaySenderEventImpl event3 = createMockGatewaySenderEventImpl(1, true, region);
+    GatewaySenderEventImpl event4 = createMockGatewaySenderEventImpl(2, true, region);
+    GatewaySenderEventImpl event5 = createMockGatewaySenderEventImpl(3, false, region);
+    GatewaySenderEventImpl event6 = createMockGatewaySenderEventImpl(3, true, region);
+
+    TestableSerialGatewaySenderQueue queue = new TestableSerialGatewaySenderQueue(sender,
+        TEST_REGION, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+
+    queue.put(event1);
+    queue.put(event2);
+    queue.put(event3);
+    queue.put(event4);
+    queue.put(event5);
+    queue.put(event6);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEventsTimeout()

Review comment:
       This test name could be more descriptive. Also, an exception is never thrown from this method, so the `throws` can be removed.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java
##########
@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {
 
   }
 
+  @Test
+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {

Review comment:
       This test name could be more descriptive. Also an Exception is never thrown from this method, so the `throws` can be removed.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java
##########
@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {
 
   }
 
+  @Test
+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 10000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 2, true, false));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 30000;
+    boolean isGroupTransactionEvents = true;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+
+    // 4 transactions of 3 events each are sent so that the first batch
+    // would initially contain the first 3 transactions complete and the first
+    // event of the next transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // events of the third transaction are added to the batch which makes
+    // that the batch is sent with 12 events.
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 1, true));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0, true));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 30000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 24;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 3, true, true));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 10000;
+    boolean isGroupTransactionEvents = true;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 24;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+
+    // 8 transactions of 3 events each are sent so that the first batch
+    // events would initially contain the first 3 transactions complete and the first
+    // event of the next transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // event of the third transaction is added to the batch which makes
+    // that the first batch is sent with 12 events. The same happens with the
+    // second batch which will contain 12 events too.
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);

Review comment:
       Use `GeodeAwaitility.await()` instead.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java
##########
@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {
 
   }
 
+  @Test
+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 10000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 2, true, false));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 30000;
+    boolean isGroupTransactionEvents = true;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+
+    // 4 transactions of 3 events each are sent so that the first batch
+    // would initially contain the first 3 transactions complete and the first
+    // event of the next transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // events of the third transaction are added to the batch which makes
+    // that the batch is sent with 12 events.
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 1, true));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0, true));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 30000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 24;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);

Review comment:
       Deprecated method.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java
##########
@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {
 
   }
 
+  @Test
+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 10000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 2, true, false));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 30000;
+    boolean isGroupTransactionEvents = true;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+
+    // 4 transactions of 3 events each are sent so that the first batch
+    // would initially contain the first 3 transactions complete and the first
+    // event of the next transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // events of the third transaction are added to the batch which makes
+    // that the batch is sent with 12 events.
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 1, true));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0, true));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()

Review comment:
       This test name could be more descriptive.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/wancommand/CreateDestroyGatewaySenderCommandDUnitTest.java
##########
@@ -155,7 +155,8 @@ public void testCreateDestroyGatewaySender() {
         + CliStrings.CREATE_GATEWAYSENDER__MAXQUEUEMEMORY + "=1000" + " --"
         + CliStrings.CREATE_GATEWAYSENDER__ALERTTHRESHOLD + "=100" + " --"
         + CliStrings.CREATE_GATEWAYSENDER__DISPATCHERTHREADS + "=2" + " --"
-        + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + "=THREAD";
+        + CliStrings.CREATE_GATEWAYSENDER__ORDERPOLICY + "=THREAD" + " --"
+        + CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS + "=false";

Review comment:
       Since the default unspecified value of group-transaction-events is false, does it need to be specified in the gfsh command here?

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -102,15 +108,18 @@ public void testQueueSizeInSecondaryBucketRegionQueuesWithMemberRestart() throws
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", NUM_PUTS));
 
     assertEquals(NUM_PUTS, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue
-                                                                                           // size
-    assertEquals(NUM_PUTS * 2, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
-    assertEquals(NUM_PUTS * 2, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                               // queued
+    // size
+    assertEquals(NUM_PUTS * 2,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS * 2,
+        v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
     assertEquals(0, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                    // distributed
-    assertEquals(NUM_PUTS, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary
-                                                                                               // queue
-                                                                                               // size
+    // distributed
+    assertEquals(NUM_PUTS,
+        v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary
+    // queue
+    // size

Review comment:
       Can these comments be cleaned up a bit?

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -137,7 +146,8 @@ public void testQueueSizeInSecondaryBucketRegionQueuesWithMemberRestart() throws
     v5List = (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", NUM_PUTS));
     v6List = (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", NUM_PUTS));
     v7List = (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", NUM_PUTS));
-    assertEquals(NUM_PUTS, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary
+    assertEquals(NUM_PUTS,
+        v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary

Review comment:
       More untidy comments.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java
##########
@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {
 
   }
 
+  @Test
+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 10000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 2, true, false));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {

Review comment:
       This test name could be more descriptive. Also an Exception is never thrown from this method, so the `throws` can be removed.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -219,10 +232,10 @@ public void testQueueSizeInSecondaryWithPrimarySwitch() throws Exception {
     v7List = (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertEquals(0, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary
-                                                                                        // queue
-                                                                                        // size
+    // queue
+    // size

Review comment:
       More untidy comments.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -194,15 +204,18 @@ public void testQueueSizeInSecondaryWithPrimarySwitch() throws Exception {
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", NUM_PUTS));
 
     assertEquals(NUM_PUTS, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue
-                                                                                           // size
-    assertEquals(NUM_PUTS * 2, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
-    assertEquals(NUM_PUTS * 2, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                               // queued
+    // size
+    assertEquals(NUM_PUTS * 2,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS * 2,
+        v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
     assertEquals(0, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                    // distributed
-    assertEquals(NUM_PUTS, v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary
-                                                                                               // queue
-                                                                                               // size
+    // distributed
+    assertEquals(NUM_PUTS,
+        v4List.get(10) + v5List.get(10) + v6List.get(10) + v7List.get(10)); // secondary
+    // queue
+    // size

Review comment:
       More untidy comments.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/serial/SerialWANStatsDUnitTest.java
##########
@@ -86,6 +86,265 @@ public void testReplicatedSerialPropagation() throws Exception {
 
   }
 
+  @Test
+  public void testReplicatedSerialPropagationTransactionNoGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 10000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(2, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 2, true, false));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionGroupTransactions() throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 30000;
+    boolean isGroupTransactionEvents = true;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 12;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+
+    // 4 transactions of 3 events each are sent so that the first batch
+    // would initially contain the first 3 transactions complete and the first
+    // event of the next transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // events of the third transaction are added to the batch which makes
+    // that the batch is sent with 12 events.
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(1, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 1, true));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0, true));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionBatchRedistributedNoGroupTransactions()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+
+    createCacheInVMs(lnPort, vm4, vm5, vm6, vm7);
+
+    int batchTimeInterval = 30000;
+    boolean isGroupTransactionEvents = false;
+    vm4.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm5.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm6.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+    vm7.invoke(
+        () -> WANTestBase.createSender("ln", 2, false, 100, 10, false, false, null, true,
+            isGroupTransactionEvents,
+            batchTimeInterval));
+
+    vm2.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", null, isOffHeap()));
+
+    startSenderInVMs("ln", vm4, vm5);
+
+    vm4.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm5.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm6.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+    vm7.invoke(() -> WANTestBase.createReplicatedRegion(testName + "_RR", "ln", isOffHeap()));
+
+    final Map keyValues = new HashMap();
+    int entries = 24;
+    for (int i = 0; i < entries; i++) {
+      keyValues.put(i, i + "_Value");
+    }
+    int eventsPerTransaction = 3;
+    vm5.invoke(() -> WANTestBase.doPutsInsideTransactions(testName + "_RR", keyValues,
+        eventsPerTransaction));
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);
+    vm2.invoke(() -> WANTestBase.createReceiver());
+
+    vm2.invoke(() -> WANTestBase.validateRegionSize(testName + "_RR", entries));
+
+    pause(2000);
+    vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(3, entries, entries, true));
+
+    vm4.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, entries, entries));
+    vm4.invoke(() -> WANTestBase.checkBatchStats("ln", 3, true, true));
+
+    vm5.invoke(() -> WANTestBase.checkQueueStats("ln", 0, entries, 0, 0));
+    vm5.invoke(() -> WANTestBase.checkBatchStats("ln", 0));
+  }
+
+  @Test
+  public void testReplicatedSerialPropagationTransactionBatchRedistributedGroupTransactions()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));

Review comment:
       Redundant cast to `Integer`.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
 
     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));
   }
 
+  @Test
+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, true, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+
+    // 3 transactions of 4 events each are sent so that the batch would
+    // initially contain the first 2 transactions complete and the first
+    // 2 events of the last transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // 2 events of the last transaction are added to the batch which makes
+    // that only one batch of 12 events is sent.
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 6;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertTrue("Batch was not redistributed",
+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));

Review comment:
       Redundant cast to `Integer`.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
 
     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));
   }
 
+  @Test
+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, true, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+
+    // 3 transactions of 4 events each are sent so that the batch would
+    // initially contain the first 2 transactions complete and the first
+    // 2 events of the last transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // 2 events of the last transaction are added to the batch which makes
+    // that only one batch of 12 events is sent.
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()

Review comment:
       This test name could be more descriptive.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -254,16 +267,17 @@ public void testPartitionedRegionParallelPropagation_BeforeDispatch() throws Exc
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", NUM_PUTS));
 
     assertEquals(NUM_PUTS, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue
-                                                                                           // size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    // size
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(0, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                    // distributed
+    // distributed
     assertEquals(0, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
-                                                                                    // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed

Review comment:
       More untidy comments.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
 
     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));
   }
 
+  @Test
+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, true, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+
+    // 3 transactions of 4 events each are sent so that the batch would
+    // initially contain the first 2 transactions complete and the first
+    // 2 events of the last transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // 2 events of the last transaction are added to the batch which makes
+    // that only one batch of 12 events is sent.
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 6;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertTrue("Batch was not redistributed",
+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches
+    // redistributed

Review comment:
       More untidy comments.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
 
     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));
   }
 
+  @Test
+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()

Review comment:
       This test name could be more descriptive. Also, the `throws` is not necessary.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed

Review comment:
       More untidy comments.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
 
     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));
   }
 
+  @Test
+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, true, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+
+    // 3 transactions of 4 events each are sent so that the batch would
+    // initially contain the first 2 transactions complete and the first
+    // 2 events of the last transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // 2 events of the last transaction are added to the batch which makes
+    // that only one batch of 12 events is sent.
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 6;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertTrue("Batch was not redistributed",
+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, true, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 6;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+
+    // 6 transactions of 4 events each are sent so that the first batch
+    // would initially contain the first 2 transactions complete and the first
+    // 2 events of the next transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // 2 events of the second transaction are added to the batch which makes
+    // that the first batch is sent with 12 events. The same happens with the
+    // second batch which will contain 12 events too.
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);
+    createReceiverInVMs(vm2);
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertTrue("Batch was not redistributed",
+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches
+    // redistributed

Review comment:
       More untidy comments.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
 
     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));
   }
 
+  @Test
+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));

Review comment:
       Redundant cast to `Integer`.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
 
     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));
   }
 
+  @Test
+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, true, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+
+    // 3 transactions of 4 events each are sent so that the batch would
+    // initially contain the first 2 transactions complete and the first
+    // 2 events of the last transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // 2 events of the last transaction are added to the batch which makes
+    // that only one batch of 12 events is sent.
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed

Review comment:
       More untidy comments.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
 
     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));
   }
 
+  @Test
+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, true, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+
+    // 3 transactions of 4 events each are sent so that the batch would
+    // initially contain the first 2 transactions complete and the first
+    // 2 events of the last transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // 2 events of the last transaction are added to the batch which makes
+    // that only one batch of 12 events is sent.
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));

Review comment:
       Redundant cast to `Integer`.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -559,17 +868,18 @@ public void testParallelPropagationWithFilter() throws Exception {
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(1000, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(1000,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(900, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                      // queued
+    // queued
     assertEquals(800, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                      // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 80); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
     assertEquals(200, v4List.get(6) + v5List.get(6) + v6List.get(6) + v7List.get(6)); // events
-                                                                                      // filtered
+    // filtered

Review comment:
       More untidy comments.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
 
     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));
   }
 
+  @Test
+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed

Review comment:
       More untidy comments.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
 
     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));
   }
 
+  @Test
+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, true, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+
+    // 3 transactions of 4 events each are sent so that the batch would
+    // initially contain the first 2 transactions complete and the first
+    // 2 events of the last transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // 2 events of the last transaction are added to the batch which makes
+    // that only one batch of 12 events is sent.
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 6;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertTrue("Batch was not redistributed",
+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()

Review comment:
       This test name could be more descriptive.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
 
     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));
   }
 
+  @Test
+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, true, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+
+    // 3 transactions of 4 events each are sent so that the batch would
+    // initially contain the first 2 transactions complete and the first
+    // 2 events of the last transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // 2 events of the last transaction are added to the batch which makes
+    // that only one batch of 12 events is sent.
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 6;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);

Review comment:
       Use `GeodeAwaitlity.await()` instead.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -343,15 +653,16 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_Redundancy_3(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(400, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(400,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(400, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                      // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed

Review comment:
       More untidy comments.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


DonalEvans commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r422349973



##########
File path: geode-core/src/main/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtils.java
##########
@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.ServiceConfigurationError;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.wan.GatewaySender;
+import org.apache.geode.logging.internal.log4j.api.LogService;
+
+public class TXLastEventInTransactionUtils {
+  private static final Logger logger = LogService.getLogger();
+
+  /**
+   * @param callbacks list of events belonging to a transaction
+   *
+   * @return the last event of the transaction.
+   *         If the regions to which the events belong do not have senders
+   *         that group transactions it returns null.
+   *         If the regions to which the
+   *         events belong have different sets of senders that group transactions
+   *         then it throws a ServiceConfigurationError exception.
+   */
+  public static EntryEventImpl getLastTransactionEvent(List<EntryEventImpl> callbacks,
+      Cache cache)
+      throws ServiceConfigurationError {
+    if (checkNoSendersGroupTransactionEvents(callbacks, cache)) {
+      return null;
+    }
+
+    List<Set> senderIdsPerEvent = getGroupingSendersPerEvent(callbacks, cache);
+    if (senderIdsPerEvent.stream().distinct().count() > 1) {
+      String info = eventsAndSendersPerEventToString(callbacks, senderIdsPerEvent);
+      throw new ServiceConfigurationError(
+          "Not all events go to the same senders that group transactions. " + info);
+    } ;

Review comment:
       Unnecessary semicolon here.

##########
File path: geode-core/src/test/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueueJUnitTest.java
##########
@@ -186,6 +188,109 @@ public void isDREventReturnsFalseForPartitionedRegionEvent() {
     assertThat(queue.isDREvent(cache, event)).isFalse();
   }
 
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEvents()
+      throws Exception {
+
+    GatewaySenderEventImpl event1 = createGatewaySenderEventImpl(1, false);
+    GatewaySenderEventImpl event2 = createGatewaySenderEventImpl(2, false);
+    GatewaySenderEventImpl event3 = createGatewaySenderEventImpl(1, true);
+    GatewaySenderEventImpl event4 = createGatewaySenderEventImpl(2, true);
+    GatewaySenderEventImpl event5 = createGatewaySenderEventImpl(3, false);
+    GatewaySenderEventImpl event6 = createGatewaySenderEventImpl(3, true);
+
+    Queue backingList = new LinkedList();
+    backingList.add(event1);
+    backingList.add(event2);
+    backingList.add(event3);
+    backingList.add(event4);
+    backingList.add(event5);
+    backingList.add(event6);
+
+    BucketRegionQueue bucketRegionQueue = mockBucketRegionQueue(backingList);
+
+    TestableParallelGatewaySenderQueue queue = new TestableParallelGatewaySenderQueue(sender,
+        Collections.emptySet(), 0, 1, metaRegionFactory);
+    queue.setGroupTransactionEvents(true);
+    queue.setMockedAbstractBucketRegionQueue(bucketRegionQueue);
+
+    List peeked = queue.peek(3, 1000);
+    assertEquals(4, peeked.size());
+    List peekedAfter = queue.peek(3, 1000);
+    assertEquals(2, peekedAfter.size());
+  }
+
+  @Test
+  public void peekedExtraEventsWhenIsGroupTransactionEventsAndTimeout()

Review comment:
       This test name could be more descriptive.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


DonalEvans commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r422427262



##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
 
     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));
   }
 
+  @Test
+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()

Review comment:
       This test name could be more descriptive. Also, the `throws` is not needed.

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -503,17 +815,16 @@ public void testParallelPropagationWithRemoteRegionDestroy() throws Exception {
     ArrayList<Integer> v7List =
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", -1));
 
-
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 1); // batches
-                                                                                    // distributed :
-                                                                                    // its quite
-                                                                                    // possible that
-                                                                                    // vm4 has
-                                                                                    // distributed
-                                                                                    // some of the
-                                                                                    // batches.
+    // distributed :
+    // its quite
+    // possible that
+    // vm4 has
+    // distributed
+    // some of the
+    // batches.
     assertTrue(v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5) >= 1); // batches
-                                                                                    // redistributed
+    // redistributed

Review comment:
       More untidy comments.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on pull request #4928:
URL: https://github.com/apache/geode/pull/4928#issuecomment-626524327


   > Methods named `isGroupTransactionEvents` might be better named `shouldGroupTransactionEvents`. Similarly, fields/variables named `isGroupTransactionEvents` might be better named simply `groupTransactionEvents`.
   
   I agree. Instead of using shouldGroupTransactionEvents I will use mustGroupTransactionEvents which is a bit shorter.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r422851648



##########
File path: geode-core/src/main/java/org/apache/geode/cache/wan/GatewaySender.java
##########
@@ -153,6 +155,13 @@
       .getInteger(GeodeGlossary.GEMFIRE_PREFIX + "gateway-connection-retry-interval", 1000)
       .intValue();
 
+  /**
+   * Number of times to retry to get events for a transaction from the gateway sender queue
+   */
+  int GET_TRANSACTION_EVENTS_FROM_QUEUE_RETRIES =
+      Integer.getInteger(GeodeGlossary.GEMFIRE_PREFIX + "get-transaction-events-from-queue-retries",

Review comment:
       I did not document this property as I thought it was too internal to be used by clients just as other properties that are not documented. For example: gateway-connection-retry-interval




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r422866672



##########
File path: geode-core/src/main/java/org/apache/geode/internal/cache/InternalRegion.java
##########
@@ -307,6 +307,11 @@ void cacheWriteBeforePut(EntryEventImpl event, Set netWriteRecipients, CacheWrit
 
   void invokeTXCallbacks(EnumListenerEvent afterDestroy, EntryEventImpl ee, boolean b);
 
+  default void invokeTXCallbacks(EnumListenerEvent afterDestroy, EntryEventImpl ee, boolean b,

Review comment:
       It is not. I will remove the default implementation.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r422867687



##########
File path: geode-core/src/main/java/org/apache/geode/internal/cache/TXLastEventInTransactionUtils.java
##########
@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package org.apache.geode.internal.cache;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.ServiceConfigurationError;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.wan.GatewaySender;
+import org.apache.geode.logging.internal.log4j.api.LogService;
+
+public class TXLastEventInTransactionUtils {
+  private static final Logger logger = LogService.getLogger();
+
+  /**
+   * @param callbacks list of events belonging to a transaction
+   *
+   * @return the last event of the transaction.
+   *         If the regions to which the events belong do not have senders
+   *         that group transactions it returns null.
+   *         If the regions to which the
+   *         events belong have different sets of senders that group transactions
+   *         then it throws a ServiceConfigurationError exception.
+   */
+  public static EntryEventImpl getLastTransactionEvent(List<EntryEventImpl> callbacks,
+      Cache cache)
+      throws ServiceConfigurationError {
+    if (checkNoSendersGroupTransactionEvents(callbacks, cache)) {
+      return null;
+    }
+
+    List<Set> senderIdsPerEvent = getGroupingSendersPerEvent(callbacks, cache);
+    if (senderIdsPerEvent.stream().distinct().count() > 1) {
+      String info = eventsAndSendersPerEventToString(callbacks, senderIdsPerEvent);
+      throw new ServiceConfigurationError(
+          "Not all events go to the same senders that group transactions. " + info);
+    } ;

Review comment:
       Good eye!




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r422882651



##########
File path: geode-core/src/main/java/org/apache/geode/internal/cache/wan/AbstractGatewaySenderEventProcessor.java
##########
@@ -862,14 +868,14 @@ private void logEvents(String message, List<GatewaySenderEventImpl> events) {
               event.getRawCallbackArgument(), this.sender.getMyDSId(), allRemoteDSIds);
           event.setCallbackArgument(geCallbackArg);
           GatewaySenderEventImpl pdxSenderEvent =
-              new GatewaySenderEventImpl(EnumListenerEvent.AFTER_UPDATE, event, null); // OFFHEAP:
-                                                                                       // event for
-                                                                                       // pdx type
-                                                                                       // meta data
-                                                                                       // so it
-                                                                                       // should
-                                                                                       // never be
-                                                                                       // off-heap
+              new GatewaySenderEventImpl(EnumListenerEvent.AFTER_UPDATE, event, null, false); // OFFHEAP:
+          // event for
+          // pdx type
+          // meta data
+          // so it
+          // should
+          // never be
+          // off-heap

Review comment:
       I have put it in a single line above the instance creation sentence. I cannot tell if the comment is significant so I do not know if it can be removed.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r422886472



##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -373,7 +373,8 @@ public static Integer createSecondRemoteLocator(int dsId, int localPort, int rem
   }
 
   public static Integer createSecondRemoteLocatorWithAPI(int dsId, int localPort, int remoteLocPort,
-      String hostnameForClients) throws IOException {
+      String hostnameForClients)

Review comment:
       No reason. I did it by mistake. I have reverted the changes.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r422994223



##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
 
     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));
   }
 
+  @Test
+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, true, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+
+    // 3 transactions of 4 events each are sent so that the batch would
+    // initially contain the first 2 transactions complete and the first
+    // 2 events of the last transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // 2 events of the last transaction are added to the batch which makes
+    // that only one batch of 12 events is sent.
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 6;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertTrue("Batch was not redistributed",
+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, true, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 6;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+
+    // 6 transactions of 4 events each are sent so that the first batch
+    // would initially contain the first 2 transactions complete and the first
+    // 2 events of the next transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // 2 events of the second transaction are added to the batch which makes
+    // that the first batch is sent with 12 events. The same happens with the
+    // second batch which will contain 12 events too.
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);

Review comment:
       ok




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r423010749



##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -299,19 +312,316 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_NoRedundancy(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(NUM_PUTS, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(NUM_PUTS,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(NUM_PUTS, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                           // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
 
     vm2.invoke(() -> WANTestBase.checkGatewayReceiverStats(10, NUM_PUTS, NUM_PUTS));
   }
 
+  @Test
+  public void testPartitionedRegionParallelPropagation_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagation_GroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, true, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 3;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+
+    // 3 transactions of 4 events each are sent so that the batch would
+    // initially contain the first 2 transactions complete and the first
+    // 2 events of the last transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // 2 events of the last transaction are added to the batch which makes
+    // that only one batch of 12 events is sent.
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(1, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagationBatchRedistributed_NoGroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+    createReceiverInVMs(vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, false, batchTimeInterval);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 6;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(3, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertTrue("Batch was not redistributed",
+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches
+    // redistributed
+  }
+
+  @Test
+  public void testPartitionedRegionParallelPropagationBatchRedistributed_GroupTransactionEvents()
+      throws Exception {
+    Integer lnPort = (Integer) vm0.invoke(() -> WANTestBase.createFirstLocatorWithDSId(1));
+    Integer nyPort = (Integer) vm1.invoke(() -> WANTestBase.createFirstRemoteLocator(2, lnPort));
+
+    createCacheInVMs(nyPort, vm2);
+
+    int batchTimeInterval = 10000;
+    createSenders(lnPort, true, batchTimeInterval);
+
+    createReceiverCustomerOrderShipmentPR(vm2, 0);
+
+    createSenderCustomerOrderShipmentPRs(0);
+
+    startSenderInVMs("ln", vm4, vm5, vm6, vm7);
+
+
+    final Map custKeyValue = new HashMap();
+    int intCustId = 1;
+    CustId custId = new CustId(intCustId);
+    custKeyValue.put(custId, new Customer());
+    vm4.invoke(() -> WANTestBase.putGivenKeyValue(customerRegionName, custKeyValue));
+
+    int transactions = 6;
+    final Map keyValues = new HashMap();
+    for (int i = 0; i < transactions; i++) {
+      OrderId orderId = new OrderId(i, custId);
+      ShipmentId shipmentId1 = new ShipmentId(i, orderId);
+      ShipmentId shipmentId2 = new ShipmentId(i + 1, orderId);
+      ShipmentId shipmentId3 = new ShipmentId(i + 2, orderId);
+      keyValues.put(orderId, new Order());
+      keyValues.put(shipmentId1, new Shipment());
+      keyValues.put(shipmentId2, new Shipment());
+      keyValues.put(shipmentId3, new Shipment());
+    }
+
+    // 6 transactions of 4 events each are sent so that the first batch
+    // would initially contain the first 2 transactions complete and the first
+    // 2 events of the next transaction (10 entries).
+    // As --group-transaction-events is configured in the senders, the remaining
+    // 2 events of the second transaction are added to the batch which makes
+    // that the first batch is sent with 12 events. The same happens with the
+    // second batch which will contain 12 events too.
+    int eventsPerTransaction = 4;
+    vm4.invoke(() -> WANTestBase.doOrderAndShipmentPutsInsideTransactions(keyValues,
+        eventsPerTransaction));
+
+    int entries = (transactions * eventsPerTransaction) + 1;
+
+    // The receiver is started later in order for the batch to be redistributed (sent again)
+    Thread.sleep(2000);
+    createReceiverInVMs(vm2);
+
+    vm4.invoke(() -> WANTestBase.validateRegionSize(customerRegionName, 1));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(orderRegionName, transactions));
+    vm4.invoke(() -> WANTestBase.validateRegionSize(shipmentRegionName, transactions * 3));
+
+    ArrayList<Integer> v4List =
+        (ArrayList<Integer>) vm4.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v5List =
+        (ArrayList<Integer>) vm5.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v6List =
+        (ArrayList<Integer>) vm6.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+    ArrayList<Integer> v7List =
+        (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
+
+    assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
+    assertEquals(entries,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(entries, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
+    // queued
+    assertEquals(entries, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
+    // distributed
+    assertEquals(2, v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4)); // batches
+    // distributed
+    assertTrue("Batch was not redistributed",
+        (v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)) > 0); // batches
+    // redistributed

Review comment:
       ok

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -343,15 +653,16 @@ public void testPartitionedRegionParallelPropagation_AfterDispatch_Redundancy_3(
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(400, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(400,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(400, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                      // queued
+    // queued
     assertEquals(NUM_PUTS, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                           // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 10); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed

Review comment:
       ok




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r423010939



##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -503,17 +815,16 @@ public void testParallelPropagationWithRemoteRegionDestroy() throws Exception {
     ArrayList<Integer> v7List =
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", -1));
 
-
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 1); // batches
-                                                                                    // distributed :
-                                                                                    // its quite
-                                                                                    // possible that
-                                                                                    // vm4 has
-                                                                                    // distributed
-                                                                                    // some of the
-                                                                                    // batches.
+    // distributed :
+    // its quite
+    // possible that
+    // vm4 has
+    // distributed
+    // some of the
+    // batches.
     assertTrue(v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5) >= 1); // batches
-                                                                                    // redistributed
+    // redistributed

Review comment:
       ok

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/parallel/ParallelWANStatsDUnitTest.java
##########
@@ -559,17 +868,18 @@ public void testParallelPropagationWithFilter() throws Exception {
         (ArrayList<Integer>) vm7.invoke(() -> WANTestBase.getSenderStats("ln", 0));
 
     assertEquals(0, v4List.get(0) + v5List.get(0) + v6List.get(0) + v7List.get(0)); // queue size
-    assertEquals(1000, v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
+    assertEquals(1000,
+        v4List.get(1) + v5List.get(1) + v6List.get(1) + v7List.get(1)); // eventsReceived
     assertEquals(900, v4List.get(2) + v5List.get(2) + v6List.get(2) + v7List.get(2)); // events
-                                                                                      // queued
+    // queued
     assertEquals(800, v4List.get(3) + v5List.get(3) + v6List.get(3) + v7List.get(3)); // events
-                                                                                      // distributed
+    // distributed
     assertTrue(v4List.get(4) + v5List.get(4) + v6List.get(4) + v7List.get(4) >= 80); // batches
-                                                                                     // distributed
+    // distributed
     assertEquals(0, v4List.get(5) + v5List.get(5) + v6List.get(5) + v7List.get(5)); // batches
-                                                                                    // redistributed
+    // redistributed
     assertEquals(200, v4List.get(6) + v5List.get(6) + v6List.get(6) + v7List.get(6)); // events
-                                                                                      // filtered
+    // filtered

Review comment:
       ok




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r423011450



##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -497,7 +498,8 @@ public static void createPersistentReplicatedRegion(String regionName, String se
   }
 
   public static void createReplicatedRegionWithAsyncEventQueue(String regionName,
-      String asyncQueueIds, Boolean offHeap) {
+      String asyncQueueIds,

Review comment:
       ok




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r423011534



##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -519,7 +521,9 @@ public static void createReplicatedRegionWithAsyncEventQueue(String regionName,
   }
 
   public static void createReplicatedRegionWithSenderAndAsyncEventQueue(String regionName,
-      String senderIds, String asyncChannelId, Boolean offHeap) {
+      String senderIds,

Review comment:
       ok

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -560,7 +564,8 @@ public static void createReplicatedRegion(String regionName, String senderIds, S
   }
 
   public static void createAsyncEventQueue(String asyncChannelId, boolean isParallel,
-      Integer maxMemory, Integer batchSize, boolean isConflation, boolean isPersistent,
+      Integer maxMemory, Integer batchSize,

Review comment:
       ok

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -589,7 +594,8 @@ public static void createAsyncEventQueue(String asyncChannelId, boolean isParall
   }
 
   public static void createPartitionedRegion(String regionName, String senderIds,
-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {
+      Integer redundantCopies, Integer totalNumBuckets,

Review comment:
       ok

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -619,7 +625,8 @@ public static void createPartitionedRegion(String regionName, String senderIds,
 
   // TODO:OFFHEAP: add offheap flavor
   public static void createPartitionedRegionWithPersistence(String regionName, String senderIds,
-      Integer redundantCopies, Integer totalNumBuckets) {
+      Integer redundantCopies,

Review comment:
       ok

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -647,7 +654,9 @@ public static void createPartitionedRegionWithPersistence(String regionName, Str
   }
 
   public static void createColocatedPartitionedRegion(String regionName, String senderIds,
-      Integer redundantCopies, Integer totalNumBuckets, String colocatedWith) {
+      Integer redundantCopies,

Review comment:
       ok

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -691,7 +700,8 @@ public static void addAsyncEventQueueThroughAttributesMutator(String regionName,
   }
 
   public static void createPartitionedRegionAsAccessor(String regionName, String senderIds,
-      Integer redundantCopies, Integer totalNumBuckets) {
+      Integer redundantCopies,

Review comment:
       ok




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r423011955



##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -709,7 +719,10 @@ public static void createPartitionedRegionAsAccessor(String regionName, String s
   }
 
   public static void createPartitionedRegionWithSerialParallelSenderIds(String regionName,
-      String serialSenderIds, String parallelSenderIds, String colocatedWith, Boolean offHeap) {
+      String serialSenderIds,

Review comment:
       ok

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -734,7 +747,8 @@ public static void createPartitionedRegionWithSerialParallelSenderIds(String reg
   }
 
   public static void createPersistentPartitionedRegion(String regionName, String senderIds,
-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {
+      Integer redundantCopies,

Review comment:
       ok

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -764,7 +778,9 @@ public static void createPersistentPartitionedRegion(String regionName, String s
   }
 
   public static void createCustomerOrderShipmentPartitionedRegion(String senderIds,
-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {
+      Integer redundantCopies,

Review comment:
       ok

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -830,7 +846,8 @@ public static void createCustomerOrderShipmentPartitionedRegion(String senderIds
   }
 
   public static void createColocatedPartitionedRegions(String regionName, String senderIds,
-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {
+      Integer redundantCopies,

Review comment:
       ok

##########
File path: geode-wan/src/distributedTest/java/org/apache/geode/internal/cache/wan/WANTestBase.java
##########
@@ -858,7 +875,8 @@ public static void createColocatedPartitionedRegions(String regionName, String s
   }
 
   public static void createColocatedPartitionedRegions2(String regionName, String senderIds,
-      Integer redundantCopies, Integer totalNumBuckets, Boolean offHeap) {
+      Integer redundantCopies,

Review comment:
       ok




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r423014670



##########
File path: geode-core/src/main/java/org/apache/geode/internal/cache/wan/parallel/ParallelGatewaySenderQueue.java
##########
@@ -1282,22 +1278,89 @@ public List peek(int batchSize, int timeToWait) throws InterruptedException, Cac
           Thread.currentThread().interrupt();
           break;
         }
-        continue;
       }
     }
+
+    if (batch.size() > 0) {
+      peekEventsFromIncompleteTransactions(batch, incompleteTransactionsInBatch, prQ);
+    }
+
     if (isDebugEnabled) {
       logger.debug("{}: Peeked a batch of {} entries. The size of the queue is {}. localSize is {}",
           this, batch.size(), size(), localSize());
     }
+
     if (batch.size() == 0) {
       blockProcessorThreadIfRequired();
     }
     return batch;
   }
 
+  private boolean stopPeekingDueToTime(long currentTime, int timeToWait, long end) {

Review comment:
       Good point




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r425869823



##########
File path: geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/CreateGatewaySenderCommand.java
##########
@@ -75,6 +75,11 @@ public ResultModel createGatewaySender(
           mandatory = true,
           help = CliStrings.CREATE_GATEWAYSENDER__REMOTEDISTRIBUTEDSYSTEMID__HELP) Integer remoteDistributedSystemId,
 
+      @CliOption(key = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,
+          specifiedDefaultValue = "true",
+          unspecifiedDefaultValue = "false",
+          help = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) boolean groupTransactionEvents,
+

Review comment:
       > Note that the GatewaySender can be configured via the Java API ... not just through gfsh. This is where I was hoping to get that check to ensure the user is configuring a valid GatewaySender (Serial GatewaySender).
   > 
   > Also, during internal testing with HA (killing servers) we've noticed data inconsistency between WAN Sites with groupTransactionEvents enabled. In addition, I've seen the primary Serial GatewaySender AEQ not drain (again, with this attribute enabled).
   > 
   > Do you have any DUnit Tests with HA (to verify that we still have consistency between wan sites and queues being drained when groupTransactionEvents is enabled)?
   > 
   > We are still investigating this and will update this PR as we narrow in on the root cause.
   
   I think I found the problem. There was a bug in the handling of events that had to be added to the batch in order to complete a transaction that under high load and concurrency situations caused that some events were not propagated.
   I have added DUnit tests with HA for the serial and gateway senders. The one for the SerialGatewaySender was failing before my fix.
   
   Please, let me know if the new commit fixes the problem you encountered.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r425869823



##########
File path: geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/CreateGatewaySenderCommand.java
##########
@@ -75,6 +75,11 @@ public ResultModel createGatewaySender(
           mandatory = true,
           help = CliStrings.CREATE_GATEWAYSENDER__REMOTEDISTRIBUTEDSYSTEMID__HELP) Integer remoteDistributedSystemId,
 
+      @CliOption(key = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,
+          specifiedDefaultValue = "true",
+          unspecifiedDefaultValue = "false",
+          help = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) boolean groupTransactionEvents,
+

Review comment:
       > Note that the GatewaySender can be configured via the Java API ... not just through gfsh. This is where I was hoping to get that check to ensure the user is configuring a valid GatewaySender (Serial GatewaySender).
   > 
   > Also, during internal testing with HA (killing servers) we've noticed data inconsistency between WAN Sites with groupTransactionEvents enabled. In addition, I've seen the primary Serial GatewaySender AEQ not drain (again, with this attribute enabled).
   > 
   > Do you have any DUnit Tests with HA (to verify that we still have consistency between wan sites and queues being drained when groupTransactionEvents is enabled)?
   > 
   > We are still investigating this and will update this PR as we narrow in on the root cause.
   
   I think I found the problem. There was a bug in the `SerialGatewaySenderQueue` handling of events that had to be added to the batch in order to complete a transaction that under high load and concurrency caused that some events were not propagated.
   
   I have added DUnit tests with HA for the serial and parallel gateway senders. The one for the `SerialGatewaySender` was failing before my fix.
   
   Please, let me know if the new commit fixes the problem you encountered.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


davebarnes97 commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r425949151



##########
File path: geode-core/src/main/java/org/apache/geode/cache/wan/GatewaySender.java
##########
@@ -153,6 +155,13 @@
       .getInteger(GeodeGlossary.GEMFIRE_PREFIX + "gateway-connection-retry-interval", 1000)
       .intValue();
 
+  /**
+   * Number of times to retry to get events for a transaction from the gateway sender queue
+   */
+  int GET_TRANSACTION_EVENTS_FROM_QUEUE_RETRIES =
+      Integer.getInteger(GeodeGlossary.GEMFIRE_PREFIX + "get-transaction-events-from-queue-retries",

Review comment:
       Apache Geode is an open-source repo, so nothing is truly hidden from users. However, there are many examples of properties that intentionally go un-mentioned in the User Guide. Such a property should be briefly commented in code, indicating the use for which it is intended and what its limitations are, so curious browsing developers won't get themselves into trouble.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on pull request #4928:
URL: https://github.com/apache/geode/pull/4928#issuecomment-630039797


   > I've reviewed the doc components and I have some changes to propose. Most are concerned with grammar and format. The only technical one is to replace references to the `is-parallel` property with the `parallel` property.
   > I'm not sure how best to submit these, as it would be good to have them reviewed before checking them in. The most convenient method for me is the output of a `git diff`, so here goes. If you'd like me to incorporate the material in some other way (e.g. push my local commit to the feature branch) please let me know.
   > 
   > diff --git a/geode-docs/reference/topics/cache_xml.html.md.erb b/geode-docs/reference/topics/cache_xml.html.md.erb
   > index 4d9e859550..39e3d66962 100644
   > --- a/geode-docs/reference/topics/cache_xml.html.md.erb
   > +++ b/geode-docs/reference/topics/cache_xml.html.md.erb
   > @@ -298,8 +298,8 @@ Configures a gateway sender to distribute region events to another <%=vars.produ
   > group-transaction-events Boolean value to ensure that all the events of a transaction are sent in the same batch, i.e., they are never spread across different batches. -
   > 
   > Only allowed to be set on gateway senders with `is-parallel` attribute set to false and `dispatcher-threads` attribute equal to 1 or on gatewaysenders with `is-parallel` attribute set to true.
   > -
   > 
   > Note that in order to work for a transaction, the regions to which the transaction events belong must be replicated by the same set of senders with this flag enabled.
   > +
   > 
   > Only allowed to be set on gateway senders with the `parallel` attribute set to false and `dispatcher-threads` attribute equal to 1, or on gateway senders with the `parallel` attribute set to true.
   > +
   > 
   > Note: In order to work for a transaction, the regions to which the transaction events belong must be replicated by the same set of senders with this flag enabled.
   > false diff --git a/geode-docs/tools_modules/gfsh/command-pages/create.html.md.erb b/geode-docs/tools_modules/gfsh/command-pages/create.html.md.erb index 6140c6f79c..771412a96d 100644 --- a/geode-docs/tools_modules/gfsh/command-pages/create.html.md.erb +++ b/geode-docs/tools_modules/gfsh/command-pages/create.html.md.erb @@ -635,8 +635,8 @@ create gateway-sender --id=value --remote-distributed-system-id=value \-\-group-transaction-events Boolean value to ensure that all the events of a transaction are sent in the same batch, i.e., they are never spread across different batches. -
   > 
   > Only allowed to be set on gateway senders with `is-parallel` attribute set to false and `dispatcher-threads` attribute equal to 1 or on gatewaysenders with `is-parallel` attribute set to true.
   > -
   > 
   > Note that in order to work for a transaction, the regions to which the transaction events belong must be replicated by the same set of senders with this flag enabled.
   > +
   > 
   > Only allowed to be set on gateway senders with the `parallel` attribute set to false and `dispatcher-threads` attribute equal to 1, or on gatewaysenders with the `parallel` attribute set to true.
   > +
   > 
   > Note: In order to work for a transaction, the regions to which the transaction events belong must be replicated by the same set of senders with this flag enabled.
   > false diff --git a/geode-docs/topologies_and_comm/multi_site_configuration/setting_up_a_multisite_system.html.md.erb b/geode-docs/topologies_and_comm/multi_site_configuration/setting_up_a_multisite_system.html.md.erb index 64a129009f..be8dfafeb9 100644 --- a/geode-docs/topologies_and_comm/multi_site_configuration/setting_up_a_multisite_system.html.md.erb +++ b/geode-docs/topologies_and_comm/multi_site_configuration/setting_up_a_multisite_system.html.md.erb @@ -171,7 +171,7 @@ When using a multi-site configuration, you choose which data regions to share be
   > 
   >     * Regions using the same parallel gateway sender ID must be colocated.
   > 
   > 
   > -- If any gateway sender configured for the region has the `group-transaction-events` flag set to true, then the regions involved in transactions must all have the same gateway senders with this flag set to true configured. This requires careful configuration of regions with gateway-senders according to the transactions expected in the system.
   > +- If any gateway sender configured for the region has the `group-transaction-events` flag set to true, then the regions involved in transactions must all have the same gateway senders configured with this flag set to true. This requires careful configuration of regions with gateway senders according to the transactions expected in the system.
   > 
   > ```
   >  **Example**:
   >  Assuming the following scenario:
   > ```
   > 
   > @@ -185,14 +185,21 @@ When using a multi-site configuration, you choose which data regions to share be
   > 
   > ```
   >  - Regions:
   > ```
   > 
   >     * ```
   >        - region1: gateway-sender-ids=sender1,sender2,sender4 type: partition, colocated-with: region2,region3
   >       ```
   > 
   >     * ```
   >        - region2: gateway-sender-ids=sender1,sender2         type: partition, colocated with: region1,region3
   >       ```
   > 
   >     * ```
   >        - region3: gateway-sender-ids=sender3                 type: partition, colocated with: region1,region2
   >       ```
   > 
   >     * ```
   >        - region4: gateway-sender-ids=sender4                 type: replicated
   >       ```
   > 
   > 
   >     * ```
   >        - region1: gateway-sender-ids=sender1,sender2,sender4<br />
   >       ```
   > 
   >     * ```
   >            type: partition<br />
   >       ```
   > 
   >     * ```
   >            colocated-with: region2,region3
   >       ```
   > 
   >     * ```
   >        - region2: gateway-sender-ids=sender1,sender2<br />
   >       ```
   > 
   >     * ```
   >            type: partition<br />
   >       ```
   > 
   >     * ```
   >            colocated with: region1,region3
   >       ```
   > 
   >     * ```
   >        - region3: gateway-sender-ids=sender3<br />
   >       ```
   > 
   >     * ```
   >            type: partition<br />
   >       ```
   > 
   >     * ```
   >            colocated with: region1,region2
   >       ```
   > 
   >     * ```
   >        - region4: gateway-sender-ids=sender4<br />
   >       ```
   > 
   >     * ```
   >            type: replicated
   >       ```
   >       
   >       
   >       
   >       * Events for the same transaction will be guaranteed to be sent in the same batch depending on the events involved in the transaction:
   > 
   > 
   >     * ```
   >        - For transactions containing events for region1 and region2, it will be guaranteed that events for those transactions will be delivered in the same batch by senders1 and sender2.
   >       ```
   > 
   > 
   >     * ```
   >        - For transactions containing events for region1 and region2, it will be guaranteed that events for those transactions will be delivered in the same batch by sender1 and sender2.
   >        - For transactions containing events for region1, region2 and region3, it will NOT be guaranteed that events for those transactions will be delivered in the same batch .
   >        - For transactions containing events for region3, it will be guaranteed that events for those transactions will be delivered in the same batch.
   >        - For transactions containing events for region4, it will NOT be guaranteed that events for those transactions will be delivered in the same batch.
   >       ```
   > 
   > 
   > diff --git a/geode-docs/topologies_and_comm/topology_concepts/multisite_overview.html.md.erb b/geode-docs/topologies_and_comm/topology_concepts/multisite_overview.html.md.erb
   > index 018715c84a..42044e1e91 100644
   > --- a/geode-docs/topologies_and_comm/topology_concepts/multisite_overview.html.md.erb
   > +++ b/geode-docs/topologies_and_comm/topology_concepts/multisite_overview.html.md.erb
   > @@ -33,7 +33,12 @@ Gateway senders and receivers are defined at startup in the member caches. A sit
   > 
   > Geode ensures that all copies of a region eventually reach a consistent state on all members and clients that host the region, including Geode members that distribute region events across a WAN.
   > 
   > -Events are sent over batches from gateway senders to receivers. In order to avoid possible long lasting inconsistencies due to a partial reception of the events belonging to a transaction after a network split, it is possible to configure gateway senders to prevent events belonging to the same transaction to be spread across different batches. It must be noted though, that this setting is only supported on serial senders with just one dispatcher thread or on parallel ones. Besides, the regions to which the transaction events belong must be replicated by the same set of gateway senders that have this setting enabled.
   > +Events are sent in batches from gateway senders to receivers. In order to avoid inconsistencies due
   > +to partial reception of the events belonging to a transaction, you can configure gateway senders to
   > +ensure that events belonging to the same transaction are sent together in the same batch.
   > +Note: This setting is supported only on serial senders with just one dispatcher
   > +thread, or on parallel senders. In addition, the regions to which the transaction events belong must
   > +be replicated by the same set of gateway senders that also have this setting enabled.
   
   @davebarnes97 Thanks for the comments. In the pasted diff it is hard to get what the changes are. I would appreciate if you either send me the diff attached or if you prefer, that you push your changes to the feature branch.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r426877956



##########
File path: geode-core/src/main/java/org/apache/geode/cache/wan/GatewaySender.java
##########
@@ -153,6 +155,13 @@
       .getInteger(GeodeGlossary.GEMFIRE_PREFIX + "gateway-connection-retry-interval", 1000)
       .intValue();
 
+  /**
+   * Number of times to retry to get events for a transaction from the gateway sender queue
+   */
+  int GET_TRANSACTION_EVENTS_FROM_QUEUE_RETRIES =
+      Integer.getInteger(GeodeGlossary.GEMFIRE_PREFIX + "get-transaction-events-from-queue-retries",

Review comment:
       I
   
   > Apache Geode is an open-source repo, so nothing is truly hidden from users. However, there are many examples of properties that intentionally go un-mentioned in the User Guide. Such a property should be briefly commented in code, indicating the use for which it is intended and what its limitations are, so curious browsing developers won't get themselves into trouble.
   
   I have added a longer description in the comments for the property in my last commit.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


davebarnes97 commented on pull request #4928:
URL: https://github.com/apache/geode/pull/4928#issuecomment-630940274


   @albertogpz I know the doc comments were extensive. I'll push the changes I'm sure about and dialog with you on points I'm unsure about. One item for you to verify: the references to the `is-parallel` attribute should be to the `parallel` attribute, yes?


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on pull request #4928:
URL: https://github.com/apache/geode/pull/4928#issuecomment-630952282


   > @albertogpz I know the doc comments were extensive. I'll push the changes I'm sure about and dialog with you on points I'm unsure about. One item for you to verify: the references to the `is-parallel` attribute should be to the `parallel` attribute, yes?
   
   Thanks, Dave.
   Yes, you are right: the references to the `is-parallel` attribute should be to the `parallel` attribute


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on pull request #4928:
URL: https://github.com/apache/geode/pull/4928#issuecomment-630952955


   > > @albertogpz I know the doc comments were extensive. I'll push the changes I'm sure about and dialog with you on points I'm unsure about. One item for you to verify: the references to the `is-parallel` attribute should be to the `parallel` attribute, yes?
   > 
   > Thanks, Dave.
   > Yes, you are right: the references to the `is-parallel` attribute should be to the `parallel` attribute
   
   The problem with the doc comments was not that they were extensive, but that they got modified when you pasted the diff here and the resulting test was not a valid diff I could apply.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


davebarnes97 commented on pull request #4928:
URL: https://github.com/apache/geode/pull/4928#issuecomment-631247566


   > The problem with the doc comments was not that they were extensive, but that they got modified when you pasted the diff here and the resulting test was not a valid diff I could apply.
   
   I lack permissions to push my commit to your fork. It consists of four edited files. What would you suggest?


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on pull request #4928:
URL: https://github.com/apache/geode/pull/4928#issuecomment-631253004


   > > The problem with the doc comments was not that they were extensive, but that they got modified when you pasted the diff here and the resulting test was not a valid diff I could apply.
   > 
   > I lack permissions to push my commit to your fork. It consists of four edited files. What would you suggest?
   
   You can send me the diff file attached to my e-mail address. I will apply the diff and then give comments if any here.
   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r427832505



##########
File path: geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/CreateGatewaySenderCommand.java
##########
@@ -75,6 +75,11 @@ public ResultModel createGatewaySender(
           mandatory = true,
           help = CliStrings.CREATE_GATEWAYSENDER__REMOTEDISTRIBUTEDSYSTEMID__HELP) Integer remoteDistributedSystemId,
 
+      @CliOption(key = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,
+          specifiedDefaultValue = "true",
+          unspecifiedDefaultValue = "false",
+          help = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) boolean groupTransactionEvents,
+

Review comment:
       @ladyVader Any news after the data inconsistency you found after having pushed my fix?




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


albertogpz commented on pull request #4928:
URL: https://github.com/apache/geode/pull/4928#issuecomment-632576516


   > > > The problem with the doc comments was not that they were extensive, but that they got modified when you pasted the diff here and the resulting test was not a valid diff I could apply.
   > > 
   > > 
   > > I lack permissions to push my commit to your fork. It consists of four edited files. What would you suggest?
   > 
   > You can send me the diff file attached to my e-mail address. I will apply the diff and then give comments if any here.
   
   I just pushed a couple of commits.
   - One with your comments about the documentation: I accepted all of them, thanks a lot for them.
   - The second one merging the latest of development.
   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


ladyVader commented on a change in pull request #4928:
URL: https://github.com/apache/geode/pull/4928#discussion_r429320060



##########
File path: geode-gfsh/src/main/java/org/apache/geode/management/internal/cli/commands/CreateGatewaySenderCommand.java
##########
@@ -75,6 +75,11 @@ public ResultModel createGatewaySender(
           mandatory = true,
           help = CliStrings.CREATE_GATEWAYSENDER__REMOTEDISTRIBUTEDSYSTEMID__HELP) Integer remoteDistributedSystemId,
 
+      @CliOption(key = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS,
+          specifiedDefaultValue = "true",
+          unspecifiedDefaultValue = "false",
+          help = CliStrings.CREATE_GATEWAYSENDER__GROUPTRANSACTIONEVENTS__HELP) boolean groupTransactionEvents,
+

Review comment:
       Thanks for both the new Exception on misconfiguring the SerialGatewaySender with groupTransactionEvents enabled + dispatcherThreads > 1.
   
   In addition, I'm no longer seeing the data inconsistencies or hangs waiting for the primary gateway sender queue to drain.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/develop from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/develop from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/develop from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/develop from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/develop from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/develop from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/develop from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/develop from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/develop from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/develop from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/develop from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/develop from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

Commit e4328553fb5783e8310833df42e1f17e48dc2ac4 in geode's branch refs/heads/feature/GEODE-8144 from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=e432855 ]

GEODE-7971: Gw sender deliver TX events atomically to Gw receivers (#4928)

* GEODE-7971: Gw sender deliver TX events atomically to Gw receivers

A new flag is added to gateway senders: group-transaction-events.
If set to true, events for the same transaction will not be
spread across different batches, i.e. it is guaranteed that
they will be delivered inside the same batch.

In order to implement this behavior,
the last event for each transaction is marked with a new flag
and the transactionId before it is put in the sender's queue
(new flag added to GatewaySenderEvent). That way, it is possible
for the gateway senders to go through a
batch ready to be sent and verify if the last event for
each transaction is present in the batch.
If not, the gateway sender will traverse the sender queue
to get the missing events for the incomplete transactions
and once they are added to the batch, the batch will be sent.

This feature has the following restrictions:
- The group-transaction-events can only be set on
serial gateway senders with just 1 dispatcher thread
or on parallel gateway senders.
- In order to guarantee that the events of a transaction
are to not spread
across different batches, the regions involved in the
transaction must all have the same senders with the
group-transaction-events flag set to true configured.

* GEODE-7971: small fix in gwSenderFactory + extra info on config error

* GEODE-7971: Add logic for case when batches are redistributed

Also added parameter for retries when not all
events for a transaction can be read from the queue.

* GEODE-7971: Undo changes on cache*.dtd files unneeded

Also changed a couple of timeouts in test cases.

* feature/GEODE-7971: Changes after review

* feature/GEODE-7971: Simplify test JUnit test case

* GEODE-7971: Update create document and refactor test case

* GEODE-7971: Add check in serial gwsender creation with threads>1 and group-trans-events=true.

Also corrected some documentation errors.

* GEODE-7971: Add HA test cases and fix bug in SerialGatewaySenderQueue

* feature/GEODE-7971: Documentation change after review and flaxy test fix

* GEODE-7971: Doc changes after review

mkevo merged pull request #4928:
URL: https://github.com/apache/geode/pull/4928


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


CI failure [https://concourse.apachegeode-ci.info/teams/main/pipelines/apache-develop-main/jobs/DistributedTestOpenJDK8/builds/223]

 
{noformat}
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=  Test Results URI =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
http://files.apachegeode-ci.info/builds/apache-develop-main/1.14.0-build.0093/test-results/distributedTest/1591059701/
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Test report artifacts from this job are available at:

http://files.apachegeode-ci.info/builds/apache-develop-main/1.14.0-build.0093/test-artifacts/1591059701/distributedtestfiles-OpenJDK8-1.14.0-build.0093.tgz {noformat}

Hi Mark,

I have been investigating the failure of this test case without success so far. I have run the test case hundreds of times and have not seen it fail once.

As the test is checking if all the data stored in one site is WAN replicated to the other and the failure seems to suggest that one entry was not replicated, I would like to see if the problem was with replication or with the entry not created locally in the first place. For that, I would add a new check in the test case so that, if it ever fails again, we have some hint.

Is it ok if I push that change? What branch should I use for it?

Thanks in advance,

Alberto G.



albertogpz opened a new pull request #5221:
URL: https://github.com/apache/geode/pull/5221


   …t case
   
   Also increased the number of retries to get events from
   the queue when group-transaction-events is set.
   
   Thank you for submitting a contribution to Apache Geode.
   
   In order to streamline the review of the contribution we ask you
   to ensure the following steps have been taken:
   
   ### For all changes:
   - [ ] Is there a JIRA ticket associated with this PR? Is it referenced in the commit message?
   
   - [ ] Has your PR been rebased against the latest commit within the target branch (typically `develop`)?
   
   - [ ] Is your initial contribution a single, squashed commit?
   
   - [ ] Does `gradlew build` run cleanly?
   
   - [ ] Have you written or updated unit tests to verify your changes?
   
   - [ ] If adding new dependencies to the code, are these dependencies licensed in a way that is compatible for inclusion under [ASF 2.0](http://www.apache.org/legal/resolved.html#category-a)?
   
   ### Note:
   Please ensure that once the PR is submitted, check Concourse for build issues and
   submit an update to your PR as soon as possible. If you need help, please send an
   email to dev@geode.apache.org.
   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Commit 9e2891cbf8e834fea0a3801eb66b075d76c5612c in geode's branch refs/heads/develop from Alberto Gomez
[ https://gitbox.apache.org/repos/asf?p=geode.git;h=9e2891c ]

GEODE-7971: Added extra check in test case to find possible flaky test case (#5221)

Also increased the number of retries to get events from
the queue when group-transaction-events is set.

mkevo merged pull request #5221:
URL: https://github.com/apache/geode/pull/5221


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org


Moved remaining issue to GEODE-8320

