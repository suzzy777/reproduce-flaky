I've been trying to create a test case for this bug, but it has proven difficult due to the fact that it's not 100% reproducible. I've tried running the body of the test in a loop (using {{100.times}} for example) but it either fails immediately or never, so it's probably related to an initialization. With the minimal test case I eventually created, the static type check fails 46% of the time.

However, while building this minimal test case and removing as much stuff as I could, I noticed that some modifications removed the bug, and it led me to an interesting discovery. The test case runs the following script:
{code}
assertScript """import org.codehaus.groovy.classgen.asm.sc.bugs.support.Groovy7363Support
    Groovy7363Support.ABC a = new Groovy7363Support.ABC()
    println('' + a.b.object.value)
"""
{code}
which fails, as in my original report, with:
{noformat}
TestScripttestCascadingGenericTypes0.groovy: 3: [Static type checking] - No such property: value for class: T
@ line 3, column 26.
               println('' + a.b.object.value)
                            ^
{noformat}
The support Java code started with:
{code}
public class Groovy7363Support {
    public interface A<T, U extends B<T>> {
        U getB();

        void setB(U b);
    }

    public static class ABC implements A<C, BC> {
        @Override
        public BC getB() {
            return new BC();
        }

        @Override
        public void setB(BC b) {}
    }

    // ...
}
{code}


The setter did not seem necessary in the interface so I removed it, along with its implementation, and then the check passed. I then added the setter back, but only in the implementation, and the check failed again (46% of the time):
{code}
public class Groovy7363Support {
    public interface A<T, U extends B<T>> {
        U getB();
    }

    public static class ABC implements A<C, BC> {
        @Override
        public BC getB() {
            return new BC();
        }

        public void setB(BC b) {}
    }

    // ...
}
{code}


And then I remembered that classes implementing generics have synthetic bridge methods generated by the compilation, so I wondered if changing the order of the methods might influence the output. And indeed, moving the setter first in front of the getter makes the check fail reliably _on my machine_ (MacOS X 10.10.4, 64-bit Oracle JDK 1.7.0u75):
{code}
public class Groovy7363Support {
    public interface A<T, U extends B<T>> {
        U getB();
    }

    public static class ABC implements A<C, BC> {
        public void setB(BC b) {}

        @Override
        public BC getB() {
            return new BC();
        }
    }

    // ...
}
{code}


Still, I'm reluctant to actually create a pull request from [my branch|https://github.com/apache/incubator-groovy/compare/GROOVY_2_4_X...fpavageau:GROOVY-7363?expand=1] because the test could actually be flaky in other environments. But [the code is there|https://github.com/fpavageau/incubator-groovy/tree/GROOVY-7363], and I might try and debug it myself, to find where the analysis of the {{ABC}} class takes place and incorrectly initializes the context.

I've been running the {{StaticTypeCheckingVisitor}} on my test under the debugger, to understand how it works and where the problem might come from, and I think I've pinpointed the origin.

The reflection finds 2 methods {{getB()}} in {{ABC}}:
- the implemented method {{BC getB()}}
- a bridge method {{B getB()}}, with the original return type as declared in the {{A}} interface

As always with reflection, the order of the methods returned by {{Class.getDeclaredMethods()}} is undefined, which is why the failure can be flaky, even if my test reproduces it reliably on my machine. When the {{ClassNode}} for {{ABC}} is initialized (in {{lazyClassInit()}}), the bridge method is returned first, the implemented method second, and both are registered in {{ClassNode.methodsList}} and {{ClassNode.methods}}.

Then, when resolving the type of the {{a.b}} expression in {{StaticTypeCheckingVisitor.existsProperty()}}, the {{ClassNode}} returns the first getter matching the name and parameters of {{getB()}} ({{MethodNode getter = current.getGetterMethod("get" + capName)}}): the bridge method with a broader return type ({{B}}) than the actual, implemented method ({{BC}}).

So the question is: is there a point in keeping the bridge methods in the {{ClassNode}}? Are they ever needed? And even if they are, shouldn't the implemented methods have precedence in {{ClassNode.methods}} by being sorted first, so the exact types are always used? Because {{Class.getDeclaredMethods()}} returns an array with an undefined order, I think it's a bad idea to simply store them in the same order.

I'll try both scenarios and see if any existing test breaks (and if it fixes mine), but it's probably better if someone has a opinion on the best route.

GitHub user fpavageau opened a pull request:

    https://github.com/apache/incubator-groovy/pull/158

    GROOVY-7363 Reliable type resolution in the static type checker with covariant getters

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/fpavageau/incubator-groovy GROOVY-7363

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/158.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #158
    
----
commit ff027adbd073b9d65971bf01252611cc2b9fb245
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2015-08-03T13:04:37Z

    GROOVY-7363 Add a failing test

commit c5326d43ea155816d336f5d51d93f27980122926
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2015-08-03T15:12:00Z

    GROOVY-7363 Change the order of methods so the check fails reliably
    
    It probably depends on the environment (MacOS X 10.10.4, Oracle JDK
    1.7.0u75 here), but at least here the static type checking always fails.
    
    So, moving the setter first creates a reliable failure, and removing it
    makes the check always pass! It makes me think the problem is related to the
    synthetic bridge method generated for ABC.getB() and the order in which the
    methods are returned by the reflection API.

commit a20410f4e0b7d4d482ef87feabecb9f6e83d57ee
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2015-10-23T12:31:28Z

    GROOVY-7363 Configure the ClassNode with sorted methods
    
    Because reflection on methods doesn't return them sorted or in any
    particular order, sorting is necessary to get a stable ClassNode definition.
    
    In particular, sorting bridge methods last ensures that the type resolution
    of expressions in the static type checker always uses the covariant return
    type of getters (due to generics, for example) and doesn't lose accuracy,
    resulting in spurious type checking errors.

----


As commented by the GitHub Bot, I've created a pull request with a simple fix.

The only viable solution was to sort methods, as ignoring bridge methods triggered other failures in the build. It's also easier and less intrusive to sort during the {{ClassNode}} configuration than inside {{ClassNode.MapOfLists.put()}}, as that's called by {{ClassNode.addMethod()}} which is itself called in a lot more places than just the configuration.

Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/158


Pull request merged. Thanks!

