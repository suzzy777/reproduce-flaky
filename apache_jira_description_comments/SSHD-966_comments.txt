Thanks for the detailed diagnosis - I'll look at it and try to follow it. Meanwhile, can you try to reproduce the issue with the newly released version 2.4.0 ? We have made some changes to the locking mechanisms (though not specifically to this one).

On an unrelated issue - why do you need Mina 2.0.17 if you are using the NIO backend ?

I'll try to rebuild the same Gerrit version with updated SSHD, and see how it goes.

As for Mina : Gerrit offers the ability to switch SSHD between either NIO2 (the default) or MINA backend, hence the dependency.

I managed to reproduce the issue after upgrading sshd to 2.4.0 as well :

{noformat}
===== Threads on d4cddee5f2b4@172.18.0.5 =====

Warning, the following threads are deadlocked : SSH git-upload-pack /project1 (mysuer), SSH git-upload-pack /project2 (mysuer), sshd-SshDaemon[61cff1e4](port=22)-nio2-thread-5

"sshd-SshDaemon[61cff1e4](port=22)-nio2-thread-5" daemon prio=5 BLOCKED
	org.apache.sshd.common.channel.ChannelOutputStream.close(ChannelOutputStream.java:260)
	org.apache.sshd.common.util.io.IoUtils.closeQuietly(IoUtils.java:194)
	org.apache.sshd.common.util.io.IoUtils.closeQuietly(IoUtils.java:148)
	org.apache.sshd.server.channel.ChannelSession.closeImmediately0(ChannelSession.java:228)
	org.apache.sshd.server.channel.ChannelSession$$Lambda$427/1209317471.run(Unknown Source)
	org.apache.sshd.common.util.closeable.Builder$1.doClose(Builder.java:47)
	org.apache.sshd.common.util.closeable.SimpleCloseable.close(SimpleCloseable.java:63)
	org.apache.sshd.common.util.closeable.SequentialCloseable$1.operationComplete(SequentialCloseable.java:56)
	org.apache.sshd.common.util.closeable.SequentialCloseable$1.operationComplete(SequentialCloseable.java:45)
	org.apache.sshd.common.future.AbstractSshFuture.notifyListener(AbstractSshFuture.java:167)
	org.apache.sshd.common.future.DefaultSshFuture.addListener(DefaultSshFuture.java:167)
	org.apache.sshd.common.util.closeable.SequentialCloseable$1.operationComplete(SequentialCloseable.java:57)
	org.apache.sshd.common.util.closeable.SequentialCloseable$1.operationComplete(SequentialCloseable.java:45)
	org.apache.sshd.common.future.AbstractSshFuture.notifyListener(AbstractSshFuture.java:167)
	org.apache.sshd.common.future.DefaultSshFuture.addListener(DefaultSshFuture.java:167)
	org.apache.sshd.common.util.closeable.SequentialCloseable$1.operationComplete(SequentialCloseable.java:57)
	org.apache.sshd.common.util.closeable.SequentialCloseable$1.operationComplete(SequentialCloseable.java:45)
	org.apache.sshd.common.future.AbstractSshFuture.notifyListener(AbstractSshFuture.java:167)
	org.apache.sshd.common.future.DefaultSshFuture.addListener(DefaultSshFuture.java:167)
	org.apache.sshd.common.util.closeable.SequentialCloseable$1.operationComplete(SequentialCloseable.java:57)
	org.apache.sshd.common.util.closeable.SequentialCloseable$1.operationComplete(SequentialCloseable.java:45)
	org.apache.sshd.common.util.closeable.SequentialCloseable.doClose(SequentialCloseable.java:69)
	org.apache.sshd.common.util.closeable.SimpleCloseable.close(SimpleCloseable.java:63)
	org.apache.sshd.common.util.closeable.AbstractInnerCloseable.doCloseImmediately(AbstractInnerCloseable.java:48)
	org.apache.sshd.common.util.closeable.AbstractCloseable.close(AbstractCloseable.java:87)
	org.apache.sshd.common.util.closeable.ParallelCloseable.doClose(ParallelCloseable.java:65)
	org.apache.sshd.common.util.closeable.SimpleCloseable.close(SimpleCloseable.java:63)
	org.apache.sshd.common.util.closeable.AbstractInnerCloseable.doCloseImmediately(AbstractInnerCloseable.java:48)
	org.apache.sshd.common.util.closeable.AbstractCloseable.close(AbstractCloseable.java:87)
	org.apache.sshd.common.util.closeable.ParallelCloseable.doClose(ParallelCloseable.java:65)
	org.apache.sshd.common.util.closeable.SimpleCloseable.close(SimpleCloseable.java:63)
	org.apache.sshd.common.util.closeable.SequentialCloseable$1.operationComplete(SequentialCloseable.java:56)
	org.apache.sshd.common.util.closeable.SequentialCloseable$1.operationComplete(SequentialCloseable.java:45)
	org.apache.sshd.common.util.closeable.SequentialCloseable.doClose(SequentialCloseable.java:69)
	org.apache.sshd.common.util.closeable.SimpleCloseable.close(SimpleCloseable.java:63)
	org.apache.sshd.common.util.closeable.AbstractInnerCloseable.doCloseImmediately(AbstractInnerCloseable.java:48)
	org.apache.sshd.common.util.closeable.AbstractCloseable.close(AbstractCloseable.java:87)
	org.apache.sshd.common.session.helpers.SessionHelper.exceptionCaught(SessionHelper.java:1156)
	org.apache.sshd.common.session.helpers.AbstractSessionIoHandler.exceptionCaught(AbstractSessionIoHandler.java:53)
	org.apache.sshd.common.io.nio2.Nio2Session.exceptionCaught(Nio2Session.java:194)
	org.apache.sshd.common.io.nio2.Nio2Session.handleWriteCycleFailure(Nio2Session.java:493)
	org.apache.sshd.common.io.nio2.Nio2Session$2.onFailed(Nio2Session.java:448)
	org.apache.sshd.common.io.nio2.Nio2CompletionHandler.lambda$failed$1(Nio2CompletionHandler.java:46)
	org.apache.sshd.common.io.nio2.Nio2CompletionHandler$$Lambda$459/199474441.run(Unknown Source)
	java.security.AccessController.doPrivileged(Native Method)
	org.apache.sshd.common.io.nio2.Nio2CompletionHandler.failed(Nio2CompletionHandler.java:45)
	sun.nio.ch.Invoker.invokeUnchecked(Invoker.java:128)
	sun.nio.ch.Invoker.invokeDirect(Invoker.java:157)
	sun.nio.ch.UnixAsynchronousSocketChannelImpl.implWrite(UnixAsynchronousSocketChannelImpl.java:736)
	sun.nio.ch.AsynchronousSocketChannelImpl.write(AsynchronousSocketChannelImpl.java:382)
	sun.nio.ch.AsynchronousSocketChannelImpl.write(AsynchronousSocketChannelImpl.java:399)
	org.apache.sshd.common.io.nio2.Nio2Session.doWriteCycle(Nio2Session.java:434)
	org.apache.sshd.common.io.nio2.Nio2Session.startWriting(Nio2Session.java:418)
	org.apache.sshd.common.io.nio2.Nio2Session.writePacket(Nio2Session.java:177)
	org.apache.sshd.common.session.helpers.AbstractSession.doWritePacket(AbstractSession.java:919)
	org.apache.sshd.common.session.helpers.AbstractSession.sendPendingPackets(AbstractSession.java:759)
	org.apache.sshd.common.session.helpers.AbstractSession.handleNewKeys(AbstractSession.java:721)
	org.apache.sshd.common.session.helpers.AbstractSession.doHandleMessage(AbstractSession.java:444)
	org.apache.sshd.common.session.helpers.AbstractSession.handleMessage(AbstractSession.java:392)
	org.apache.sshd.common.session.helpers.AbstractSession.decode(AbstractSession.java:1304)
	org.apache.sshd.common.session.helpers.AbstractSession.messageReceived(AbstractSession.java:348)
	org.apache.sshd.common.session.helpers.AbstractSessionIoHandler.messageReceived(AbstractSessionIoHandler.java:63)
	org.apache.sshd.common.io.nio2.Nio2Session.handleReadCycleCompletion(Nio2Session.java:368)
	org.apache.sshd.common.io.nio2.Nio2Session$1.onCompleted(Nio2Session.java:346)
	org.apache.sshd.common.io.nio2.Nio2Session$1.onCompleted(Nio2Session.java:343)
	org.apache.sshd.common.io.nio2.Nio2CompletionHandler.lambda$completed$0(Nio2CompletionHandler.java:38)
	org.apache.sshd.common.io.nio2.Nio2CompletionHandler$$Lambda$381/1571388590.run(Unknown Source)
	java.security.AccessController.doPrivileged(Native Method)
	org.apache.sshd.common.io.nio2.Nio2CompletionHandler.completed(Nio2CompletionHandler.java:37)
	sun.nio.ch.Invoker.invokeUnchecked(Invoker.java:126)
	sun.nio.ch.Invoker$2.run(Invoker.java:218)
	sun.nio.ch.AsynchronousChannelGroupImpl$1.run(AsynchronousChannelGroupImpl.java:112)
	java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	java.lang.Thread.run(Thread.java:748)

"SSH git-upload-pack /project1 (mysuer)" prio=1 BLOCKED
	org.apache.sshd.common.session.helpers.AbstractSession.writePacket(AbstractSession.java:848)
	org.apache.sshd.common.channel.AbstractChannel.writePacket(AbstractChannel.java:785)
	org.apache.sshd.common.channel.ChannelOutputStream.flush(ChannelOutputStream.java:236)
	org.apache.sshd.common.channel.ChannelOutputStream.write(ChannelOutputStream.java:132)
	org.eclipse.jgit.transport.UploadPack$ResponseBufferedOutputStream.write(UploadPack.java:2183)
	org.eclipse.jgit.transport.SideBandOutputStream.writeBuffer(SideBandOutputStream.java:174)
	org.eclipse.jgit.transport.SideBandOutputStream.write(SideBandOutputStream.java:153)
	org.eclipse.jgit.internal.storage.pack.PackOutputStream.write(PackOutputStream.java:132)
	org.eclipse.jgit.internal.storage.file.ByteArrayWindow.write(ByteArrayWindow.java:91)
	org.eclipse.jgit.internal.storage.file.WindowCursor.copyPackAsIs(WindowCursor.java:284)
	org.eclipse.jgit.internal.storage.file.PackFile.copyPackAsIs(PackFile.java:425)
	org.eclipse.jgit.internal.storage.file.LocalCachedPack.copyAsIs(LocalCachedPack.java:86)
	org.eclipse.jgit.internal.storage.file.WindowCursor.copyPackAsIs(WindowCursor.java:272)
	org.eclipse.jgit.internal.storage.pack.PackWriter.writePack(PackWriter.java:1169)
	org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:2133)
	org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:1947)
	org.eclipse.jgit.transport.UploadPack.service(UploadPack.java:971)
	org.eclipse.jgit.transport.UploadPack.upload(UploadPack.java:776)
	com.google.gerrit.sshd.commands.Upload.runImpl(Upload.java:77)
	com.google.gerrit.sshd.AbstractGitCommand.service(AbstractGitCommand.java:99)
	com.google.gerrit.sshd.AbstractGitCommand.access$000(AbstractGitCommand.java:32)
	com.google.gerrit.sshd.AbstractGitCommand$1.run(AbstractGitCommand.java:64)
	com.google.gerrit.sshd.BaseCommand$TaskThunk.run(BaseCommand.java:469)
	com.google.gerrit.server.logging.LoggingContextAwareRunnable.run(LoggingContextAwareRunnable.java:83)
	java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	java.util.concurrent.FutureTask.run(FutureTask.java:266)
	java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	com.google.gerrit.server.git.WorkQueue$Task.run(WorkQueue.java:646)
	java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	java.lang.Thread.run(Thread.java:748)

"SSH git-upload-pack /project2 (mysuer)" prio=1 BLOCKED
	org.apache.sshd.common.session.helpers.AbstractSession.writePacket(AbstractSession.java:848)
	org.apache.sshd.common.channel.AbstractChannel.writePacket(AbstractChannel.java:785)
	org.apache.sshd.common.channel.ChannelOutputStream.flush(ChannelOutputStream.java:236)
	org.apache.sshd.common.channel.ChannelOutputStream.write(ChannelOutputStream.java:132)
	org.eclipse.jgit.transport.UploadPack$ResponseBufferedOutputStream.write(UploadPack.java:2183)
	org.eclipse.jgit.transport.SideBandOutputStream.writeBuffer(SideBandOutputStream.java:174)
	org.eclipse.jgit.transport.SideBandOutputStream.write(SideBandOutputStream.java:153)
	org.eclipse.jgit.internal.storage.pack.PackOutputStream.write(PackOutputStream.java:132)
	org.eclipse.jgit.internal.storage.file.ByteArrayWindow.write(ByteArrayWindow.java:91)
	org.eclipse.jgit.internal.storage.file.WindowCursor.copyPackAsIs(WindowCursor.java:284)
	org.eclipse.jgit.internal.storage.file.PackFile.copyPackAsIs(PackFile.java:425)
	org.eclipse.jgit.internal.storage.file.LocalCachedPack.copyAsIs(LocalCachedPack.java:86)
	org.eclipse.jgit.internal.storage.file.WindowCursor.copyPackAsIs(WindowCursor.java:272)
	org.eclipse.jgit.internal.storage.pack.PackWriter.writePack(PackWriter.java:1169)
	org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:2133)
	org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:1947)
	org.eclipse.jgit.transport.UploadPack.service(UploadPack.java:971)
	org.eclipse.jgit.transport.UploadPack.upload(UploadPack.java:776)
	com.google.gerrit.sshd.commands.Upload.runImpl(Upload.java:77)
	com.google.gerrit.sshd.AbstractGitCommand.service(AbstractGitCommand.java:99)
	com.google.gerrit.sshd.AbstractGitCommand.access$000(AbstractGitCommand.java:32)
	com.google.gerrit.sshd.AbstractGitCommand$1.run(AbstractGitCommand.java:64)
	com.google.gerrit.sshd.BaseCommand$TaskThunk.run(BaseCommand.java:469)
	com.google.gerrit.server.logging.LoggingContextAwareRunnable.run(LoggingContextAwareRunnable.java:83)
	java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	java.util.concurrent.FutureTask.run(FutureTask.java:266)
	java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	com.google.gerrit.server.git.WorkQueue$Task.run(WorkQueue.java:646)
	java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	java.lang.Thread.run(Thread.java:748)
{noformat}


Thanks - I'll see when I can get to it - meanwhile you did gain something - you upgraded to the latest version of SSHD...

FTR: SSHD Upgrade to 2.4 version is here: [1] and here: [2].

[~Typz] Are you aware of this thread: [3], with this solution suggestion: [4]?

{noformat}
To cut a long story short after much trial, we fixed the issue by add 
	sshd.rekeyBytesLimit = 0
	sshd.rekeyTimeLimit = 0
to the gerrit config.
{noformat}

This was added by Gustaf in: [4].

[1] https://gerrit-review.googlesource.com/c/gerrit/+/254658
[2] https://gerrit-review.googlesource.com/c/gerrit/+/258152
[3] https://groups.google.com/d/topic/repo-discuss/wx75Ox5_v7o/discussion
[4] https://gerrit.googlesource.com/gerrit/+/6f721702f07249c4babdd6d32d87765005081dcc

I see the problem, but will have to think some more about a solution....

I believe I have a possible solution - see https://github.com/lgoldstein/mina-sshd/tree/SSHD-966. I would appreciate it if you could test it and let me know. You are more than welcome to also review the associated PR (https://github.com/apache/mina-sshd/pull/117)

[~lgoldstein] Thanks for the quick fix, very much appreciated. To test your PR, can we download somewhere the final artifact?

Sorry, I spoke too soon - the code has a bug inasmuch as if there is a lot of traffic the KEX state might never be marked as {{DONE}} (or marked as such very late). Back to the drawing board...

I have tried several workarounds - but none successful. This is a tough one - still looking....  Basically, the problem is that we need to flush all the pending messages that were accumulated while KEX was in progress and then mark KEX as DONE. However, we must do this while preventing other packets from being sent until flush is complete. I have thought about using a dedicated +thread+ that waits on a pending outgoing queue of messages - it would solve this issue, but raise others - e.g., the need to return an {{IOWriteFuture}} from {{writePacket}} (possible, but adds non-trivial complexity).

any ideas ?

maybe adding a extra KexState state for FLUSHING :
 * When key exchange has completed, instead of marking KEX as DONE,
 ** if queue is empty, just mark KEX as DONE ;
 ** else, take the first packet from queue and set KEX as FLUSHING, then send the packet ;
 * when packet is sent, repeat the same process until the queue is empty
 * if application needs to send some other packets while in this FLUSHING state, they are simply queued (like during the actual KEX)
 * if another KEX happens while in this state, nothing special to do I think: only need to take care that the queue is not cleared...

Something roughly like this should work I think, but I have no idea how big a change it means or if there are other impacts...

I will take a closer look at the suggestion but from my initial review it looks a lot like what I was trying to do when I spoke too soon about having found a solution. The problem remains the same - if there is enough traffic then the KEX  state remains FLUSHING. Furthermore, the traffic is slowed down significantly since all packets must be queued and then dequeued and sent via {{synchronized}} mechanisms.

Moreover, some code might actually rely on the {{IoWriteFuture}} returned from {{writePacket}} - in which case we need to establish some equivalent (IMO complex) mechanism.

Last but not least - introducing a new KEX state to what already is a complex state machine is likely to introduce bugs and destabilize the code.

You have given me some ideas to explore though - perhaps one of them will pan out. Thanks for the response.

Hello! Could you make any progress on a fix?

On Gerrit side, I have been playing with the idea of setting [MAX_CONCURRENT_CHANNELS_PROP|https://javadoc.io/static/org.apache.sshd/sshd-core/2.3.0/org/apache/sshd/common/session/helpers/AbstractConnectionService.html#MAX_CONCURRENT_CHANNELS_PROP] property to 1, to actually disable multiplexing and avoid the issue for now. However, I could not find a how this property is expected to be set; should I subclass the ServerConnectionServiceFactory class, so I can tweak the properties of the session/connectionService ?

{quote}
Hello! Could you make any progress on a fix?
{quote}
Sorry - have tried 2-3 new approaches but they did not pan out - I am waiting for some inspiration.

{quote}
On Gerrit side, I have been playing with the idea of setting MAX_CONCURRENT_CHANNELS_PROP property to 1, to actually disable multiplexing and avoid the issue for now. However, I could not find a how this property is expected to be set
{quote}
Easy - call {{PropertyResolverUtils#updateProperty(..., MAX_CONCURRENT_CHANNELS_PROP, 1)}} where first argument can be either the client/server or the session. The difference is that if the property is set on the client/server then it is +global+ (i.e. applies to all sessions) vs +specific+ to the relevant session. See [Properties and inheritance model|https://github.com/apache/mina-sshd/blob/master/docs/internals.md#properties-and-inheritance-model] section of the documentation

I think this issue in Gerrit: [1] and the corresponding SSHD-779 (that was closed because we did not know how to reproduce it) is exactly the same issue.

[1] [https://bugs.chromium.org/p/gerrit/issues/detail?id=7486]

Looks very similar indeed...

{quote}
Looks very similar indeed...
{quote}

According to the SSHD-779, the problem only occurs in {{NIO2}} backend, so that the blatantly workaround would just be: [1], correct?

[~lgoldstein] Can you comment on performance implication for disabling multiplexing? Also can you see why the same problem would not happen in {{MINA}} backend? Or is that the problem reporter was just lucky and the problem could also happen in {{MINA}} backend and we should rather disable the multiplexing on both backends?

[1] https://gerrit-review.googlesource.com/c/gerrit/+/267615

{quote}
Can you comment on performance implication for disabling multiplexing? Also can you see why the same problem would not happen in MINA backend? Or is that the problem reporter was just lucky and the problem could also happen in MINA backend and we should rather disable the multiplexing on both backends?
{quote}
Not really - hard to tell. I do have another idea that seems hopeful (like those before it...) - cross your fingers...

[~davido2] I published https://github.com/apache/mina-sshd/pull/131 that IMO seems to fix this issue. I would appreciate some review on it. It's not very elegant but it does have several advantages:

* The cooperating classes use a single lock instead of 2
* Even if there is a deadlock it will eventually time out after at most ~2 min. so at least the code won't hang

If  you want to test the code you can clone it at https://github.com/lgoldstein/mina-sshd/tree/SSHD-966
Let me know...
Thanks.

Thanks for the next attempt to fix it.

I conducted this custom release to consume the build from Gerrit: [1] and uploaded this CL: [2] to switch to using sshd-2.4.1-SNAPSHOT build. While unit tests are passing, the stress test is still failing as reported by [~Typz] in: [2]

{quote}
Server-side, I still get the deadlock, and it still there ~30min later.
{quote}

[1] https://github.com/davido/mina-sshd/releases/tag/SSHD-966
[2] https://gerrit-review.googlesource.com/c/gerrit/+/267747


{quote}
Server-side, I still get the deadlock, and it still there ~30min later.
{quote}
Is it the same flow or some new deadlock ? Can we tell in any way ?

Checking the backtrace right now, but it does not seem to match with the code form your fork :-/

Here is the relevant part of the thread dumps:
{code:java}
"SSH git-upload-pack /aosp/cts (francois)" prio=1 BLOCKED
	org.apache.sshd.common.session.helpers.AbstractSession.writePacket(AbstractSession.java:1107)
	org.apache.sshd.common.channel.AbstractChannel.writePacket(AbstractChannel.java:798)
	org.apache.sshd.common.channel.ChannelOutputStream.flush(ChannelOutputStream.java:227)
	org.apache.sshd.common.channel.ChannelOutputStream.write(ChannelOutputStream.java:127)
	org.eclipse.jgit.transport.UploadPack$ResponseBufferedOutputStream.write(UploadPack.java:2183)
	org.eclipse.jgit.transport.SideBandOutputStream.writeBuffer(SideBandOutputStream.java:174)
	org.eclipse.jgit.transport.SideBandOutputStream.write(SideBandOutputStream.java:153)
	org.eclipse.jgit.internal.storage.pack.PackOutputStream.write(PackOutputStream.java:132)
	org.eclipse.jgit.internal.storage.file.ByteArrayWindow.write(ByteArrayWindow.java:91)
	org.eclipse.jgit.internal.storage.file.WindowCursor.copyPackAsIs(WindowCursor.java:284)
	org.eclipse.jgit.internal.storage.file.PackFile.copyPackAsIs(PackFile.java:425)
	org.eclipse.jgit.internal.storage.file.LocalCachedPack.copyAsIs(LocalCachedPack.java:86)
	org.eclipse.jgit.internal.storage.file.WindowCursor.copyPackAsIs(WindowCursor.java:272)
	org.eclipse.jgit.internal.storage.pack.PackWriter.writePack(PackWriter.java:1169)
	org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:2133)
	org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:1947)
	org.eclipse.jgit.transport.UploadPack.service(UploadPack.java:971)
	org.eclipse.jgit.transport.UploadPack.upload(UploadPack.java:776)
	com.google.gerrit.sshd.commands.Upload.runImpl(Upload.java:77)
	com.google.gerrit.sshd.AbstractGitCommand.service(AbstractGitCommand.java:98)
	com.google.gerrit.sshd.AbstractGitCommand.access$000(AbstractGitCommand.java:31)
	com.google.gerrit.sshd.AbstractGitCommand$1.run(AbstractGitCommand.java:63)
	com.google.gerrit.sshd.BaseCommand$TaskThunk.run(BaseCommand.java:467)
	com.google.gerrit.server.logging.LoggingContextAwareRunnable.run(LoggingContextAwareRunnable.java:83)
	java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	java.util.concurrent.FutureTask.run(FutureTask.java:266)
	
"SSH git-upload-pack /aosp/prebuilts/tools (francois)" prio=1 BLOCKED
	org.apache.sshd.common.session.helpers.AbstractSession.writePacket(AbstractSession.java:1107)
	org.apache.sshd.common.channel.AbstractChannel.writePacket(AbstractChannel.java:798)
	org.apache.sshd.common.channel.ChannelOutputStream.flush(ChannelOutputStream.java:227)
	org.apache.sshd.common.channel.ChannelOutputStream.write(ChannelOutputStream.java:127)
	org.eclipse.jgit.transport.UploadPack$ResponseBufferedOutputStream.write(UploadPack.java:2183)
	org.eclipse.jgit.transport.SideBandOutputStream.writeBuffer(SideBandOutputStream.java:174)
	org.eclipse.jgit.transport.SideBandOutputStream.write(SideBandOutputStream.java:153)
	org.eclipse.jgit.internal.storage.pack.PackOutputStream.write(PackOutputStream.java:132)
	org.eclipse.jgit.internal.storage.file.PackFile.copyAsIs2(PackFile.java:614)
	org.eclipse.jgit.internal.storage.file.PackFile.copyAsIs(PackFile.java:433)
	org.eclipse.jgit.internal.storage.file.WindowCursor.copyObjectAsIs(WindowCursor.java:221)
	org.eclipse.jgit.internal.storage.pack.PackWriter.writeObjectImpl(PackWriter.java:1644)
	org.eclipse.jgit.internal.storage.pack.PackWriter.writeObject(PackWriter.java:1621)
	org.eclipse.jgit.internal.storage.pack.PackOutputStream.writeObject(PackOutputStream.java:171)
	org.eclipse.jgit.internal.storage.file.WindowCursor.writeObjects(WindowCursor.java:229)
	org.eclipse.jgit.internal.storage.pack.PackWriter.writeObjects(PackWriter.java:1609)
	org.eclipse.jgit.internal.storage.pack.PackWriter.writeObjects(PackWriter.java:1597)
	org.eclipse.jgit.internal.storage.pack.PackWriter.writePack(PackWriter.java:1154)
	org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:2133)
	org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:1947)
	org.eclipse.jgit.transport.UploadPack.service(UploadPack.java:971)
	org.eclipse.jgit.transport.UploadPack.upload(UploadPack.java:776)
	com.google.gerrit.sshd.commands.Upload.runImpl(Upload.java:77)
	com.google.gerrit.sshd.AbstractGitCommand.service(AbstractGitCommand.java:98)
	com.google.gerrit.sshd.AbstractGitCommand.access$000(AbstractGitCommand.java:31)
	com.google.gerrit.sshd.AbstractGitCommand$1.run(AbstractGitCommand.java:63)
	com.google.gerrit.sshd.BaseCommand$TaskThunk.run(BaseCommand.java:467)
	com.google.gerrit.server.logging.LoggingContextAwareRunnable.run(LoggingContextAwareRunnable.java:83)
	java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	java.util.concurrent.FutureTask.run(FutureTask.java:266)

"sshd-SshServer[20d92f1e]-nio2-thread-1" daemon prio=5 BLOCKED
	org.apache.sshd.common.channel.ChannelOutputStream.close(ChannelOutputStream.java:249)
	org.apache.sshd.common.util.io.IoUtils.closeQuietly(IoUtils.java:151)
	org.apache.sshd.server.channel.ChannelSession.doCloseImmediately(ChannelSession.java:205)
	org.apache.sshd.common.util.closeable.AbstractCloseable.close(AbstractCloseable.java:83)
	org.apache.sshd.common.channel.AbstractChannel.close(AbstractChannel.java:576)
	org.apache.sshd.common.util.closeable.ParallelCloseable.doClose(ParallelCloseable.java:65)
	org.apache.sshd.common.util.closeable.SimpleCloseable.close(SimpleCloseable.java:63)
	org.apache.sshd.common.util.closeable.AbstractInnerCloseable.doCloseImmediately(AbstractInnerCloseable.java:46)
	org.apache.sshd.common.util.closeable.AbstractCloseable.close(AbstractCloseable.java:83)
	org.apache.sshd.common.util.closeable.ParallelCloseable.doClose(ParallelCloseable.java:65)
	org.apache.sshd.common.util.closeable.SimpleCloseable.close(SimpleCloseable.java:63)
	org.apache.sshd.common.util.closeable.SequentialCloseable$1.operationComplete(SequentialCloseable.java:56)
	org.apache.sshd.common.util.closeable.SequentialCloseable$1.operationComplete(SequentialCloseable.java:45)
	org.apache.sshd.common.util.closeable.SequentialCloseable.doClose(SequentialCloseable.java:69)
	org.apache.sshd.common.util.closeable.SimpleCloseable.close(SimpleCloseable.java:63)
	org.apache.sshd.common.util.closeable.AbstractInnerCloseable.doCloseImmediately(AbstractInnerCloseable.java:46)
	org.apache.sshd.common.util.closeable.AbstractCloseable.close(AbstractCloseable.java:83)
	org.apache.sshd.common.session.helpers.AbstractSession.exceptionCaught(AbstractSession.java:973)
	org.apache.sshd.common.session.helpers.AbstractSessionIoHandler.exceptionCaught(AbstractSessionIoHandler.java:53)
	org.apache.sshd.common.io.nio2.Nio2Session.exceptionCaught(Nio2Session.java:186)
	org.apache.sshd.common.io.nio2.Nio2Session.handleWriteCycleFailure(Nio2Session.java:460)
	org.apache.sshd.common.io.nio2.Nio2Session$2.onFailed(Nio2Session.java:415)
	org.apache.sshd.common.io.nio2.Nio2CompletionHandler.lambda$failed$1(Nio2CompletionHandler.java:46)
	org.apache.sshd.common.io.nio2.Nio2CompletionHandler$$Lambda$435/1722053589.run(Unknown Source)
	java.security.AccessController.doPrivileged(Native Method)
	org.apache.sshd.common.io.nio2.Nio2CompletionHandler.failed(Nio2CompletionHandler.java:45)
	sun.nio.ch.Invoker.invokeUnchecked(Invoker.java:128)
	sun.nio.ch.Invoker.invokeDirect(Invoker.java:157)
	sun.nio.ch.UnixAsynchronousSocketChannelImpl.implWrite(UnixAsynchronousSocketChannelImpl.java:736)
	sun.nio.ch.AsynchronousSocketChannelImpl.write(AsynchronousSocketChannelImpl.java:382)
	sun.nio.ch.AsynchronousSocketChannelImpl.write(AsynchronousSocketChannelImpl.java:399)
	org.apache.sshd.common.io.nio2.Nio2Session.doWriteCycle(Nio2Session.java:401)
	org.apache.sshd.common.io.nio2.Nio2Session.startWriting(Nio2Session.java:386)
	org.apache.sshd.common.io.nio2.Nio2Session.writePacket(Nio2Session.java:169)
	org.apache.sshd.common.session.helpers.AbstractSession.doWritePacket(AbstractSession.java:1181)
	org.apache.sshd.common.session.helpers.AbstractSession.sendPendingPackets(AbstractSession.java:910)
	org.apache.sshd.common.session.helpers.AbstractSession.handleNewKeys(AbstractSession.java:875)
	org.apache.sshd.common.session.helpers.AbstractSession.doHandleMessage(AbstractSession.java:606)
	org.apache.sshd.common.session.helpers.AbstractSession.handleMessage(AbstractSession.java:555)
	org.apache.sshd.common.session.helpers.AbstractSession.decode(AbstractSession.java:1527)
	org.apache.sshd.common.session.helpers.AbstractSession.messageReceived(AbstractSession.java:516)
	org.apache.sshd.common.session.helpers.AbstractSessionIoHandler.messageReceived(AbstractSessionIoHandler.java:63)
	org.apache.sshd.common.io.nio2.Nio2Session.handleReadCycleCompletion(Nio2Session.java:339)
	org.apache.sshd.common.io.nio2.Nio2Session$1.onCompleted(Nio2Session.java:318)
	org.apache.sshd.common.io.nio2.Nio2Session$1.onCompleted(Nio2Session.java:315)
	org.apache.sshd.common.io.nio2.Nio2CompletionHandler.lambda$completed$0(Nio2CompletionHandler.java:38)
	org.apache.sshd.common.io.nio2.Nio2CompletionHandler$$Lambda$312/866347029.run(Unknown Source)
	java.security.AccessController.doPrivileged(Native Method)
	org.apache.sshd.common.io.nio2.Nio2CompletionHandler.completed(Nio2CompletionHandler.java:37)
	sun.nio.ch.Invoker.invokeUnchecked(Invoker.java:126)
	sun.nio.ch.Invoker$2.run(Invoker.java:218)
	sun.nio.ch.AsynchronousChannelGroupImpl$1.run(AsynchronousChannelGroupImpl.java:112)
	java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	java.lang.Thread.run(Thread.java:748)
{code}

Sorry for the confusion.
I will recompile everything and perform the test again, from scratch, to confirm.

After debugging my build/deploy issues, I am happy to report it seems to run much better indeed! Sorry for my earlier report, and kudos for finding a fix! I have lots of errors (as expected since I try to cause some timeouts while rekying...), I still need to verify the logs to confirm nothing fishy there. I will also continue stressing this out, and let you know.

One small (?) issue though: I get quite a few warnings which look like this:

{code:java}
WARN  org.apache.sshd.common.future.DefaultCloseFuture : notifyListener(DefaultCloseFuture[id=Builder][value=true]) failed (RuntimeSshException) to invoke org.apache.sshd.common.util.closeable.SequentialCloseable$1@42b3beb5: null
{code}

Is this ok?


{quote}
WARN  org.apache.sshd.common.future.DefaultCloseFuture : notifyListener(DefaultCloseFuture[id=Builder][value=true]) failed (RuntimeSshException) to invoke org.apache.sshd.common.util.closeable.SequentialCloseable$1@42b3beb5: null

Is this ok?
{quote}
Thanks for bringing it to my attention - I will look into it (though I do not believe it is related to this issue).

{quote}
 I am happy to report it seems to run much better indeed! Sorry for my earlier report, and kudos for finding a fix! I have lots of errors (as expected since I try to cause some timeouts while rekying...), I still need to verify the logs to confirm nothing fishy there.
{quote}
Indeed, let's make sure we do not introduce "noise" that might mask out the fix...

{quote}
 I will also continue stressing this out, and let you know.
{quote}
Sounds promising - let me know.

Still need to dig into the logs, but there are really lots of errors. Even without multiplexing I get lots of errors, so I suspect there may be some issue...
But still not deadlock so far, looking good on that side (y)

{quote}
Even without multiplexing I get lots of errors, so I suspect there may be some issue...
{quote}
If you think they originate from SSHD please add them to this issue - perhaps I  can shed some light on it.

There is definitely an issue. When downloading a single (large), after having reduced the rekey limits (100M / 1min), I get the following:

{code:java}
$ git clone ssh://gerrit/aosp/external/linux-kselftest
Cloning into 'linux-kselftest'...
remote: Counting objects: 6370616, done
remote: Finding sources: 100% (6370616/6370616)
fatal: internal server error086/6370616), 199.75 MiB | 4.24 MiB/s
fatal: the remote end hung up unexpectedly
fatal: early EOF
fatal: index-pack failed
{code}

Actually, it fails after having retrieved ~200MiB, after getting stuck there for some time.
Note that another time it failed at ~100MiB, so this is not just about the second rekey:

{code:java}
$ git clone ssh://gerrit/aosp/external/linux-kselftest
Cloning into 'linux-kselftest'...
remote: Counting objects: 6370616, done
remote: Finding sources: 100% (6370616/6370616)
fatal: internal server error479/6370616), 99.85 MiB | 3.06 MiB/s
fatal: the remote end hung up unexpectedly
fatal: early EOF
fatal: index-pack failed
{code}

Here is the logs (for both attempts):

{code:java}
[2020-05-18 18:38:36,913] [SSH git-upload-pack aosp/external/linux-kselftest (francois)] ERROR org.apache.sshd.server.channel.ChannelSession : lockedFlush(ChannelOutputStream[ChannelSession[id=0, recipient=0]-ServerSessionImpl[francois@/172.16.0.10:51178]] SSH_MSG_CHANNEL_DATA) failed (SocketTimeoutException) to wait for space of len=20480: waitForCondition(Window[server/remote](ChannelSession[id=0, recipient=0]-ServerSessionImpl[francois@/172.16.0.10:51178])) timeout exceeded: 30000
[2020-05-18 18:38:36,913] [SSH git-upload-pack aosp/external/linux-kselftest (francois)] ERROR org.apache.sshd.server.channel.ChannelSession : write(ChannelOutputStream[ChannelSession[id=0, recipient=0]-ServerSessionImpl[francois@/172.16.0.10:51178]] SSH_MSG_CHANNEL_DATA) len=65520 failed to write
java.net.SocketTimeoutException: waitForCondition(Window[server/remote](ChannelSession[id=0, recipient=0]-ServerSessionImpl[francois@/172.16.0.10:51178])) timeout exceeded: 30000
	at org.apache.sshd.common.channel.Window.waitForCondition(Window.java:307)
	at org.apache.sshd.common.channel.Window.waitForSpace(Window.java:255)
	at org.apache.sshd.common.channel.ChannelOutputStream.lockedFlush(ChannelOutputStream.java:275)
	at org.apache.sshd.common.channel.ChannelOutputStream.lockedWrite(ChannelOutputStream.java:175)
	at org.apache.sshd.common.channel.ChannelOutputStream.lambda$write$1(ChannelOutputStream.java:138)
	at org.apache.sshd.common.session.helpers.AbstractSession.executeUnderPendingPacketsLock(AbstractSession.java:691)
	at org.apache.sshd.common.channel.ChannelOutputStream.write(ChannelOutputStream.java:136)
	at org.eclipse.jgit.transport.UploadPack$ResponseBufferedOutputStream.write(UploadPack.java:2387)
	at org.eclipse.jgit.transport.SideBandOutputStream.writeBuffer(SideBandOutputStream.java:141)
	at org.eclipse.jgit.transport.SideBandOutputStream.write(SideBandOutputStream.java:120)
	at org.eclipse.jgit.internal.storage.pack.PackOutputStream.write(PackOutputStream.java:99)
	at org.eclipse.jgit.internal.storage.file.PackFile.copyAsIs2(PackFile.java:564)
	at org.eclipse.jgit.internal.storage.file.PackFile.copyAsIs(PackFile.java:399)
	at org.eclipse.jgit.internal.storage.file.WindowCursor.copyObjectAsIs(WindowCursor.java:188)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writeObjectImpl(PackWriter.java:1703)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writeObject(PackWriter.java:1680)
	at org.eclipse.jgit.internal.storage.pack.PackOutputStream.writeObject(PackOutputStream.java:138)
	at org.eclipse.jgit.internal.storage.file.WindowCursor.writeObjects(WindowCursor.java:196)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writeObjects(PackWriter.java:1668)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writeObjects(PackWriter.java:1653)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writePack(PackWriter.java:1214)
	at org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:2328)
	at org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:2164)
	at org.eclipse.jgit.transport.UploadPack.service(UploadPack.java:1078)
	at org.eclipse.jgit.transport.UploadPack.uploadWithExceptionPropagation(UploadPack.java:835)
	at org.eclipse.jgit.transport.UploadPack.upload(UploadPack.java:749)
	at com.google.gerrit.sshd.commands.Upload.runImpl(Upload.java:78)
	at com.google.gerrit.sshd.AbstractGitCommand.service(AbstractGitCommand.java:99)
	at com.google.gerrit.sshd.AbstractGitCommand.access$000(AbstractGitCommand.java:32)
	at com.google.gerrit.sshd.AbstractGitCommand$1.run(AbstractGitCommand.java:64)
	at com.google.gerrit.sshd.BaseCommand$TaskThunk.run(BaseCommand.java:469)
	at com.google.gerrit.server.logging.LoggingContextAwareRunnable.run(LoggingContextAwareRunnable.java:83)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	at com.google.gerrit.server.git.WorkQueue$Task.run(WorkQueue.java:646)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
[2020-05-18 18:38:36,929] [SSH git-upload-pack aosp/external/linux-kselftest (francois)] ERROR com.google.gerrit.sshd.BaseCommand : Internal server error (user francois account 1000002) during git-upload-pack 'aosp/external/linux-kselftest'
org.eclipse.jgit.transport.UploadPackInternalServerErrorException
	at org.eclipse.jgit.transport.UploadPack.upload(UploadPack.java:772)
	at com.google.gerrit.sshd.commands.Upload.runImpl(Upload.java:78)
	at com.google.gerrit.sshd.AbstractGitCommand.service(AbstractGitCommand.java:99)
	at com.google.gerrit.sshd.AbstractGitCommand.access$000(AbstractGitCommand.java:32)
	at com.google.gerrit.sshd.AbstractGitCommand$1.run(AbstractGitCommand.java:64)
	at com.google.gerrit.sshd.BaseCommand$TaskThunk.run(BaseCommand.java:469)
	at com.google.gerrit.server.logging.LoggingContextAwareRunnable.run(LoggingContextAwareRunnable.java:83)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	at com.google.gerrit.server.git.WorkQueue$Task.run(WorkQueue.java:646)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.net.SocketTimeoutException: waitForCondition(Window[server/remote](ChannelSession[id=0, recipient=0]-ServerSessionImpl[francois@/172.16.0.10:51178])) timeout exceeded: 30000
	at org.apache.sshd.common.channel.Window.waitForCondition(Window.java:307)
	at org.apache.sshd.common.channel.Window.waitForSpace(Window.java:255)
	at org.apache.sshd.common.channel.ChannelOutputStream.lockedFlush(ChannelOutputStream.java:275)
	at org.apache.sshd.common.channel.ChannelOutputStream.lockedWrite(ChannelOutputStream.java:175)
	at org.apache.sshd.common.channel.ChannelOutputStream.lambda$write$1(ChannelOutputStream.java:138)
	at org.apache.sshd.common.session.helpers.AbstractSession.executeUnderPendingPacketsLock(AbstractSession.java:691)
	at org.apache.sshd.common.channel.ChannelOutputStream.write(ChannelOutputStream.java:136)
	at org.eclipse.jgit.transport.UploadPack$ResponseBufferedOutputStream.write(UploadPack.java:2387)
	at org.eclipse.jgit.transport.SideBandOutputStream.writeBuffer(SideBandOutputStream.java:141)
	at org.eclipse.jgit.transport.SideBandOutputStream.write(SideBandOutputStream.java:120)
	at org.eclipse.jgit.internal.storage.pack.PackOutputStream.write(PackOutputStream.java:99)
	at org.eclipse.jgit.internal.storage.file.PackFile.copyAsIs2(PackFile.java:564)
	at org.eclipse.jgit.internal.storage.file.PackFile.copyAsIs(PackFile.java:399)
	at org.eclipse.jgit.internal.storage.file.WindowCursor.copyObjectAsIs(WindowCursor.java:188)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writeObjectImpl(PackWriter.java:1703)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writeObject(PackWriter.java:1680)
	at org.eclipse.jgit.internal.storage.pack.PackOutputStream.writeObject(PackOutputStream.java:138)
	at org.eclipse.jgit.internal.storage.file.WindowCursor.writeObjects(WindowCursor.java:196)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writeObjects(PackWriter.java:1668)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writeObjects(PackWriter.java:1653)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writePack(PackWriter.java:1214)
	at org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:2328)
	at org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:2164)
	at org.eclipse.jgit.transport.UploadPack.service(UploadPack.java:1078)
	at org.eclipse.jgit.transport.UploadPack.uploadWithExceptionPropagation(UploadPack.java:835)
	at org.eclipse.jgit.transport.UploadPack.upload(UploadPack.java:749)
	... 14 more

[2020-05-18 18:43:06,336] [SSH git-upload-pack aosp/external/linux-kselftest (francois)] ERROR org.apache.sshd.server.channel.ChannelSession : lockedFlush(ChannelOutputStream[ChannelSession[id=0, recipient=0]-ServerSessionImpl[francois@/172.16.0.10:52292]] SSH_MSG_CHANNEL_DATA) failed (SocketTimeoutException) to wait for space of len=28672: waitForCondition(Window[server/remote](ChannelSession[id=0, recipient=0]-ServerSessionImpl[francois@/172.16.0.10:52292])) timeout exceeded: 30000
[2020-05-18 18:43:06,337] [SSH git-upload-pack aosp/external/linux-kselftest (francois)] ERROR org.apache.sshd.server.channel.ChannelSession : write(ChannelOutputStream[ChannelSession[id=0, recipient=0]-ServerSessionImpl[francois@/172.16.0.10:52292]] SSH_MSG_CHANNEL_DATA) len=65520 failed to write
java.net.SocketTimeoutException: waitForCondition(Window[server/remote](ChannelSession[id=0, recipient=0]-ServerSessionImpl[francois@/172.16.0.10:52292])) timeout exceeded: 30000
	at org.apache.sshd.common.channel.Window.waitForCondition(Window.java:307)
	at org.apache.sshd.common.channel.Window.waitForSpace(Window.java:255)
	at org.apache.sshd.common.channel.ChannelOutputStream.lockedFlush(ChannelOutputStream.java:275)
	at org.apache.sshd.common.channel.ChannelOutputStream.lockedWrite(ChannelOutputStream.java:175)
	at org.apache.sshd.common.channel.ChannelOutputStream.lambda$write$1(ChannelOutputStream.java:138)
	at org.apache.sshd.common.session.helpers.AbstractSession.executeUnderPendingPacketsLock(AbstractSession.java:691)
	at org.apache.sshd.common.channel.ChannelOutputStream.write(ChannelOutputStream.java:136)
	at org.eclipse.jgit.transport.UploadPack$ResponseBufferedOutputStream.write(UploadPack.java:2387)
	at org.eclipse.jgit.transport.SideBandOutputStream.writeBuffer(SideBandOutputStream.java:141)
	at org.eclipse.jgit.transport.SideBandOutputStream.write(SideBandOutputStream.java:120)
	at org.eclipse.jgit.internal.storage.pack.PackOutputStream.write(PackOutputStream.java:99)
	at org.eclipse.jgit.internal.storage.file.ByteArrayWindow.write(ByteArrayWindow.java:58)
	at org.eclipse.jgit.internal.storage.file.PackFile.copyAsIs2(PackFile.java:547)
	at org.eclipse.jgit.internal.storage.file.PackFile.copyAsIs(PackFile.java:399)
	at org.eclipse.jgit.internal.storage.file.WindowCursor.copyObjectAsIs(WindowCursor.java:188)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writeObjectImpl(PackWriter.java:1703)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writeObject(PackWriter.java:1680)
	at org.eclipse.jgit.internal.storage.pack.PackOutputStream.writeObject(PackOutputStream.java:138)
	at org.eclipse.jgit.internal.storage.file.WindowCursor.writeObjects(WindowCursor.java:196)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writeObjects(PackWriter.java:1668)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writeObjects(PackWriter.java:1653)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writePack(PackWriter.java:1214)
	at org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:2328)
	at org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:2164)
	at org.eclipse.jgit.transport.UploadPack.service(UploadPack.java:1078)
	at org.eclipse.jgit.transport.UploadPack.uploadWithExceptionPropagation(UploadPack.java:835)
	at org.eclipse.jgit.transport.UploadPack.upload(UploadPack.java:749)
	at com.google.gerrit.sshd.commands.Upload.runImpl(Upload.java:78)
	at com.google.gerrit.sshd.AbstractGitCommand.service(AbstractGitCommand.java:99)
	at com.google.gerrit.sshd.AbstractGitCommand.access$000(AbstractGitCommand.java:32)
	at com.google.gerrit.sshd.AbstractGitCommand$1.run(AbstractGitCommand.java:64)
	at com.google.gerrit.sshd.BaseCommand$TaskThunk.run(BaseCommand.java:469)
	at com.google.gerrit.server.logging.LoggingContextAwareRunnable.run(LoggingContextAwareRunnable.java:83)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	at com.google.gerrit.server.git.WorkQueue$Task.run(WorkQueue.java:646)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
[2020-05-18 18:43:06,348] [SSH git-upload-pack aosp/external/linux-kselftest (francois)] ERROR com.google.gerrit.sshd.BaseCommand : Internal server error (user francois account 1000002) during git-upload-pack 'aosp/external/linux-kselftest'
org.eclipse.jgit.transport.UploadPackInternalServerErrorException
	at org.eclipse.jgit.transport.UploadPack.upload(UploadPack.java:772)
	at com.google.gerrit.sshd.commands.Upload.runImpl(Upload.java:78)
	at com.google.gerrit.sshd.AbstractGitCommand.service(AbstractGitCommand.java:99)
	at com.google.gerrit.sshd.AbstractGitCommand.access$000(AbstractGitCommand.java:32)
	at com.google.gerrit.sshd.AbstractGitCommand$1.run(AbstractGitCommand.java:64)
	at com.google.gerrit.sshd.BaseCommand$TaskThunk.run(BaseCommand.java:469)
	at com.google.gerrit.server.logging.LoggingContextAwareRunnable.run(LoggingContextAwareRunnable.java:83)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	at com.google.gerrit.server.git.WorkQueue$Task.run(WorkQueue.java:646)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.net.SocketTimeoutException: waitForCondition(Window[server/remote](ChannelSession[id=0, recipient=0]-ServerSessionImpl[francois@/172.16.0.10:52292])) timeout exceeded: 30000
	at org.apache.sshd.common.channel.Window.waitForCondition(Window.java:307)
	at org.apache.sshd.common.channel.Window.waitForSpace(Window.java:255)
	at org.apache.sshd.common.channel.ChannelOutputStream.lockedFlush(ChannelOutputStream.java:275)
	at org.apache.sshd.common.channel.ChannelOutputStream.lockedWrite(ChannelOutputStream.java:175)
	at org.apache.sshd.common.channel.ChannelOutputStream.lambda$write$1(ChannelOutputStream.java:138)
	at org.apache.sshd.common.session.helpers.AbstractSession.executeUnderPendingPacketsLock(AbstractSession.java:691)
	at org.apache.sshd.common.channel.ChannelOutputStream.write(ChannelOutputStream.java:136)
	at org.eclipse.jgit.transport.UploadPack$ResponseBufferedOutputStream.write(UploadPack.java:2387)
	at org.eclipse.jgit.transport.SideBandOutputStream.writeBuffer(SideBandOutputStream.java:141)
	at org.eclipse.jgit.transport.SideBandOutputStream.write(SideBandOutputStream.java:120)
	at org.eclipse.jgit.internal.storage.pack.PackOutputStream.write(PackOutputStream.java:99)
	at org.eclipse.jgit.internal.storage.file.ByteArrayWindow.write(ByteArrayWindow.java:58)
	at org.eclipse.jgit.internal.storage.file.PackFile.copyAsIs2(PackFile.java:547)
	at org.eclipse.jgit.internal.storage.file.PackFile.copyAsIs(PackFile.java:399)
	at org.eclipse.jgit.internal.storage.file.WindowCursor.copyObjectAsIs(WindowCursor.java:188)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writeObjectImpl(PackWriter.java:1703)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writeObject(PackWriter.java:1680)
	at org.eclipse.jgit.internal.storage.pack.PackOutputStream.writeObject(PackOutputStream.java:138)
	at org.eclipse.jgit.internal.storage.file.WindowCursor.writeObjects(WindowCursor.java:196)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writeObjects(PackWriter.java:1668)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writeObjects(PackWriter.java:1653)
	at org.eclipse.jgit.internal.storage.pack.PackWriter.writePack(PackWriter.java:1214)
	at org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:2328)
	at org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:2164)
	at org.eclipse.jgit.transport.UploadPack.service(UploadPack.java:1078)
	at org.eclipse.jgit.transport.UploadPack.uploadWithExceptionPropagation(UploadPack.java:835)
	at org.eclipse.jgit.transport.UploadPack.upload(UploadPack.java:749)
	... 14 more
{code}


I'll see what I can do

Hello! Have you been able to find a fix?

Not really - from time to time I have been thinking about, but I am waiting for some inspiration... :-(

[~Typz], could you try your test case again with latest master, please? There was a race condition in KEX that got fixed in SSHD-1197.

The Gerrit issue for this appears to be [bug 12758|https://bugs.chromium.org/p/gerrit/issues/detail?id=12758]. No reaction to my post there.

Sorry for the late reply. Unfortunately I don't have access to a Gerrit setup anymore, so I will not be able to check if it fixes the problem.

See also [https://groups.google.com/g/repo-discuss/c/aNxN5XGCxUs] .

I do suspect this lock inversion still exists if there's an exception during {{sendPendingPackets()}}. One way to try to resolve this might be to use finer grained locking in {{ChannelOutputStream()}}, making sure to protect only the shared buffer state, but do any waits on {{remoteWindow}}, {{flush()}} calls, and {{packetWriter.writeData()}} calls outside that lock. That in itself doesn't look simple, but may be doable. (Certainly for {{write()}}; not sure about {{flush()}}. Concurrent writes may not need to be supported, but flushing concurrently is needed with the current architecture, and then it may not be easy to manage the window space and to ensure packets always get written in the right order.)

But even then: if there's an exception during {{sendPendingPackets()}} and closing the {{ChannelOutputStream}} does try to write something during {{flush()}}, those packets would be added to {{pendingPackets}} while {{sendPendingPackets()}} is iterating over it. Is that OK, or might that block again – waiting for window space in {{ChannelOutputStream.flush()}}? Remote window adjustments are not possible at that point; we still hold the global {{sessionLock}} and thus cannot handle the peer's window adjustment messages.

I don't like this whole logic with that {{pendingPackets}} queue. What was the reason for that? I also wonder if it's possible to have that much data queued up on this queue such that sending makes the peer trigger a KEX again before the current KEX is DONE. What would happen then? (Probably we'd just keep on sending until the queue is drained because we still hold the global {{sessionLock}} and thus can't handle a new KEX request from the peer before the queue is drained and we're done with {{handleNewKeys()}} completely. But is that OK?)

Why can't we make {{AbstractSession.writePacket()}} block until the KEX state is DONE instead of queueing up the packet? Then there'd be no need for this whole {{pendingPackets}} queue. I see quite a few calls to {{writePacket()}} that ignore the returned future, though, so blocking might have to happen inside {{writePacket()}}, independent of the future. (Possibly with some timeout? What if some KEX takes a bit longer and that timeout is too low?) And it would need a mechanism to unblock and throw an exception if the stream or channel or session gets closed while waiting inside {{writePacket()}}. For instance, if KEX fails.

{quote}Why can't we make AbstractSession.writePacket() block until the KEX state is DONE instead of queueing up the packet?{quote}
To answer my own question: with the current architecture we can't do that because {{writePacket()}} may be called while the session lock and decoder lock are held. If we'd block then, no other request, not even KEX requests, could be handled.

This is also what stumped me when I tried to write a solution for it. I attempted several workarounds - all of them only +minimized+ the synchronized lock holding duration, but the code becomes very convoluted...

Yes, the code becomes more complicated.

I think one problem is that the current code still has a race condition in {{writePacket()}}. This may be called by arbitrary threads. Consider a server spawning a thread to serve large data through a {{ChannelOutputStream}}. A thread handling a SSH_MSG_KEX_INIT ({{handleKexInit()}}) may run concurrently. Then the following sequence is possible:
{code}
            writePacket                    handleKexInit

                 |                                |
           enqueuePacket                          | 
                 |                        doKexNegotiation      
         kexState == DONE                         |
           return null                   set kexState RUN
                 |                                |
                 |                          sendKexInit
                 |                                |
          doWritePacket                   doWritePacket
                 |                                |
                 |                        acquire encodeLock
                 |                                |
                 |                       send SSH_MSG_KEX_INIT
                 |                                |
         acquire encodeLock                       |
                 |                                |
            send data                             |
{code}
Now the server sends a high-level message after SSH_MSG_KEX_INIT, which it mustn't do according to RFC 4253.

The other problem is that to avoid the lock inversion flushing the queue _must_ occur asynchronously after kexState DONE, and concurrent {{writePacket()}} calls must still not go through, but at the same time also should not queue up more packets, otherwise the asynchronous flush may never terminate.

I'm actually making good progress with a solution that avoids this race and that flushes asynchronously. However, I still haven't found a solution for the problem that writePacket() calls while kex is DONE but we're still flushing might keep queuing packets and thus keep that asynchronous flush busy forever.

{quote}
I'm actually making good progress with a solution that avoids this race and that flushes asynchronously
{quote}
Good luck - keeping my finger crossed...

[PR-217|https://github.com/apache/mina-sshd/pull/217] is my take on this, resolving the lock inversion by writing in a separate thread, and the above race condition.

There is another problem with the current KEX implementation, but that's for another day and another commit:

According to RFC 4253 section 7.1, SSH_MESSAGE_SERVICE_REQUEST and SSH_MSG_SERVICE_ACCEPT packets must not be sent during an ongoing KEX (even though they have low message numbers). Also, when a server initiates a KEX by sending its SSH_MSG_KEX_INIT, it must still be able to process incoming SSH_MSG_SERVICE_REQUESTs until it receives the SSH_MSG_KEX_INIT from the client.

So {{AbstractSession.handleServiceRequest()}} should be allowed in KEX states DONE or INIT, not just DONE, and SSH_MSG_SERVICE_ACCEPT must be queued if sent during KEX. And the inverse may be true on the client side.

Also see [https://groups.google.com/g/repo-discuss/c/hNmktQHp9o0] . This confirms that the problem still exists in Apache MINA sshd 2.8.0.

[PR-217|https://github.com/apache/mina-sshd/pull/217] has been merged. I'm tentatively closing this; if it re-occurs, feel free to open a new issue.

